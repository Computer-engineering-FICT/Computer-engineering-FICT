<?xml version="1.0" encoding="UTF-8"?><FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:xlink="http://www.w3.org/1999/xlink"><description><title-info><genre>antique</genre><author><first-name></first-name><last-name>Unknown</last-name></author><book-title>СПО Мегашпори</book-title><lang>en</lang></title-info><document-info><author><first-name></first-name><last-name>Unknown</last-name></author><program-used>calibre 0.8.51</program-used><date>25.5.2012</date><id>8a7f60e1-fec2-4109-97f5-e8a0e75c6756</id><version>1.0</version></document-info></description><body>
<section>
<p><strong>Преамбула</strong></p>

<p>Спочатку йдуть білети - просто питання. У третьому розділі - відповіді. До вирішених питань прикріплені теги. Для тегування використовувалися асоціації, англійські і транслітеровані скорочення. Шукайте найкоротші слова. А ще краще пробіжіться перед екзаменом по тегах і питаннях. Дайте мозку вловити мої ассоціації. :)</p>

<p><strong>Білети - лінки на відповіді</strong></p>

<p>Білет 1</p><empty-line /><p>
Білет 2</p><empty-line /><p>
Білет 3</p><empty-line /><p>
Білет 4</p><empty-line /><p>
Білет 5</p><empty-line /><p>
Білет 6</p><empty-line /><p>
Білет 7</p><empty-line /><p>
Білет 8</p><empty-line /><p>
Білет 9</p><empty-line /><p>
Білет 10</p><empty-line /><p>
Білет 11</p><empty-line /><p>
Білет 12</p><empty-line /><p>
Білет 13</p><empty-line /><p>
Білет 14</p><empty-line /><p>
Білет 15</p><empty-line /><p>
Білет 16</p><empty-line /><p>
Білет 17</p><empty-line /><p>
Білет 18</p><empty-line /><p>
Білет 19</p><empty-line /><p>
Білет 20</p><empty-line /><p>
Білет 21</p><empty-line /><p>
Білет 22</p><empty-line /><p>
Білет 23</p><empty-line /><p>
Білет 24</p><empty-line /><p>
Білет 25</p><empty-line /><p>
Білет 26</p><empty-line /><p>
Білет 27</p><empty-line /><p>
Білет 28</p><empty-line /><p><strong>Білети</strong></p>

<p><strong>Білет 1</strong></p>

<p>У чому сенс закону Гроша й чому він зараз не діє?</p>

<p>На що впливає введення поняття «надійний стан системи»?</p>

<p>Умови створення процесу. Хто створює процес.</p>

<p>Чому Р3 и Р4 не мають циклу?</p>

<p>Види завантажників. Їх основні відмінності.</p>

<p>Дати визначення ініціалізації системи. Мета ініціалізаціі.</p>

<p>Дати визначення програми простої структури. Переваги й недоліки.</p>

<p>Функції  редактора зв’язків. Звідки він бере інформацію для зв’язування?</p>

<p>Дати визначення статичного планування.</p>

<p>Що таке критичний шлях та критичний час?</p>

<p>Що таке перегляд команд вперед та яка характеристика при цьому покращується?</p>

<p>Що таке 'свопінг'?</p>

<p>Перерахувати стратегії, що застосовуються в алгоритмах оптимізації.</p>

<p>Недоліки алгоритму Шаркара .</p>

<p>Види планування та їх особливості.</p>

<p><strong>Білет 2</strong></p>

<p>Математична постановка задачі динамічного планування для багатопроцесорних систем.</p>

<p>Особливості операційних систем локальних обчислювальних мереж.</p>

<p>Що таке резидентні програми ОС?</p>

<p>Дати визначення динамічного планування.</p>

<p>Види модулів. Участь системних програм в перетворенні модулів.</p>

<p>Ідея алгоритму Янга.</p>

<p>Дати визначення програми оверлейної структури. Переваги, недоліки.</p>

<p>Вхідна й вихідна інформація редактору зв’язків.</p>

<p>Що таке неоднорідна система? Якими характеристиками визначається неоднорідність?</p>

<p>Перерахувати стратегії, що застосовуються в алгоритмах оптимізації.</p>

<p>Чим визначається перехід від непрямого методу доступу до колективного?.</p>

<p>Пояснити непряме введення-виведення.</p>

<p>Що таке супервизор й де він знаходиться?</p>

<p>Недолік генетичних алгоритмів.</p>

<p>Рівні планування в одно процесорній системі.</p>

<p><strong>Білет 3</strong></p>

<p>Недоліки методу колективного доступу.</p>

<p>Особливості розподілених операційних систем.</p>

<p>Стpуктуpа модуля.</p>

<p>Стратегії, що використовуються при динамічному плануванні.</p>

<p>Що таке транзитні програми ОС?</p>

<p>Резиденція системи. Які програми там знаходяться?</p>

<p>Програма динамічної послідовної структури. Чим вона краще інших структур.</p>

<p>Коли застосовують евристичні алгоритми?</p>

<p>Дати визначення балансового планування. Які проблеми в його вирішенні?</p>

<p>Що таке резидентні вершини? Як їх знайти та як можна їх використати?</p>

<p>Недоліки використання мультипрограмування.</p>

<p>Основна відмінність використання підпрограм в компілюючих системах и інтерпретуючих.</p>

<p>Як знайти максимально й мінімально необхідну кількість процесорів?</p>

<p>Ідея застосування алгоритмів кластеризації. Шляхи визначення вузлів, що кластерізуються.</p>

<p>Навіщо потрібен рівень реконфигурації в системі планування багатопроцесорної паралельної системи?</p>

<p><strong>Білет 4</strong></p>

<p>Якими міркуваннями визначається вибір кванта при паралельній обробці?</p>

<p>Коли застосовують евристичні алгоритми?</p>

<p>Дати визначення області збереження. Чим визначається розмір, яка інформація завжди має бути збережена?</p>

<p>Особливості програмного забезпечення розподілених систем обробки інформації.</p>

<p>Відмінність завантажувального модуля від абсолютного. Які системні програми приймають участь у їх створенні?</p>

<p>Дати визначення ініціалізації ядра. Чим вона відрізняється від ініціалізації системи?</p>

<p>Чим визначається вибір змішаної дисципліни обслуговування?</p>

<p>Що називається ядром супервізора? Його функції.</p>

<p>Як визначити мінімально необхідну кількість процесорів для завантаження паралельного алгоритму? Дати приклад, коли формула дає неправильних результат.</p>

<p>Завантаження операційної системи. Етапи.?</p>

<p>Структура бібліотеки . Чим ця структура відрізняється від структури файлової системи?</p>

<p>Що таке віртуальна операційна система? Чи використовується вона в персональних комп’ютерах?</p>

<p>Основна характеристика задач планування з передуванням.</p>

<p>Перерахувати стратегії, що використовуються в алгоритмах оптимізації.</p>

<p>Алгоритми динамічного планування, що використовуються в сучасних ОС.</p>

<p><strong>Білет 5</strong></p>

<p>Дати визначення класичного мультипрограмування.</p>

<p>Дати визначення процесу. Стан процесу. Чим визначається вихід з активного в підготовлений стан?</p>

<p>Яка програма виконує запис інформації в область зберігання та яка інформація туди записується?</p>

<p>Чим відрізняється загрузка EXE й COM  модулів?</p>

<p>Функції завантажника. В яких завантажниках які функції виконуються системою?</p>

<p>Чим відрізняються файлова система та бібліотека?</p>

<p>Як визначити об’єм пам’яті, необхідної для завантаження програми простої та оверлейної структури?</p>

<p>Чому алгоритм FBn краще RR? Яка характеристика при цьому покращується?</p>

<p>Дати визначення балансового планування. Які проблеми мають вирішуватися?</p>

<p>Що таке напівнеоднорідна система? Як виражається відношення «задача – ресурс»?</p>

<p>Що таке супервізор й де він знаходиться?</p>

<p>Дати визначення розподіленої операційної системи.</p>

<p>Які стратегії використовуються при розв’язанні NP-повних задач?</p>

<p>Дати визначення пошуку максимального паросполучення.</p>

<p>У чому відмінність часової складності від обчислювальної?</p>

<p><strong>Білет 6</strong></p>

<p>Дати визначення програми з точки зору операційної системи.</p>

<p>Умова переходу процесу з активного стану в підготований.</p>

<p>Зв'язок модулів за керуванням. Які операції виконуються й якими програмами? Яка інформація й куди при цьому записується?</p>

<p>Умови переходу з Р3 у Р1 або Р2.</p>

<p>При наявності віяла, яке ребро береться у рішення?</p>

<p>Основні дії програми початкового завантаження. Де вона зберігається та як її знайти?</p>

<p>Як визначити об’єм пам’яті, необхідної для завантаження програми оверлейної структури?</p>

<p>Дати визначення ГРІД системи.</p>

<p>Як визначити зону знаходження оптимального розкладу для систем зі спільною пам’яттю?</p>

<p>Що таке строго неоднорідна ОС? Яка задача має розв’язуватися при плануванні?</p>

<p>Що шукає алгоритм Мальгранжа та який його основний недолік?</p>

<p>Яку задачу розв’язує лінійний планувальник? Яка стратегія при цьому використовується?</p>

<p>Чим відрізняється матриця зв’язності від матриці інцидентності?</p>

<p>Дати приклад неявної транзитності .</p>

<p>Засоби оцінки складності алгоритму.</p>

<p><strong>Білет 7</strong></p>

<p>Дати визначення непрямого доступу. Переваги й недоліки. Де він застосовується зараз.</p>

<p>Чому спулінг схильний до тупикових ситуацій?</p>

<p>Сформулювати принцип оптимальності Белмана?.</p>

<p>Задачі, що розв’язуються при статичному плануванні.</p>

<p>Функції завантажника, що налаштовує. Яка програма готує для нього інформацію?</p>

<p>Де знаходиться програма початкового завантаження? Її функції.</p>

<p>Як визначити об’єм пам’яті, необхідної для завантаження програми динамічної послідовної структури?</p>

<p>Основна особливість пріоритетних дисциплін обслуговування. Види пріоритетів.</p>

<p>Що таке конфліктне значення? Навіщо їх виділяти?</p>

<p>Ідея оптимізації  «базового» рішення.</p>

<p>Ідея алгоритмів покрокового конструювання.</p>

<p>Що таке NP-повна задача?</p>

<p>Основа алгоритму кластеризації, з застосуванням стратегії пошуку критичного шляху.</p>

<p>Способи опису графу.</p>

<p>Види топології паралельних систем. В який топології можна досягнути мінімізації пересилок?</p>

<p><strong>Білет 8</strong></p>

<p>Дати визначення колективного доступу. Переваги й недоліки. Чи застосовується він зараз й де саме?</p>

<p>Умова переходу процесу з активного стану в заблокований.</p>

<p>Чому усі алгоритми, засновані на теоремі Бержа про максимальне паросполучення непридатні для використання в динамічних планувальниках?</p>

<p>Характеристика розподіленої операційної системи.</p>

<p>Дати визначення транзитного модуля. Чому вони, як правило, є СOM-файлами?</p>

<p>Дати визначення табличного методу керування. Назвати першу таблицю, що заповнюється.</p>

<p>Цільова функція планування в реальному часі.</p>

<p>Яка характеристика покращується у змішаних алгоритмах обслуговування й чому її треба покращувати?</p>

<p>У чому відмінність між максимальним паросполученням й досконалим?</p>

<p>Що таке критичні вершини? Навіщо необхідно їх визначати та як вони визначаються?</p>

<p>Чим визначається зміст програм, що знаходяться в оперативній пам’яті?</p>

<p>У чому складність для операційної системи в організації багатопрограмного режиму?</p>

<p>Як визначити верхню границю кількості процесорів для завантаження комплексу задач?</p>

<p>Класифікація задач планування.</p>

<p>Як визначити мінімальну кількість процесорів?</p>

<p><strong>Білет 9</strong></p>

<p>Які основні характеристики розподілених систем обробки інформації ?</p>

<p>Умова переходу процесу з заблокованого стану у готове.</p>

<p>Коли застосовують евристичні алгоритми?</p>

<p>Методи підвищення ефективності використання ресурсів обчислювальної системи.</p>

<p>Дати приклад «неявної» транзитності.</p>

<p>Що називається ядром супервізора, які його функції?</p>

<p>Яка системна програма готує інформацію для роботи завантажника?</p>

<p>Як визначити зону знаходження оптимального розкладу в системі із загальною шиною?</p>

<p>Навіщо потрібно виконувати структурний аналіз вихідного графа? Дати приклад.</p>

<p>Як змінюється вихідна інформація системи динамічного планування для однорідних і неоднорідних ОС?</p>

<p>У чому відмінність між максимальним парасполученням й досконалим?</p>

<p>Що таке пряме введення-виведення? Який метод застосовується в сучасних системах?</p>

<p>Дати визначення "спулінг". Навіщо він застосовується? У чому небезпека його застосування при введенні / виведенні?</p>

<p>Закон Амдала.</p>

<p>Критерії оптимізації рішення задач статичного планування.</p>

<p><strong>Білет 10</strong></p>

<p>Який механізм являється основою багатопрограмного режиму роботи?</p>

<p>Умова переходу процесу з активного стану у готовий або підготовлений.</p>

<p>Властивості модуля. Пояснити необхідність кожного.</p>

<p>Причини виникнення «безкінечного» відкладання. Чому воно небезпечне?</p>

<p>Дати визначення транзитного модуля. За якою схемою завантажуються транзитні модулі і в яку область пам’яті?</p>

<p>Які програми знаходяться у ядрі операційної системи? (Види програм)</p>

<p>Яку інформацію та як компілятор передає завантажнику, що налаштовує?</p>

<p>Чому NP-повні задачі не придатні для динамічного планування?</p>

<p>Чому й коли блокується система переривань?</p>

<p>Які методи використовуються для розв’язання NP-повних задач?</p>

<p>Що таке «спулінг», чому він схильний до тупикових ситуацій?</p>

<p>Дати визначення розподіленій системі.</p>

<p>Що таке базове рішення та у чому ідея його оптимізації?</p>

<p>Навіщо потрібно виділяти обов’язкові призначення?</p>

<p>Як визначити граничну кількість процесорів для завантаження програм у системі з загальною пам’яттю?</p>

<p><strong>Білет 11</strong></p>

<p>Дати визначення системного програмного забезпечення.</p>

<p>Особливості статичних планувальників.</p>

<p>Структура модуля.</p>

<p>У чому складність розв’язання задач планування паралельних процесів?</p>

<p>Що таке часова складність?</p>

<p>Причина переходу процесу з готового стану в активний.</p>

<p>Як визначити об’єм пам’яті, необхідної для завантаження програми динамічної послідовної структури?</p>

<p>Яка характеристика покращується у змішаних алгоритмах обслуговування?</p>

<p>Ідея алгоритмів, заснованих на стратегії критичного шляху.</p>

<p>Яку задачу вирішує потоковий  планувальник? Коли й чому він неефективний?</p>

<p>Що таке перегляд команд вперед та яка  характеристика покращується?</p>

<p>Пояснити непряме введення-виведення.</p>

<p>Які стратегії покращують роботу просторового планувальника?</p>

<p>Ідея створення адаптивних алгоритмів планування.</p>

<p>Як й коли визначається пріоритет системних та проблемних задач.</p>

<p><strong>Білет 12</strong></p>

<p>Перерахувати властивості модуля.</p>

<p>Особливості розподілених операційних систем. Чим вони відрізняються від ОС ЛВС?</p>

<p>Основні недоліки застосування мультипрограмування.</p>

<p>Методи організації обчислювального процесу, що підвищують продуктивність обчислювальної системи.</p>

<p>У чому смисл глобальної та поточної настройки адресних констант.</p>

<p>Закон Гроша.</p>

<p>Як визначити об’єм пам’яті, необхідний для завантаження програми простої структури?</p>

<p>Чому алгоритм «Коpбато» краще FBn?</p>

<p>Де знаходяться нові PSW?</p>

<p>Ідея застосування методу оціночних функцій. Переваги й недоліки.</p>

<p>Недолік колективного доступу та як він усувається у сучасних системах?</p>

<p>Чому в розподілених системах переважніше використовувати крупнозернисте планування?</p>

<p>Пояснити термін «дружня операційна система».</p>

<p>Функції рівня операційної системи у багаторівневій системі програмування.</p>

<p>Описати рівні статичного планування для одно процесорної ОС.</p>

<p><strong>Білет 13</strong></p>

<p>Який тип транслятора використовується при трансляції з традиційної машинної мови у команди машини та як він реалізується?</p>

<p>Визначення метаобчислень (суперобчислень)</p>

<p>Чому в розподілених системах переважніше використовувати крупнозернисте планування?</p>

<p>Дії, що виконує програма ініціалізації ядра. Звідки вона викликається?</p>

<p>Функції завантажника, що налаштовує. Яку інформацію повідомляє йому компілятор?</p>

<p>Сформулювати теорему про обов’язкові призначення.</p>

<p>Як визначити об’єм пам’яті, необхідний для завантаження програми оверлейної структури?</p>

<p>Основна особливість пріоритетних дисциплін обслуговування. Види.</p>

<p>Дати визначення паралельної системи.</p>

<p>Ідея розв’язання задачі планування методом «пізнього» планування.</p>

<p>Задача «наповнення рюкзака». Для розв’язання якої задачі планування можна її застосовувати?</p>

<p>Яка інформація міститься у MBR?</p>

<p>Дати визначення процесу. Коли це поняття стало застосовуватися й чому?</p>

<p>Застосування GRID систем.</p>

<p>Відмінність завдання від задачі. Де зберігається завдання?</p>

<p><strong>Білет 14</strong></p>

<p>Що таке розв’язання задачі планування з передуванням?</p>

<p>Сформулювати теорему про обов’язкові призначення.</p>

<p>Яка програма виконує запис інформації в область збереження та яка інформація туди записується?</p>

<p>Обробка станів Р3 й Р4.</p>

<p>Який тип завантажника працює з модулями з розширеннями COM та EXE?</p>

<p>На яку характеристику впливають пріоритетні дисципліни обслуговування заявок?</p>

<p>Як визначити об’єм пам’яті, необхідний для завантаження програми динамічної паралельної структури?</p>

<p>Математична постановка задачі статичного планування.</p>

<p>Чому й коли блокується система переривань?</p>

<p>Як змінюється організація обчислювального процесу для систем зі спільною пам’яттю та СМР?</p>

<p>Сформулювати теорему про віяло.</p>

<p>Що таке віртуальна операційна система, чи застосовується вона у сучасних ОС?</p>

<p>Проблеми керування паралельними процесами. Чому вони важкі для реалізації?</p>

<p>Для чого слугує характеристика «часова складність алгоритму»?</p>

<p>Що таке «строго неоднорідна ОС»? Дати приклад такої неоднорідності.</p>

<p><strong>Білет 15</strong></p>

<p>Дати характеристику неоднорідної системи.</p>

<p>Процес. Коли та як визначаються пріоритети системних й проблемних процесів?</p>

<p>Як передаються дані між модулями в оверлейних системах?</p>

<p>Які операціі виконує завантажник при завантаженні EXE файлу?</p>

<p>Дати визначення резидентного модуля. Коли визначається склад резидентних програм?</p>

<p>Дати визначення табличного методу керування. Чому він застосовується?</p>

<p>Яка системна програма підготовлює інформацію для роботи завантажника, та яку?</p>

<p>Як визначити зону знаходження оптимального розкладу? Зі спільною пам’яттю та зі спільною шиною.</p>

<p>Структура супервізора.</p>

<p>Що таке транзитні програми? Спосіб їх завантаження.</p>

<p>Що таке запис у бібліотеку без каталогізації? Дати приклад.</p>

<p>Як змінюється інформація системи динамічного планування для однорідних та неоднорідних ОС?</p>

<p>Математична постановка задачі планування для одно процесорних систем.</p>

<p>Що таке розв’язання задачі планування з передуванням?</p>

<p>Принципи підвищення ефективності ОС.</p>

<p><strong>Білет 16</strong></p>

<p>Які міркування використовуються при визначені величини кванта?</p>

<p>Умова переходу процесу з підготованого стану у готовий та з активного в підготований?</p>

<p>Чим відрізняється традиційна машинна мова програмування від команд машини?</p>

<p>Сенс розв’язання задачі реконфігурації при балансовому плануванні.</p>

<p>Що таке масштабування розподілених систем?</p>

<p>Чому застосовуються багаторівневі системи програмування?</p>

<p>Яку інформацію та як компілятор передає завантажнику, що налаштовує.</p>

<p>Функції редактора зв’язків. Як йому передається інформація?</p>

<p>Як визначити вершини графа, що знаходяться на критичному шляху?</p>

<p>Які методи використовуються для розв’язання NP-повних задач?</p>

<p>У чому відмінність розв’язання задачі планування від розподілення? Яка з них розв’язується при динамічному плануванні?</p>

<p>Функція мети задачі динамічного планування.</p>

<p>Сформулювати теорему про потужність паросполучення.</p>

<p>За якою схемою завантажуються транзитні програми супервізора?</p>

<p>Що таке межа Бременмана?</p>

<p><strong>Білет 17</strong></p>

<p>Дати визначення непрямого доступу. Чи застосовується він зараз й коли?</p>

<p>Що таке модульний принцип програмування?</p>

<p>Сформулювати принцип оптимальності Белмана.</p>

<p>Характеристика розподіленої операційної системи. Чим вона відрізняється від мережної?</p>

<p>Види завантажників та їх особливості. Коли який застосовується?</p>

<p>Які програми знаходяться у ядрі операційної системи? (Види програм)</p>

<p>Дати визначення програми простої структури. Коли використання такої структури неефективно?</p>

<p>Вхідна та вихідна інформація редактору зв’язків.</p>

<p>Як визначити вершини графу, що знаходяться на критичному шляху?</p>

<p>Основна ідея «угорського алгоритму». Заміна якого блоку покращує його характеристики?</p>

<p>Навіщо потрібно водити характеристику «надійний стан системи»?</p>

<p>Ідея алгоритмів, заснованих на стратегії критичного шляху.</p>

<p>Методи підвищення ефективності організації обчислювального процесу в ОС.</p>

<p>Що таке шлях, що збільшує, шлях, що чергується?</p>

<p>Які задачі розв’язуються при статичному плануванні у паралельній ОС?</p>

<p><strong>Білет 18</strong></p>

<p>Сформулювати принцип оптимальності Белмана.</p>

<p>Чи використовується у сучасних системах колективний доступ та чим він відрізняється від того, що використовувався раніше?</p>

<p>Умови створення процесу. Який ресурс при цьому є критичним?</p>

<p>Умови переходу зі стану Р1 у Р2 та назад.</p>

<p>Основні недоліки застосування мультипрограмування.</p>

<p>Чому у розподілених системах переважніше використовувати крупнозернисте планування?</p>

<p>Дати визначення програми оверлейної структури. Як передаються дані?</p>

<p>Сформулювати теорему про конфліктні призначення.</p>

<p>Дати визначення розподіленої операційної системи. Її відмінність від мережної.</p>

<p>Ідея створення адаптивних алгоритмів планування.</p>

<p>Особливості різних форм взаємодії «людина – машина». Які характеристики при цьому змінюються?</p>

<p>У чому складність для операційної системи в організації багатопрограмного режиму роботи? Які задачі про цьому розв’язуються та які механізми використовуються?</p>

<p>В якому вигляді компілятор передає інформацію завантажнику, що налаштовує?</p>

<p>Перерахувати рівні планування у паралельний системи. Які задачі потрібно розв’язувати у статиці, а які – у динаміці?</p>

<p>Що таке «строго неоднорідна ОС»? Які параметри ОС визначають неоднорідність?</p>

<p><strong>Білет 19 [n/a]</strong></p>

<p>Перерахувати способи реалізації багатопрограмного режиму роботи.</p>

<p>Сформулювати теорему про конфліктні призначення.</p>

<p>Вимоги до статичних планувальників.</p>

<p>Чим визначається пріоритет проблемних й системних програм та коли ці пріоритети визначаються?</p>

<p>Перерахувати ресурси ОС.</p>

<p>Дати визначення резидентного тому. Яка системна програма формує зміст резидентного тома?</p>

<p>Дати визначення програми динамічної послідовної структури.</p>

<p>Різниця між обчислювальною та часовою складністю. Яка оцінка коли застосовується?</p>

<p>Функція мети задачі статичного планування. Чому потрібно розділяти планування та розподілення?</p>

<p>Динамічне планування для систем реального часу.</p>

<p>Дати визначення керуючих програм операційної системи.</p>

<p>Що таке пряме введення-виведення? Чому непряме краще?</p>

<p>Як компілятор передає інформацію безпосередньо завантажнику, що зв’язує?</p>

<p>Обчислювальні системи реального часу. Визначення. Особливості</p>

<p>Назвати нижні рівні керування зовнішніми пристроями.</p>

<p><strong>Білет 20 [n/a]</strong></p>

<p>Чому для оцінки придатності алгоритму використовують часову складність, а не обчислювальну? 
2.Чому усі алгоритми, засновані на теоремі Бержа про максимальне паросполучення непридатні для використання в динамічних планувальниках?</p>

<p>Що таке супервізор та де він знаходиться?</p>

<p>У чому відмінність визначення пріоритетів проблемних та системних програм?</p>

<p>Функції абсолютного завантажника.</p>

<p>Дати визначення резиденції системи. Чим визначається склад програм?</p>

<p>Дати визначення програми динамічної паралельної структури.</p>

<p>Коли застосовують евристичні алгоритми?</p>

<p>Як визначити конфліктне призначення?</p>

<p>Дати визначення розподіленої операційної системи.</p>

<p>Що таке «спулінг», коли він ефективний?</p>

<p>Ідея застосування алгоритмів кластеризації.</p>

<p>Яку задачу розв’язує просторовий планувальник?</p>

<p>У чому різниця завантаження COM та EXE програм?</p>

<p>Як визначити часову складність алгоритму?</p>

<p><strong>Білет 21</strong></p>

<p>Сформулювати принцип оптимальності Белмана.</p>

<p>Коли застосовують евристичні алгоритми?</p>

<p>Яка програма виконує запис інформації в область збереження та що там зберігається?</p>

<p>Що таке резидентні вершини та як їх знайти? Навіщо вони потрібні?</p>

<p>Функції завантажника, що налаштовує.</p>

<p>Дати визначення ініціалізації системи. Функції.</p>

<p>У чому відмінність меж максимальним паросполученням та досконалим?</p>

<p>Чому алгоритм «Коpбато» краще FBn?</p>

<p>Що таке неоднорідна система? Як визначити степінь неоднорідності?</p>

<p>Функція мети задачі динамічного планування.</p>

<p>Сформулювати теорему про обов’язкові призначення.</p>

<p>Що таке «свопінг»?</p>

<p>Різниця між плануванням та розподіленням?</p>

<p>По який характеристиці можна судити про придатність розробленого алгоритму для роботи у динамічному режимі?</p>

<p>Етапи завантаження операційної системи.</p>

<p><strong>Білет 22</strong></p>

<p>Дати визначення режиму розподілення часу.</p>

<p>Особливості розподілених операційних систем.</p>

<p>Зв'язок модулів по керуванню. Які операції виконуються та якими програмами?</p>

<p>Принципи підвищення ефективності роботи системи з допомогою організації обчислювального процесу.</p>

<p>Який тип завантажника працює з модулями з розширенням COM та EXE?</p>

<p>Різниця між плануванням й розподіленням?</p>

<p>Як визначити об’єм пам’яті, необхідний для завантаження програми оверлейної структури?</p>

<p>Основна особливість пріоритетних дисциплін обслуговування. Їх види.</p>

<p>Ідея оптимізації «базового» рішення.</p>

<p>Що таке конфліктне призначення? Навіщо потрібно його виділяти?</p>

<p>Що таке тимчасова бібліотека? Коли вона використовується?</p>

<p>Які операції виконує програма першого рівня планування?</p>

<p>Назвати рівні багаторівневих систем програмування.</p>

<p>Призначення операційних систем.</p>

<p>Задачі планування в системах масового розпаралелювання та чим вони відрізняються від задач планування для розподілених систем?</p>

<p><strong>Білет 23</strong></p>

<p>Умова переходу зі стану Р1 у Р2 й навпаки.</p>

<p>Які операції виконує програма першого рівня планування?</p>

<p>В чому перевага алгоритмів покрокового конструювання?</p>

<p>Чому для оцінки придатності алгоритму використовують тимчасову складність, а не обчислювальну?</p>

<p>Як визначити об’єм пам'яті, необхідної для завантаження програми динамічної-паралельної структури?</p>

<p>Назвати стратегії, що застосовуються в алгоритмах оптимізації.</p>

<p>Чому і коли блокується система переривань?</p>

<p>Основна ідея «угорського алгоритму».</p>

<p>Як змінюється вихідна інформація системи динамічного планування для однорідних і неоднорідних ОС?</p>

<p>Ідея розв’язання задачі планування методом «раннього» планування.</p>

<p>Що називається ядром супервізора, його функції?</p>

<p>Що таке віртуальна операційна система. Коли вона застосовується?</p>

<p>Дати визначення термінам «завдання» й «програма», дані з точки зору ОС.</p>

<p>Що таке квазі-оптимальне рішення?</p>

<p>Як підвищити ефективність роботи ОС зі спільною пам'яттю?</p>

<p><strong>Білет 24 [n/a]</strong></p>

<p>Дати визначення паралельної обробки. Недоліки та як їх позбутися?</p>

<p>Дати визначення процесу. Стратегія визначення пріоритетів в ОС.</p>

<p>Зв'язок модулів за керуванням. Які операції виконуються й якими програмами?</p>

<p>Особливості розв’язання задач в ОС ЛВС.</p>

<p>Види модулів. Які програми беруть участь в перетворенні модулів?</p>

<p>Дати визначення табличного методу керування. Як формується таблиця векторів переривань?</p>

<p>Як визначити об’єм пам'яті, необхідної для завантаження програми динамічної паралельної структури?</p>

<p>Чому алгоритм «Коpбато» краще FBn?</p>

<p>Що таке критичні вершини?</p>

<p>Які операції виконує програма другого рівня планування?</p>

<p>Як змінюється організація обчислювального процесу для СМР і РС?</p>

<p>Ідея оптимізації «базового» ​​рішення.</p>

<p>Яка характеристика покращується в змішаних алгоритмах обслуговування?</p>

<p>Дати визначення NP - повним завданням.</p>

<p>Різниця між плануванням і розподілом.</p>

<p><strong>Білет 25</strong></p>

<p>Дати визначення роботи в реальному часі. Надати приклад.</p>

<p>Різниця між плануванням і розподілом.</p>

<p>Чим відрізняється традиційна машинна мова програмування від команд машини?</p>

<p>У чому полягає сенс перегляду команд вперед і коли цей прийом неефективний?</p>

<p>Відмінність завантажувального модуля від абсолютного. Яка програма виконує перетворення?</p>

<p>Які операції виконує програма другого рівня планування?.</p>

<p>Дати визначення програми оверлейной структури. Недоліки.</p>

<p>Вхідна і вихідна інформація редактора зв’язків.</p>

<p>Динамічне планування для систем реального часу.</p>

<p>Як визначити обов'язкове призначення? Навіщо це потрібно робити?</p>

<p>Що таке «розширення» розподілених систем?</p>

<p>Що таке «свопінг», чим відрізняється від «спулінга»?</p>

<p>Основні проблеми розв’язування задач планування в багатопроцесорних паралельних системах.</p>

<p>Описати послідовність дій, які виконуються завантажувачем при завантаженні програм.</p>

<p>Чому COM файли мають обмеження за розміром?</p>

<p><strong>Білет 26</strong></p>

<p>На що впливає введення поняття «надійний стан системи»?</p>

<p>Пропозиції Лебедєва по підвищенню ефективності роботи ОС та як вони реалізовані в сучасних ОС.</p>

<p>Відмінність функцій програм системного введення /виведення від режиму спулінга.</p>

<p>Яка характеристика ОС покращується в змішаних дисциплінах обслуговування?</p>

<p>Частиною якої програми є редактор зв'язку?</p>

<p>Що таке супервізор й де він знаходиться?.</p>

<p>Навіщо потрібно виконувати структурний аналіз вихідного графа?</p>

<p>Функції 3-го рівня багаторівневих систем програмування.</p>

<p>Назвати рівні планування для багатопроцесорних ОС. Функції кожного.</p>

<p>Коли застосовується запис до бібліотеки без каталогізації?</p>

<p>Як визначити пріоритет процесу системного і проблемного?</p>

<p>Як змінюється організація обчислювального процесу для СМР і РС?</p>

<p>Функція мети завдання динамічного планування.</p>

<p>Ідея побудови «базового» ​​рішення.</p>

<p>Сформулюйте принцип оптимальності Белмана.</p>

<p><strong>Білет 27</strong></p>

<p>Основні принципи організації обчислювального процесу, що підвищують ефективність роботи ОС.</p>

<p>Дати визначення режиму поділу часу.</p>

<p>Назвати базові рівні в багаторівневих системах програмування.</p>

<p>Визначити умови переходу зі стану Р3 в стан Р й Р2.</p>

<p>Перерахувати пріоритетні дисципліни обслуговування. Яка характеристика впливає на вибір дисципліни?</p>

<p>Види завантажувачів та їх основні відмінності.</p>

<p>Чому спулінг схильний до тупиків?</p>

<p>Чому всі алгоритми, засновані на теоремі Бержа про максимальне паросполучення, не придатні для використання в динамічних планувальниках?</p>

<p>Особливості розподілених операційних систем. У чому їх відмінність від мережних?</p>

<p>Види модулів. Участь системних програм в перетворенні модулів.</p>

<p>Що таке обчислювальна складність?</p>

<p>Основна ідея «угорського алгоритму».</p>

<p>Чому не можна зациклити стан Р3 й Р4?</p>

<p>Коли застосовують евристичні алгоритми?.</p>

<p>Яким чином і коли фіксується пріоритет процесів?</p>

<p><strong>Білет 28</strong></p>

<p>Чому впровадження логіки переривань зумовило підвищення продуктивності?</p>

<p>Що таке максимальне паросполучення?</p>

<p>Недолік непрямого методу доступу. Де і як зараз він використовується?</p>

<p>Дати визначення завдання, програми, даних.</p>

<p>Дати визначення ресурсу в сучасній ОС.</p>

<p>Перерахувати стратегії, що застосовуються в алгоритмах оптимізації.</p>

<p>Чим алгоритм FBn гірше алгоритму «Корбато»?</p>

<p>Сформулюйте принцип оптимальності Белмана.</p>

<p>Назвати стратегії вирішення задачі розподілу завдань по ресурсах з пересилками.</p>

<p>Як визначити зону знаходження оптимального розкладу з урахуванням пересилань?</p>

<p>Визначити умови переходу зі стану Р2 в стан Р1.</p>

<p>Навіщо потрібно виконувати структурний аналіз вихідного графа? Чи можна його робити в динамічному режимі?</p>

<p>Дати характеристику однорідної системи.</p>

<p>Математична постановка задачі динамічного планування.</p>

<p>Чому в розподілених системах переважніше використовувати крупнозернисте планування?</p>

<p><strong>Відповіді</strong></p>

<p><strong>Білет 1</strong></p>

<p><strong>1. У чому сенс закону Гроша й чому він зараз не діє?</strong> #grosh</p><empty-line /><p>
Сенс закону Гроша в тому, що продуктивність комп’ютера пропорційна квадрату його вартості. Зараз цей закон не діє, оскільки збільшення вартості комп’ютеру в 10 разів не означає збільшення продуктивності в 100 разів. Досягти потрібних потужностей складно.</p>

<p><strong>2. На що впливає введення поняття «надійний стан системи»?</strong> #nadi</p><empty-line /><p>
На запобігання тупіків та взаємного блокування процесів в системі.</p>

<p><strong>3. Умови створення процесу. Хто створює процес.</strong> #proces</p><empty-line /><p>
Умови створення процесу – коректність опису процесу на мові опису процесів та виділення ресурсів. Процес створює ОС.</p>

<p><strong>4. Чому Р3 и Р4 не мають циклу?</strong> #p3 #p4 #cikl</p><empty-line /><p>
Тому що Р4 означає, що машина не працює, а Р3 є атомарною операцією.</p>

<p><strong>5. Види завантажників. Їх основні відмінності.</strong> #zavant</p><empty-line /><p>
Абсолютні – тільки завантаження у пам’ять. Налаштовуючі – виділення пам’яті, налаштування зв’язування, завантаження у пам’ять. В кожному модулі потрібні внутрішні та зовнішні вектори. Безпосередньо зв’язуючі – тільки зв’язування.</p>

<p><strong>6. Дати визначення ініціалізації системи. Мета ініціалізаціі</strong> #init #inic</p><empty-line /><p>
Ініціалізація системи – ініціалізація установок та програм користувача.</p>

<p><strong>7. Дати визначення програми простої структури. Переваги й недоліки.</strong> #pros #srtuct</p><empty-line /><p>
Програма, яка при виконанні не звертається до інших програм, а має в своєму тілі все потрібне для виконання. Перевага: швидкодія. Недоліки: займає більше місця, складніша для написання.</p>

<p><strong>8. Функції  редактора зв’язків. Звідки він бере інформацію для зв’язування?</strong> #red #zv</p><empty-line /><p>
Редактор зв’язків збирає програму з багатьох об’єктних модулів та формує адреси у звертаннях до зовнішніх точок. Назви модулів йому дає компілятор.</p>

<p><strong>9. Дати визначення статичного планування.</strong> #static #stat #plan</p><empty-line /><p>
План складається до вирішення задач та на іншому обладнанні. Важливою є якість, а не час.</p>

<p><strong>10. Що таке критичний шлях та критичний час?</strong> #crit</p><empty-line /><p>
Критичний шлях – максимальний шлях у графі. Критичний час – максимальний час проходу графу зверху вниз.</p>

<p><strong>11. Що таке перегляд команд вперед та яка характеристика при цьому покращується?</strong> #command #comand</p><empty-line /><p>
Попередня вибірка, покращується швидкодія.</p>

<p><strong>12. Що таке 'свопінг'?</strong> #swap #swop</p><empty-line /><p>
Свопінг – засіб реалізації багатопрограмного режиму роботи на одно процесорній машині. Проблема налаштування пов’язана з переміщенням програм в ОП. Якщо ОС працює зі свопінгом – потрібне пере налаштування адресних констант (глобальне – пере налаштування всіх адресних констант, локальне – обчислення адреси тієї змінної, яка знаходиться реально в ОП).</p>

<p><strong>13. Перерахувати стратегії, що застосовуються в алгоритмах оптимізації.</strong> #optim #strat</p><empty-line /><p>
Генетичних алгоритмів, оціночних функцій, напрямного пошуку, Anealing метод, метод пошуку максимального паросполучення у зваженому графі, модифікований угорський, метод гілок та границь, модифікований метод для RealTimeOS, евристичний, складання розкладу, метод виключного планування.</p>

<p><strong>14.  Недоліки алгоритму Шаркара .</strong> #shark #algo</p><empty-line /><p>
Необхідно проглядати весь граф, а це займає багато часу.</p>

<p><strong>15. Види планування та їх особливості.</strong> #plan</p><empty-line /><p>
  * Статичне – час неважливий, план складається до вирішення задачі та на іншому обладнанні в інший час. 
  * Динамічне – проблема в швидкості, працює під час рішення задач на тому ж обладнанні в той же час.
  * Балансове – система планує навантаження, коли задача не вирішується – зовнішній планувальник намагається визначити чи правильне розподілення на вузлах. Проблеми – як визначити, що програма вісить? Передбачити звільнення, проблема міграції.</p>

<p><strong>Білет 2</strong></p>

<p><strong>1. Математична постановка задачі динамічного планування для багатопроцесорних систем.</strong> #mat #math #plan</p><empty-line /><p>
Задача комбінаторики по розміщенню задач в просторі та у площині.</p>

<p><strong>2. Особливості операційних систем локальних обчислювальних мереж.</strong> #os #local #net</p><empty-line /><p>
З’єднання незалежних пристроїв,  високий рівень взаємозв’язку пристроїв, використання ЛМ для передачі інформації в цифровій формі.</p>

<p><strong>3. Що таке резидентні програми ОС?</strong> #resident</p><empty-line /><p>
Програми, що завжди знаходяться в ОП.</p>

<p><strong>4. Дати визначення динамічного планування.</strong> #dynamic #plan</p><empty-line /><p>
Динамічне планування – планування під час виконання задач на тому ж обладнанні і в той же час.</p>

<p><strong>5. Види модулів. Участь системних програм в перетворенні модулів.</strong> #modul</p><empty-line /><p>
Вихідний, об’єктний, завантажувальний, абсолютний.  Компілятор між вихідним та об’єктним, редактор зв’язку між об’єктним та завантажувальним, завантажувач між завантажувальним та абсолютним.</p>

<p><strong>6. Ідея алгоритму Янга.</strong> #yanga #janga #algo</p><empty-line /><p>
Алгоритм Янга виділяє критичні вершини та піднімає їх (кластерізує).</p>

<p><strong>7. Дати визначення програми оверлейної структури. Переваги, недоліки.</strong> #overlay</p><empty-line /><p>
Задача, що розділяється на модулі. Переваги – простота написання, можливість використання модулів в різних програмах, модуль важить менше монолітної програми. Недоліки – потрібно описати взаємодію модулів, підключаючи їх, багато модулів займають більше місця.</p>

<p><strong>8. Вхідна й вихідна інформація редактору зв’язків.</strong> #red #link</p><empty-line /><p>
Вхідна – об’єктний модуль, вихідна – завантажувальний.</p>

<p><strong>9. Що таке неоднорідна система? Якими характеристиками визначається неоднорідність?</strong> #system #neodnor</p><empty-line /><p>
Заявка не може бути виконана на даному ресурсі.</p>

<p><strong>10. Перерахувати стратегії, що застосовуються в алгоритмах оптимізації.</strong> #start #optim</p><empty-line /><p>
Генетичних алгоритмів, оціночних функцій, напрямного пошуку, Anealing метод, метод пошуку максимального паросполучення у зваженому графі, модифікований угорський, метод гілок та границь, модифікований метод для RealTimeOS, евристичний, складання розкладу, метод виключного планування.</p>

<p><strong>11. Чим визначається перехід від непрямого методу доступу до колективного?.</strong> #collect #dost #access</p><empty-line /><p>
Тим, що реакція машини стає більш швидкою, ніж реакція користувача.</p>

<p><strong>12. Пояснити непряме введення-виведення.</strong> #io #nepr</p><empty-line /><p>
Непряме введення-виведення – не сам процесор виконує ввід/вивід, а спеціальні процесори – канали. Це сталося після появи логіки переривань. Ввід/вивід розпаралелено з роботою основного процесору.</p>

<p><strong>13. Що таке супервизор й де він знаходиться?</strong> #supervisor</p><empty-line /><p>
Супервізор спостерігає за процесором від моменту створення до виходу. Він керує процесом, пам’яттю і роботою обладнання ОС.  Знаходиться в ядрі.</p>

<p><strong>14. Недолік генетичних алгоритмів.</strong> #genet #algo</p><empty-line /><p>
Проблематично, коли необхідно знайти точний глобальний оптимум, час виконання функції великий, необхідно знайти всі рішення задачі, конфігурація не є простою (кодування рішення).</p>

<p><strong>15. Рівні планування в одно процесорній системі.</strong> #plan #level</p><empty-line /><p>
Завдання проходять через три рівні. Перший – ті, що пройшли, претендують на захват ресурсів в системі. Середній рівень оброблює пріоритети і переводить завдання в ранг задач. Нижній рівень – визначення черги задач по виділенню часу процесора.</p>

<p><strong>Білет 3</strong></p>

<p><strong>1. Недоліки методу колективного доступу.</strong> #collect</p><empty-line /><p>
Смуга пропускання не належить одному користувачу, можуть бути проблеми з QoS.</p>

<p><strong>2. Особливості розподілених операційних систем.</strong> #rozpod</p><empty-line /><p>
Розподілена ОС – сукупність обчислювальних вузлів, з’єднаних між собою каналами зв’язку, з точки зору користувача представляє собою єдине ціле. Відсутність спільної пам’яті призводить до неможливості визначення загального стану за допомогою множини спільних змінних, а неможливість спільного звернення до пам’яті та різниця в затримках передач повідомлень призводить до того, що при визначенні стану будь-якого елементу системи з різних точок можна отримати різні результати. Виконання роботи розподіляється у вузлах, виходячи з міркувань пропускної здатності усієї системи. Розподіленні системи мають високий рівень організації паралельних обчислень.</p>

<p><strong>3. Стpуктуpа модуля  Специфікація та тіло.</strong></p>

<p><strong>4. Стратегії, що використовуються при динамічному плануванні.</strong> #dynamic #strat</p><empty-line /><p>
Пошук максимального паросполучення, визначення конфліктних призначень, виділення підматриць.</p>

<p><strong>5. Що таке транзитні програми ОС?</strong> #transit</p><empty-line /><p>
Які завантажуються у пам’ять тільки при необхідності.</p>

<p><strong>6. Резиденція системи. Які програми там знаходяться?</strong> #resident</p><empty-line /><p>
Це ОС, що отримується в результаті генерації. В ній знаходяться резидентні програми, тобто програми, що завжди в пам’яті.</p>

<p><strong>7. Програма динамічної послідовної структури. Чим вона краще інших структур.</strong> #struct #posl</p><empty-line /><p>
Програми, налаштовані за допомогою модульного принципу, представлені в переміщувальному вигляді, можуть підгружатися за мірою необхідності з організацією зв’язків по керуванню та даними. Краще інших, тому що пам’ять виділяється тільки коли потрібна.</p>

<p><strong>8. Коли застосовують евристичні алгоритми?</strong> #evrist</p><empty-line /><p>
Коли висока обчислювальна складність.</p>

<p><strong>9. Дати визначення балансового планування. Які проблеми в його вирішенні?</strong> #balans #plan</p><empty-line /><p>
Система планує навантаження, коли задача не вирішується – зовнішній планувальник намагається визначити чи правильне розподілення на вузлах. Проблеми – як визначити, що програма вісить? Передбачити звільнення, проблема міграції.</p>

<p><strong>10. Що таке резидентні вершини? Як їх знайти та як можна їх використати?</strong> #resident</p><empty-line /><p>
Вершини, що увійшли в критичний шлях, а їх часові та просторові координати не повинні змінюватись при вирішенні задач. Знайти критичний шлях.</p>

<p><strong>11. Недоліки використання мультипрограмування.</strong> #multi</p><empty-line /><p>
Може збільшитися час вирішення окремої задачі, завантаження процесорів збільшується, якщо задача захватить процесор, то вона його не віддає.</p>

<p><strong>12. Основна відмінність використання підпрограм в компілюючих системах и інтерпретуючих.</strong> #program #compil #interp</p><empty-line /><p>
Інтерпретуючі переводять частину програми в машинні команди і одразу виконують, виконуючи налаштування адресних констант. Компілючі створюють об’єктний модуль, який потім обробляється редактором зв’язків.</p>

<p><strong>13. Як знайти максимально й мінімально необхідну кількість процесорів?</strong> #proc #min</p><empty-line /><p>
Максимальна ширина ярусу ярусно-паралельної форми – максимальна кількість. Мінімальна: N<emphasis>min = [SUM(i=1, n) {t</emphasis>i} / T_kp]</p>

<p><strong>14. Ідея застосування алгоритмів кластеризації.</strong> #claster #algo</p><empty-line /><p>
Шляхи визначення вузлів, що кластерізуються. Зменшення графу. Знаходження критичної вершини, що визначає час вирішення.</p>

<p><strong>15. Навіщо потрібен рівень реконфигурації в системі планування багатопроцесорної паралельної системи?</strong> #reconf #level</p><empty-line /><p>
Для продовження роботи в разі виходу з ладу якогось обладнання.</p>

<p><strong>Білет 4</strong></p>

<p><strong>1. Якими міркуваннями визначається вибір кванта при паралельній обробці?</strong> #kvant</p><empty-line /><p>
Час кванту повинен бути більшим за час переключення процесів.</p>

<p><strong>2. Коли застосовують евристичні алгоритми?</strong> #evrist</p><empty-line /><p>
Коли висока обчислювальна складність задачі.</p>

<p><strong>3. Дати визначення області збереження. Чим визначається розмір, яка інформація завжди має бути збережена?</strong>  #obl #save #zberej</p><empty-line /><p>
Це область пам’яті, в якій зберігаються регістри та відгалуження повернення. В неї записується інформація про перерваний процес і звідти система бере дані при відновленні процесу. Розмір залежить від кількості даних, які необхідні системі для відновлення процесу.</p>

<p><strong>4. Особливості програмного забезпечення розподілених систем обробки інформації.</strong> #rozpod #distr</p><empty-line /><p>
Відсутність спільної пам’яті призводить до неможливості визначення загального стану за допомогою множини спільних змінних, а неможливість спільного звернення до пам’яті та різниця в затримках передач повідомлень призводить до того, що при визначенні стану будь-якого елементу системи з різних точок можна отримати різні результати. Виконання роботи розподіляється у вузлах, виходячи з міркувань пропускної здатності усієї системи. Розподіленні системи мають високий рівень організації паралельних обчислень.</p>

<p><strong>5. Відмінність завантажувального модуля від абсолютного. Які системні програми приймають участь у їх створенні?</strong> #modul #zavant #load #abs</p><empty-line /><p>
Абсолютний модуль розміщується в пам’яті. Завантажувальний не може бути виконаним. Завантажувальний модуль отримується з об’єктного, оброблено редактором зв’язків. Абсолютний отримується з завантажувального, який оброблює завантажувач.</p>

<p><strong>6. Дати визначення ініціалізації ядра. Чим вона відрізняється від ініціалізації системи?</strong> #kernel #init</p><empty-line /><p>
Ініціалізація ядра – для формування системних таблиць, в яких зберігається вся інформація про програми супервізора та всіх параметрів, що динамічно змінюються. Ініціалізація системи – додавання додаткових функцій, які визначені користувачем.</p>

<p><strong>7.  Чим визначається вибір змішаної дисципліни обслуговування?</strong> #zmish #disc</p><empty-line /><p>
Для покращення обслуговування. Використовуються різні комбінації щоб взяти найкращі сторони дисциплін.</p>

<p><strong>8.  Що називається ядром супервізора? Його функції.</strong> #supervis</p><empty-line /><p>
Ядром супервізора є блок керування процесом. Він містить ім’я процесу, розподілені ресурси та контролює їх.</p>

<p><strong>9. Як визначити мінімально необхідну кількість процесорів для завантаження паралельного алгоритму? Дати приклад, коли формула дає неправильних результат.</strong> #min #proc</p><empty-line /><p>
N<emphasis>min = [SUM(i=1, n) {t</emphasis>i} / T_kp]</p>

<p><strong>10. Завантаження операційної системи. Етапи.?</strong> #boot #os #load</p><empty-line /><p>
Першим загружається BIOS. Він тестує обладнання, завантажує таблиці переривань. Завантажується завантажувач MBR, який визначає кількість розділів, чи є на них ОС та яка. Потім загрузка передається ОС. Визначаються апаратні засоби, обирається конфігурація. Після цього відбувається загрузка ядра, його ініціалізація. Потім ініціалізація системи.</p>

<p><strong>11. Структура бібліотеки . Чим ця структура відрізняється від структури файлової системи?</strong> #lib #fs #struct</p><empty-line /><p>
Бібліотека, керуюча програма, каталог. Файлова система складається з каталогів та файлів.</p>

<p><strong>12. Що таке віртуальна операційна система? Чи використовується вона в персональних комп’ютерах?</strong> #virt #os</p><empty-line /><p>
Це ОС, яка може бути запущена з іншої ОС, при цьому їй виділяються або реальні апаратні засоби, або віртуальні. Це дозволяє на одній машині користуватися декільком користувачам різними ОС. Використовується.</p>

<p><strong>13.  Основна характеристика задач планування з передуванням.</strong> #plan #pered</p><empty-line /><p>
Заздалегідь відомо що буде виконуватись (задача), на чому (ресурси), тому планування можна провести до виконання задач та на іншому обладнанні.</p>

<p><strong>14. Перерахувати стратегії, що використовуються в алгоритмах оптимізації.</strong> #strat #optim</p><empty-line /><p>
Генетичних алгоритмів, оціночних функцій, напрямного пошуку, Anealing метод, метод пошуку максимального паросполучення у зваженому графі, модифікований угорський, метод гілок та границь, модифікований метод для RealTimeOS, евристичний, складання розкладу, метод виключного планування.</p>

<p><strong>15. Алгоритми динамічного планування, що використовуються в сучасних ОС.</strong> #dynam #plan</p><empty-line /><p>
Алгоритм пошуку максимального паросполучення, виділення конфліктних призначень, пошук підматриць.</p>

<p><strong>Білет 5</strong></p>

<p><strong>1. Дати визначення класичного мультипрограмування.</strong> #multiprog</p><empty-line /><p>
Иначе именуется пакетным
Задачи, планируемые к выполнению, называются пакетом. Переключение между задачами в пакетном режиме инициируется выполняющейся в данный момент задачей, поэтому промежутки времени выполнения той или иной задачи неопределены.</p>

<p><strong>2. Дати визначення процесу. Стан процесу. Чим визначається вихід з активного в підготовлений стан?</strong> #proc #state</p><empty-line /><p>
Процессом является выполняемая программа, вместе с текущими значениями счетчика комманд, регистров и переменных.</p>

<p><strong>3. Яка програма виконує запис інформації в область зберігання та яка інформація туди записується?</strong></p>

<p><strong>4. Чим відрізняється загрузка EXE й COM  модулів?</strong> #com #exe #load</p><empty-line /><p>
COM – абсолютный загрузчик, EXE – настраивающий.
TLDR: COM не имеет хедеров и грузится с дефолтными настройками. EXE имеет кучу метаданных + таблицу линковки DLL + еще кучу ресурсов и тп. Там много математики вычисления сементов.
<emphasis>Загрузка COM-программы</emphasis>
В процессе загрузки com-программы операционная система выполняет следующие действия: 
сегментные регистры CS, DS, ES, SS устанавливаются на начало PSP ; 
регистр SP устанавливается на конец сегмента PSP ; 
вся область памяти после PSP распределяется программе; 
в стек записывается слово 0000; 
указатель команд IP устанавливается на 100h (начало программы) с помощью команды JMP по адресу PSP :100h. 
<emphasis>Загрузка EXE-программы</emphasis>
Загрузка exe-программы происходит значительно сложнее, так как связана с настройкой сегментных адресов: 
во внутренний буфер MS-DOS считывается форматированная часть заголовка файла;
определяется размер загрузочного модуля
определяется смещение начала загрузочного модуля в exe-файле
вычисляется сегментный адрес для загрузки START<emphasis>SEG
загрузочный модуль считывается в память по адресу START</emphasis>SEG:0000;
сканируются элементы таблицы перемещений, располагающейся в exe-файле со смещением relt<emphasis>off;
для каждого элемента таблицы выполняются следующие действия:
- считывается содержимое элемента таблицы как два двухбайтных слова (OFF, SEG); 
- вычисляется сегментный адрес ссылки перемещения
- выбирается слово по адресу REL</emphasis>SEG:OFF, затем к этому слову прибавляется значение START<emphasis>SEG, после чего сумма записывается обратно по тому же адресу
заказывается память для программы, исходя из значений min</emphasis>mem и max<emphasis>mem; 
инициализируются регистры; 
программе передается управление. 
При инициализации регистры ES и DSустанавливаются на начало PSP , регистр AXустанавливается так же, как и для com-программ, в сегментный регистр стека SS записывается значение START</emphasis>SEG + ss<emphasis>reg, а в регистр SP записывается значение sp</emphasis>reg. 
Для передачи управления программе в сегментный регистр CS записывается значение START<emphasis>SEG + cs</emphasis>reg, а в регистр IP - значение ip_reg. Такая запись невозможна напрямую, поэтому операционная система сначала записывает в свой стек значение для CS, затем значение для IP и после этого выполняет команду дальнего возврата RETF (команда возврата из дальней процедуры).</p>

<p><strong>5. Функції завантажника. В яких завантажниках які функції виконуються системою?</strong> #load #boot</p><empty-line /><p>
Распределение памяти, настройка, редактирование, загрузка.</p>

<p><strong>6.  Чим відрізняються файлова система та бібліотека?</strong> #fs #lib</p><empty-line /><p>
Бібліотека, керуюча програма, каталог. Файлова система складається з каталогів та файлів.</p>

<p><strong>7.  Як визначити об’єм пам’яті, необхідної для завантаження програми оверлейної структури?</strong> #struct #memory #overlay</p><empty-line /><p>
Теория:
Оверлей - это такой способ использования оперативной памяти, при котором в один и тот же участок памяти, называемый оверлейным буфером, попеременно по мере надобности загружаются различные оверлейные (перекрывающиеся) модули. При этом все оверлейные модули в готовом к работе виде хранятся на диске, а в оперативной памяти в каждый момент находится лишь один активный модуль и, возможно, небольшое число неактивных.</p>

<p>Ответ: 
Минимальный размер памяти = размер главного модуля + максимальный размер оверлейного модуля.</p>

<p><strong>8.  Чому алгоритм FBn краще RR? Яка характеристика при цьому покращується?</strong> #fbn #rr #algo</p><empty-line /><p>
http://www.lk.cs.ucla.edu/data/files/Kleinrock/Feedback%20Queueing%20Models%20for%20Time-Shared%20Systems.pdf
В FBn существует N очередей. Заявка помещается в конец первуй очереди. Процессор берет заявку из i-й очереди если очереди от 1 до i-1 пусты. После истечения кванта заявки идет в i+1 очередь
Преимущество в том, что мелкие задачи быстрее выходят.</p>

<p><strong>9.  Дати визначення балансового планування. Які проблеми мають вирішуватися?</strong></p>

<p><strong>10. Що таке напівнеоднорідна система? Як виражається відношення «задача – ресурс»?</strong></p>

<p><strong>11. Що таке супервізор й де він знаходиться?</strong> #supervis</p><empty-line /><p>
A supervisory program or supervisor is a computer program, usually part of an operating system, that controls the execution of other routines and regulates work scheduling, input/output operations, error actions, and similar functions and regulates the flow of work in a data processing system.
It can also refer to a program that allocates computer component space and schedules computer events by task queuing and system interrupts. Control of the system is returned to the supervisory program frequently enough to ensure that demands on the system are met.</p>

<p><strong>12. Дати визначення розподіленої операційної системи.</strong></p>

<p><strong>13. Які стратегії використовуються при розв’язанні NP-повних задач?</strong> #np #strat</p><empty-line /><p>
Метод ветвей и границ состоит в отбрасывании заведомо неоптимальных решений целыми классами в соответствии с некоторой оценкой
Метод локальных улучшений состоит в поиске более оптимального решения в окрестности некоторого текущего решения
Приближенные и эвристические методы состоят в применении эвристик для выбора элементов решения
Псевдополиномиальные алгоритмы представляют собой подкласс динамического программирования
Метод случайного поиска состоит в представлении выбора последовательностью случайных выборов</p>

<p><strong>14. Дати визначення пошуку максимального паросполучення.</strong> #max #parasp #search</p><empty-line /><p>
Паросочетанием M называется набор попарно несмежных рёбер графа (иными словами, любой вершине графа должно быть инцидентно не более одного ребра из множества M). Мощностью паросочетания назовём количество рёбер в нём. Наибольшим (или максимальным) паросочетанием назовём паросочетание, мощность которого максимальна среди всех возможных паросочетаний в данном графе. Все те вершины, у которых есть смежное ребро из паросочетания (т.е. которые имеют степень ровно один в подграфе, образованном M), назовём насыщенными этим паросочетанием.</p>

<p><strong>15. У чому відмінність часової складності від обчислювальної?</strong> #skladn #obig #bigo</p><empty-line /><p>
Временная сложность – ф-я времени выполнения от размерности задачи.
Вычислительная содержит 2 параметра – временную и пространственную (требование к памяти от размерности задачи)</p>

<p><strong>Білет 6</strong></p>

<p><strong>1. Дати визначення програми з точки зору операційної системи.</strong> #program #os</p><empty-line /><p>
Ничего адекватного пока не нашел</p>

<p><strong>2. Умова переходу процесу з активного стану в підготований</strong> #state #active</p><empty-line /><p><strong>3. Зв'язок модулів за керуванням. Які операції виконуються й якими програмами? Яка інформація й куди при цьому записується?</strong></p>

<p><strong>4.  Умови переходу з Р3 у Р1 або Р2.</strong> #perehid #p3 #p1 #p2</p><empty-line /><p>
Выход из прерывания, вызов сист. Функции из прерывания
Р4 - машина не работает, выхода из него нет
Р3 - состояние, в которое переходит если зафиксировано прерывание. атомарная операция расшифровки прерывания
Р2 - программы пользователя (прикладные)
Р1 - система обрабатывает системные процессы</p>

<p><strong>5.  При наявності віяла, яке ребро береться у рішення?</strong></p>

<p><strong>6.  Основні дії програми початкового завантаження. Де вона зберігається та як її знайти?</strong> #boot #load</p><empty-line /><p>
POST(проверка оборудования). Загрузка бутового загрузчика и передача ему управления. Лежит в BIOS.</p>

<p><strong>7.  Як визначити об’єм пам’яті, необхідної для завантаження програми оверлейної структури?</strong> #struct #overlay</p><empty-line /><p>
Теория:
Оверлей - это такой способ использования оперативной памяти, при котором в один и тот же участок памяти, называемый оверлейным буфером, попеременно по мере надобности загружаются различные оверлейные (перекрывающиеся) модули. При этом все оверлейные модули в готовом к работе виде хранятся на диске, а в оперативной памяти в каждый момент находится лишь один активный модуль и, возможно, небольшое число неактивных.

Ответ: 
Размер памяти = размер главного модуля + максимальный размер оверлейного модуля.  Если модули вызывают друг-друга, то максимальная сумма одновременно загруженых модулей</p>

<p><strong>8.  Дати визначення ГРІД системи.</strong></p><empty-line /><p>
Он точно это давал на лекции,  нужно просмотреть конспекты</p>

<p><strong>9.  Як визначити зону знаходження оптимального розкладу для систем зі спільною пам’яттю?</strong></p>

<p><strong>10. Що таке строго неоднорідна ОС? Яка задача має розв’язуватися при плануванні? </strong> #neodnor #os</p><empty-line /><p>
http://www.multicoreinfo.com/research/papers/whitepapers/OSHMA_2007.pdf
Проблемы:
1. Optimal performance (Производительность)
2. Core assignment balance(Баланс нагрузки)
3. Response time fairness.</p>

<p><strong>11. Що шукає алгоритм Мальгранжа та який його основний недолік?</strong> #malgrandj #nirvana #algo</p><empty-line /><p>
разбиение графов на сильно связные под-графы.</p>

<p><strong>12. Яку задачу розв’язує лінійний планувальник? Яка стратегія при цьому використовується?</strong></p>

<p><strong>13. Чим відрізняється матриця зв’язності від матриці інцидентності?</strong> #matrix</p><empty-line /><p>
Связность показывает связь между i-й и j-й вершинами
Инцидентность показывает соседство вершин и ребер(строка – вершина, столбец – ребро)</p>

<p><strong>14. Дати приклад неявної транзитності .</strong> #transit #image</p><empty-line /><p><strong>Білет 7</strong></p>

<p><strong>1. Дати визначення непрямого доступу. Переваги й недоліки. Де він застосовується зараз.</strong> #acces #dost #nepr</p><empty-line /><p>
Режим буферизации для выравнивания скоростей при вводе и считывании информации из буфера.При работе программ системного ввода u/ режим спуллинга – согласование скоростей на входе и выходе.</p>

<p><strong>2. Чому спулінг схильний до тупикових ситуацій?</strong> #spul #tupik #sssr</p><empty-line /><p>
1.  Спулинг - это выравнивание скоростей передачи данных внешних устройств за счет буферизации.
2.  В алгоритмах кластеризации схожие по функциональным признакам узлы объединяются в группы - кластеры</p>

<p><strong>3. Сформулювати принцип оптимальності Белмана?. </strong> #belman #optim #princ</p><empty-line /><p>
Эвристические (основанные на опыте людей), Пошаговое конструирование – разделение всего процесса решения на определенное кол-во шагов и нахождение оптимального или квазиоптимального  решения. ЭТО – соответствует принципу оптимальности Белмана.(???)</p>

<p><strong>4. Задачі, що розв’язуються при статичному плануванні.</strong> #static #plan</p><empty-line /><p>
Поиск min-го кол-ва процессоров, необходимых для решения комплекса информационно- и по управлению взаимосвязанных задач за время, не превышающее заданное или критическое; поиск плана решения заданного комплекса информационно- и по управлению взаимосвязанных задач на заданном кол-ве процессоров за минимальное время.</p>

<p><strong>5. Функції завантажника, що налаштовує. Яка програма готує для нього інформацію?</strong> #loader #comp #func</p><empty-line /><p>
Распределение памяти, настройка, редактирование, загрузка. Информацию для него готовит компилятор.</p>

<p><strong>6. Де знаходиться програма початкового завантаження? Її функції. </strong> #loader #func #mbr</p><empty-line /><p>
В MBR. Активизация программ начальной загрузки.</p>

<p><strong>7. Як визначити об’єм пам’яті, необхідної для завантаження програми динамічної послідовної структури?</strong> #struct #memory #dynamic</p><empty-line /><p>
Корневой сегмент + наибольший суммарный объем модулей, которые могут выполнятся параллельно</p>

<p><strong>8. Основна особливість пріоритетних дисциплін обслуговування. Види пріоритетів. </strong> #prior #disc</p><empty-line /><p>
Заявки имеют приоритет. Приоритетное обслуживание – заявка на вход системы с заданным приопитетом. Относительный приоритет – не может прервать задачу на ресурсе, даже если она имеет низкий приоритет. Абсолютный приоритет – прерывает задачу на ресурсе если та имеет более низкий приоритет. Динамический приоритет – ЕСЛИ возникает опасность бесконечного откладывания. ЕСЛИ по мнению sys, заявка слишком долго занимает ресурс, ТО ее приоритет понижается. ЕСЛИ заявка очень долго ожидает ресурс ТО ее приоритет повышается.(QoS)</p>

<p><strong>9. Що таке конфліктне значення? Навіщо їх виділяти?</strong> #conflict</p><empty-line /><p>
1.  Конфликтное назначение уменьшает мощность паросочетания. Это назначения стоящие под главной диагональю после выделения основных подматриц.</p>

<p><strong>10. Ідея оптимізації  «базового» рішення.</strong> #base #optimis</p><empty-line /><p>
2.  «Базовое» решение оптимизируется по необходимому критерию - время выполнения,       количество процессоров.</p>

<p><strong>11. Ідея алгоритмів покрокового конструювання. </strong></p>

<p><strong>12. Що таке NP-повна задача?  </strong> #np</p><empty-line /><p>
Та, яка не вирішується за поліноміальний час, по ходу</p>

<p><strong>13. Основа алгоритму кластеризації, з застосуванням стратегії пошуку критичного шляху.(??)</strong> #clast #algo</p><empty-line /><p>
Зменшення графу. Знаходження критичної вершини, що визначає час вирішення.</p>

<p><strong>14. Способи опису графу. </strong> #graph</p><empty-line /><p>
    Табличный, графический, аналитический и словесный.</p>

<p><strong>15. Види топології паралельних систем. В який топології можна досягнути мінімізації пересилок?</strong> #topol #paral</p><empty-line /><p>
PARA-PC Velsh – Рисунок – много ОЗУ много ПЭ – все подключены к облаку – Коммуникационная среда – (Статическая и динамическая коммутация(ПЭ-ПЭ или ПЭ ОЗУ)) =&gt; Можно моделировать (Общую Память) (Общая Шина ) (КЭШ-шинно ориентированные – Общая шина + Каждый ПЭ общается с шиной via КЭШ (содержит программный код и промежуточные данные) (Система с виртуальной памятью – предидущее без ОП))Дерево Гипергуб</p>

<p><strong>Білет 8</strong></p>

<p><strong>1. Дати визначення колективного доступу. Переваги й недоліки. Чи застосовується він зараз й де саме?</strong> #access #collectiv #colectiv</p><empty-line /><p>
Коллективный доступ Предусматривающий доступ к ресурсам системы (система работает в многопрограммном режиме) многих пользователей, одновременная работа нескольких userov на машине (Логика прерываний).Увеличивается скорость.Надежность машины. Доступ к ресурсам системы имеют несколько пользователей, система работает в многопрограммном режиме. У каждого пользователя свой терминал. Система должна бать очень надежной, а центральная машина - очень мощной.</p>

<p><strong>2.Умова переходу процесу з активного стану в заблокований</strong> #perehid #state #proc</p><empty-line /><p>
Истечение кванта времени. (Выделенное время процессора для выполнение этого процесса завершилось и процессор занят другим процессом).</p>

<p><strong>3. Чому усі алгоритми, засновані на теоремі Бержа про максимальне паросполучення непридатні для використання в динамічних планувальниках</strong> #berj #berg</p><empty-line /><p>
Пусть зафиксировано некоторое паросочетание M. Тогда простая цепь P = (v1, v2, ..., vk) называется чередующейся цепью, если в ней рёбра по очереди принадлежат - не принадлежат паросочетанию M. Чередующаяся цепь называется увеличивающей, если её первая и последняя вершины не принадлежат паросочетанию. Иными словами, простая цепь P является увеличивающей тогда и только тогда, когда вершина v1 !in M, ребро (v2, v3) in M, ребро (v4, v5) in M, ..., ребро (v<emphasis>{k-2}, v</emphasis>{k-1}) in M, и вершина vk !in M.</p><empty-line /><p>Теорема Бержа (Claude Berge, 1957 г.). Паросочетание M является наибольшим тогда и только тогда, когда для него не существует увеличивающей цепи.</p><empty-line /><p>
Доказательство необходимости. Пусть для паросочетания M существует увеличивающая цепь P. Покажем, как перейти к паросочетанию большей мощности. Выполним чередование паросочетания M вдоль этой цепи P, т.е. включим в паросочетание рёбра (v1, v2), (v3, v4), ..., (v<emphasis>{k-1}, vk), и удалим из паросочетания рёбра (v2, v3), (v4, v5), ..., (v</emphasis>{k-2}, v<emphasis>{k-1}) . В результате, очевидно, будет получено корректное паросочетание, мощность которого будет на единицу выше, чем у паросочетания M (т.к. мы добавили k/2 рёбер, а удалили k/2 - 1 ребро). </emphasis></p><empty-line /><p><emphasis>
Доказательство достаточности. Пусть для паросочетания M не существует увеличивающей цепи, докажем, что оно является наибольшим. Пусть M — наибольшее паросочетание. Рассмотрим симметрическую разность G = M (+) M (т.е. множество рёбер, принадлежащих либо M, либо M, но не обоим одновременно </emphasis>(WTF?!)_). Покажем, что G содержит одинаковое число рёбер из M и M (т.к. мы исключили из G только общие для них рёбра, то отсюда будет следовать и |M| = |M|). Заметим, что G состоит только из простых цепей и циклов (т.к. иначе одной вершине были бы инцидентны сразу два ребра какого-либо паросочетания, что невозможно). Далее, циклы не могут иметь нечётную длину (по той же самой причине). Цепь в G также не может иметь нечётную длину (иначе бы она являлась увеличивающей цепью для M, что противоречит условию, или для M, что противоречит его максимальности). Наконец, в чётных циклах и цепях чётной длины в G рёбра поочерёдно входят в M и M, что и означает, что в G входит одинаковое количество рёбер от M и M. Как уже упоминалось выше, отсюда следует, что |M| = |M|, т.е. M является наибольшим паросочетанием.
Теорема Бержа даёт основу для алгоритма Эдмондса — поиск увеличивающих цепей и чередование вдоль них, пока увеличивающие цепи находятся.</p>

<p><strong>4.Розподілена система — це набір незалежних комп'ютерів, що представляється їх користувачам єдиною об'єднаною системою. </strong> #rozpod</p><empty-line /><p>
У цьому визначенні обмовляються два моменти. Перший відноситься до апаратури: всі машини автономні. Другий стосується програмного забезпечення: користувачі думають, що мають справу з єдиною системою. Важливо обидва моменти. Можливо, замість того щоб розглядати визначення, розумніше буде зосередитися на важливих характеристиках розподілених систем. Перша з таких характеристик полягає в тому, що від користувачів приховані відмінності між комп'ютерами і способи зв'язку між ними. Те ж саме відноситься і до зовнішньої організації розподілених систем. Іншою важливою характеристикою розподілених систем є спосіб, за допомогою якого користувачі і додатки одноманітно працюють в розподілених системах, незалежно від того, де і коли відбувається їх взаємодія.</p><empty-line /><p>
Розподілені системи повинні також відносно легко піддаватися розширенню, або масштабуванню. Ця характеристика є прямим наслідком наявності незалежних комп'ютерів, але в той же час не указує, яким чином ці комп'ютери насправді об'єднуються в єдину систему. Розподілені системи зазвичай існують постійно, проте деякі їх частини можуть тимчасово виходити з ладу. Користувачі і додатки не повинні повідомлятися про те, що ці частини замінені або полагоджені або що додані нові частини для підтримки додаткових користувачів або додатків.</p><empty-line /><p>
Для того, щоб підтримати представлення різних комп'ютерів і мереж у вигляді єдиної системи, організація розподілених систем часто включає додатковий рівень програмного забезпечення, що знаходиться між верхнім рівнем, на якому знаходяться користувачі і додатки, і нижнім рівнем, що складається з операційних систем, як показано на рис. 1. Відповідно, така розподілена система зазвичай називається системою проміжного рівня (middleware).</p>

<p><strong>5.Дать определение – транзитный модуль.</strong> #transit</p><empty-line /><p>
Программы, связанные с выполнением функций ОС, но не находящиеся постоянно в ОП называются транзитными. Эти программы вызываются в ОП по мере необходимости. – проги., которые могут понадобится 4/ выполнения ф-ций ОС (но не резидентные) – могут вызываться по оверлейной || динамически-последовательной схеме в транзитную зону.</p>

<p><strong>6. Дать определение Табличный метод управления</strong> #table</p><empty-line /><p>
Метод когда решение управляющей системы принимается на основании инфы, хранящейся в таблицах, содержащих данные состояния всех частей системы.</p>

<p><strong>7. Цільова функція планування в реальному часі. </strong></p>

<p><strong>8. Яка характеристика покращується у змішаних алгоритмах обслуговування й чому її треба покращувати? </strong> #mixed #algo</p><empty-line /><p>
Среднее время ожидания заявки</p>

<p><strong>9. Найти максимальное паросочетание</strong> #para #max</p><empty-line /><p>
- значит найти максимальное число ребер графа в которых не совпадают координаты вершин, либо найти максимальное число единиц матрицы у которых не совпадают координаты. С ………………..</p>

<p><strong>10.Що таке критичні вершини?</strong></p>

<p><strong>11. . Чим визначається зміст програм, що знаходяться в оперативній пам’яті? </strong></p>

<p><strong>12. У чому складність для операційної системи в організації багатопрограмного режиму?</strong> #multi #os</p><empty-line /><p>
Организация защиты от взаимного влияния друг на друга на уровне оперативной и на уровне внешней памяти; разделение аппаратных и программных ресурсов; планирование (во времени, а в случае ПВС и в пространстве).</p>

<p><strong>13.Как определить верхнюю границу кол-ва процессоров для погружения комплекса задач .</strong> #max #proc</p><empty-line /><p>
Можно определить max число процессоров,  выше которого практически не выгодно иметь больше процессоров – max ширина яруса.</p>

<p><strong>14.Классификация задач планирования(?)</strong> #plan</p><empty-line /><p>
Динамическое Статическое Балансовое В реальном времени</p>

<p><strong>15. минимальное к-во процессоров,</strong> #proc #min</p><empty-line /><p>
когда время выполнения взаимосвязанных задач не превышает Ткр
N<emphasis>min = [SUM(i=1, n) {t</emphasis>i} / T_kp]</p>

<p><strong>Білет 9</strong></p>

<p><strong>1.Розподілена система</strong> #distr #sys</p><empty-line /><p>
— це набір незалежних комп'ютерів, що представляється їх користувачам єдиною об'єднаною системою. 
У цьому визначенні обмовляються два моменти. Перший відноситься до апаратури: всі машини автономні. Другий стосується програмного забезпечення: користувачі думають, що мають справу з єдиною системою. Важливо обидва моменти. Можливо, замість того щоб розглядати визначення, розумніше буде зосередитися на важливих характеристиках розподілених систем. Перша з таких характеристик полягає в тому, що від користувачів приховані відмінності між комп'ютерами і способи зв'язку між ними. Те ж саме відноситься і до зовнішньої організації розподілених систем. Іншою важливою характеристикою розподілених систем є спосіб, за допомогою якого користувачі і додатки одноманітно працюють в розподілених системах, незалежно від того, де і коли відбувається їх взаємодія.</p><empty-line /><p>
Розподілені системи повинні також відносно легко піддаватися розширенню, або масштабуванню. Ця характеристика є прямим наслідком наявності незалежних комп'ютерів, але в той же час не указує, яким чином ці комп'ютери насправді об'єднуються в єдину систему. Розподілені системи зазвичай існують постійно, проте деякі їх частини можуть тимчасово виходити з ладу. Користувачі і додатки не повинні повідомлятися про те, що ці частини замінені або полагоджені або що додані нові частини для підтримки додаткових користувачів або додатків.</p><empty-line /><p>
Для того, щоб підтримати представлення різних комп'ютерів і мереж у вигляді єдиної системи, організація розподілених систем часто включає додатковий рівень програмного забезпечення, що знаходиться між верхнім рівнем, на якому знаходяться користувачі і додатки, і нижнім рівнем, що складається з операційних систем, як показано на рис. 1. Відповідно, така розподілена система зазвичай називається системою проміжного рівня (middleware).</p>

<p><strong>2. Условие перехода процесса из блокированного состояния  в готовое.</strong> #block #proc #pereh #state</p><empty-line /><p>
Наступление события, освобождения ресурса, завершение ввода/вывода.</p>

<p><strong>3. В інформатиці, евристичний алгоритм</strong>, #everist</p><empty-line /><p>
або просто евристика, це алгоритм спроможний видати прийнятне рішення проблеми серед багатьох рішень, але неспроможний гарантувати, що це рішення буде найкращим. Отже такі алгоритми є приблизними і неточними. Зазвичай такі алгоритми знаходять рішення близьке до найкращого і роблять це швидко. Іноді такий алгоритм може бути точним, тобто він знаходить дійсно найкраще рішення, але він все одно буде називатися евристичним, доти доки не буде доведено, що рішення дійсно найкраще. Один з найвідоміших жадібний алгоритм, для того, щоб бути простим і швидким цей алгоритм ігнорує деякі вимоги задачі.</p><empty-line /><p>
Дві фундаментальні цілі в інформатиці - знаходження алгоритмів з вірогідно найкращим часом виконання та з хорошою або оптимальною якістю. Евристичний алгоритм відмовляється від однієї або обох цих цілей; наприклад, він зазвичай знаходить дуже хороше рішення, але немає доказів, що рішення насправді не є поганим; або працює досить швидко, але не має гарантії, що він завжди видасть рішення.</p><empty-line /><p>
Декілька евристичних методів використовуються антивірусним ПЗ для виявлення вірусів та іншого шкідливого ПЗ.</p><empty-line /><p>
Часто, можна знайти таку задачу, що евристичний алгоритм буде працювати або дуже довго, або видавати невірні результати, однак, такі парадоксальні приклади можуть ніколи не зустрітись на практиці через свою специфічну структуру. Таким чином, використання евристики дуже поширене в реальному світі. Для багатьох практичних проблем евристичні алгоритми, можливо, єдиний шлях для отримання гарного рішення в прийнятний проміжок часу. Існує клас евристичних стратегій названих метаалгоритмами, котрі часто використовують, наприклад, випадковий пошук. Такі алгоритми можуть бути застосовані до широкого кола завдань, при цьому хороші характеристики не гарантуються.</p>

<p><strong>4. Методи підвищення ефективності використання ресурсів обчислювальної системи.</strong></p>

<p><strong>5. Дати приклад «неявної» транзитності.</strong> #transit #image</p><empty-line /><p><strong>6. Що називається ядром супервізора, які його функції?</strong> #supervis #kernel</p><empty-line /><p>
Ядром супервізора є блок керування процесом. Він містить ім’я процесу, розподілені ресурси та контролює їх.</p>

<p><strong>7. Яка системна програма готує інформацію для роботи завантажника</strong> #loader #compiler</p><empty-line /><p>
Компілятор.</p>

<p><strong>8. Як визначити зону знаходження оптимального розкладу в системі із загальною шиною?</strong></p>

<p><strong>9. Навіщо потрібно виконувати структурний аналіз вихідного графа? Дати приклад.</strong></p>

<p><strong>10. Як змінюється вихідна інформація системи динамічного планування для однорідних і неоднорідних ОС?</strong></p>

<p><strong>11. У чому відмінність між максимальним парасполученням й досконалим?</strong> #parasp #vidm</p><empty-line /><p>
Найти максимальное паросочетание - значит найти максимальное число ребер графа в которых не совпадают координаты вершин, либо найти максимальное число единиц матрицы у которых не совпадают координаты.</p>

<p><strong>12. Що таке пряме введення-виведення? Який метод застосовується в сучасних системах?</strong> #io</p><empty-line /><p>
Когда не используются управляющие программы. Пользовательский процесс  сам осуществляет i/o</p>

<p><strong>13. Дати визначення "спулінг". Навіщо він застосовується? У чому небезпека його застосування при введенні / виведенні?</strong> #spul</p><empty-line /><p>
Режим буферизации для выравнивания скоростей при вводе и считывании информации из буфера.При работе программ системного ввода u/ режим спуллинга – согласование скоростей на входе и выходе.</p>

<p><strong>14. Закон Амдала.</strong> #amdala #amnedala</p><empty-line /><p>
Зако́н Амдала (англ. Amdahl's law, иногда также Закон Амдаля-Уэра) — иллюстрирует ограничение роста производительности вычислительной системы с увеличением количества вычислителей. Джин Амдал сформулировал закон в 1967 году, обнаружив простое по существу, но непреодолимое по содержанию ограничение на рост производительности при распараллеливании вычислений: «В случае, когда задача разделяется на несколько частей, суммарное время её выполнения на параллельной системе не может быть меньше времени выполнения самого длинного фрагмента». Согласно этому закону, ускорение выполнения программы за счёт распараллеливания её инструкций на множестве вычислителей ограничено временем, необходимым для выполнения её последовательных инструкций.</p><empty-line /><p>
Предположим, что необходимо решить некоторую вычислительную задачу. Предположим, что её алгоритм таков, что доля  от общего объёма вычислений может быть получена только последовательными расчётами, а, соответственно, доля может быть распараллелена идеально (то есть время вычисления будет обратно пропорционально числу задействованных узлов ). Тогда ускорение, которое может быть получено на вычислительной системе из процессоров, по сравнению с однопроцессорным решением не будет превышать величины</p><empty-line /><p>
Sp = 1 / {alpha + {1 - alpha} / p}</p><empty-line /><p>
Закон Амдала показывает, что прирост эффективности вычислений зависит от алгоритма задачи и ограничен сверху для любой задачи с alpha != 0. Не для всякой задачи имеет смысл наращивание числа процессоров в вычислительной системе.</p><empty-line /><p>
Более того, если учесть время, необходимое для передачи данных между узлами вычислительной системы, то зависимость времени вычислений от числа узлов будет иметь максимум. Это накладывает ограничение на масштабируемость вычислительной системы, то есть означает, что с определенного момента добавление новых узлов в систему будет увеличивать время расчёта задачи.</p>

<p><strong>15. Критерії оптимізації рішення задач статичного планування</strong> #optim #crit #static #plan</p><empty-line /><p>
Статическое планирование – план составляется на другой машине &amp;&amp;/|| в другое время. Оптимальный(оптимизированный) план за обозримое (физически нормальное время) Критерий оптимальности – время решения задачи и минимизация u/ресурсов. (NP-полная – времення сложность - експонента)</p>

<p><strong>Білет 10</strong></p>

<p><strong>1. Який механізм являється основою багатопрограмного режиму роботи?</strong> #multi</p><empty-line /><p>
Механізм переривань</p>

<p><strong>2. Умова переходу процесу з активного стану у готовий або підготовлений?</strong> #state #active #ready</p><empty-line /><p>
Коли процес довго виконується та двигається достатньо далеко, то планувальник процесів вирішує, що процесор необхідно віддати іншому процесу, після чого переводить цей процес в стан підготовка та віддає процесор іншому. Коли  ресурс виділяється процесу, то він переходить в стан готовий.</p>

<p><strong>3. Властивості модуля. Пояснити необхідність кожного.</strong> #module</p><empty-line /><p>
Властивості: стандартна внутрішня структура, взаємна незалежність модулів, функціональна завершеність, параметрична універсальність. Вихідний модуль містить в собі код модуля, який потім буде виконуватись. Об’єктний модуль містить в собі скомпільований код, який потім може бути об’єднаний з іншими модулями для виконавчого модуля або бібліотеки. Завантажувальний модуль готовий до виконання, але в ньому не налаштовані адресні константи, написаний на машино-орієнтованій мові. Абсолютний модуль є виконавчим, в ньому визначені адресні константи.</p>

<p><strong>4. Причини виникнення «безкінечного» відкладання. Чому воно небезпечне?</strong> #unlim #infinite #danger #warning</p><empty-line /><p>
Безкінечне відкладання може виникнути якщо процес має малий пріоритет коли планувальник розподіляє ресурси по пріоритетам. Постійно будуть приходити більш пріоритетні процеси, а цей буде безкінечно довго очікувати виділення ресурсів. Це небезпечно тим, що безкінечне очікування може призвести до тупика, який важко відловити.</p>

<p><strong>5. Дати визначення транзитного модуля. За якою схемою завантажуються транзитні модулі і в яку область пам’яті?</strong> #transit</p><empty-line /><p>
Транзитний модуль – модуль, який завантажується в пам’ять тільки тоді, коли він потрібен. Завантажуються по оверлейній або динамічно-послідовній схемі в транзитну область. Але зараз завантажуються в будь-яку область ОП.</p>

<p><strong>6. Які програми знаходяться у ядрі операційної системи? (Види програм)</strong> #kernel #prog</p><empty-line /><p>
Програми, що оброблюють переривання, контролюють процеси, забезпечують їх взаємодію, підтримують операції вводу/виводу, підтримують роботу файлової системи, диспетчеризація процесів, задач, ресурсів, ведення обліку роботи машини.</p>

<p><strong>7. Яку інформацію та як компілятор передає завантажнику, що налаштовує?</strong> #boot #loader #compiler</p><empty-line /><p>
Компілятор передає інформацію про адресні константи в даній команді за допомогою бітів перемістимості.</p><empty-line /><p><strong>8. Чому NP-повні задачі не придатні для динамічного планування?</strong> #np #dynamic #plan</p><empty-line /><p>
Тому що вони не можуть бути вирішені за поліноміальний час n^k. А при динамічному плануванні основна ціль – зменшити час планування, тому динамічні алгоритми мають як правило лінійну складність.</p>

<p><strong>9. Чому й коли блокується система переривань?</strong> #int #interupt #bloc</p><empty-line /><p>
При дешифрації поточного переривання, тому що дешифрація є атомарною операцією.</p>

<p><strong>10. Які методи використовуються для розв’язання NP-повних задач?</strong> #np #method</p><empty-line /><p>
Еврістичні алгоритми, псевдополіноміальні, метод локальних покращень, метод гілок та границь, метод випадкового пошуку.</p>

<p><strong>11. Що таке «спулінг», чому він схильний до тупикових ситуацій?</strong> #spul</p><empty-line /><p>
Спулінг – на вході в систему обслуговування одна швидкість, на виході інша. Задачам при цьому створюється ілюзія одночасного доступу до пристроїв, але задачі працюють без прямого доступу до пристроїв. Спулінг допомогає уникнути тупиків, оскільки напряму з пристроєм працює лише демон.</p>

<p><strong>12. Дати визначення розподіленій системі.</strong> #distr</p><empty-line /><p>
Розподілена ОС – сукупність обчислювальних вузлів, з’єднаних між собою каналами зв’язку, з точки зору користувача представляє собою єдине ціле.</p>

<p><strong>13. Що таке базове рішення та у чому ідея його оптимізації?</strong> #base #optimis</p><empty-line /><p>
Базове рішення – перше правильне рішення задачі. Оптимізація його зменшує час вирішення задачі.</p>

<p><strong>14. Навіщо потрібно виділяти обов’язкові призначення?</strong> #prizn #obov</p><empty-line /><p>
Для того, щоб знайти максимальне паросполучення та щоб можна було виявити конфліктні призначення.</p>

<p><strong>15. Як визначити граничну кількість процесорів для завантаження програм у системі з загальною пам’яттю?</strong> #proc #max #min</p><empty-line /><p>
Максимальна ширина ярусу ярусно-паралельної форми – максимальна кількість.
Мінімальна: N<emphasis>min = [SUM(i=1, n) {t</emphasis>i} / T_kp]</p>

<p><strong>Білет 11</strong></p>

<p><strong>1. Дати визначення системного програмного забезпечення.</strong> #sys</p><empty-line /><p>
Системное программное обеспечение – совокупность программ и их описание для обеспечения функционирования вычислительной системы. Ф-ции: Обеспечить эффективное прохождение заданий usera через систему (с точки зрения usera – среднее время ожидания и производительность) и повышения эффективности.</p>

<p><strong>2. Особливості статичних планувальників.</strong> #stat #plan</p><empty-line /><p>
План решения задач может составляться на другом оборудовании и/или в другое время</p>

<p><strong>3. Структура модуля</strong></p>

<p><strong>4.  У чому складність розв’язання задач планування паралельних процесів?</strong> #plan #parallel #paralel</p><empty-line /><p>
Добавляется планирование в пространстве; появляется проблема синхронизации процессов.
ЕСЛИ в системе нет одинаковых  устройств то очереди обрабатываются по линейной схеме =&gt; планирование только во времени ИНАЧЕ планирование во времени и в пространстве.</p>

<p><strong>5. Временная сложность</strong> –зависимость времени решения задачи от размерности задачи. (Берем наихудший случай) #skl #time</p><empty-line /><p><strong>6. Причина переходу процесу з готового стану в активний.</strong> #state #activ #ready</p><empty-line /><p>
Выделение кванта времени процессора, запуск</p>

<p><strong>7. Як визначити об’єм пам’яті, необхідної для завантаження програми динамічної послідовної структури?</strong> #dynamic #struct</p><empty-line /><p>
Память выделяется по мере надобности – по цепочке.
Уровни не выделяются. Корневой модуль всегда в памяти</p>

<p><strong>8.</strong></p>

<p><strong>9.</strong></p>

<p><strong>10.</strong></p>

<p><strong>11.</strong></p>

<p><strong>12. Пояснити непряме введення-виведення</strong> #io</p><empty-line /><p>
Используется единое обращение к памяти ВУ, процессор освобождается от управления ВУ, и функция ЦП заключается в инициализировании канальных программ и завершении организации ввода/вывода с помощью канала (многопроцессорная система).</p>

<p><strong>13.</strong></p>

<p><strong>14. Ідея створення адаптивних алгоритмів планування</strong> #adaptiv #plan</p><empty-line /><p>
Я думаю, (а значить, існую) динамическое назначение приоритетов</p>

<p><strong>15. Як й коли визначається пріоритет системних та проблемних задач.</strong> #prior #sys</p><empty-line /><p>
Приоритеты системных процессов – при инициализации системы. Блоки управления проблемными (пользовательскими) процессами создаются в процессе активизации процессов динамически – по идее, в этот момент и назначаются приоритеты</p>

<p><strong>Білет 12</strong></p>

<p><strong>1. Перерахувати властивості модуля.</strong> #modul</p><empty-line /><p>
Стандартность внутренней структуры, функциональная завершенность, параметрическая универсальность, взаимная независимость</p>

<p><strong>2. Особливості розподілених операційних систем. Чим вони відрізняються від ОС ЛВС?</strong> #dist #os #sys</p><empty-line /><p>
Распределенная sys – совокупность выч. узлов, связанных между собой каналами связи, с точки зрения usera представляют собой единое целое.Отсутствие общей памяти приводит к невозможности определения общего состояния с помощью множества совместных переменных, а невозможность совместного обращения к памяти и различие в задержках передач сообщений приводит к тому что при определении состояния какого либо элемента системы из двух различных точек можно получить разные результаты. Выполнение работы распределяется  в узлах исходя из соображения пропускной способности всей системы. Распределенные системы имеют высокий уровень организации параллельных вичислений</p>

<p><strong>3.Основні недоліки застосування мультипрограмування. </strong></p>

<p><strong>4. Методи організації обчислювального процесу, що підвищують продуктивність обчислювальної системи.</strong> #prod #sys #org</p><empty-line /><p>
Нашел только производительность файловой системы: -кєширование(использовать буфера в ОП) –для бістрого поиска в кєше используется хєш таблица
  * опережающее чтение блока
  * снижение времени перемещения блока головок 
  * файловая система с журнальной структурой LFS (очень мутная)</p>

<p><strong>5. У чому смисл глобальної та поточної настройки адресних констант.</strong> #const #adr</p><empty-line /><p>
глобальная – перенастройка всех адресных констант, локальная – вычисление адреса той переменной, которая находится реально в ОП</p>

<p><strong>6. Закон Гроша.</strong> #grosh</p><empty-line /><p>
Производительность компьютера увеличивается как квадрат стоимости. Если компьютер A стоит в два раза дороже, чем компьютер B, то вы должны ожидать, что компьютер A в четыре раза быстрее, чем компьютер B.[1]</p>

<p><strong>7. Як визначити об’єм пам’яті, необхідний для завантаження програми простої структури?</strong> #memory #struct</p><empty-line /><p>
размер самой программы + корневой каталог.</p>

<p><strong>8. Алгоритм Корбато лучше алгоритма FBn</strong>, #corbato #fbn #korbato</p><empty-line /><p>
т.к. потенциально обладает большей производительностью т.к. распределяет задачи по очередям не по их приоритетам, а по признаку - абсолютная длина кода программы (чем меньше код тем выше приоритет)(В систему добавлен анализатор, который сразу размещает заявки в свою очередь, соответственно среднее время ожидания уменьшается.)</p>

<p><strong>9. Де знаходяться нові PSW?</strong> #psw #new</p><empty-line /><p>
Значение нового PSW находится в векторе прерывания с номером n, где n указывает номер прерывания обработчик которого нужно взять</p>

<p><strong>10. Ідея застосування методу оціночних функцій. Переваги й недоліки.</strong></p>

<p><strong>11. Недолік колективного доступу та як він усувається у сучасних системах?</strong> #collect #colect #access</p><empty-line /><p>
Предусматривающий доступ к ресурсам системы_(система работает в многопрограммном режиме) многих пользователей, одновременная работа нескольких userov на машине (Логика прерываний). Смуга пропускання не належить одному користувачу, можуть бути проблеми з QoS.</p>

<p><strong>12.  Чому в розподілених системах переважніше використовувати крупнозернисте планування?</strong> #zern #plan</p><empty-line /><p>
Крупнозернистое планирование – когда время выполнения узла больше времени пересылки</p>

<p><strong>13. Пояснити термін «дружня операційна система»</strong></p>

<p><strong>14. Функції рівня операційної системи у багаторівневій системі програмування.</strong></p>

<p><strong>15. Описати рівні статичного планування для одно процесорної ОС.</strong> #plan #level</p><empty-line /><p>
Раннее планирование – запускаем задачу, как только есть все условия.
Позднее – придерживаем задачу без увеличения критического пути</p>

<p><strong>Білет 13</strong></p>

<p><strong>1. Який тип транслятора використовується при трансляції з традиційної машинної мови у команди машини та як він реалізується? </strong> #transl #asm #codes</p><empty-line /><p>
По идее, Ассемблер. Процесс трансляции программы на языке ассемблера в объектный код принято называть ассемблированием. В отличие от компилирования, ассемблирование — более или менее однозначный и обратимый процесс. В языке ассемблера каждой мнемонике соответствует одна машинная инструкция, в то время как в языках программирования высокого уровня за каждым выражением может скрываться большое количество различных инструкций. В принципе, это деление достаточно условно, поэтому иногда трансляцию ассемблерных программ также называют компиляцией.</p>

<p><strong>2. Визначення метаобчислень (суперобчислень)</strong> #metacount #supercount #count</p><empty-line /><p>
Теория метасистемных переходов - это теория эволюции.
Условия реализации эволюции можно создать в мире программ. Достаточно написать для них метапрограммы, то есть программы, преобразующие другие программы. Последовательное и (формально) бесконечное применение метапрограмм к программам и к самим себе будет порождать новые программы. При этом могут возникать метасистемные переходы, приводящие к качественно новым возможностям программ. Созданием метапрограмм (новых метасистем) над программами на основе методов анализа и преобразования программ и занимается теория метавычислений. =))</p>

<p><strong>3. Чому в розподілених системах переважніше використовувати крупнозернисте планування? </strong> #plan #zern</p><empty-line /><p>
Крупнозернистое планирование – когда время выполнения узла больше времени пересылки</p>

<p><strong>4. Дії, що виконує програма ініціалізації ядра. Звідки вона викликається?</strong> #kernel #init</p><empty-line /><p>
При инициализации ядра и системы активизируются и исполняются следующие процессы операционной системы: администратор памяти, программа работы с ВУ, программа поддержки файловой системы и процесс, подчиненный таймеру. Вызывается BIOS=&gt;первичный загрузчик=&gt;вторичный загрузчик=&gt;прогр. Иниц.ядра</p>

<p><strong>5. Функції завантажника, що налаштовує. Яку інформацію повідомляє йому компілятор?</strong> #loader #compiler</p><empty-line /><p>
Распределение памяти, настройка, редактирование, загрузка. Инфу для него готовит компилятор. 
Настраивающий – работает в загр. Модуле которому больше ничего не надо. Постепенно его ф-ции взял на себя редактор связей. Непосредственно в настраивающем загрузчике каждый модуль может транслироваться отдельно. Чтобы передать сообщение редактору связей надо ему непосредственно указать, что надо транслировать. В каждом модуле в начале трансляции выделяются вектора перехода, внешние и внутренние.(Экспорт и Импорт процедур и ф-ций). Кроме того для выполнения настройки каждая команда отмечается битом переместимости. ОС выделяет и пользуетс глобально выделенной памятью, а загрузчик с локальной.</p>

<p><strong>6. Сформулювати теорему про обов’язкові призначення.</strong> #prizn #obov</p><empty-line /><p>
С помощью анализа матрицы выделяют назначение, которое есть обязательным еще до нахождения базового решения.
Теорема 1: Если в двудольном графе существует вершина, которой инцидентно только одно ребро, то вершины, инцидентные этому ребру, должны быть взяты в решение</p>

<p><strong>7. Як визначити об’єм пам’яті, необхідний для завантаження програми оверлейної структури?</strong> #struct #loader #overlay</p><empty-line /><p>
? Гляньте іще теги overlay. Корневой сегмент + самый большой модуль.</p>

<p><strong>8. Основна особливість пріоритетних дисциплін обслуговування. Види. </strong> #obslug #prior</p><empty-line /><p>
Приоритетное обслуживание – заявка на вход системы с заданным приопитетом. Относительный приоритет – не может прервать задачу на ресурсе, даже если она имеет низкий приоритет. Абсолютный приоритет – прерывает задачу на ресурсе если та имеет более низкий приоритет. Динамический приоритет – ЕСЛИ возникает опасность бесконечного откладывания. ЕСЛИ по мнению sys, заявка слишком долго занимает ресурс, ТО ее приоритет понижается. ЕСЛИ заявка очень долго ожидает ресурс ТО ее приоритет повышается.(QoS). Если заявка с более высоким приоритетом не прерывает обслуживание заявки с низким приоритетом –  относительная ДО без вытеснения, соответственно, если наоборот - абсолютная ДО с вытеснением.
Приоритеты бывают: 
  * статические (сразу задаются заявке и не изменяются в процессе)
  * динамические (приоритеты меняются в зависимости от t<emphasis>ожид. или t</emphasis>обслуж.).</p>

<p><strong>9. Дати визначення паралельної системи. </strong> #parallel #paralel #sys</p><empty-line /><p>
Параллельные вычислительные системы — это физические компьютерные, а также программные системы, реализующие тем или иным способом параллельную обработку данных на многих вычислительных узлах.[1] Вики</p>

<p><strong>10. Ідея розв’язання задачі планування методом «пізнього» планування. </strong> #plan #pizn</p><empty-line /><p>
придерживаем задачу без увеличения критического пути</p>

<p><strong>11. Задача «наповнення рюкзака». Для розв’язання якої задачі планування можна її застосовувати?</strong></p>

<p><strong>12. Яка інформація міститься у MBR?</strong> #mbr</p><empty-line /><p>
код загрузчика, таблицу разделов (partition table) и специальную сигнатуру</p>

<p><strong>13. Дати визначення процесу. Коли це поняття стало застосовуватися й чому?</strong> #process #epic #lol</p><empty-line /><p>
Процесс – это траектория процессора в адресном пространстве машины</p>

<p><strong>14. Застосування GRID систем. </strong> #grid #usage</p><empty-line /><p>
Эта технология применяется для решения научных, математических задач, требующих значительных вычислительных ресурсов. Грид-вычисления используются также в коммерческой инфраструктуре для решения таких трудоёмких задач, как экономическое прогнозирование, сейсмоанализ, разработка и изучение свойств новых лекарств.+адронный коллайдер</p>

<p><strong>15 Відмінність завдання від задачі. Де зберігається завдання?</strong> #task</p><empty-line /><p>
Задание – внешняя единица работы системы (описывается на специальном языке). Задание загружается в систему только тогда , когда система имеет свободные ресурсы и преобразуется в задачу.
Задача – внутренняя единица работы системы,для которой система выделила ресурсы кроме процессорного времени.Задача фиксируется в системе если ей выделены системные ресурсы (блок управления процессом).</p>

<p><strong>Білет 14</strong></p>

<p><strong>1. Що таке розв’язання задачі планування з передуванням? </strong> #pered #task #plan</p><empty-line /><p>
Задача после стрелки (на графе, из конспекта)) решается только после того, как решена задача до стрелки. Это при статическом планировании</p>

<p><strong>2. Сформулювати теорему про обов’язкові призначення.</strong> #prizn #obov</p><empty-line /><p>
С помощью анализа матрицы выделяют назначение, которое есть обязательным еще до нахождения базового решения.</p><empty-line /><p>
Теорема 1: Если в двудольном графе существует вершина, которой инцидентно только одно ребро, то вершины, инцидентные этому ребру, должны быть взяты в решение</p>

<p><strong>3. Яка програма виконує запис інформації в область збереження та яка інформація туди записується?</strong> #save #obl #store</p><empty-line /><p>
Область сохранения - область в которую записывается информация о прерванном процессе, и откуда система берет данные при восстановлении процесса. Какая программа выполняет запись в область сохранения(?) – Та часть ядра которая переключает задачи</p>

<p><strong>4. Обробка станів Р3 й Р4.</strong> #state #p3 #p4</p><empty-line /><p>
В Р3 происходит выполнение процедуры сохранения, дешифрации прерывания, а также восстановления прерваной программы. P4 – состояние, в которое машина входит от схем контроля</p>

<p><strong>5. Який тип завантажника працює з модулями з розширеннями COM та EXE?</strong> #com #exe #modul #loader</p><empty-line /><p>
С COM - абсолютный; c EXE - настраивающий.</p>

<p><strong>6. На яку характеристику впливають пріоритетні дисципліни обслуговування заявок?</strong> #prior #obslug</p><empty-line /><p>
Я думаю, логично предположить, на среднее время ожидания</p>

<p><strong>7. Як визначити об’єм пам’яті, необхідний для завантаження програми динамічної паралельної структури?</strong> #memory #dynamic #struct</p><empty-line /><p>
Корневой сегмент + наибольший суммирующий объем модулей, которые могут выполнятся параллельно</p>

<p><strong>8. Математична постановка задачі статичного планування. </strong> #plan #math</p><empty-line /><p>
1.Для задачи, заданной в виде ациклического ориентированного графа, найти минимальное количество процессоров, чтобы время решения не превышало Ткритическое.</p><empty-line /><p>
2. Для того же графа найти такое распределение задач по процессорам, когда минимизируется время решения при заданном кол-ве процессоров.</p>

<p><strong>9. Чому й коли блокується система переривань? </strong> #interupt #block</p><empty-line /><p>
При дешифрации текущего прерывания</p>

<p><strong>10 Як змінюється організація обчислювального процесу для систем зі спільною пам’яттю та СМР?</strong></p>

<p><strong>11. Сформулювати теорему про віяло.</strong> #japan #viyalo #vijalo #teorem #theorem</p><empty-line /><p>
Теорема:</p><empty-line /><p>
Если в двудольном графе есть вершины, которым инцидентно одно ребро, то в этом слуае в решение берутся эти вершины, остальное - редуцируется</p>

<p><strong>12. Що таке віртуальна операційна система, чи застосовується вона у сучасних ОС?</strong> #os #virt</p><empty-line /><p>
Так называемая ОС, которая позволяет многим пользователям работающим на одной и той же технической базе(одно ус-во) одновременно работать в различных операционных средах. Виртуальные ОС – разрешает нескольким useram работать на одном и томже dev на разных ОС.</p>

<p><strong>13. Проблеми керування паралельними процесами. Чому вони важкі для реалізації?</strong> #process #hard #drive</p><empty-line /><p>
Добавляется планирование в пространстве; появляется проблема синхронизации процессов. Тупики</p>

<p><strong>14. Для чого слугує характеристика «часова складність алгоритму»?</strong> #time #sklad</p><empty-line /><p>
Я думаю, логично предположить, для оценки и сравнения эффективности работы алгоритмов</p>

<p><strong>15. Що таке «строго неоднорідна ОС»? Дати приклад такої неоднорідності. </strong> #neodnor #os</p><empty-line /><p>
структуры, где узлы сильно разнятся между собой по своим аппаратным ресурсам, программному обеспечению и структурам данных, соответственно одна и та же заявка на разных узлах может быть обслужена с разной скоростью</p>

<p><strong>Білет 15</strong></p>

<p><strong>1. Дати характеристику неоднорідної системи.</strong> #neodnor #sys</p><empty-line /><p>
Для железа – система содержит процесосры разной специализации и/или производительности. Если имеется ввиду ОС – то хз.</p>

<p><strong>2. Процес. Коли та як визначаються пріоритети системних й проблемних процесів?</strong></p>

<p><strong>3. Як передаються дані між модулями в оверлейних системах? </strong> #data #module #overlay #sys</p><empty-line /><p>
(Не уверен, со справочника по Borland Pascal): передача через стек основной программы.</p>

<p><strong>4. Які операціі виконує завантажник при завантаженні EXE файлу?</strong> #loader #ex</p><empty-line /><p>
1. В  области  памяти после резидентной части выполняющей загрузку программы строится Префикс Программного сегмента.</p><empty-line /><p>
2. Стандартная частъ заголовка считывается в памятъ.</p><empty-line /><p>
3. Определятся длина тела загрузочного модуля (разностъ длины файла  04-07  и  длины  заголовка  08-09 плюс число байт в последнем блоке 02-03).  В зависимости от признака, указывающего загружатъ задачу в конец  памяти  или в начало,  определяется сегментный адрес для загрузки. Этот сегмент называется началъным сегментом.</p><empty-line /><p>
4. Загрузочный модулъ считывается в началъный сегмент.</p><empty-line /><p>
5. Таблица настройки порциями считывается в рабочую памятъ.</p><empty-line /><p>
6. Для  каждого элемента таблицы настройки к полю сегмента прибавляется сегментный адрес началъного сегмента.  В резулътате элемент таблицы  указывает  на  нужное слово в памяти;  к этому слову прибавляется сегментный адрес началъного сегмента.</p><empty-line /><p>
7. Когда таблица настройки адресов обработана,  регистрам SS и  SP придаются значения, указанные в заголовке, к SS прибавляется сегментный адрес началъного сегмента. В ES и DS засылается сегментный адрес начала Префикса Программного сегмента. Управление передается загруженной задаче по адресу, указанному в заголовке (байты 14-17).</p><empty-line /><p><strong>5. Дати визначення резидентного модуля. Коли визначається склад резидентних програм?</strong> #resident #module</p><empty-line /><p>
Резидентная программа (или TSR-программа, от англ. Terminate and Stay Resident — «завершиться и остаться резидентной») — в операционной системе MS-DOS программа, вернувшая управление оболочке операционной системы (command.com), либо надстройке над операционной системой (Norton Commander и т. п.), но оставшаяся в оперативной памяти персонального компьютера. Резидентная программа активизируется каждый раз при возникновении прерывания, вектор которого эта программа изменила на адрес одной из своих процедур.</p>

<p><strong>6. Дати визначення табличного методу керування. Чому він застосовується?</strong></p>

<p><strong>7. Яка системна програма підготовлює інформацію для роботи завантажника, та яку?</strong>
Компилятор/линковщик.</p>

<p><strong>8. Як визначити зону знаходження оптимального розкладу? Зі спільною пам’яттю та зі спільною шиною.</strong></p>

<p><strong>9. Структура супервізора.</strong></p>

<p><strong>10. Що таке транзитні програми? Спосіб їх завантаження. </strong> #transit #program</p><empty-line /><p>
Программы, связанные с выполнением функций ОС, но не находящиеся постоянно в ОП называются транзитными. Эти программы вызываются в ОП по мере необходимости.</p>

<p><strong>11. Що таке запис у бібліотеку без каталогізації? Дати приклад. </strong> #store #lib #catalog</p><empty-line /><p>
Запись временных данных, которые удаляются после выполнения программы.</p>

<p><strong>12. Як змінюється інформація системи динамічного планування для однорідних та неоднорідних ОС?</strong></p>

<p><strong>13. Математична постановка задачі планування для одно процесорних систем. </strong></p>

<p><strong>14. Що таке розв’язання задачі планування з передуванням? </strong></p>

<p><strong>15. Принципи підвищення ефективності ОС.</strong></p>

<p><strong>Білет 16</strong></p>

<p><strong>1. Які міркування використовуються при визначені величини кванта? </strong> #kvant #size #doesmatters</p><empty-line /><p>
Чем меньше квант – тем больше переключений задач (возможны бОльшие дополнительные расходы). При большом кванте возможна ситуация, когда время работы задачи меньше кванта, тогда оставшееся время процессор простаивает. Также при большом кванте RR, FBn, Корбато очередь стремиться к FIFO-виду.</p>

<p><strong>2. Умова переходу процесу з підготованого стану у готовий та з активного в підготований? </strong></p>

<p><strong>3. Чим відрізняється традиційна машинна мова програмування від команд машини?</strong> #command #machine #lang</p><empty-line /><p>
Команды машины - это самые элементарные выполняемые команды (самый низкий уровень); традиционный машинный язык - это набор процедур из элементарных команд, выполняемых на самом низком уровне.</p>

<p><strong>4. Сенс розв’язання задачі реконфігурації при балансовому плануванні. </strong></p>

<p><strong>5. Що таке масштабування розподілених систем?</strong></p>

<p><strong>6. Чому застосовуються багаторівневі системи програмування? </strong></p>

<p><strong>7. Яку інформацію та як компілятор передає завантажнику, що налаштовує.</strong></p>

<p><strong>8. Функції редактора зв’язків. Як йому передається інформація?</strong></p>

<p><strong>9. Як визначити вершини графа, що знаходяться на критичному шляху?</strong></p>

<p><strong>10. Які методи використовуються для розв’язання NP-повних задач?</strong> #np #method</p><empty-line /><p>
  * Метод ветвей и границ состоит в отбрасывании заведомо неоптимальных решений целыми классами в соответствии с некоторой оценкой
  * Метод локальных улучшений состоит в поиске более оптимального решения в окрестности некоторого текущего решения
  * Приближенные и эвристические методы состоят в применении эвристик для выбора элементов решения
  * Псевдополиномиальные алгоритмы представляют собой подкласс динамического программирования
  * Метод случайного поиска состоит в представлении выбора последовательностью случайных выборов</p>

<p><strong>11. У чому відмінність розв’язання задачі планування від розподілення? Яка з них розв’язується при динамічному плануванні? </strong></p>

<p><strong>12. Функція мети задачі динамічного планування. </strong></p>

<p><strong>13. Сформулювати теорему про потужність паросполучення. </strong></p>

<p><strong>14. За якою схемою завантажуються транзитні програми супервізора?</strong></p>

<p><strong>15. Що таке межа Бременмана?</strong></p>

<p><strong>Білет 17</strong></p>

<p><strong>1. Дати визначення непрямого доступу. Чи застосовується він зараз й коли? </strong> #nepr #access</p><empty-line /><p>
Непрямой доступ – (косвенный доступ) – доступ к машине через управляющую программу (прообраз ОС, пакетный режим)</p>

<p><strong>2. Що таке модульний принцип програмування?</strong> #program #module</p><empty-line /><p>
Модульный принцип программирования – идея: программа разбита на куски. Каждый кусок выполняется с определенными соглашениями.</p><empty-line /><p>
Свойства:</p><empty-line /><p>
- каждый модуль обладает стандартностью внутр. Структуры</p><empty-line /><p>
- взаимная независимость</p><empty-line /><p>
- функц. Завершенность</p><empty-line /><p>
-параметрическая универсальность</p><empty-line /><p>
Виды модулей – вызывающий и вызываемый.</p><empty-line /><p><strong>3. Сформулювати принцип оптимальності Белмана.</strong> #princ #belman #optim</p><empty-line /><p>
Принцип оптимальности Беллмана - замена решения исходной многомерной задачи последовательностью задач меньшей размерности.</p>

<p><strong>4. Характеристика розподіленої операційної системи. Чим вона відрізняється від мережної? </strong> #net #os #sys #rozpod</p><empty-line /><p>
Распределенная ОС - совокупность выч. узлов, связанных между собой каналами связи, с точки зрения usera представляют собой единое целое(одна вирт машина). Функции: расширяемость, масштабируемость, прозрачность</p><empty-line /><p>
Сетевая ОС предоставляет пользователю некую виртуальную вычислительную систему, работать с которой гораздо проще, чем с реальной сетевой аппаратурой. В тоже время эта виртуальная система не полностью скрывает распределенную природу своего реального прототипа, то есть является виртуальной сетью. При работе юзер точно знает на какой машине выполняется задача.</p>

<p><strong>5. Види завантажників та їх особливості. Коли який застосовується? </strong> #loader</p><empty-line /><p>
Функции:</p><empty-line /><p>
- Выделение памяти</p><empty-line /><p>
-настройка</p><empty-line /><p>
- связывание</p><empty-line /><p>
- погружение</p><empty-line /><p>
Виды загрузчиков: в зависимости от того, кто выполняет функции(прогр или система) разделяют:
- абсолютный загрузчик(выполняет только посл функцию)</p><empty-line /><p>
- настраивающий (выполняет все функции (работает при создании .ехе файла), компилятор ему должен сообщить доп. информацию: внешние и внутренние вектора переходов и биты переместимости (?) для настройки адресных констант)</p><empty-line /><p>
- связывающий (непосредственно связывающий) – все функции выполняются по мере необходимости (ООП)</p>

<p><strong>6. Які програми знаходяться у ядрі операційної системи? (Види програм)</strong> #kernel #os #program</p><empty-line /><p>
ядро супервизора, включающие только те программы, которые отвечают за реакцию системы.</p><empty-line /><p>
Гугл:</p><empty-line /><p>
• обработка прерываний;</p><empty-line /><p>
• создание и уничтожение процессов;</p><empty-line /><p>
• переключение процессов из состояния в состояние;</p><empty-line /><p>
• диспетчеризацию заданий, процессов и ресурсов;</p><empty-line /><p>
• приостановка и активизация процессов;</p><empty-line /><p>
• синхронизация процессов;</p><empty-line /><p>
• организация взаимодействия между процессами;</p><empty-line /><p>
• манипулирование РСВ;</p><empty-line /><p>
• поддержка операций ввода/вывода;</p><empty-line /><p>
• поддержка распределения и перераспределения памяти;</p><empty-line /><p>
• поддержка работы файловой системы;</p><empty-line /><p>
. • поддержка механизма вызова— возврата при обращении к процедурам;</p><empty-line /><p>
• поддержка определенных функций по ведению учета работы машины;</p><empty-line /><p><strong>7. Дати визначення програми простої структури. Коли використання такої структури неефективно? </strong> #program #simple #struct</p><empty-line /><p>
Программа которая при её исполнении не обращается к другим программам. Простейшая структура (имеют в своем теле все что нужно для выполнения)</p>

<p><strong>8. Вхідна та вихідна інформація редактору зв’язків. </strong>: #editor #link #redak #input #output</p><empty-line /><p>
вх- объектный модуль , вых – загрузочный модуль.</p>

<p><strong>9. Як визначити вершини графу, що знаходяться на критичному шляху?</strong> #graph #versh #detect</p><empty-line /><p>
(?) это вершины, которые попадают на максимальный путь по графу (худшее время решения задачи)</p>

<p><strong>10. Основна ідея «угорського алгоритму». Заміна якого блоку покращує його характеристики? : </strong> #venger #algo #idea</p><empty-line /><p>
-если из всех элементов некоей строки или столбца вычесть одно и то же число  , общая стоимость уменьшится на  , а оптимальное решение не изменится;</p><empty-line /><p>
-если есть решение нулевой стоимости, оно оптимально.</p><empty-line /><p>
Алгоритм ищет значения, которые надо вычесть из всех элементов каждой строки и каждого столбца (разные для разных строк и столбцов), такие что все элементы матрицы останутся неотрицательными, но появится нулевое решение.</p>

<p><strong>11. Навіщо потрібно водити характеристику «надійний стан системи»?</strong> #os #state #nadiyn #nadijn</p><empty-line /><p>
Надежное состояние системы - ОС может обеспечить всем процессам их выполнение в течение конечного времени.</p>

<p><strong>12. Ідея алгоритмів, заснованих на стратегії критичного шляху</strong> #crit #idea #algo #strateg</p><empty-line /><p>
Основная идея – кластеризация. Критический путь грузится на 1 проц и все пересылки зануляются.</p>

<p><strong>13. Методи підвищення ефективності організації обчислювального процесу в ОС.</strong> #improve #better #efect #os #count</p><empty-line /><p>
1. Декомпозиция задачи.</p><empty-line /><p>
2. Методы перебора состояний</p><empty-line /><p>
3. Приведение целевой функции к сепарабельному виду.</p><empty-line /><p>
4. Распараллеливание вычислительного процесса.</p><empty-line /><p>
5. Разработка квазиоптимальных графиков.</p><empty-line /><p><strong>14. Що таке шлях, що збільшує, шлях, що чергується? </strong> #way #path #goto #whoisondutytoday</p><empty-line /><p>
(?)Теорема Герта: max парасочетания получаются, если от свободной вершины нельзя найти увеличивающийся путь.Идея: для двудольного графа, случайно, выделяются ребра, которые не имеют инцендентных вершин.
Пространственный планировщвик – задача поиск максимального паросочетания в двудольном графе. Вот там и используется увеличивающийся чередующийся путь.</p>

<p><strong>15. Які задачі розв’язуються при статичному плануванні у паралельній ОС?</strong> #os #static #plan</p><empty-line /><p>
Стат планирование: NP-полные задачи, только  для специализированных систем.
2 типа: минимальное время решения при заданном кол-ве проц; минимальное количество процессоров, чтобы время не превышало Тмах.</p>

<p><strong>Білет 18</strong></p>

<p><strong>1. Сформулювати принцип оптимальності Белмана.</strong> #belman #optim #princ</p><empty-line /><p>
Принцип оптимальности Беллмана - замена решения исходной многомерной задачи последовательностью задач меньшей размерности.</p>

<p><strong>2. Чи використовується у сучасних системах колективний доступ та чим він відрізняється від того, що використовувався раніше? </strong> #collect #access</p><empty-line /><p>
Коллективный доступ- Предусматривающий доступ к ресурсам системы (система работает в многопрограммном режиме) многих пользователей. Отличия (?)</p>

<p><strong>3. Умови створення процесу. Який ресурс при цьому є критичним? </strong> #process</p><empty-line /><p>
Корректность описания процесса на языке описания процессов и выделение ресурсов
Критичный ресурс – адресное пространство</p>

<p><strong>4. Умови переходу зі стану Р1 у Р2 та назад.</strong> #p1 #p2 #pereh</p><empty-line /><p>
Р1- системные процессы, Р2- пользовательские. У системных приоритет больше. Переходы по квантам.</p>

<p><strong>5. Основні недоліки застосування мультипрограмування. </strong> #multi #program #bad</p><empty-line /><p>
Недостатки связаны с распределением памяти: избыточное выделение, фрагментация</p>

<p><strong>6.  Чому у розподілених системах переважніше використовувати крупнозернисте планування? </strong> #zern #plan</p><empty-line /><p>
Крупнозернистое планирование – Твыполнения &lt;&lt; Tпересылки (?)</p>

<p><strong>7. Дати визначення програми оверлейної структури. Як передаються дані? </strong> #overlay #struct #data</p><empty-line /><p>
Программа оверлейной структуры -Задача, разделяемая на модули. Модули находящиеся на одном оверлейном уровне не могут одновременно находится в ОП. Оверлей (заданные перекрытия два модуля на одном оверлейном уровне не могут быть выполнены, Инфа передается via корневой модуль)</p>

<p><strong>8. Сформулювати теорему про конфліктні призначення. </strong> #theorem #teorem #confict</p><empty-line /><p>
ЕСЛИ в матрице связности можно выделить основную подматрицу (из нулей) x*y, x+y=N и расположить ее в верхнем правом углу, тогда все единицы входящие в матрицу симметричную ей относительно главной диагонали являются конфликтными и должны быть удалены из рассмотрения(занулены) -&gt; граф редуцируется =&gt; граф распадается на две части и поиск парасочетаний может вестись отдельно. (ЕСЛИ несколько основных подматриц ТО граф распадается на несколько частей)</p>

<p><strong>9. Дати визначення розподіленої операційної системи. Її відмінність від мережної. </strong> #net #distrib #os</p><empty-line /><p>
Распределенная ОС - совокупность выч. узлов, связанных между собой каналами связи, с точки зрения usera представляют собой единое целое(одна вирт машина). Функции: расширяемость, масштабируемость, прозрачность</p><empty-line /><p> 
Сетевая ОС предоставляет пользователю некую виртуальную вычислительную систему, работать с которой гораздо проще, чем с реальной сетевой аппаратурой. В тоже время эта виртуальная система не полностью скрывает распределенную природу своего реального прототипа, то есть является виртуальной сетью. При работе юзер точно знает на какой машине выполняется задача.</p>

<p><strong>10. Ідея створення адаптивних алгоритмів планування. </strong>
(?) Система анализирует штраф за время ожидания заявки и штраф за время обслуживания.</p>

<p><strong>11. Особливості різних форм взаємодії «людина – машина». Які характеристики при цьому змінюються? </strong></p>

<p><strong>12. У чому складність для операційної системи в організації багатопрограмного режиму роботи? Які задачі про цьому розв’язуються та які механізми використовуються? </strong> #os #multi #prog #meh</p><empty-line /><p>
Организация защиты от взаимного влияния друг на друга на уровне оперативной и на уровне внешней памяти; разделение аппаратных и программных ресурсов; планирование (во времени, а в случае ПВС и в пространстве).
Создается система прерываний, система управления процессами.</p>

<p><strong>13. В якому вигляді компілятор передає інформацію завантажнику, що налаштовує? </strong> #compiler #loader #data</p><empty-line /><p>
В виде структуры: внешние и внутренние вектора переходов; биты переместимости для настройки адресных констант.</p>

<p><strong>14. Перерахувати рівні планування у паралельний системи. Які задачі потрібно розв’язувати у статиці, а які – у динаміці? </strong> #plan #level #sys #paraller #paralel</p><empty-line /><p>
Динамическое, статическое, балансовое, в реальном времени. В динамике – работа во время решения задач, на том же оборудовании, быстрая обработка в ущерб качеству; в статике – планирование решения задач ДО самого решения на другом оборудовании.</p>

<p><strong>15. Що таке «строго неоднорідна ОС»? Які параметри ОС визначають неоднорідність?</strong> #neodnor #sys #param
Є вище</p>

<p><strong>Білет 19</strong></p>

<p><strong>1. Перерахувати способи реалізації багатопрограмного режиму роботи.  </strong> #multi #program #work</p><empty-line /><p>
Классическое мультипрограммирование (пакетная обработка)</p><empty-line /><p>
Разделение времени</p><empty-line /><p>
Режим реального времени</p><empty-line /><p><strong>2. Сформулювати теорему про конфліктні призначення.</strong> #conflict #theorem #teorem</p><empty-line /><p>
ЕСЛИ в матрице связности можно выделить основную подматрицу (из нулей) x*y, x+y=N и расположить ее в верхнем правом углу, тогда все единицы входящие в матрицу симметричную ей относительно главной диагонали являются конфликтными и должны быть удалены из рассмотрения(занулены) -&gt; граф редуцируется =&gt; граф распадается на две части и поиск парасочетаний может вестись отдельно. (ЕСЛИ несколько основных подматриц ТО граф распадается на несколько частей)</p>

<p><strong>3. Вимоги до статичних планувальників. </strong> #static #plan</p><empty-line /><p>
Годится только для спец. систем, NP-полных задач, в статике – планирование решения задач ДО самого решения на другом оборудовании.</p><empty-line /><p>
2 типа: минимальное время решения при заданном кол-ве проц; минимальное количество процессоров, чтобы время не превышало Тмах.</p>

<p><strong>4. Чим визначається пріоритет проблемних й системних програм та коли ці пріоритети визначаються?</strong> #prior #problem #sysem</p><empty-line /><p>
Приоритет системных программ выше приоритета проблемных. (?)</p>

<p><strong>5. Перерахувати ресурси ОС. </strong>: #os #res</p><empty-line /><p>
железо(всё); программы, информация.</p>

<p><strong>6. Дати визначення резидентного тому. Яка системна програма формує зміст резидентного тома? </strong> #tom #resident</p><empty-line /><p>
Том – место нахождения резиденции – сгенерированной ОС. Формируется программой начальной загрузки(БУТлоадер) которая нах. В MBR.(?)</p>

<p><strong>7. Дати визначення програми динамічної послідовної структури. </strong> #struct #dynamic
Программы настроенные с помощью модульного принципа, представляется в перемещаемом виде, могут подгружаться по мере необходимости с организацией связей по управлению и данными. 3. Динамически посл.(Память выделяется по мере надобности – по цепочке. Уровни не выделяются. Корневой модуль всегда в памяти)</p>

<p><strong>8. Різниця між обчислювальною та часовою складністю. Яка оцінка коли застосовується? </strong> #time #cound #skaldn</p><empty-line /><p>
Временная сложность – зависимость времени решения задачи от размерности задачи.(худший случай)
Вычислительная – зависимость объема работы от размера входных данных.
Когда применяется (?)</p>

<p><strong>9. Функція мети задачі статичного планування. Чому потрібно розділяти планування та розподілення?</strong> #meta #static #plan</p><empty-line /><p>
Годится только для спец. систем , NP-полных задач, в статике – планирование решения задач ДО самого решения на другом оборудовании.</p><empty-line /><p>
2 типа: минимальное время решения при заданном кол-ве проц; минимальное количество процессоров, чтобы время не превышало Тмах.</p><empty-line /><p>
Разделять нужно потому что выполняются на разных машинах (оборудовании)</p>

<p><strong>10. Динамічне планування для систем реального часу. . </strong> #dynamic #plan</p><empty-line /><p>
Время реакции системы соответствует ранее заданному.</p><empty-line /><p>
Т работы
Приоритеты задачам распр динамически – предпочтение задачам с меньшим Тработы.</p>

<p><strong>11. Дати визначення керуючих програм операційної системи. </strong> #program #os #ker #boss</p><empty-line /><p>
Программы постоянно находящиеся в памяти (резидентные) организующие корректное выполнение процессов и функционирование всех устройств системы при решении задач. Составляют ядро ОС. Управление : Заданиями – слежение за прохождением заданий от входа до выхода на всех этапах его выполнения. Задачами – (Процессами) – слежение за всеми задачами активизированными в системе и процессами их выполнения на ресурсах. Памятью – решение задач эффективного u/ mem (internal) в соответствии с ее организацией.(Защита – согласование ин-фы в кешах) Данными – эффективное размещение и u/ данных на внешних носителях (проблема эффективности u/ процессора) Внешними ус-вами …</p>

<p><strong>12. Що таке пряме введення-виведення? Чому непряме краще? </strong> #io</p><empty-line /><p>
Прямой : Когда не используются управляющие программы. Пользовательский процесс  сам осуществляет i/o. Непрямой лучше потому что обеспечивается ОС(а значит надежней, правильней, круче, выше, дальше, смелее, добрее, няшней)</p>

<p><strong>13. Як компілятор передає інформацію безпосередньо завантажнику, що зв’язує? </strong> #compiler #loader</p><empty-line /><p>
Настраивающий – работает в загр. Модуле которому больше ничего не надо. Постепенно его ф-ции взял на себя редактор связей. Непосредственно в настраивающем загрузчике каждый модуль может транслироваться отдельно. Чтобы передать сообщение редактору связей надо ему непосредственно указать, что надо транслировать. В каждом модуле в начале трансляции выделяются вектора перехода, внешние и внутренние.(Экспорт и Импорт процедур и ф-ций). Кроме того для выполнения настройки каждая команда отмечается битом переместимости. ОС выделяет и пользуетс глобально выделенной памятью, а загрузчик с локальной.</p>

<p><strong>14. Обчислювальні системи реального часу. Визначення. Особливості</strong> #system #realtime</p><empty-line /><p>
Системы реального времени - режим работы автоматизированной системы обработки информации и управления, при котором учитываются ограничения на временны́е характеристики функционирования. Если выход за рамки временных ограничений – отказ системы (жесткая СРВ) или ухудшение качества (мягкая СРВ).
Системы реального времени обычно используют специализированное оборудование и программное обеспечение. При создании систем реального времени приходится решать проблемы привязки внутрисистемных событий к моментам времени, своевременного захвата и освобождения системных ресурсов, синхронизации вычислительных процессов, буферизации потоков данных и т. п.</p>

<p><strong>15. Назвати нижні рівні керування зовнішніми пристроями. </strong> #lover #level #drive #manage #pristr #device</p><empty-line /><p>
Нижние уровни управления внешними устройствами  (?)</p>

<p><strong>Білет 20</strong></p>

<p><strong>Білет 21</strong></p>

<p><strong>1. Сформулювати принцип оптимальності Беллмана.</strong> #bellman #belman #princ #optim</p><empty-line /><p>
БЕЛЛМАНА ПРИНЦИП ОПТИМАЛЬНОСТИ [Bellman’s optimality principle] — важнейшее положение динамического программирования, которое гласит: оптимальное поведение в задачах динамического программирования обладает тем свойством, что каковы бы ни были первоначальное состояние и решение (т. е. “управление”), последующие решения должны составлять оптимальное поведение относительно состояния, получающегося в результате первого решения. Этот принцип можно выразить и рассуждая от противного: если не использовать наилучшим образом то, чем мы располагаем сейчас, то и в дальнейшем не удастся наилучшим образом распорядиться тем, что мы могли бы иметь.Следовательно, если имеется оптимальная траектория, то и любой ее участок представляет собой оптимальную траекторию. Этот принцип позволяет сформулировать эффективный метод решения широкого класса многошаговых задач. (Подробнее см. Динамическое программирование.)</p>

<p><strong>2. Коли застосовують евристичні алгоритми?</strong> #evrist #algo</p><empty-line /><p>
В інформатиці, евристичний алгоритм, або просто евристика, це алгоритм спроможний видати прийнятне рішення проблеми серед багатьох рішень, але неспроможний гарантувати, що це рішення буде найкращим. Отже такі алгоритми є приблизними і неточними. Зазвичай такі алгоритми знаходять рішення близьке до найкращого і роблять це швидко. Часто, можна знайти таку задачу, що евристичний алгоритм буде працювати або дуже довго, або видавати невірні результати, однак, такі парадоксальні приклади можуть ніколи не зустрітись на практиці через свою специфічну структуру. Таким чином, використання евристики дуже поширене в реальному світі. Для багатьох практичних проблем евристичні алгоритми, можливо, єдиний шлях для отримання гарного рішення в прийнятний проміжок часу. Існує клас евристичних стратегій названих метаалгоритмами, котрі часто використовують, наприклад, випадковий пошук. Такі алгоритми можуть бути застосовані до широкого кола завдань, при цьому хороші характеристики не гарантуються.</p>

<p><strong>3. Яка програма виконує запис інформації в область збереження та що там зберігається.</strong> #write #info #save</p><empty-line /><p>
Ядро ОС. Записываются значения регистров при переключении процесов из состояния в состояние либо их синхронизации.</p>

<p><strong>4. Що таке резидентні вершини та як їх знайти? Навіщо вони потрібні?</strong> #resident #versh</p><empty-line /><p>
Вершини, що увійшли в критичний шлях, а їх часові та просторові координати не повинні змінюватись при вирішенні задач. Знайти критичний шлях.</p>

<p><strong>5. Функції завантажника, що налаштовує.</strong> #set #loader</p><empty-line /><p>
Настраиваемый - До этапа выполнения программы в модулях описываются векторы переходов (внутри – и внешнемодульные), и константы, которые нужно переопределить. Загрузчик при просмотре этих записей определяет абсолютные адреса гастраиваемых величин. Настройка адресных констант, Выделение памяти, Связывание, Собственно загрузка. Инфу для него готовит компилятор.</p><empty-line /><p>
  -  выделение места для программ в памяти (распределение);</p><empty-line /><p>
 - фактическое размещение команд и данных в памяти (загрузка); 
- разрешение символических ссылок между объектами (связывание);</p><empty-line /><p>
 - настройка всех величин в модуле, зависящих от физических адресов в - соответствии с выделенной памятью (перемещение);</p><empty-line /><p>
- передача управления на входную точку программы (инициализация).</p><empty-line /><p><strong>6.  Дати визначення ініціалізації системи. Функції.</strong> #init #system</p><empty-line /><p>
В виду того, что ядро ОС представляет собой совокупность взаимосвязанных модулей, имеющих связь друг с другом, процесс структурной организации модулей называется инициализацией. Инициализация системы - процесс создания ядра системы  который включает не только перезапись программ, но и системных структур, обеспечивающих знания системы о ее параметрах. Программа - загрузчик. Small intro: ОС предназначена для удовлетворения нужд пользователей и должна содержать все необходимые пользователю модули или программы и поддерживать аппаратные средства. Инициализация – процесс структурной организации взаимосвязанных модулей,из которых состоит ядро ОС. Различают инициализацию ядра ,которая происходит по умолчанию и системы ,которая происходит по файлам инициализации.</p>

<p><strong>7. У чому відмінність меж максимальним паросполученням та досконалим.</strong> #max #para #doscon #ideal</p><empty-line /><p>
Найти максимальное паросочетание - значит найти максимальное число ребер графа в которых не совпадают координаты вершин, либо найти максимальное число единиц матрицы у которых не совпадают координаты.</p>

<p><strong>8. Чому алгоритм «Коpбато» краще FBn.</strong> #corbato #algo #corbato #fbn</p><empty-line /><p>
Алгоритм Корбата лучше алгоритма FBn, т.к. потенциально обладает большей производительностью т.к. распределяет задачи по очередям не по их приоритетам, а по признаку - абсолютная длина кода программы (чем меньше код тем выше приоритет). (В систему добавлен анализатор, который сразу размещает заявки в свою очередь, соответственно среднее время ожидания уменьшается.)</p>

<p><strong>9. Що таке неоднорідна система? Як визначити степінь неоднорідності.</strong> #sys #neodnor
Вычислительную систему можно рассматривать как совокупность неоднородных ресурсов с различной степенью детализации, а объекты планирования вычислений или заявки на ресурсы могут быть представлены как программы, процедуры, параллельные участки программ и т.д.</p><empty-line /><p>
Понятие "неоднородность" системы можно рассматривать для трех случаев:</p><empty-line /><p>
1<emphasis> В полунеоднородной системе, когда или задания, или ресурсы являются однородными или неоднородными. Число различных расписаний (до оптимизации) равно размещению из R элементов по N без повторения и без перестановки, то есть число возможных вариантов равно  [21, 59, 134]. </emphasis></p><empty-line /><p><emphasis>
2</emphasis> В неоднородной системе и задания, и ресурсы являются неоднородными, и любое назначение заданиересурс всегда является возможным (лишь имеют разные значения Te и Tc). Число различных расписаний (до оптимизации) равно размещению из R элементов по N без повторения, но с перестановками, тогда число возможных вариантов равно  [72].</p><empty-line /><p>
В строго неоднородной системе имеет место понятие совместимости ресурсазадания, при этом некоторые назначения ресурсзадание могут быть невозможными. Поэтому планирование для таких систем состоит из двух этапов: на первом этапе ищутся расписания возможных назначений максимальной мощности, а на втором этапе требуется найти оптимальное расписание из найденных на предыдущем этапе. Число возможных вариантов на первом этапе равно  число различных и возможных расписаний (до оптимизации), или равно числу максимальных паросочетаний двух множеств N и R  V1[13, 40]. Число возможных вариантов на втором этапе V2V1.</p>

<p><strong>10. Функція мети задачі динамічного планування.</strong> #dynamic #plan #meta</p><empty-line /><p>
Под динамическим планированием понимается решение задачи распределения работ (составление расписания) и процессов в пространственных или пространственновременных координатах во время выполнения вычислений и  на том же оборудовании. Если планирование составляется на том же оборудовании на котором должно выполняться и во время решения задачи, то это планирование называется динамическим</p>

<p><strong>11. Сформулювати теорему про обов’язкові призначення.</strong> #teorem #theorem #obov #prizn</p><empty-line /><p>
С помощью анализа матрицы выделяют назначение, которое есть обязательным еще до нахождения базового решения. Теорема 1 :</p><empty-line /><p>
Если в двудольном графе существует вершина, которой инцидентно только одно ребро, то вершины, инцидентные этому ребру, должны быть взяты в решение</p>

<p><strong>12. Що таке «свопінг»?</strong> #swap</p><empty-line /><p>
Свопинг - способ реализации многопрограммного режима работы на однопроцессорной машине</p>

<p><strong>13. Різниця між плануванням та розподіленням.</strong> #plan</p><empty-line /><p>
Задача  распределение (загрузка) (Task Allocation). Вычислительные процессы имеют слабые  требования по предшествованию и отображаются несвязными графами. Это направление часто связывается с задачами балансирования и минимизации пересылок. При решении этих задач основой является определение  какой процесс (задание) будет выполняться на каком процессоре (ресурсе), а не определение порядка их выполнения [155]. При этом, в основном, решаются задачи пространственного распределения процессов (заданий).</p><empty-line /><p>
Задача  планирование (Task Scheduling). Вычислительные процессы имеют сильные требования по предшествованию и отображаются связными ациклическими графами (DAG). При этом, к решению задач первого направления добавляется также определение порядка выполнения заданий. На этом уровне часто решаются задачи минимизации суммарного времени выполнения полного DAG на выделенных или имеющихся ресурсах.</p><empty-line /><p>
Задачи по обоим направлениям, в общем случае, являются NP-полными или NP-сложными даже для двухпроцессорной системы [11] и имеют экспоненциальную временную сложность</p>

<p><strong>14. По який характеристиці можна судити про придатність розробленого алгоритму для роботи у динамічному режимі? </strong> #dynamic #algo</p><empty-line /><p>
В большинстве случаев разработчики систем планирования реального времени используют статические алгоритмы и заранее определяют максимальный список заданий, допустив наихудший случай для получения статической управляющей таблицы (плана). Этот план фиксируется и используется для безусловного исполнения в динамическом режиме со следующими допущениями:</p><empty-line /><p>
3<emphasis> все временные ограничения остаются неизменными на время выполнения плана; </emphasis></p><empty-line /><p><emphasis>
4</emphasis> все задачи вкладываются в свое критическое время.</p><empty-line /><p>
В других случаях при помощи приемов статического планирования создается статический список приоритетов для использования во время диспетчеризации самих работ в динамическом режиме.</p>

<p><strong>15. Етапи завантаження операційної системи.</strong> #os #load #boot #zavant #etap</p><empty-line /><p>
Першим загружається BIOS. Він тестує обладнання, завантажує таблиці переривань. Завантажується завантажувач MBR, який визначає кількість розділів, чи є на них ОС та яка. Потім загрузка передається ОС. Визначаються апаратні засоби, обирається конфігурація. Після цього відбувається загрузка ядра, його ініціалізація. Потім ініціалізація системи.</p>

<p><strong>Білет 22</strong></p>

<p><strong>1. Дати визначення режиму розподілення часу.</strong> #rozpod #time</p><empty-line /><p>
Реж. раз. Времени - режим совмещающий мультипрограммирование и параллельную обработку, плюс возможность привелигилированным пользователям иметь прямой доступ к ресурсам системы</p>

<p><strong>2. Особливості розподілених операційних систем.</strong> #rospod #distributive #system #os</p><empty-line /><p>
Розподілена ОС – сукупність обчислювальних вузлів, з’єднаних між собою каналами зв’язку, з точки зору користувача представляє собою єдине ціле. Відсутність спільної пам’яті призводить до неможливості визначення загального стану за допомогою множини спільних змінних, а неможливість спільного звернення до пам’яті та різниця в затримках передач повідомлень призводить до того, що при визначенні стану будь-якого елементу системи з різних точок можна отримати різні результати. Виконання роботи розподіляється у вузлах, виходячи з міркувань пропускної здатності усієї системи. Розподіленні системи мають високий рівень організації паралельних обчислень.</p>

<p><strong>3. Зв'язок модулів по керуванню. Які операції виконуються та якими програмами.</strong> #link #module #manage</p><empty-line /><p>
Связь по данным может быть через общие ресурсы либо через адрес списка параметров.      Спомощью макрокоманд  возможно указание:</p><empty-line /><p>
1<emphasis> возврат из (i+1)-го модуля только в i-й; </emphasis></p><empty-line /><p><emphasis>
2</emphasis> возврат из (i+n)-го модуля в i-й;</p><empty-line /><p>
3* вызывающий модуль после передачи управления стирается                                                              Для связи по управлению данными определены некоторые ресурсы</p><empty-line /><p><strong>4. Принципи підвищення ефективності роботи системи з допомогою організації обчислювального процесу.</strong> #efect #princ #hight #count</p><empty-line /><p>
Максимальное эффективное использование ресурсов методом эффективного планирования ВП. На однопроцессорных комплексах используется планирование во времени. На многопроцессорных -  планирование как в пространстве так и во времени.</p>

<p><strong>5. Який тип завантажника працює з модулями з розширенням COM та EXE.</strong> #loader #com #exe</p><empty-line /><p>
С сом модулями работает абсолютный загрузчик, с ехе - настраивающий</p>

<p><strong>6. Різниця між плануванням й розподіленням.</strong> #plan #rozpod</p><empty-line /><p>
Задача  распределение (загрузка) (Task Allocation). Вычислительные процессы имеют слабые  требования по предшествованию и отображаются несвязными графами. Это направление часто связывается с задачами балансирования и минимизации пересылок. При решении этих задач основой является определение  какой процесс (задание) будет выполняться на каком процессоре (ресурсе), а не определение порядка их выполнения [155]. При этом, в основном, решаются задачи пространственного распределения процессов (заданий).</p><empty-line /><p>
Задача  планирование (Task Scheduling). Вычислительные процессы имеют сильные требования по предшествованию и отображаются связными ациклическими графами (DAG). При этом, к решению задач первого направления добавляется также определение порядка выполнения заданий. На этом уровне часто решаются задачи минимизации суммарного времени выполнения полного DAG на выделенных или имеющихся ресурсах.
Задачи по обоим направлениям, в общем случае, являются NP-полными или NP-сложными даже для двухпроцессорной системы [11] и имеют экспоненциальную временную сложность</p>

<p><strong>7. Як визначити об’єм пам’яті, необхідний для завантаження програми оверлейної структури.</strong> #memory #overlay #program</p><empty-line /><p>
Определить обьём памяти, необходимый для загрузки оверлейной структуры можно путём вычисления ОП, необходимой для самой длинной цепочки вызовов</p>

<p><strong>8. Основна особливість пріоритетних дисциплін обслуговування. Їх види</strong> #prior #task</p><empty-line /><p>
Каждая заявка имеет приоритет при входе в систему. Заявки с более высоким приоритетом получают возможность быстрее выйти из системы. В системах со статическими приоритетами возможно бесконечное откладывание. Применяют также системы со смешенными алгоритмами. Бывает абсолютный, относительный, динамический.</p>

<p><emphasis></emphasis>9. Ідея оптимізації «базового» рішення._ #base #optimiz</p><empty-line /><p>
«Базовое» решение оптимизируется по необходимому критерию - время выполнения,       количество процессоров</p>

<p><emphasis></emphasis>10. Що таке конфліктне призначення? Навіщо потрібно його виділяти._ #conflict</p><empty-line /><p>
Конфликтное назначение уменьшает мощность паросочетания. Это назначения стоящие под главной диагональю после выделения основных подматриц</p>

<p><strong>11. Що таке тимчасова бібліотека? Коли вона використовується</strong> #temp #lib</p><empty-line /><p>
Временная библиотека существует только во время выполнения программы. Не помещается в каталог библиотек.</p>

<p><strong>12. Які операції виконує програма першого рівня планування.</strong> #operation #program #level #plan</p><empty-line /><p>
В интерпретаторе настройка адресных констант происходит в процессе выполнения</p>

<p><strong>13. Назвати рівні багаторівневих систем програмування </strong> #level #system #program</p><empty-line /><p>
Визуальные средства</p><empty-line /><p>
ЯВУ</p><empty-line /><p>
Уровень ОС</p><empty-line /><p>
Ассемблер</p><empty-line /><p>
Микропрограммы</p><empty-line /><p>
Процессор</p><empty-line /><p><strong>14. Призначення операційних систем</strong> #os #usage</p><empty-line /><p>
ОС предназначена для : 1- нахождения задач в ВС 2- обеспечение максимальной эффективности использования ресурсов ВС</p>

<p><strong>15. Задачі планування в системах масового розпаралелювання та чим вони відрізняються від задач планування для розподілених систем.</strong> #plan #system #parallel #paralel</p><empty-line /><p>
В СМР решаются следующие задачи планирования Вычислит Процессов: 1 - найти минимальное к-во процессоров, когда время выполнения взаимосвязанных задач не превышает Ткр 2- найти минимальное время выполнения комплекса ВС на заданном к-ве процессоров. При этом, если учитывается вес пересылок, нужно обеспечить их минимум</p>

<p><strong>Білет 23</strong></p>

<p><strong>Білет 24</strong></p>

<p><strong>Білет 25</strong></p>

<p><strong>1. Дати визначення роботи в реальному часі. Надати приклад.</strong> #real #time #mode</p><empty-line /><p>
Режим реального времени – время реакции системы соответствует ранее заданному</p>

<p><strong>2. Різниця між плануванням і розподілом.</strong></p>

<p><strong>3. Чим відрізняється традиційна машинна мова програмування від команд машини?</strong> #machine #command #lang</p><empty-line /><p>
Команды машины - это самые элементарные выполняемые команды (самый низкий уровень); традиционный машинный язык - это набор процедур из элементарных команд, выполняемых на самом низком уровне.</p>

<p><strong>4. У чому полягає сенс перегляду команд вперед і коли цей прийом неефективний?</strong> #select #comand #prev</p><empty-line /><p>
Предварительная выборка (увеличивается быстродействие)</p>

<p><strong>5. Відмінність завантажувального модуля від абсолютного. Яка програма виконує перетворення?</strong> #modul #loader #abs</p><empty-line /><p>
Загрузочный модуль имеет все для своего выполнения . Написан на машинно-ориентированном языке, но быть выполненным не может. Нужно настроить адресные константы. Абсолютный – все адресные константы уже настроены.</p>

<p><strong>6. Які операції виконує програма другого рівня планування?.</strong></p>

<p><strong>7. Дати визначення програми оверлейной структури. Недоліки.</strong> #overlay #struct</p><empty-line /><p>
Задача, разделяемая на модули. Модули находящиеся на одном оверлейном уровне не могут одновременно находится в ОП. Оверлей (заданные перекрытия два модуля на одном оверлейном уровне не могут быть выполнены Инфа передается via корневой модуль)</p>

<p><strong>8. Вхідна і вихідна інформація редактора зв’язків.</strong> #input #output #info #edit #link</p><empty-line /><p>
Входна - объектный модуль, выходная - загрузочный модуль.</p>

<p><strong>9. Динамічне планування для систем реального часу.</strong> #dynamic #plan #sys #realtime</p><empty-line /><p>
План составляется на том же оборудовании на котором выполняется решение задач во времени. Имеет ограничение на время составления плана. Динамическое планирование – задача планирования решается на том же оборудовании, что и выполняется план, который она составляет. Быстрое (чтобы не грузить оборудование) и неоптимальное решение  Def. Джонсона – найти план распределения по ресурсам, при котором время решения не превышало бы критического с min кол-вом процов. Найти min кол-во ресурсов, чтобы задача решалась за min время. Для 2-х процов задача решается точно. Для одного в условиях RealTime.</p>

<p><strong>10. Як визначити обов'язкове призначення? Навіщо це потрібно робити?</strong></p>

<p><strong>11. Що таке «розширення» розподілених систем?</strong> #sys #distrib</p><empty-line /><p>
Распределенная sys – совокупность выч. узлов, связанных между собой каналами связи, с точки зрения usera представляют собой единое целое.Отсутствие общей памяти приводит к невозможности определения общего состояния с помощью множества совместных переменных, а невозможность совместного обращения к памяти и различие в задержках передач сообщений приводит к тому что при определении состояния какого либо элемента системы из двух различных точек можно получить разные результаты. Выполнение работы распределяется  в узлах исходя из соображения пропускной способности всей системы. Распределенные системы имеют высокий уровень организации параллельных вычислений.</p>

<p><strong>12.  Що таке «свопінг», чим відрізняється від «спулінга»?</strong> #swap</p><empty-line /><p>
Свопинг - способ реализации многопрограммного режима работы на однопроцессорной машине.</p>

<p><strong>13. Основні проблеми розв’язування задач планування в багатопроцесорних паралельних системах.</strong> #problem #task #multi #proc</p><empty-line /><p>
Добавляется планирование в пространстве; появляется проблема синхронизации процессов.</p>

<p><strong>14. Описати послідовність дій, які виконуються завантажувачем при завантаженні програм.</strong></p><empty-line /><p>
В MBR. Активизация программ начальной загрузки ОС (брехня?)</p>

<p><strong>15. Чому COM файли мають обмеження за розміром?</strong></p>

<p><strong>Білет 26</strong></p>

<p><strong>1. На що впливає введення поняття «надійний стан системи»? </strong> #sys #nadiyn</p><empty-line /><p>
Необходимо чтобы система была в надежном состоянии (ОС должна обеспечить всем текущим пользователям  (процессам) завершение их заданий в течении конечного времени)</p>

<p><strong>2.  Пропозиції Лебедєва по підвищенню ефективності роботи ОС та як вони реалізовані в сучасних ОС.</strong></p>

<p><strong>3. Відмінність функцій програм системного введення /виведення від режиму спулінга. </strong> #system #spul</p><empty-line /><p>
Режим буферизации для выравнивания скоростей при вводе и считывании информации из буфера.При работе программ системного ввода u/ режим спуллинга – согласование скоростей на входе и выходе.</p>

<p><strong>4.Яка характеристика ОС покращується в змішаних дисциплінах обслуговування?</strong> #disc #os #obsl</p><empty-line /><p>
Дисциплина обслуживания заявок – правило по которому решается задача обработки очереди заявок к каждому ресурсу. Бывают линейные (FiFo,Lifo,Random (нет одинаковых ресурсов)) циклические (RR,FBn,смешанная)</p>

<p><strong>5. Частиною якої програми є редактор зв'язку?</strong> #edit #link</p><empty-line /><p>
Редактирование связей. (Выполнение связывания подпрограмм являющихся внешними по отношению к загружаемому модулю). (С помощью редактора связи мы получаем из объектного модуля загрузочный модуль имеющий всё для своего исполнения).</p>

<p><strong>6. Що таке супервізор й де він знаходиться?.</strong> #supervis #mode</p><empty-line /><p>
Режим супервизора — привилегированный режим работы процессора, как правило используемый для выполнения ядра операционной системы.</p>

<p><strong>7. Навіщо потрібно виконувати структурний аналіз вихідного графа?</strong> #graph #analis</p><empty-line /><p>
Структурный анализ заявок и определение возможности  распараллеливания (Задача распараллеливания)</p>

<p><strong>8. Функції 3-го рівня багаторівневих систем програмування. </strong></p>

<p><strong>9.Назвати рівні планування для багатопроцесорних ОС. Функції кожного.</strong> #level #proc #multi #os</p><empty-line /><p>
 Семиуровневая модель – схема системы планирования с учетом (Маштабируемость, Разделяемость,  Параллельность)</p><empty-line /><p>
1. Предварительное (входное) планирование исходного потока заявок (задача фильтрации)</p><empty-line /><p>
2. Структурный анализ взаимосвязи входного потока заявок по ресурсам  с определением общих ресурсов (Анализ)</p><empty-line /><p>
3. Структурный анализ заявок и определение возможности  распараллеливания (Задача распараллеливания)</p><empty-line /><p>
4. Адаптация распределения работ соответственно особенностям ВС (Задача адаптирования)</p><empty-line /><p>
5. Составление плана – расписания выполнения взаимосвязанных процедур. Оптимизация плана по времени решения и кол-ву ресурсов (Задача Оптимизации)</p><empty-line /><p>
6. Планирование потока задач претендующих на захват времени процессора на каждый прцессор – задача распределения.</p><empty-line /><p>
7. Выделение процессорного времени, активизация задач. Перераспределение работ в ВС, при отказе оборудования (задача распределения – перераспределения).</p><empty-line /><p><strong>10.  Коли застосовується запис до бібліотеки без каталогізації?</strong> #write #lib #catalog</p><empty-line /><p>
Запись временных данных, которые удаляются после выполнения программы.</p>

<p><strong>11. Як визначити пріоритет процесу системного і проблемного?</strong> #prior #system #problem</p><empty-line /><p>
Добавляется планирование в пространстве; появляется проблема синхронизации процессов. ЕСЛИ в системе нет одинаковых  устройств то очереди обрабатываются по линейной схеме =&gt; планирование только во времени ИНАЧЕ планирование во времени и в пространстве.</p>

<p><strong>12. Як змінюється організація обчислювального процесу для СМР і РС?</strong></p>

<p><strong>13. Функція мети завдання динамічного планування.</strong> #dynamic #plan</p><empty-line /><p>
План составляется на том же оборудовании на котором выполняется решение задач во времени. Имеет ограничение на время составления плана. Динамическое планирование – задача планирования решается на том же оборудовании, что и выполняется план, который она составляет. Быстрое (чтобы не грузить оборудование) и неоптимальное решение  Def. Джонсона – найти план распределения по ресурсам, при котором время решения не превышало бы критического с min кол-вом процов. Найти min кол-во ресурсов, чтобы задача решалась за min время. Для 2-х процов задача решается точно. Для одного в условиях RealTime.</p>

<p><strong>14.Ідея побудови «базового» ​​рішення.</strong></p>

<p><strong>15.Сформулюйте принцип оптимальності Белмана. </strong> #woot</p><empty-line /><p>
 ???? Эвристические<emphasis></emphasis> (основанные на опыте людей), Пошаговое конструирование – разделение всего процесса решения на определенное кол-во шагов и нахождение оптимального или квазиоптимального  решения. ЭТО – соответствует принципу оптимальности Белмана.</p>

<p><strong>Білет 27</strong></p>

<p><strong>1. Основні принципи організації обчислювального процесу, що підвищують ефективність роботи ОС.</strong></p>

<p><strong>2. Дати визначення режиму поділу часу.</strong> #time #podil</p><empty-line /><p>
режим совмещающий мультипрограммирование и параллельную обработку, плюс возможность привелигированным пользователям иметь прямой доступ к ресурсам системы. (Логика прерываний)</p>

<p><strong>3. Назвати базові рівні в багаторівневих системах програмування.</strong> #level #system</p><empty-line /><p>
Семиуровневая модель – схема системы планирования с учетом (Маштабируемость, Разделяемость,  Параллельность)</p><empty-line /><p>
1. Предварительное (входное) планирование исходного потока заявок (задача фильтрации)</p><empty-line /><p>
2. Структурный анализ взаимосвязи входного потока заявок по ресурсам  с определением общих ресурсов (Анализ)</p><empty-line /><p>
3. Структурный анализ заявок и определение возможности  распараллеливания (Задача распараллеливания)</p><empty-line /><p>
4. Адаптация распределения работ соответственно особенностям ВС (Задача адаптирования)</p><empty-line /><p>
5. Составление плана – расписания выполнения взаимосвязанных процедур. Оптимизация плана по времени решения и кол-ву ресурсов (Задача Оптимизации)</p><empty-line /><p>
6. Планирование потока задач претендующих на захват времени процессора на каждый прцессор – задача распределения.</p><empty-line /><p>
7. Выделение процессорного времени, активизация задач. Перераспределение работ в ВС, при отказе оборудования (задача распределения – перераспределения).</p><empty-line /><p><strong>4. Визначити умови переходу зі стану Р3 в стан Р й Р2.</strong></p><empty-line /><p>
Дивіться зверху за тегами.</p>

<p><strong>5. Перерахувати пріоритетні дисципліни обслуговування. Яка характеристика впливає на вибір дисципліни?</strong></p><empty-line /><p>
Заявки имеют приоритет. Дякую, кеп :)</p>

<p><strong>6. Види завантажувачів та їх основні відмінності.</strong> #loader</p><empty-line /><p>
Отличаются выполнением основных 4-х  функций: распределения памяти, настройки, редактирования и загрузки. Загрузчики делятся: Абсолютный загрузчик, настраивающий загрузчик, непосредственно - связывающий загрузчик.</p>

<p><strong>7. Чому спулінг схильний до тупиків?</strong> #spuling #spooling #tupic #sssr</p><empty-line /><p>
1) Условие взаимного исключения;</p><empty-line /><p>
2) Условие ожидания;</p><empty-line /><p>
3) Условие перераспределения;</p><empty-line /><p>
4) Круговая цепь ожидания.</p><empty-line /><p><strong>8. Чому всі алгоритми, засновані на теоремі Бержа про максимальне паросполучення, не придатні для використання в динамічних планувальниках?</strong></p>

<p><strong>9. Особливості розподілених операційних систем. У чому їх відмінність від мережних?</strong> #distr #sys #net</p><empty-line /><p>
Распределенная sys – совокупность выч. узлов, связанных между собой каналами связи, с точки зрения usera представляют собой единое целое.Отсутствие общей памяти приводит к невозможности определения общего состояния с помощью множества совместных переменных, а невозможность совместного обращения к памяти и различие в задержках передач сообщений приводит к тому что при определении состояния какого либо элемента системы из двух различных точек можно получить разные результаты. Выполнение работы распределяется  в узлах исходя из соображения пропускной способности всей системы. Распределенные системы имеют высокий уровень организации параллельных вычислений.</p>

<p><strong>10. Види модулів. Участь системних програм в перетворенні модулів.</strong>: #module #type #sys</p><empty-line /><p>
1) исходный ( текст программы);</p><empty-line /><p>
2) объектный;</p><empty-line /><p>
3) загрузочный;</p><empty-line /><p>
4) исполняемый (абсолютный).</p><empty-line /><p>
Системные программы (компилятор, редактор связей, загрузчик) используются для преобразования от 1) к 4).</p>

<p><strong>11. Що таке обчислювальна складність?</strong> #skl #obch #bigo #obig</p><empty-line /><p>
вычислительная сложность алгоритма — это функция, определяющая зависимость объёма работы, выполняемой некоторым алгоритмом, от размера входных данных. Раздел, изучающий вычислительную сложность, называется теорией сложности вычислений.</p>

<p><strong>12. Основна ідея «угорського алгоритму».</strong> #venger #ugor #algo</p><empty-line /><p>
алгоритм оптимизации, решающий задачу о назначениях за полиномиальное время</p>

<p><strong>13. Чому не можна зациклити стан Р3 й Р4?</strong></p><empty-line /><p>
Є зверху</p>

<p><strong>14. Коли застосовують евристичні алгоритми?.</strong></p><empty-line /><p>
Є зверху</p>

<p><strong>15. Яким чином і коли фіксується пріоритет процесів?</strong></p>

<p><strong>Білет 28</strong></p>

<p><strong>1. Чому впровадження логіки переривань зумовило підвищення продуктивності?</strong> #logic #interupt #process</p><empty-line /><p>
Якщо не було б переривань. То потрібно було б завжди робити циклічний опрос системи, а на це витрачається багато часу, тому швидше використовувати логіку переривань, яка єдиноразово при виклику видасть те, що нам потрібно.</p>

<p><strong>2. Що таке максимальне паросполучення?</strong> #max #para</p><empty-line /><p>
Максимальне паросполучення - це максимально можлива кільність ребер, які мають спільних кінців.</p>

<p><strong>3. Недолік непрямого методу доступу. Де і як зараз він використовується?</strong> #acces #nepr</p><empty-line /><p>
Режим непрямого доступу має істотний недолік. Він не дозволяє повністю виключити випадки простою процесора або непродуктивного його використання. Всякий раз, коли чергова програма, викликана в процесор,попередньо не забезпечена даними, процесор змушений простоювати. При цьому різко знижується ефективність використання ЕОМ.</p><empty-line /><p>
Використовуються, наприклад в SQL-запросах</p>

<p><strong>4. Дати визначення завдання, програми, даних.</strong> #data #task #program</p><empty-line /><p>
Завдання – це одиниця, для якої виділяються ресурси.</p><empty-line /><p>
Програма – це послідовність, у тому числі кількох паралельних, які виконуються ЕОМ для досягнення поставленої мети або завдання.</p><empty-line /><p>
(Інше визначення: Програма – це набір інструкцій, які деталізують обчислення або завдання)
Дані – це відомості, факти, показники, виражені я в числовій так і в будь-якій іншій формі.</p>

<p><strong>5. Дати визначення ресурсу в сучасній ОС.</strong> #os #resource</p><empty-line /><p>
Ресурсом називають можливість, що забезпечується компонентами обчислювальної системи, що витрачається (займана) в процесі її роботи.</p>

<p><strong>6. Перерахувати стратегії, що застосовуються в алгоритмах оптимізації.</strong> #strategy #algo #optimiz</p><empty-line /><p>
Генетичних алгоритмів, оціночних функцій, напрямного пошуку, Anealing метод, метод пошуку максимального паросполучення у зваженому графі, модифікований угорський, метод гілок та границь, модифікований метод для RealTimeOS, евристичний, складання розкладу, метод виключного планування.</p>

<p><strong>7. Чим алгоритм FBn гірше алгоритму «Корбато»?</strong> #fbn #korbato #corbato</p><empty-line /><p>
Перевага Корбато над іншими(списано с теорії до лабораторної):
Корбато дозволяє скоротити кількість системних перемикань за рахунок того, що програмам , що вимагають більшого часу рішення, надаватимуться чималі кванти часу вже при першому занятті ними ресурсу.
Можлива ще така відповідь(привильність невідома):</p><empty-line /><p>
Алгоритм Корбато краще алгоритму FBn, т.к. потенційно володіє більшою продуктивністю тому розподіляє завдання по чергах не з їх пріоритетів, а за ознакою - абсолютна довжина коду програми (чим менше код тим вище пріоритет) (В систему додано аналізатор, який відразу розміщує заявки в свою чергу, відповідно середній</p><empty-line /><p>
Час очікування зменшується)</p>

<p><strong>8. Сформулюйте принцип оптимальності Белмана.</strong> #belman #optim</p><empty-line /><p>
Евристичні (засновані на досвіді людей), Покрокове конструювання - поділ всього процесу рішення на певну кількість кроків і знаходження оптимального або квазіоптимального рішення. ЦЕ - відповідає принципу оптимальності Белмана.</p>

<p><strong>9. Назвати стратегії вирішення задачі розподілу завдань по ресурсах з пересилками.</strong></p>

<p><strong>10. Як визначити зону знаходження оптимального розкладу з урахуванням пересилань?</strong></p>

<p><strong>11. Визначити умови переходу зі стану Р2 в стан Р1.</strong> #p2 #p1 #pereh #state</p><empty-line /><p>
Переходить з Р2 в Р1 якщо процеси знаходяться в одній черзі</p>

<p><strong>12. Навіщо потрібно виконувати структурний аналіз вихідного графа? Чи можна його робити в динамічному режимі?</strong> #analis #struct #graph</p><empty-line /><p>
Для подальшої оптимізації.</p>

<p><strong>13. Дати характеристику однорідної системи.</strong> #odnoridn #sys</p><empty-line /><p>
Система однорідна, коли задачі в неї поступають однаково.</p>

<p><strong>14. Математична постановка задачі динамічного планування.</strong> #math #task #dynamic</p><empty-line /><p>
Задача комбінаторики по розміщенню задач в просторі та у площині.</p>

<p><strong>15. Чому в розподілених системах переважніше використовувати крупнозернисте планування?</strong> #plan #zern #distrib</p><empty-line /><p>
Крупнозернисте планування – це коли час виконання вузла &gt; часу пересилки.</p>
</section>

</body></FictionBook>
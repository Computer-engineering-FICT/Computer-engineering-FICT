	ljmp start		;переходимо на точку старту
;операція X*Y=Z
MUL:mov r2,#0h		;очистка
	mov r3,#0h		;байтів
	mov r4,#0h		;результату
	mov r5,#0h		;r2,r3,r4,r5
	jnb 16.7, n1	;перевіряємо знак множеного, якщо він нульовий, переходимо на мітку n1
	mov a,#1h		;переслати 1h у акумулятор
	mov @10h,a		;вміст акумулятора - у байт 10h
	cpl 16.7		;змінюємо знак множеного на протолежний
n1:	jnb 0.7, n2		;перевіряємо знак множника, якщо він нульовий, переходимо на мітку n2
	mov a,#1h		;переслати 1h у акумулятор
	mov @11h,a		;вміст акумулятора - у байт 11h
	cpl 0.7		;змінюємо знак множника на протолежний
n2:	clr c			;обнуляємо біт переносу
	mov a,23h		;завантажуємо в акумулятор молодший байт множеного
	mov b,21h		;завантажуємо в регістр В молодший байт множника
	mul ab		;множення вмісту акумулятора на вміст регістра В(результат - у В,А)	
	mov r5,a		;молодші розряди результату пересилаються у молодші розряди добутку
	mov a,b		;пересилаємо старші розряди результату у акумулятор	 
	mov r4,a		;старші розряди результату пересилаються у 2-ий байт добутку
	mov a,22h		;завантажуємо в акумулятор старший байт множеного
	mov b,21h		;завантажуємо в регістр В молодший байт множника
	mul ab		;множення вмісту акумулятора на вміст регістра В(результат - у В,А)
	addc a,r4		;сумуємо молодші розряди результату із значенням у 2-му байті добутку
	mov r4,a		;отримана сума пересилається у 2-ий байт добутку
	mov a,b		;пересилаємо старші розряди результату у акумулятор
	mov r3,a		;старші розряди результату пересилаються у 3-ий байт добутку

	mov a,23h		;завантажуємо в акумулятор молодший байт множеного
	mov b,20h		;завантажуємо в регістр В старший байт множника
	mul ab		;множення вмісту акумулятора на вміст регістра В(результат - у В,А)
	addc a,r4		;сумуємо молодші розряди результату із значенням у 2-му байті добутку
	mov r4,a		;отримана сума пересилається у 2-ий байт добутку
	mov a,b		;пересилаємо старші розряди результату у акумулятор
	addc a,r3		;сумуємо старші розряди результату із значенням у 3-му байті добутку
	mov r3,a		;старші розряди результату пересилаються у 3-ий байт добутку
	mov a,22h		;завантажуємо в акумулятор молодший байт множеного
	mov b,20h		;завантажуємо в регістр В старший байт множник
	mul ab		;множення вмісту акумулятора на вміст регістра В(результат - у В,А)
	addc a,r3		;сумуємо молодші розряди результату із значенням у 3-му байті добутку
	mov r3,a		;отримана сума пересилається у 3-ий байт добутк
	mov a,b		;пересилаємо старші розряди результату у акумулятор
	mov r2,a		;старші розряди результату пересилаються у 4-ий байт добутку
	mov a,@10h		;завантажуємо з байту 10h мітку знаку множеного в акумулятор
	xrl a,@11h		;сума по модулю 2 вмісту акумулятора та мітки знаку множника
	jz l12		;якщо результат - 0, перейти на мітку l12
	orl @2h,#80h 	;якщо результат - 1, знаковий розряд добутку встановлюється в 1
l12:	RET			;повернення з підпрограми

;операція X-Y=Z
SUB:mov r2,#0h		;очистка
	mov r3,#0h		;байтів
	mov r4,#0h		;результату
	mov r5,#0h		;r2,r3,r4,r5
	clr c			;обнуляємо біт переносу
	jnb 32.7, n3	;перевіряємо знак зменшуваного, якщо він нульовий, переходимо на мітку n3
	mov a,#1h		;переслати 1h у акумулятор
	mov @10h,a		;вміст акумулятора - у байт 10h
	cpl 32.7		;змінюємо знак зменшуваного на протилежний
	mov r0,#4h		;в r0 записуємо кількість батів зменшуваного
	mov r1,#27h		;в r1 записуємо адресу молодшого байту зменшуваного
	clr c			;встановлюємо біт с
	cpl c			;в 1
ll1:	mov a,@r1		;в акумулятор-черговий байт зменшуваного
	cpl a			;інвертуємо чеговий байт
	addc a,#0h		;враховуємо попередній перенос
 	mov @r1,a		;записуємо байт, переведений у ДК назад
	dec r1		;знаходимо адресу наступного байту зменшуваного
	djnz r0,ll1		;виконуємо цикл для усіх байтів зменшуваного
n3:	jnb 0.7, n4		;перевіряємо знак від"ємника, якщо він нульовий, переходимо на мітку n4
	mov a,#1h		;переслати 1h у акумулятор
	mov @11h,a		;вміст акумулятора - у байт 11h
	cpl 0.7		;змінюємо знак від"ємника на протилежний
	mov r0,#4h		;в r0 записуємо кількість батів від"ємника
	mov r1,#23h		;в r1 записуємо адресу молодшого байту від"ємника
	clr c			;встановлюємо біт с
	cpl c			;в 1
ll2:	mov a,@r1		;в акумулятор-черговий байт від"ємника
	cpl a			;інвертуємо чеговий байт
	addc a,#0h		;враховуємо попередній перенос
 	mov @r1,a		;записуємо байт, переведений у ДК назад
	dec r1		;знаходимо адресу наступного байту від"ємника
	djnz r0,ll2		;виконуємо цикл для усіх байтів від"ємника
n4:	clr c			;обнуляємо біт переносу
	mov dpl,#4h		;в dpl записуємо кількість байтів операндів
	mov r0,#23h		;в r0 записуємо адресу молодшого байту від"ємника
	mov r1,#27h		;в r1 записуємо адресу молодшого байту зменшуваного
ll3:	mov a,@r1		;в акумулятор записуємо черговий байт зменшуваного
	subb a,@r0		;віднімаємо з врахуванням позики від вмісту акумулятора черговий байт від"ємника
	mov @r0,a		;результат записуємо на місце від"ємника
	dec r0		;розраховуємо адресу наступного байта від"ємника
	dec r1		;розраховуємо адресу наступного байта зменшуваного
	djnz dpl,ll3	;викрнуємо цикл для всіх байтів операндів
	RET			;повернення з підпрограми

;операція X+Y=Z
ADD:mov r2,#0h		;очистка
	mov r3,#0h		;байтів
	mov r4,#0h		;результату
	mov r5,#0h		;r2,r3,r4,r5
	clr c			;обнуляємо біт переносу
	jnb 32.7,n5		;перевіряємо знак доданку1, якщо він нульовий, переходимо на мітку n5
	mov a,#1h		;переслати 1h у акумулятор
	mov @10h,a		;вміст акумулятора - у байт 10h
	cpl 32.7		;змінюємо знак доданку1 на протилежний
	mov r0,#4h		;в r0 записуємо кількість батів доданку1
	mov r1,#27h		;в r1 записуємо адресу молодшого байту доданку1
	clr c			;встановлюємо біт с
	cpl c			;в 1
ll4:	mov a,@r1		;в акумулятор-черговий байт доданку1
	cpl a			;інвертуємо чеговий байт
	addc a,#0h		;враховуємо попередній перенос
 	mov @r1,a		;записуємо байт, переведений у ДК назад
	dec r1		;знаходимо адресу наступного байту доданку1
	djnz r0,ll4		;виконуємо цикл для усіх байтів доданку1
n5:	jnb 0.7, n6		;перевіряємо знак доданку2, якщо він нульовий, переходимо на мітку n6
	mov a,#1h		;переслати 1h у акумулятор
	mov @11h,a		;вміст акумулятора - у байт 11h
	cpl 0.7		;змінюємо знак доданку2 на протилежний
	mov r0,#4h		;в r0 записуємо кількість батів доданку2
	mov r1,#23h		;в r1 записуємо адресу молодшого байту доданку2
	clr c			;встановлюємо біт с
	cpl c			;в 1
ll5:	mov a,@r1		;в акумулятор-черговий байт доданку2
	cpl a			;інвертуємо чеговий байт
	addc a,#0h		;враховуємо попередній перенос
 	mov @r1,a		;записуємо байт, переведений у ДК назад
	dec r1		;знаходимо адресу наступного байту доданку2
	djnz r0,ll5		;виконуємо цикл для усіх байтів доданку2
n6:	clr c			;обнуляємо біт переносу
	mov dpl,#4h		;в dpl записуємо кількість байтів операндів
	mov r0,#23h		;в r0 записуємо адресу молодшого байту доданку2
	mov r1,#27h		;в r1 записуємо адресу молодшого байту доданку1
ll6:	mov a,@r1		;в акумулятор записуємо черговий байт доданку1
	addc a,@r0		;додаємо з врахуванням переносу до вмісту акумулятора черговий байт доданку2
	mov @r0,a		;результат записуємо на місце доданку2
	dec r0		;розраховуємо адресу наступного байта доданку2
	dec r1		;розраховуємо адресу наступного байта доданку1
	djnz dpl,ll6	;викрнуємо цикл для всіх байтів операндів
	RET			;повернення з підпрограми

start:mov r0,#30h	;записуємо адресу масиву операндів
	mov r1,#0Ch		;кількість операндів
pr1:	mov a,P0		;зчитуємо значення з порту Р0 в акумулятор
	mov @r0,a		;значення з акумулятора-в масив операндів
	inc r0		;знаходимо наступну адресу
	djnz r1,pr1		;повторюємо цикл, поки не запишемо усіі необхідні операнди
	mov 20h,#0h		;X2
	mov 21h,#0h
	mov 22h,32h
	mov 23h,33h
	mov 20h,22h		;розповсюджуємо байт зі знаком
	anl 22h,#7Fh	;видаляємо знак всередині операнду
	anl 20h,#80h	;виділяємо знак
	mov 24h,#0h		;X1
	mov 25h,#0h
	mov 26h,30h
	mov 27h,31h
	mov 24h,26h		;розповсюджуємо байт зі знаком
	anl 26h,#7Fh	;видаляємо знак всередині операнду
	anl 24h,#80h	;виділяємо знак
	acall SUB		;викликаємо підпрограму віднімання
	mov 28h,20h		;(X1-X2)
	mov 29h,21h
	mov 2Ah,32h
	mov 2Bh,33h
	mov 20h,34h		;X5
	mov 21h,35h
	mov 22h,34h
	mov 23h,35h
	acall MUL		;викликаємо підпрограму віднімання
	mov 20h,2h		;X5^2
	mov 21h,3h
	mov 22h,4h
	mov 23h,5h
	mov 24h,#0h		;X6
	mov 25h,#0h
	mov 26h,36h
	mov 27h,37h
	mov 24h,26h		;розповсюджуємо байт зі знаком
	anl 26h,#7Fh	;видаляємо знак всередині операнду
	anl 24h,#80		;виділяємо знак
	acall ADD		;викликаємо підпрограму додавання:(X5^2+X6)
	mov 24h,28h		;(X1-X2)
	mov 25h,29h
	mov 26h,2Ah
	mov 27h,2Bh
	acall ADD		;викликаємо підпрограму додавання
	mov 24h,20h		;(X1-X2)+(X5^2+X6)
	mov 25h,21h
	mov 26h,22h
	mov 27h,23h
	mov 20h,38h		;X9
	mov 21h,39h
	mov 22h,38h
	mov 23h,39h
	acall MUL		;викликаємо підпрограму множення
	mov 20h,2h		;X9^2
	mov 21h,3h
	mov 22h,4h
	mov 23h,5h
	acall ADD		;викликаємо підпрограму додавання
	mov 24h,20h		;(X1-X2)+(X5^2+X6)+X9^2
	mov 25h,21h
	mov 26h,22h
	mov 27h,23h
	mov 20h,3Ah		;X10
	mov 21h,3Bh
	mov 22h,3Ah
	mov 23h,3Bh
	acall MUL		;викликаємо підпрограму множення
	mov 20h,2h		;X10^2
	mov 21h,3h
	mov 22h,4h
	mov 23h,5h
	acall ADD		;(X1-X2)+(X5^2+X6)+X9^2
	mov r0,#4h		;кількість байтів у результаті
	mov r1,#20h		;адреса першого байту
pr2:	mov P0,@r1		;пересилаємо байт результату на порт Р0
	inc r1		;знаходимо наступну адресу
	djnz r0,pr2		;повторюємо цикл, поки не передамо результат

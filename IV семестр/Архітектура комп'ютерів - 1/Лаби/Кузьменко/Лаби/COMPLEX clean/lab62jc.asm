\ Лабораторная работа №6-2

\ КОПы:
\ in:  0001  - Чтение из адр в R15    (адресация как прямая так и косвенная)
\ out: 0010  - Запись из R15 в адр    (адресация как прямая так и косвенная)
\ cjp: 1111  - Условный переход по адресу указ. в ячейке,
\               на которую ссылается содержимое ячейки, указанной в адр если
\               устaновлен бит R15[7]
\ jmp: 0000  - Условный переход по адресу указ. в ячейке,
\               на которую ссылается содержимое ячейки, указанной в адр

\ mul: 1110  - Умножение на операнд по адресу адр (прямая адресация)
\               по адресу, что указан в адресной части команды умножения
\               находится адрес операнда


    dw 00h:0000110001000101%                \ in R15, [[45h]]     (косвенная)
    dw 02h:0001010001000011%                \ out [[43h]], R15    (косвенная)
    dw 04h:0111000001000111%                \ mul R15, [47h]      (прямая)
    dw 06h:0111110001001001%                \ cjp [49h]           (косвенная)
    dw 08h:0000100001100101%                \ in R15, [65h]       (прямая)
    dw 0Ah:0001000001100011%                \ out [63h], R15      (прямая)
    dw 0Ch:1000111001010011%                \ & (2-adr)
    dw 0Eh:1000111001010011%                \ & (2-adr)
    dw 10h:0000010001000001%                \ jmp start           (косвенная)


    dw 41h:0000000001100001%                \ Указатель на адрес безусл. перехода
    dw 43h:0000000001100011%                \ Указатель на номер порта A2
    dw 45h:0000000001100101%                \ Указатель на номер порта 22
    dw 47h:1010101111001101%                \ Операнд к-ды умножения = 0ABCDh
    dw 49h:0000000001100111%                \ Указатель на адрес условного перехода
    dw 50h:1111101011111010%                \ Первый операнд для &
    dw 51h:0001000100100010%                \ Второй операнд для &
\Результат:0001000000100010%    = 1022h
    dw 52h:1111101011111010%                \ Первый операнд для & (№2)
    dw 53h:1001001001001001%                \ Второй операнд для & (№2)
\Результат:1001001001001000%    = 9248h
    dw 54h:1101101010011010%                \ Первый операнд для & (№3)
    dw 55h:1001001001001001%                \ Второй операнд для & (№3)
\Результат:1001001000001000%    = 9208h

    dw 61h:0000000000000000%                \ Адрес безусл. перехода
    dw 63h:0000000010100100%                \ номер порта A4
    dw 65h:0000000000100100%                \ номер порта 24
    dw 67h:0000000000001010%                \ Удрес условного перехода


    link     l3:ct
    link     l1:rdm
    link     l2:rdd
    link     ewh:16                         \ сигнал EWH-запись в 4 ст. разр. РА
    accept   R7:0                           \ Инициализация счетчика команд
\   accept   R0:0050h
\   accept   R1:0051h
    accept   R2:0050h
    accept   R3:0051h
    accept dev[1]:i, 22h, 24h, 3, 15
    accept dev[2]:o, 0A2h, 0A4h, 3, 14
    accept dev_buf[1]: 01234h, 01111h       \ Содержимое БД ВУ вывода №1
\ -----------------------------------------------------------------------------
\   R7  - счетчик команд
\   R8  - регистр комманд
\   R10 - вспомогательный регистр
\   R11 - счетчик циклов умножения
\   R12 - младшее слово регистра суммы частичных произведений
\   R13 - знак при умножении
\   R14 - старшее слово сумматора, 2-й операнд умножения (множитель)
\   R15 - аккумулятор, 1-й операнд умножения (множимое)
\ -----------------------------------------------------------------------------
    include macro.inc
\ ------------------------ Выборка комманды из памяти -------------------------
Start
    {ewh; oey; xor nil, R7, R7;}            \ Читаем в PA, [R7] - PK
    {ewl; oey; or nil, R7, R7;}
m_wait
    {R; cjp rdm,m_wait; or R8,bus_d,z;}     \ Цикл чтения, R8 - PK

\ -----------------------------------------------------------------------------
    {and nil,R8,8000h; load RM, flags;}     \ Команда одноадpесная ?
    {cjp not rm_z, cmd2adr;}                \ Если 2-ух-адресная, то переход

\ --------------------- Блок обработки одноадресных команд --------------------
    {or R10,R8, z;}                         \ Копирование регистра команд
    {and R10,R10,7800h;}                    \ Выделение поля КОП
    {sub R10,R10,7000h,nz; load RM,Flags;}  \ Комманда умножения ?
    {cjp not rm_z, notmul;}                 \ Если не умножения, то переход

\ ----------------------- Обработка команды умножения -------------------------
    {or R10, 0400h, z;}                     \ Грузим маску для типа адресации
    {and nil, R8, R10; load RM, flags;}     \ Проверка поля типа адресации в РК
    {cjp not rm_z, mulcosvadr;}             \ Переход если косвенная
    
    {or R10, R8, z;}                        \ Копируем регистр команд в R10
    {and R10, R10, 3FFh;}                   \ Выделяем адресную часть команды
    {or nil, R10, z; oey; ewl;}             \ Посылаем адрес на шину адреса
m_wait1
    {r; cjp RDM,m_wait1; or R14,bus_d,z;}   \ Читаем из памяти в R14 - множитель

    {call dk_to_pk;}                        \ Преобразовать x и y в ПК
    {call multip;}                          \ Процедура умножения
    {call setressign;}                      \ Процедура установки знака
    {jmp bfsak;}                            \ Переход на форм. адр. сл. к-ды
mulcosvadr                                  \ Случай косвенной адресации (умн.)
    {cont; jmp bfsak;}
\ ----------------------------------------------------------------------------- 

notmul                                      \ В команде не микрооперация умнож.
    {or R10, R8, z;}
    {and R10, R10, 0111100000000000%;}      \ Маска для КОП
    {sub R10, 7800h, nz; load rm, flags;}   \ Проверка: команда условного перехода?
    {cjp not rm_z, notcjp;}                 \ Если нет, то переход

\ -------------------- Обработка команды условного перехода -------------------
    {and nil, R8, 0400h; load rm, flags;}   \ Проверка: косвенная адресация?
    {cjp rm_z, cjpdirect;}                  \ Переход если прямая адресация

    {and nil, R15, 0080h; load rm, flags;}  \ Проверка 7-го бита R15
    {cjp rm_z, bfsak;}                      \ Если R15[7] = 0, то ничего не делать
    {or R10, R8, z;}                        \ Копируем регистр команд
    {or R11,03ffh, z;}                      \ Пишем константу в R1
    {and R10, R10, R11; OEY; EWL;}          \ Выделяем адресную часть команды
m_wait2
    {r; cjp rdm,m_wait2; or R10,bus_d,z;}   \ Считываем из памяти pointer
    {or nil,R10,z; OEY; EWL;}
    {r; cjp rdm, cp; or R10,bus_d,z;}       \ Read jmp address

    {or R7, R10, z; jmp start;}             \ Пишем в IP адрес перехода
cjpdirect                                   \ Случай прямой адресации
    {cont; jmp bfsak;}
\ ----------------------------------------------------------------------------- 

notcjp                                      \ Не команда условного перехода
    {or R10, R8, z;}                        \ Копируем регистр команд
    {and R10, R10, 7800h; load rm, flags;}  \ Выделение поля КОП
    {cjp not rm_z, notjmp;}                 \ Если не к-да безусл.п., то переход

\ ------------------ Обработка команды безусловного перехода ------------------
    {and nil, R8, 0400h; load rm, flags;}   \ Проверка: косвенная адресация?
    {cjp rm_z, jmpdirect;}                  \ Переход если прямая адресация

    {or R10, R8, z;}                        \ Копируем регистр команд
    {or R11,03FFh, z;}                      \ Пишем константу в R1
    {and R10, R10, R11; OEY; EWL;}          \ Выделяем адресную часть команды
m_wait3
    {r; cjp rdm,m_wait3; or R10,bus_d,z;}   \ Считываем из памяти pointer
    {or nil,R10,z; OEY; EWL;}
    {r; cjp rdm, cp; or R10,bus_d,z;}       \ Read jmp address

    {or R7, R10, z; jmp start;}             \ Пишем в IP адрес перехода
jmpdirect                                   \ Случай прямой адресации
    {cont; jmp bfsak;}
\ ----------------------------------------------------------------------------- 

notjmp
    {or R10, R8, z;}                        \ Не команда безусл. перехода
    {and R10, R10, 7800h;}                  \ Выделение поля КОП
    {sub R10,R10,0800h,nz; load rm,flags;}  \ Проверка: команда ввода?
    {cjp not rm_z, notin;}                  \ Если не к-да ввода, то переход

\ -------------------------- Обработка команды ввода --------------------------
    {or R10, R8, z;}                        \ Копируем регистр команд
    {or R11,03FFh, z;}                      \ Запись константы в регистр
    {and R10,R10,R11; OEY; EWL;}            \ Выделяем адресную часть команды
m_wait4
    {r; cjp rdm,m_wait4; or R10,bus_d,z;}   \ Считываем из памяти адрес
    {and nil, R8, 0400h; load rm, flags;}   \ Проверка зоны типа адресации
    {cjp rm_z, cont_in;}                    \ Если прямая, то один цикл чтения

    {or nil, R10, z; OEY; EWL;}
    {r; cjp rdm, cp; or R10, bus_d,z;}      \ Считываем из памяти адрес
cont_in
    {or R12, 2, z;}
    {sub R10, R10, R12, nz; OEY; EWL;}      \ Вычисляем адрес РС
d_wait1
    {i; cjp rdd,d_wait1; or R11,bus_d,z;}   \ Считываем регистр состояния
dnotready1
    {and nil, R11,0080h; load rm, flags;}   \ Проверяем бит готовности
    {cjp rm_z, dnotready1;}                 \ Ждем пока не будет готово
    {or R12, 2, z;}
    {add R10, R10, R12, z; OEY; EWL;}       \ Вычисляем адрес РД
d_wait2
    {i; cjp rdd,d_wait2; or R15,bus_d,z;}   \ Считываем с ЛШ в аккумулятоор
    {jmp bfsak;}
\ ----------------------------------------------------------------------------- 
notin                                       \ Не команда ввода

    {or R10, R8, z;}
    {and R10,R10,7800h;}                    \ Выделение поля КОП
    {sub R10,R10,1000h, nz;load rm,flags;}  \ Проверка: команда вывода?
    {cjp not rm_z, notout;}                 \ Если не к-да вывода, то переход

\ ------------------------- Обработка команды вывода --------------------------
    {or R10, R8, z;}
    {or R11,03FFh, z;}                      \ Запись константы в регистр
    {and R10, R10, R11; OEY; EWL;}          \ Выделяем адресную часть команды
m_wait5
    {r; cjp rdm,m_wait5; or R10,bus_d,z;}   \ Считываем из памяти адрес
    {and nil, R8, 0400h; load rm, flags;}   \ Проверка зоны типа адресации
    {cjp rm_z, out_cont;}                   \ Если прямая, то переход

    {or nil, R10, z; OEY; EWL;}
    {r; cjp rdm,m_wait5; or R10,bus_d,z;}   \ Считываем из памяти адрес
out_cont
    {or R12, 2, z;}
    {sub R10, R10, R12, nz; OEY; EWL;}      \ Вычисляем адрес РС
d_wait5
    {i; cjp rdd,d_wait5; or R11,bus_d,z;}   \ Считываем регистр состояния
dnotready3
    {and nil,R11,0080h; load rm,flags;}     \ Проверяем бит готовности
    {cjp rm_z, dnotready3;}                 \ Ждем пока не будет готово
    {or R12, 2, z;}
    {add R10, R10, R12, z; OEY; EWL;}       \ Вычисляем адрес РД
d_wait6
    {or nil,R15,z; OEY; o; cjp rdd,d_wait6;}\ Записываем аккумулятоор в РД
    {jmp bfsak;}
\ -----------------------------------------------------------------------------
notout
    {cont; jmp bfsak;}
cmd2adr                                     \ Обработка двухадресной комманды
    {or R10,R8, z;}                         \ Копирование регистра команд
    {and R10,R10,0111110000000000%;}        \ Выделение поля КОП
    {sub R10,R10,0C00h,nz; load RM,Flags;}  \ Операция конъюнкции ?
    {cjp not rm_z, notkon;}                 \ Если нет, то переход

    {and R10,R8,0300h;}
    {sub R10,R10,0200h,nz; load rm,flags;}  \ 1-ый оп. адр-ия автоинкрементная?
    {cjp not rm_z, not1ai;}                 \ Если нет, то переход

    {and R10,R8,0018h;}
    {sub R10,R10,010h,nz; load rm,flags;}    \ 2-ый оп. адр-ия автоинкрементная?
    {cjp not rm_z, not2ai;}                 \ Если нет, то переход

    {and R10,R8,00E0h;}                     \ Выделяем номер регистра
    {push nz,4;}                            \ Сдвиг на 5 разрядов вправо
    {rfct; or srl,R10,R10,z;}
    {or RQ,R10,z; OEY; EWB;}                    \ Запись в RB номера регистра
    {or nil,RB,z; OEY; EWL;}
    {r; cjp rdm,cp; or R11,bus_d,z;}
    {or RQ,RB,z; OEY;}
    {or R9,RQ,z;}

    {or R10, 2, z;}
    {add RB,RB,R10,z;}

    {and R10,R8,0007h;}
    {or nil,R10,z; OEY; EWB;}              \ Выделяем номер регистра и пишем RA
    {or nil,RB,z; OEY; EWL;}
    {r; cjp rdm,cp; or R12,bus_d,z;}
    {or R10,2,z;}
    {add RB,RB,R10,z;}

    {or nil,R9,z; OEY; EWL;}
    {and R11,R11,R12; OEY; w; cjp rdm,cp;}
    {jmp bfsak;}
notkon
    {cont; jmp bfsak;}
not1ai
    {cont; jmp bfsak;}
not2ai
    {cont; jmp bfsak;}


\ ---------------- Блок формирования адреса след. команды----------------------
bfsak                                       \ Формирование адреса след. к-ды
    {add  R7, R7, 2, z;}                    \ Увеличиваем счетчик команд
    {jmp start;}



\ ---- Подпрограмма перевода из ДК в положительное ПК (регистры R15 и R14) ----
\ -- Информация о знаке результата сохраняется в R13: 01 = '-';  00,10 = '+' --
dk_to_pk
    {and R13, z;}                           \ Знак результата
    {and RQ, R14, 8000h;}
    {cjp not zo, R14minus;}                 \ После AND zo=0, значит отриц.
    {jmp next1;}                            \ положительное
R14minus
    {or R13, R13, 0001h;}                   \ Установить "зн." разряд для 1-го
    {nxor R14, z;}                          \ Перевод в ПК множителя
    {add R14,z,nz;}                         \ +1
next1
    {and RQ, R15, 8000h;}                   \ Проверка знакового бита
    {cjp not zo, R15minus;}
    {cjp nz, next2;}                        \ положительное
R15minus
    {add R13, z, nz;}                       \ Установить "зн." разряд для 2-го
    {nxor R15, z;}                          \ Перевод в ПК множимого
    {add R15, z, nz;}                       \ +1
next2
    {ret;}
\------------------------------------------------------------------------------


\------- Подпрограмма определения знака результата (определение R14[15]) ------
setressign
    {and nil, R13, 1; load RM, flags;}      \ Анализ младшего бита R13
    {cjp rm_z, bret;}                       \ Результат положительный ?
    {or R14,R14,8000h;}                     \ Установить старший бит
bret
    {ret;}                                  \ Oтдать управление
\------------------------------------------------------------------------------

\ --------------------------- Подпрограмма умножения --------------------------
\ ----------- R14 - множитель, R15 - множимое, результат - R14:R15 -------------
multip
    {or R11, 16, z;}                        \ Установка счетчика циклов
    {and R12, z;}                           \ Сброс R12
loop1
    {or sll, R12, R12, z;}                  \ Сдвиг суммы частичных произведений
                                            \ Сдвиг множителя
    {or  sl.25, R14, R14, z; cjp not rm_c, noadd;}
    {add R12, R12, R15, z; load rm, flags;} \ Сложение множимого с суммой ч.п.
    {cjp not rm_c, noadd;}
    {add R14, z, nz;}                       \ В случае переноса из сумматора
noadd                                       \ Декремент и проверка
    {dec R11; load rm, flags; cem_c; cjp not rm_z, loop1;}
    {mov R15, R12;}
    {ret;}                                  \ Pезультат в R14:R15
    {add R12, R12, R15, z; load rm, flags;} \ Сложение множимого с суммой ч.п.
    {add R14, z, nz;}                       \ В случае переноса из сумматора
    {mov R15, R12;}
    {mov R15, R12;}

                          ╔═════════════╗
                          ║~0001C O M P L E X~║
                          ╚═════════════╝

   Программа эмуляции работы вычислительной системы построенной на
   ═══════════════════════════════════════════════════════════════
        базе микропрограммируемого секционированого комплекта
        ═════════════════════════════════════════════════════
                             серии КМ1804
                             ════════════

                   ╔═══════════════════════════════╗
                   ║~0012    Структура микрокоманды.    ~║
                   ╚═══════════════════════════════╝

 Память  микрокоманд  разработанной системы содержит  отдельные
 микрокоманды, каждая из которых  делится  на поля:

   1. ~0036Поле констант~:
                    адрес БМУ;
                    константа БОД;
   2. ~0085Поле БОД (блок обработки данных)~:
                    микросхема КМ1804 ВС1;
                    микросхема КМ1804 ВР2;
                    регистры адресов операндов РАА,РАВ;
   3. ~0623Поле БМУ (блок микропрограммного управления)~:
                    микросхема КМ1804 ВУ4;
                    мультиплексор условий;
   4. ~0769Поле БПП (блок приоритетных прерываний)~;
                    микросхема КМ1084 ВН1;
   5. ~0858Поле управляющих сигналов~:
                    ОП  - оперативная память;
                    УВВ - устройства ввода/вывда;
                    РА  - регистр адреса.

                       ┌──────────────────╖
                       │~0036 1.ПОЛЕ КОНСТАНТ. ~║
                       ╘══════════════════╝
 Включает:
           ~0044D   - константа~;
           ~0066OED - разрешить выдачу константы~.


 ┌────────╖
 │~0044 Поле D ~║  КОНСТАНТА.
 ╘════════╝   ─────────┘
 Назначение.
        1) Младшие  12  разрядов  используются для формирования
           адресов переходов вырабатываемых БМУ. Данные разряды
           постоянно поступают на шину адреса ветвления, если в
           результате выполнения команды в БМУ (микросхема ВУ4)
           формируется сигнал PE=0;
        2) Все  16 разрядов могут быть использованы для задания
           констант,которые под управлением сигнала OED=0 могут
           быть выданы на системную шину  данных.  Эта  особен-
           ность позволяет:
           -  во-первых, уменьшить разрядность ПЗУ  МК(микроко-
            манд) за счет  совмещения  полей;
           -   во-вторых, дает возможность загружать  необходи-
           мые константы, маски и т.п. в  любое  из  устройств,
           подключенное к системной шине данных.

 Примечание. Значения вводятся в  шестнадцатиричном  коде.
             При вводе новой команды задается нулевая константа.

 ┌────────╖
 │~0066  OED   ~║  РАЗРЕШИТЬ ВЫДАЧУ КОНСТАНТЫ НА ШИНУ АДРЕСА.
 ╘════════╝   ─────────────────────────────────────────┘
 Назначение.
           Разрешение выдачи всех шестнадцати  разрядов  поля D
           на шину данных системы. Установка данного сигнала  в
           нулевое значение приводит к формированию на  систем-
           ной шине данных значения константы поля D.
 Уровень:  0 - Активный  (выдача разрешена);
           1 - Пассивный (выдача запрещена).
 Примечание.
           Значения вводятся в двоичном коде(значение 0 или 1).
           При вводе новой команды выдача константы из ПМК на шину данных
           запрещена.





             ┌───────────────────────────────────────╖
             │~0085  2.ПОЛЕ БОД (блок обработки данных).  ~║
             ╘═══════════════════════════════════════╝

 Блок обработки данных(далее БОД) предлагаемой системы построен
 с  использованием  следующих функциональных узлов:

    1) 4 микропроцессорных секции КМ1804ВС1,которые образуют
       основу 16-разрядного АЛУ.
    2) Схема управления состоянием и сдвигами КМ1804ВР2, которая
       предназначена  для  совместной  работы  с  процессорными
       элементами ВС1  и  обеспечивает замыкание данных  вокруг
       микропроцессорных секций. Данная микросхема обеспечивает
       функции  регистра  состояния  и  формирователя   сигнала
       переноса,  смесь   источников   входного  переноса  АЛУ,
       организовывает  32  типа  сдвигов (арифметические, логи-
       ческие, циклические), которые  могут  быть  обычной  или
       двойной  длины,  содержит   два   4-разрядных   регистра
       состояния, выполняет 16 операций по формированию сигнала
       условия.
    3) Микросхемы обрамления:
        4-разрядные регисты операндов (РАА,РАВ);
        Мультиплексоры  выбора  источника   операндов,  который
        позволяет  адресовать  регистры  участвующие в операции
        АЛУ либо из ПМК,либо по адреса,хранящемуся в РАА и РАВ.

 Для управления вышеперечисленными устройствами,каждая команда
 в ПМК содержит следующие поля.

 Включает:
     Микросхема КМ1804ВС1:
                ~0136BC1_MI¤~  - операция в ВС1;
                ~0231A,B~      - номера регистров АЛУ;
                ~0246OEY~      - разрешене выдачи результата из АЛУ;

                Микросхема КМ1804ВР2:
                ~0260BP2_MI¤~  - операция в ВР2;
                ~0528E.ZNCV~   - побитное разрешение записи меток в RM;
                ~0543OECT~     - разрешение выдачи кода условия;
                ~0560CEM~      - разрешение записи меток в RM;
                ~0560CEN~      - разрешение записи меток в RN;
                ~0572SE~       - разрешение выполнения сдвига;

                Микросхемы обрамления:
                ~0584MSA~      - источник операндов в АЛУ (ПМК или РА);
                ~0584MSB~      - источник операндов в АЛУ (ПМК или РB);
                ~0601EWA~      - запись в регистры операнда PA;
                ~0601EWB~      - запись в регистры операнда PB.



 ┌────────╖
 │~0136 BC1_MI¤~║  ПОЛЕ МИКРОКОМАНДЫ МИКРОСХЕМЫ ВС1.
 ╘════════╝   ────────────────────────────────┘
 Назначение.
           Задает операцию выполняемую в АЛУ. Данное  поле  со-
           держит несколько разделов (полей), каждое из  которых
           определяет характер выполняемой операции.
                1)      ~0151Поле приемника результата в АЛУ~;
                2)      ~0181Поле операции  в АЛУ~;
                3)      ~0206Поле операндов в АЛУ~.
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤).


 ┌───────────╖
 │~0151BC1_MI¤.876~║  ПРИЕМНИК РЕЗУЛЬТАТА ОПЕРАЦИИ В АЛУ.
 ╘═══════════╝   ──────────────────────────────────┘
 Назначение.
           Поле приемника результата  в  АЛУ  (разряды  8,7,6).
           Определяет куда помещается результат операции.
           ┌───┬────────────────────────────────────────────────┐
           │MI │                                                │
           │876│   куда попадет результат выполнения операции   │
           ├───┼────────────────────────────────────────────────┤
           │000│   F -> Q                                       │
           │001│ результат операции в АЛУ не заносится ни в один│
           │   │ из внутренних регистров используется лишь кос- │
           │   │ венный эффект, например переустановленные флаж-│
           │   │ ки операций, либо выдача результата на шину    │
           │   │ данных                                         │
           │010│   F -> B и на шину выдается не результат, а    │
           │   │ значение регистра - операнда А                 │
           │011│   F -> B                                       │
           │100│   F/2 -> B, Q/2 -> Q                           │
           │101│   F/2 -> B                                     │
           │110│   2F -> B,  2Q -> Q                            │
           │111│   2F -> B                                      │
           └───┴────────────────────────────────────────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (MI¤).
           При вводе новой команды задается код 001.


 ┌───────────╖
 │~0181BC1_MI¤.543~║  ОПЕРАЦИЯ В АЛУ.
 ╘═══════════╝   ──────────────┘
 Назначение.
           Поле операции в АЛУ (разряды 5,4,3). Определяет  ха-
           рактер  преобразования  над  выбранными  операндами.
           ┌───┬──────┬───────────────┐
           │MI │мнемо-│               │
           │543│ ника │операция в АЛУ │
           ├───┼──────┼───────────────┤
           │000│ ~1108ADD~  │   R+S+CI      │
           │001│ ~1109SUB~  │   S-R-1+CI    │
           │010│ ~1109SUB~  │   R-S-1+CI    │
           │011│ ~1110OR~   │   R or S      │
           │100│ ~1111AND~  │   R and S     │
           │101│ ~1113NAND~ │   not(R) and S│
           │110│ ~1112XOR~  │   R xor S     │
           │111│ ~1115NXOR~ │   not(R xor S)│
           └───┴──────┴───────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (MI¤).
           При вводе новой команды задается  код  000


 ┌───────────╖
 │~0206BC1_MI¤.210~║  ПОЛЕ ОПЕРАНДОВ ОПЕРАЦИИ В АЛУ.
 ╘═══════════╝   ─────────────────────────────┘
 Назначение.
           Поле операндов в  АЛУ  (разряды  2,1,0).  Определяет
           операнды, которые участвуют в  выполнении  операции.
           ┌───┬───────────┬──────┐
           │MI │           │      │
           │210│ мнемоника │R    S│
           ├───┼───────────┼──────┤
           │000│ ~1168Rx~ , ~1166RQ~ ; │A    Q│
           │001│ ~1168Rx~ , ~1168Rx~ ; │A    B│
           │010│ ~1162Z~  , ~1166RQ~ ; │Z    Q│
           │011│ ~1162Z~  , ~1168Rx~ ; │Z    B│
           │100│ ~1162Z~  , ~1168Rx~ ; │Z    A│
           │101│ ~1172Val~, ~1168Rx~ ; │D    A│
           │110│ ~1172Val~, ~1166RQ~ ; │D    Q│
           │111│ ~1172Val~, ~1162Z~  ; │D    Z│
           └───┴───────────┴──────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (MI¤).
           При вводе новой команды задается  код  000


 ┌────────╖
 │~0231  A, B  ~║  НОМЕРА РЕГИСТРОВ АЛУ, ИСПОЛЬЗУЕМЫХ В ОПЕРАЦИИ.
 ╘════════╝   ─────────────────────────────────────────────┘
 Назначение.
           Поля определяют номера регистров  АЛУ,  которые  ис-
           пользуются при выполнении операции. Значения из это-
           го поля поступают на входы  А  и  В  микросхемы  ВС1
           соответственно. Условием  коммутации  этих  полей  на
           микросхему ВС1 являются  сигналы  на
           мультиплексорах выбора источника операндов MSA=0 и MSB=0.
 Примечание.
           Значения вводятся в шестнадцатиричном коде.
           При вводе новой команды задаются  нулевые РОНы


 ┌────────╖
 │~0246  OEY   ~║  РАЗРЕШЕНИЕ ВЫДАЧИ РЕЗУЛЬТАТА.
 ╘════════╝   ────────────────────────────┘
 Назначение.
           Разрешение выдачи результата из АЛУ  (BC1)  на  шину
           данных системы.
 Уровень : 0 - Активный  (выдача разрешена)
           1 - Пассивный  (выдача запрещена).
 Примечание.
           Значения вводятся в двоичном кода.
           При вводе новой команды выдача результата операции в
           АЛУ запрещена.


 ┌─────────╖
 │~0260 BP2_MI¤ ~║  ПОЛЕ МИКРОКОМАНДЫ МИКРОСХЕМЫ ВР2.
 ╘═════════╝   ────────────────────────────────┘
 Назначение.
           Задает микрокоманду выполняемую в устройстве  управ-
           ления состоянием и сдвигами КМ1804ВР2 ,которая обес-
           печивает замыкание данных  вокруг  микропроцессорных
           секций (КМ1804ВС1). Поле содержит  несколько  разде-
           лов :
              1) ~0278Поле управления сигналами переноса CI~;
              2) ~0304Поле управления выполнением сдвигов~;
              3) ~0361Поле управления выхода кода условия~ и  загруз-
                 ки регистров меток.
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).


 ┌──────────╖
 │~0278BP2_MI¤.CB~║  УПРАВЛЕНИЕ СИГНАЛОМ СI.
 ╘══════════╝   ──────────────────────┘
 Назначение.
           Поле  управления  сигналами  переноса  CI   (разряды
           12,11). Значение этого поля  позволяет  коммутировать
           различные сигналы на вход СI  секции  АЛУ.
     ┌──┬──────┬───────────────────────────────────────────────┐
     │MI│мнемо-│                                               │
     │CB│ ника │      перенос, подаваемый на вход БОД          │
     ├──┼──────┼───────────────────────────────────────────────┤
     │00│  ~1279Z~   │                    0                          │
     │01│~1285not~ Z │                    1                          │
     │10│      │              не задействовано                 │
     │11│ ~1281RM_C~ │сигнал переноса задается  с выходов С регистров│
     │  │ ~1283RN_C~ │меток RM и RN по следующему порядку:           │
     │  │~1285not~   │при  MI.5 = 1 с RM.C, иначе с RN.C ;           │
     │  │  RM_C│при  MI.321 = 100 сигнал берется с инверсией;  │
     │  │  RN_C│при любой другой комбинации - без нее          │
     └──┴──────┴───────────────────────────────────────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).
           При вводе новой команды задается код 00


 ┌───────────╖
 │~0304BP2_MI¤.A-6~║  ПОЛЕ УПРАВЛЕНИЯ СДВИГОМ.
 ╘═══════════╝   ───────────────────────┘
 Назначение.
           Поле управления выполнения сдвигов (разряды 10-6).
 ┌─────┬────┬───────────────┬───────────────────────────────────────────┐
 │     │    │               │  формирование сигнала сдвига на регистры  │
 │  MI │    │               │          БОД   (при сигнале SE = 0 )      │
 │A9876│dec.│  мнемоника    ├──────────────┬──────────┬─────────────────┤
 │     │    │               │  на регистр  │на регистр│загрузка флажка С│
 │     │    │               │  прм.рез-та  │    RQ    │рег-ра меток RM  │
 ├─────┴────┴───────────────┴──────────────┴──────────┴─────────────────┤
 │~0316                  П Р А В Ы Е      С Д В И Г И                        ~│
 ├─────┬────┬───────────────┬──────────────┬──────────┬─────────────────┤
 │00000│ 00 │        ~1250SR.0~   │SRB:=0        │SRQ:=0    │      нет        │
 │00001│ 01 │        ~1250SR.1~   │SRB:=1        │SRQ:=1    │      нет        │
 │00010│ 02 │ ~1226SRL~  (~1250SR.2~)   │SRB:=0        │SRQ:=RM.N │   RM.C:=SRB     │
 │00011│ 03 │        ~1250SR.3~   │SRB:=1        │SRQ:=SRB  │      нет        │
 │00100│ 04 │        ~1250SR.4~   │SRB:=RM.C     │SRQ:=SRB  │      нет        │
 │00101│ 05 │        ~1250SR.5~   │SRB:=RM.N     │SRQ:=SRB  │      нет        │
 │00110│ 06 │        ~1250SR.6~   │SRB:=0        │SRQ:=SRB  │      нет        │
 │00111│ 07 │ ~1226SRWL~ (~1250SR.7~)   │SRB:=0        │SRQ:=SRB  │   RM.C:=SRQ     │
 │01000│ 08 │        ~1250SR.8~   │SRB:=SRB      │SRQ:=SRQ  │   RM.C:=SRB     │
 │01001│ 09 │        ~1250SR.9~   │SRB:=RM.C     │SRQ:=SRQ  │   RM.C:=SRB     │
 │01010│ 10 │        ~1250SR.10~  │SRB:=SRB      │SRQ:=SRQ  │      нет        │
 │01011│ 11 │        ~1250SR.11~  │SRB:=CO       │SRQ:=SRB  │      нет        │
 │01100│ 12 │        ~1250SR.12~  │SRB:=RM.C     │SRQ:=SRB  │   RM.C:=SRQ     │
 │01101│ 13 │        ~1250SR.13~  │SRB:=SRQ      │SRQ:=SRB  │   RM.C:=SRQ     │
 │01110│ 14 │~1226SRA SRWA~(~1250SR.14~)│SRB:=NO xor VO│SRQ:=SRB  │      нет        │
 │01111│ 15 │        ~1250SR.15~  │SRB:=SRQ      │SRQ:=SRB  │      нет        │
 ├─────┴────┴───────────────┴──────────────┴──────────┴─────────────────┤
 │~0335                  Л Е В Ы Е        С Д В И Г И                        ~│
 ├─────┬────┬───────────────┬──────────────┬──────────┬─────────────────┤
 │10000│ 16 │ ~1226SLL~  (~1250SL.16~)  │SLB:=0        │SLQ:=0    │   RM.C:=SLB     │
 │10001│ 17 │        ~1250SL.17~  │SLB:=1        │SLQ:=1    │   RM.C:=SLB     │
 │10010│ 18 │ ~1226SLA~  (~1250SL.18~)  │SLB:=0        │SLQ:=0    │      нет        │
 │10011│ 19 │        ~1250SL.19~  │SLB:=1        │SLQ:=1    │      нет        │
 │10100│ 20 │ ~1226SLWL~ (~1250SL.20~)  │SLB:=SLQ      │SLQ:=0    │   RM.C:=SLB     │
 │10101│ 21 │        ~1250SL.21~  │SLB:=SLQ      │SLQ:=1    │   RM.C:=SLB     │
 │10110│ 22 │ ~1226SLWA~ (~1250SL.22~)  │SLB:=SLQ      │SLQ:=0    │      нет        │
 │10111│ 23 │        ~1250SL.23~  │SLB:=SLQ      │SLQ:=1    │      нет        │
 │11000│ 24 │        ~1250SL.24~  │SLB:=SLB      │SLQ:=SLQ  │   RM.C:=SLB     │
 │     │    │               │              │          │                 │
 │11001│ 25 │        ~1250SL.25~  │SLB:=RM.C     │SLQ:=SLB  │   RM.C:=SLB     │
 │11010│ 26 │        ~1250SL.26~  │SLB:=SLB      │SLQ:=SLB  │      нет        │
 │11011│ 27 │        ~1250SL.27~  │SLB:=RM.C     │SLQ:=0    │      нет        │
 │11100│ 28 │        ~1250SL.28~  │SLB:=SLQ      │SLQ:=RM.C │   RM.C:=SLB     │
 │11101│ 29 │        ~1250SL.29~  │SLB:=SLQ      │SLQ:=SLB  │   RM.C:=SLB     │
 │11110│ 30 │        ~1250SL.30~  │SLB:=SLQ      │SLQ:=RM.C │      нет        │
 │11111│ 31 │        ~1250SL.31~  │SLB:=SLQ      │SLQ:=SLB  │      нет        │
 └─────┴────┴───────────────┴──────────────┴──────────┴─────────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).
           При вводе новой команды задается код 00000


 ┌───────────╖
 │~0361BP2_MI¤.5-0~║  УСЛОВИЕ СТ или ЗАГРУЗКА РЕГИСТРОВ МЕТОК.
 ╘═══════════╝   ───────────────────────────────────────┘
 Назначение.
           Поле управления выхода кода условия и  загрузки  ре-
           гистров меток (разряды 5-0).Содержимое данного  поля
           может интерпритироваться различным образом:
             1)   ~0372формирование сигнала логического условия~
                  (при сигнале OECT=0);
             2)   ~0446операции загрузки регистров меток~.
                  (при сигнале OECT=1);
           ┌──────┬───┬──────┬────────────────────────────────────────┐
           │  MI  │   │мнемо-│формирование сигнала логического условия│
           │543210│dec│ ника │        (при сигнале OECT = 0 )         │
           │──────┼───┼──────┼────────────────────────────────────────┤
           │000000│ 00│      │CT:=RN.Z  or (RN.N  xor RN.V);          │
           │000001│ 01│      │CT:=not(RN.N  xor RN.V) and not(RN.Z);  │
           │000010│ 02│      │CT:=RN.N xor RN.V;                      │
           │000011│ 03│      │CT:=not(RN.N xor RN.V);                 │
           │000100│ 04│ ~1505RN_Z~ │CT:=RN.Z;                               │
           │000101│ 05│      │CT:=not(RN.Z);                          │
           │000110│ 06│ ~1505RN_V~ │CT:=RN.V;                               │
           │000111│ 07│      │CT:=not(RN.V);                          │
           │001000│ 08│      │CT:=RN.C or RN.Z;                       │
           │001001│ 09│      │CT:=not(RN.C) and not(RN.Z);            │
           │001010│ 10│ ~1505RN_C~ │CT:=RN.C;                               │
           │001011│ 11│      │CT:=not(RN.C);                          │
           │001100│ 12│      │CT:=not(RN.C) or RN.Z;                  │
           │001101│ 13│      │CT:=RN.C and not(RN.Z);                 │
           │001110│ 14│      │CT:=NO xor RM.N;                        │
           │001111│ 15│      │CT:=not(NO xor RM.N);                   │
           │010000│ 16│      │CT:=RgN.Z or (RN.N xor RN.V);           │
           │010001│ 17│      │CT:=not(RN.N xor RN.V) and not(RN.Z);   │
           │010010│ 18│      │CT:=RN.N xor RN.V;                      │
           │010011│ 19│      │CT:=not(RN.N xor RN.V);                 │
           │010100│ 20│      │CT:=RN.Z;                               │
           │010101│ 21│      │CT:=not(RN.Z);                          │
           │010110│ 22│      │CT:=RN.V;                               │
           │010111│ 23│      │CT:=not(RN.V);                          │
           │011000│ 24│      │CT:=RN.C or RN.Z;                       │
           │011001│ 25│      │CT:=not(RN.C) and not(RN.Z);            │
           │011010│ 26│      │CT:=RN.C;                               │
           │011011│ 27│      │CT:=not(RN.C);                          │
           │011100│ 28│      │CT:=not(RN.C) or RN.Z;                  │
           │011101│ 29│      │CT:=RN.C and not(RN.Z);                 │
           │011110│ 30│ ~1505RN_N~ │CT:=RN.N;                               │
           │011111│ 31│      │CT:=not(NO xor RM.N);                   │
           │100000│ 32│      │CT:=RM.Z or (RM.N xor RM.V);            │
           │100001│ 33│      │CT:=not(RM.N xor RM.V) and not(RM.Z);   │
           │100010│ 34│      │CT:=RM.N xor RM.V;                      │
           │100011│ 35│      │CT:=not(RM.N xor RM.V);                 │
           │100100│ 36│ ~1502RM_Z~ │CT:=RM.Z;                               │
           │100101│ 37│      │CT:=not(RM.Z);                          │
           │100110│ 38│ ~1502RM_V~ │CT:=RM.V;                               │
           │100111│ 39│      │CT:=not(RM.V);                          │
           │101000│ 40│      │CT:=RM.C or RM.Z;                       │
           │101001│ 41│      │CT:=not(RM.C) and not(RM.Z);            │
           │101010│ 42│ ~1502RM_C~ │CT:=RM.C;                               │
           │101011│ 43│      │CT:=not(RM.C);                          │
           │101100│ 44│      │CT:=not(RM.C) or RM.Z;                  │
           │101101│ 45│      │CT:=RM.C and not(RM.Z);                 │
           │101110│ 46│ ~1502RM_N~ │CT:=RM.N;                               │
           │101111│ 47│      │CT:=not(RM.N);                          │
           │110000│ 48│      │CT:=ZO or (NO xor VO);                  │
           │110001│ 49│      │CT:=not(NO xor VO) and not(ZO);         │
           │110010│ 40│ ~1507NXORV~│CT:=NO xor VO;                          │
           │110011│ 51│      │CT:=not(NO xor VO);                     │
           │110100│ 52│ ~1499ZO~   │CT:=ZO;                                 │
           │110101│ 53│      │CT:=not(ZO);                            │
           │110110│ 54│ ~1499VO~   │CT:=VO;                                 │
           │110111│ 55│      │CT:=not(VO);                            │
           │111000│ 56│      │CT:=CO or ZO;                           │
           │111001│ 57│ ~1510ZORC~ │CT:=not(CO) and not(ZO);                │
           │111010│ 58│ ~1499CO~   │CT:=CO;                                 │
           │111011│ 59│      │CT:=not(CO);                            │
           │111100│ 60│      │CT:=not(CO) or ZO;                      │
           │111101│ 61│      │CT:=CO and not(ZO);                     │
           │111110│ 62│ ~1499NO~   │CT:=NO;                                 │
           │111111│ 63│      │CT:=not(NO);                            │
           └──────┴───┴──────┴────────────────────────────────────────┘
 Примечание: если мнемоника не задана, то нужно применять команду FIELD.
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).
           При вводе новой команды задается код 000000
           ┌──────┬───┬─────────────────┬────────────────────────────────────────┐
           │  MI  │   │                 │   операции загрузки регистров меток    │
           │      │   │                 ├───────────────────┬────────────────────┤
           │543210│dec│   мнемоника     │ операции в RN     │  операции в RM     │
           │      │   │                 │   (при CEN=0)     │при CEM, E.C,Z,N,V=0│
           ├──────┼───┼─────────────────┼───────────────────┼────────────────────┤
           │000000│ 00│ ~1632LOAD RN,RM;~     │    RN:=RM;        │    нет загрузки    │
           │000001│ 01│ ~1632LOAD RM,NZ;~     │    RN:=1111       │    RM:=1111        │
           │      │   │ ~1632LOAD RN,NZ;~     │                   │                    │
           │000010│ 02│ ~1632LOAD RM,RN;~     │    RN <--> RM     │    RM:=RN          │
           │000011│ 03│ ~1632LOAD RM,Z;~      │    RN:=0000       │    RM:=0000        │
           │      │   │ ~1632LOAD RN,Z;~      │                   │                    │
           │000100│ 04│ ~1632LOAD RN,FLAGS;~  │    RN:=FLAGS      │ Z:=ZO N:=NO C<-->V │
           │000101│ 05│                 │    RN:=FLAGS      │    RM:=not RM      │
           │000110│ 06│ ~1632LOAD  RM,FLAGS;~  RN:=FLAGS за искл. │    RM:=FLAGS       │
           │000111│ 07│ ~1632LOAD @RN,FLAGS;~  RN.V:=RN.V xor VO  │    RM:=FLAGS       │
           │001000│ 08│ ~1632LOAD @RM,FLAGS;~ │    RN.Z:=0         RM:=FLAGS за искл.  │
           │001001│ 09│                 │    RN.Z:=1         RM.C:=not CO        │
           │001010│ 10│                 │    RN.C:=0        │    RM:=FLAGS       │
           │001011│ 11│                 │    RN.C:=1        │    RM:=FLAGS       │
           │001100│ 12│                 │    RN.N:=0        │    RM:=FLAGS       │
           │001101│ 13│                 │    RN.N:=1        │    RM:=FLAGS       │
           │001110│ 14│                 │    RN.V:=0        │    RM:=FLAGS       │
           │001111│ 15│                 │    RN.V:=1        │    RM:=FLAGS       │
           │010000│ 16│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │010001│ 17│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │010010│ 18│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │010011│ 19│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │010100│ 20│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │010101│ 21│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │010110│ 22│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │010111│ 23│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │011000│ 24│                  RN:=FLAGS за искл.  RM:=FLAGS за искл.  │
           │011001│ 25│                  RN.C:=not CO        RM.C:=not CO        │
           │011010│ 26│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │011011│ 27│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │011100│ 28│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │011101│ 29│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │011110│ 30│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │011111│ 31│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100000│ 32│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100001│ 33│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100010│ 34│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100011│ 35│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100100│ 36│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100101│ 37│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100110│ 38│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │100111│ 39│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │101000│ 40│                  RN:=FLAGS за искл.  RM:=FLAGS за искл.  │
           │101001│ 41│                  RN.C:=not CO        RM.C:=not CO        │
           │101010│ 42│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │101011│ 43│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │101100│ 44│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │101101│ 45│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │101110│ 46│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │101111│ 47│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110000│ 48│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110001│ 49│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110010│ 40│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110011│ 51│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110100│ 52│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110101│ 53│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110110│ 54│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │110111│ 55│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │111000│ 56│                  RN:=FLAGS за искл.  RM:=FLAGS за искл.  │
           │111001│ 57│                  RN.C:=not CO        RM.C:=not CO        │
           │111010│ 58│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │111011│ 59│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │111100│ 60│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │111101│ 61│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │111110│ 62│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           │111111│ 63│                 │    RN:=FLAGS      │    RM:=FLAGS       │
           └──────┴───┴─────────────────┴───────────────────┴────────────────────┘
 Примечание: если мнемоника не задана, то нужно применять команду FIELD;
             разорванные линии в таблице означают, что дана одна
             команда для двух кодов.
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (MI¤).
           При вводе новой команды задается код 000000


 ┌─────────╖
 │~0528E.C,Z,N,V~║  ПОРАЗРЯДНОЕ РАЗРЕШЕНИЕ ЗАПИСИ В РЕГИСТР RM.
 ╘═════════╝   ───────────────────────────────────────────┘
 Назначение.
           Разрешение записи меток в один из разрядов  регистра
           меток RM микросхемы ВР2. Запись осуществляется  при
           условии, что сигнал СЕМ=0
 Уровни   :  0 - Активный  (запись разрешена)
             1 - Пассивный (запись запрещена).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды поразрядная запись для всех меток разрешена.



 ┌─────────╖
 │~0543  OECT   ~║  РАЗРЕШЕНИЕ ВЫДАЧИ КОДА УСЛОВИЯ НА ВЫХОД СТ.
 ╘═════════╝   ──────────────────────────────────────────┘
 Назначение.
           Разрешение выдачи кода условия на выход CT микросхе-
           мы КМ1804ВР2. При этом формируемый сигнал на  выходе
           СТ определяется кодом в  поле  BP2_MI¤.5-0  (разряды
           5-0 кода микрокоманды микросхемы ВР2). Сигнал логи-
           ческого условия формируется при OECT=0.
 Уровень :
           0 - Активный  (формирование разрешено)
           1 - Пассивный (формирование  запрещено).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды формирование логического ус-
           ловия запрещено.

 ┌─────────╖
 │~0560 CEN,CEM ~║  РАЗРЕШЕНИЕ ЗАПИСИ МЕТОК В РЕГСТИРЫ RN/RM.
 ╘═════════╝   ──────────────────────────────────────────┘
 Назначение.
           Разрешение записи меток в регистры меток RN и RM
           микросхемы МК1804ВР2 соответственно.
 Уровень : 0 - Активный  (запись разрешена)
           1 - Пассивный (запись запрещена).
 Примечание.
           Значение вводится в двоичном кода.
           При вводе новой команды запись в регистры запрещена.

 ┌─────────╖
 │~0572   SE    ~║  РАЗРЕШЕНИЕ ВЫПОЛНЕНИЯ СДВИГА.
 ╘═════════╝   ────────────────────────────┘
 Назначение.
           Разрешение выполнения сдвига в микросхеме МК1804ВР2.
 Уровень : 0 - Активный  (сдвиг разрешен)
           1 - Пассивный (сдвиг запрещен).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды сдвиги запрещены.


 ┌─────────╖
 │~0584 MSA,MSB ~║  ВЫБОР ИСТОЧНИКОВ АДРЕСА ОПЕРАНДОВ.
 ╘═════════╝   ─────────────────────────────────┘
 Назначение.
           Выбор источника операндов в АЛУ (ПМК  или  РА). Поле
           содержит сигналы управления  мультиплексором  выбора
           источника адреса операнда для операции в АЛУ.
 Значение : 0 - Номер регистра микросхемы КМ1804ВС1  извлекает-
                ся  из  ПМК;
            1 - Номер регистра микросхемы КМ1804ВС1  извлекает-
                ся из внешнего регистра.
 Примечание.
           Значения вводятся в двоичном коде.
           При вводе новой команды мультиплексор выбирает номер регистра из
           памяти микрокоманд.


 ┌─────────╖
 │~0601  EWA,EWB~║  ЗАПИСЬ ИНФОРМАЦИИ В РЕГИСТРЫ ВЫБОРА ОПЕРАНДОВ АЛУ.
 ╘═════════╝   ─────────────────────────────────────────────────┘
 Назначение.
           Сигнал низкого уровня обеспечивает  запись  информа-
           ции c системной шины данных в  4-разрядные  регистры
           (RA,RB) выбора операнда АЛУ.  Номера  разрядов  шины
           данных используемых для загрузки  регистров  опреде-
           ляются при настройке системы.
 Уровень : 0 - Активный  (запись);
           1 - Пассивный (хранение).
 Примечание.
           Значения вводятся в двоичном коде.
           При вводе новой команды запись в регистры запрещена.








      ┌───────────────────────────────────────────────────╖
      │~0623  3. ПОЛЕ БМУ (блок микропрограммного управления). ~║
      ╘═══════════════════════════════════════════════════╝

 Блок микропрограммного  управления  построен  с  использованием
 микросхемы  КМ1804ВУ4,  которая  предназначена  для  управления
 последовательностью  выборки микрокоманд из памяти  микрокоманд
 (ПМК).Микросхема обеспечивает формирование 12-разрядного адреса
 микрокоманды, т.е.  обьем ПМК может составлять 4096 слов.  Каж-
 дая микрокоманда, хранящаяся в ПМК содержит поля,  управляющие
 микросхемой КМ1804ВУ4 и обрамляющим оборудованием.

 Включает:
           Микросхема ВУ4:
           ~0646BУ4_MI¤~ - Микрокоманда;
           ~0689CCE~     - Разрешение анализа условия;
           ~0701COM~     - Инвертирование входа условия;
           ~0713CI~      - Формирование адреса следующей микрокоманды;
           ~0730RLD~     - Безусловная загрузка регистра адреса/счетчика;

           ~0743MS~      - Мультиплексор выбора сигнала условия.


 ┌───────────╖
 │~0646BУ4_MI¤.4-0~║  МИКРОКОМАНДА МИКРОСХЕМ КМ1804ВУ4.
 ╘═══════════╝   ────────────────────────────────┘
 Назначение.
           Поле микрокоманды микросхемы ВУ4 (блок микропрограм-
           много управления). Соответствие между  кодом  опера-
           ции и выполняемой функцией приведено в таблице.
 ┌────┬─────────────────┬───────────────────────────────────────────────┐
 │ MI │                 │                                               │
 │3210│   Мнемоника     │      микрокоманда выполняемая на ВУ4          │
 ├────┼─────────────────┼───────────────────────────────────────────────┤
 │0000│ ~1354JZ;~             │переход к нулевому адресу                      │
 │0001│ ~1358CJS Cond,Addr;~  │условный переход к подпрограмме по  адресу из  │
 │    │                 │регистра микрокоманд                           │
 │0010│ ~1365JMAP Addr;~      │переход к адресу из дешифратора команд         │
 │0011│ ~1371CJP Cond,Addr;~  │условный переход к адресу из регистра микроко- │
 │    │                 │манд                                           │
 │0100│ ~1377PUSH Cond,Val;~  │запись в стек и условная запись в регистр адре-│
 │    │                 │са                                             │
 │0101│ ~1390JSRP Cond,Addr;~ │переход к одной из двух подпрограмм: по адресу │
 │    │                 │либо из РА, либо из регистра микрокоманд       │
 │0110│ ~1399CJV Cond;~       │условный переход к адресу из внешнего источника│
 │0111│ ~1406JRP Cond,Addr;~  │переход к адресу, условно выбираемому либо из  │
 │    │                 │ РА,  либо из регистра микрокоманд             │
 │1000│ ~1410RFCT;~           │повтореное цикла, если счетчик РА <> 0         │
 │1001│ ~1424RPCT Addr;~      │повтореное адреса из регистра микрокоманд, если│
 │    │                 │счетчик РА <> 0                                │
 │1010│ ~1433CRTN Cond;~      │условный возврат из подпрограммы               │
 │1011│ ~1440CJPP Cond,Addr;~ │условный переход к адресу из регистра микроко- │
 │    │                 │манд и считывание из стека                     │
 │1100│ ~1454LDCT Val;~       │запись в РА                                    │
 │1101│ ~1459LOOP Cond;~      │условное прекращение цикла                     │
 │1110│ ~1470CONT;~           │продолжение работы                             │
 │1111│ ~1473TWB Cond,Addr;~  │ветвление на три направления                   │
 └────┴─────────────────┴───────────────────────────────────────────────┘
 где Cond      - проверяемое условие;
     Addr, Val - численные значения адреса перехода и загрузки РА.
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (MI¤).
           При вводе новой команды задается код 1110 (CONT).


 ┌────────╖
 │~0689  CCE   ~║  РАЗРЕШЕНИЕ АНАЛИЗА СИГНАЛА УСЛОВИЯ.
 ╘════════╝   ──────────────────────────────────┘
 Назначение.
           Разрешение анализа сигнала условия.
 Уровень:  1 - Пасивный (анализ запрещен)
           0 - Aктивный (анализ разрешен).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды анализ условия запрещен.


 ┌─────────╖
 │~0701  COM    ~║  ИНВЕРТИРОВАНИЕ ВХОДНОГО УСЛОВИЯ.
 ╘═════════╝   ───────────────────────────────┘
 Назначение.
           Инвертирование входного условия. Обеспечивает инвер-
           тирование анализируемого в БМУ сигнала.
 Уровень : 0 - Пасивный (инвертирование запрещено)
           1 - Aктивный (инвертирование разрешено).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды входное условие не инвертируется.

 ┌─────────╖
 │~0713   CI    ~║  СИГНАЛ ВЫЧИСЛЕНИЯ АДРЕСА СЛЕДУЮЩЕЙ МК.
 ╘═════════╝   ─────────────────────────────────────┘
 Назначение.
            Формирование адреса следующей микрокоманды. В  каж-
            дом такте к выходному адресу прибавляется  значение
            сигнала на входе СI, что обеспечивает  автоматичес-
            кое вычисление адреса следующей микрокоманды.
 Уровень : 0 - Пасивный (не формируется адрес следующей  микро-
               команды);
           1 - Aктивный (формируется адрес  следующей  микроко-
               манды);
 Примечание.
            Значение вводится в двоичном коде.
            При вводе новой команды инкремент регистра задан.


 ┌─────────╖
 │~0730   RLD   ~║  БЕЗУСЛОВНАЯ ЗАГРУЗКА РА/Сч.
 ╘═════════╝   ──────────────────────────┘
 Назначение.
           Безусловная загрузка регистра адреса/счетчика значе-
           ние с шины адреса ветвления.
 Уровень : 0 - Активный  (загрузка разрешена)
           1 - Пассивный (загрузка запрещена).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды запись в регистр адреса запрещена.


 ┌─────────╖
 │~0743   MS    ~║  МУЛЬТИПЛЕКСОР УСЛОВИЙ.
 ╘═════════╝   ─────────────────────┘
 Назначение.
           Мультиплексор выбора сигнала условия. Этот сигнал (от
           0 до 7) обеспечивае подачу на вход логического усло-
           вия одного из 8 сигналов,  настройка  которых  выпол-
           няется при комутации связей.
                ┌────────┬────────┐
                │управле-│  выход │
                │  ние   │   MS   │
                ├────────┼────────┤
                │   000  │  Z     │
                │001..110│ L1..L6 │
                │   111  │  NZ    │
                └────────┴────────┘
 Примечание.
           Ко входам с 1 по 6 возможно подлючение любых сигналов,
           предусмотренных в настройке.
           При вводе новой команды код выбора входа MS задан 000.






       ┌─────────────────────────────────────────────╖
       │~0769 4. ПОЛЕ БПП (болк приоритетных прерываний). ~║
       ╘═════════════════════════════════════════════╝

 Микросхема  КМ1804ВН1 - это  8-разрядная  микропрограммируемая
 наращиваемая схема векторного приоритетного прерывания,  кото-
 рая производит приоритетную обработку запросов на  прерывания,
 поступающих по восьми шинам от различных устройств. Ниже  при-
 ведены поля, обеспечивающие управление работой БПП:

 Включает:
           Микросхема КМ1804ВН1:
           ~0787BН1_MI¤~ - Микрокоманда;
           ~0823EINS~    - Разрешение приема инструкции;
           ~0836EV~      - Разрешение выдачи константы  ПЗУ  векторов
                     на ШД.


 ┌─────────╖
 │~0787 BH1_MI¤ ~║  МИКРОКОМАНДА МИКРОСХЕМЫ КМ1804ВН1.
 ╘═════════╝   ─────────────────────────────────┘
 Назначение.
           Поле микрокоманды микросхемы КМ1804ВН1 (блок приори-
           тетных прерываний). Соответствие между кодом  опера-
           ции и выполняемой функцией приведено в таблице.
           ┌────┬─────────────┬─────────────────────────────────┐
           │ MI │             │микрокоманда, выполняемая на ВН1 │
           │3210│  мнемоника  │   (при сигнале EINS = 0 )       │
           ├────┼─────────────┼─────────────────────────────────┤
           │0000│ ~1533RESET;~      │общая очистка                    │
           │0001│ ~1546RESET IR;~   │очистка IR                       │
           │0010│ ~1548CLR IR,Val;~ │очистка IR сигналами с шины маски│
           │0011│ ~1548CLR IR,MR;~  │очистка IR под управлением MR    │
           │0100│ ~1548CLR IR,VR;~  │очистка IR под управлением VR    │
           │0101│ ~1572READ VR;~    │чтение VR                        │
           │0110│ ~1572READ SR;~    │чтение SR                        │
           │0111│ ~1572READ MR;~    │чтение MR                        │
           │1000│             │установка MR                     │
           │1001│ ~1658LOAD SR,Val;~│загрузка SR                      │
           │1010│ ~1548CLR MR,Val;~ │поразрядная очистка MR           │
           │1011│ ~1565SET MR,Val;~ │поразрядная установка MR         │
           │1100│ ~1542RESET MR;~   │очистка MR                       │
           │1101│ ~1585DI;~         │запрет запроса прерывания        │
           │1110│ ~1658LOAD MR,Val;~│загрузка MR                      │
           │1111│ ~1588EI;~         │разрешение запроса прерывания    │
           └────┴─────────────┴─────────────────────────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤). При  вводе
           новой команды в это поле  записывается  код  команды
           общая очистка, но при этом сигнал EINS=1, что приво-
           дит к тому, что инструкция не выполняется.


 ┌─────────╖
 │~0823  EINS   ~║  РАЗРЕШЕНИЕ ПРИЕМА ИНСТРУКЦИИ.
 ╘═════════╝   ────────────────────────────┘
 Назначение.
           Разрешение приема инструкции. Обеспечивает  прием  к
           выполнению инструкции заданной в поле ВН1_IM¤.
 Уровень : 1 - Пасивный (микрокоманда на ВН1 не выполняется);
           0 - Aктивный (микрокоманда на ВН1 выполняется).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды подача кода команды на м/с
           КМ1804ВН1 запрещена.

 ┌─────────╖
 │~0836   EV    ~║  РАЗРЕШЕНИЕ ВЫДАЧИ КОНСТАНТЫ ИЗ ПЗУ ВЕКТОРОВ.
 ╘═════════╝   ───────────────────────────────────────────┘
 Назначение.
           Активный уровень сигнала обеспечивает выдачу  16-раз-
           рядной константы из 8-адресного ПЗУ векторов на сис-
           темную шину данных. Адресом для ПЗУ является  3-раз-
           рядный вектор, выдаваем КПП  (контроллер  приоритет-
           ных прерываний). Значения констант, хранимых в  ПЗУ,
           заносятся при настройке системы.

 Уровень : 1 - Пасивный (константа не выдается, т.к. выходы ПЗУ
               находятся в третьем  состоянии);
           0 - Aктивный (выдача константы).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды выдача константы запрещена.





               ┌───────────────────────────────╖
               │~0858  5. Поле управляющих сигналов.~║
               ╘═══════════════════════════════╝
 Включает:
           I   - сигнал чтения с внешнего устройства;
           O   - сигнал записи на внешнее устройство;
           LCK - LOCK - сигнал фиксации состояни дейзи-цепочки
                 (используется перед считываем вектора);
           IA  - INTA - сигнал подтверждения прерывания для 
                 устройств в дейзи-цепочке и для чтения на ШД
                 вектора прерывания;
           R   - сигнал чтения из памяти;
           W   - сигнал записи в память;
           EWH - сигнал записи в старшие разряды регистра адреса;
           EWL - сигнал записи в младшие разряды регистра адреса.











                           ╔═══════════════╗
                           ║~0879C O M A N D O R~║
                           ╚═══════════════╝

   Мнемонический двухпроходный ассемблер учебной системы "COMPLEX"
   ═══════════════════════════════════════════════════════════════

                               ОПИСАНИЕ
                               ════════

                              Содержание
                              ══════════

  - ~0915Предисловие~.
1.  ~0928Исходный файл~.
2.  ~0982Числовые константы~.
3.  ~1014Метки~.
4.  ~1045Комментарии~.
5.  ~1068Структура задания микрокоманды~.
6.  ~1098Арифметико-логические команды~.
7.  ~1294Команды передачи управления~.
8.  ~1523Команды обработки прерываний~.
9.  ~1613Команда загрузки регистров LOAD~.
10. ~1674Команда задания поля микрокоманды  FIELD~.
11. ~1754Служебные  команды~.
12. ~1803Директивы ассемблера~.
 Приложение 1:
  - ~2062Таблица зарезервированных мнемоник~.
 Приложение 2:
  - ~2128Сообщения об ошибках~.
 Приложение 3:
  - ~2168Задание микрокоманды по умолчанию~.
 Приложение 4:
  - ~2225Пример написания программы~.


                           ~0915Предисловие.~
                           ════════════

   Мнемонический двухпроходный ассемблер "COMANDOR"  предназначен  для
облегчения кропотливого труда программиста  по  написанию  микрокоманд
микропроцессорной системы "COMPLEX", отладке и выполнению программ  на
программном эмуляторе и быстрому внесению изменений в исходный текст.
  Результатом работы  ассемблера  по  трансляции  исходного текстового
файла является файл данных с расширением  '.pmk',  являющийся  в  свою
очередь  исходным  для программного эмулятора микропроцессорного комп-
лекса.


                           ~09281. Исходный файл.~
                           ═════════════════

   В качестве исходного файла для трансляции берется обычный текстовый
файл, для которого справедливы следующие нормы написания:

    1) все  цельные  мнемоники должны писаться слитно,  различия между
       заглавными и строчными буквами алфавита  ассемблер  не  делает,
       поэтому мнемоники

               'ADD' 'AdD' 'ADd' 'Add' 'aDD'

       являются идентичными и ассемблером не различаются;

    2) между отдельными мнемониками,  цифровыми константами,  метками,
       соответствиями и комментариями может быть сколько угодно незна-
       чащих символов и управляющих знаков,  таких как пробел, табуля-
       ция,  возврат каретки, перевод строки и т.п., никаких ограниче-
       ний на размещение команд по тексту не налагается; это позволяет
       программисту достаточно свободно относиться к тексту пограммы с
       точки зрения ее внешнего вида;

    3) следует  обратить внимание на то,что хотя ассемблер и поддержи-
       вает верхнюю часть таблицы символов ASCII,  в  которую  включен
       национальный алфавит, но все стандартные мнемоники, приведенные
       в приложении 1 - таблице зарезервированных мнемоник  оттрансли-
       рованы для латинского алфавита, и поэтому следует аккуратно от-
       носиться к набивке мнемоник,  имеющих в своем составе  символы,
       одинаково пишущиеся, но имеющие разную кодировку. Данное прави-
       ло однако не означает,  что программист должен вообще  избегать
       национального алфавита, кроме как для написания поясняющих ком-
       ментариев,  что приходится сплошь и рядом видеть в таких языках
       программирования,  которые были изначально ориентированы только
       на англоязычного пользователя.  С  помощью  структуры  меток  и
       соответствий  пользователь может в любом месте своего исходного
       файла задать понятное для него обозначение и использовать его в
       дальнейшем  на  равне со стандартной мнемоникой языка.  Поэтому
       такая, например, команда, как

                       Сложить операнд1,  операнд2;

       не будет содержать никаких ошибок и будет правильно  оттрансли-
       рована при том, конечно, условии, что все приведенные в  приме-
       ре мнемоники  будут  заранее  соответсвующим  образом  описаны.

    4) основной файл должен  заканчиваться  командой  микропроцессора,
       заключенной в кавычки.

  Строгое придерживание правил написания команд, аккуратность в  набо-
ре текста программы будут гарантировать быструю трансляцию и отладку -
практика свидетельствует, что большинство ошибок возникает прежде все-
го из-за небрежного стиля написания и неточного знания самого  объекта
разработки.

                         ~09822. Числовые константы.~
                         ══════════════════════

   Числовые константы применяются при задании числовых операндов,  ад-
ресов переходов и загрузочных констант. Признаком  константы  является
цифра в начале мнемоники. "COMANDOR" различает четыре  основные  формы
задания чисел:

    1) десятичная форма:
       10
       0
       65535

    2) шестнадцатиричная форма:
       0Ah
       15H
       0FFFFh

    3) восьмеричная форма:
       7o
       177777o

    4) двоичная форма:
       011%
       1111111111111111%

   Все константы не должны превышать размера машинного слова.

   Кроме непосредственного задания константы в команде Вы можете  сос-
латься на текущий Указатель Команды СР. Ассемблер трансформирует его в
текущее численное значение Указателя Команды.

                               ~10143. Метки.~
                               ═════════

   Метки служат для замены часто  используемых  констант  на  символи-
ческий  эквивалент  с  целью повышения читабельности исходного текста.

Основные правила написания меток:

    1) символы, которые не могу входить в состав метки:
                   # $ ( ) * + , - . / [ \ ] { | }

    2) метка не может начинаться начинаться с цифры;

    3) признаком конца метки является любой знак  пунктуации,  пробел,
       знак табуляции, конец строки, а также любой из символов,  пере-
       численных в правиле 1;

    4) метка не должна совпадать с зарезервированной мнемоникой
       (смотри приложение 1 - таблица зарезервированных мнемоник);

    5) длина метки при задании может быть произвольной,  но ассеммблер
       распознает только первые десять символов; поэтому при использо-
       вании  меток  длиной более десяти символов при трансляции могут
       возникать ошибки;

  Примеры написания меток: - Loop
                           - First_go
                           - Метка_1
                           - Слишком_длинная_метка_и_поэтому_неверная


                           ~10454. Комментарии.~
                           ═══════════════

   Комментарии используются для пояснения работы той или иной команды,
либо всей программы в целом, а также для "закомментирования" какой-ли-
бо проверочной команды.
  Признаком начала комментария служит символ

                             '\'.

  Ассемблер  игнорирует все встречающиеся символы до следующего симво-
ла '\' либо до  конца строки. Например:

     \ краткий пример программы \
     { add RB,X,Z;  }      \ записываем X в R10
     { add R11,Y,Z; }      \ записываем Y в R11
     { add RQ,R10,Z;       \ переписываем X в RQ
       cjp l1,compute; }   \ если число положительное то переходим на
                           \ вычисление
     { sub RQ,Z,RQ;  }     \ иначе   приводим  X  к  положительному
     { sub R11,Z,R11; }    \ преобразуем Y для правильного знака


                ~10685. Структура задания микрокоманды.~
                ══════════════════════════════════

   Память микрокоманд микропроцессорного комплекса содержит  отдельные
микрокоманды, каждая из которых делится в свою очередь на поля. Коман-
да ассемблера модифицирует то или иное поле микрокоманды. Вся микроко-
манда задается оператором задания микрокоманды, который описывается  с
помощью пары фигурных скобок
                              {}
   Таким образом совокупность команд ассемблера,  ограниченная  внутри
'{}' представляет из себя одну  микрокоманду  микропроцессорного  ком-
плекса. Внутри скобок может содержаться любое количество команд ассем-
блера, либо ни одной. Так что даже при задании пустой микрокоманды  вы
определялете определенные действия, производимые внутри эмулятора мик-
ропроцессора. Обычно  -  это  "пустые"  действия,  то  есть  действия,
реально соответствующие команде NOP, если бы она существовала.
   Ниже приведены основные правила написания команд на языке ассембле-
ра "COMANDOR":

    1) все  команды ассемблера должны помещаться внутри операторов за-
       дания микрокоманды '{}';

    2) команда всегда начинается с имени команды, которое является за-
       резервированной мнемоникой;

    3) операнды разделяются между собой оператором разделения операндов
        ',';

    4) команда должна заканчиваться оператором конца команды ';';

                     ~10986. Арифметико-логические команды.~
                     ═════════════════════════════════

   Арифметико-логические команды  служат  для выполнения микроопераций
сложения, вычитания, поразрядных логических операций, операций сдвига,
загрузки,  инвентирования  отдельных  регистров Арифметико Логического
Блока, построенного на четырех микросхемах ВС1 и одной м/с ВР2.
  Всего есть 7 команд,  форматы  которых  будут  рассмотрены в данном
разделе:

    1)ADD  - арифметическое сложение;
    2)SUB  - арифметическое вычитание;
    3)OR   - логическое сложение;
    4)AND  - логическое умножение;
    5)XOR  - логическое вычитание(исключающее "ИЛИ");
    6)NAND - логическое умножение при котором первый операнд берется с
             инверсией;
    7)NXOR - логическое вычитание при котором результат инвертируется;

   Далее будут рассмотрены:

    6.1. ~1124Задание сдвигов регистров~.
    6.2. ~1143Задание приемника результата~.
    6.3. ~1178Задание операндов, над которыми выполняется операция~.
    6.4. ~1261Задание входного переноса~.

                     ~11246.1. Приемник результата.~
                     ─────────────────────────

  В качестве приемника результата могут выступать следующие операнды:

    1) RQ - рабочий регистр АЛБ;

    2) R0..R15 - один из регистров общего назначения;

    3) RB - РОН, номер которого определен в RB;

    4) NIL - пустой приемник (результат не сохраняется, но может выда-
             ваться на ШД, а также могут использоваться флажки,  уста-
             новленные при выполнении операции).

  Задание RB подразумевает использование РОНа, номер которого  хранит-
ся в вынесенном регистре RB.


         ~11436.2. Операнды, над которыми выполняется операция.~
         ─────────────────────────────────────────────────

   Любая из семи вышеперечисленных  команд  позволяет  выполнять  дей-
ствия над двумя операндами и помещать результат операции в регистр,  в
общем случае не совпадающий с операндами, над которыми операция выпол-
нялась. Например,

                       ADD RQ,R1,R2;

   Но зачастую  приемник результата  одновременно  является и одним из
рабочих операндов. Тогда можно опускать написание этого операнда дваж-
ды, и ассемблер сам возьмет на себя задачу доопределения операндов ко-
манды. Например:

                       SUB  RQ,1;

  Вот возможные операнды, которые можно указывать при задании команды:

    1) Z - "внутренний" нуль,  специально реализованный в м/с ВС1  для
           того, чтобы не загружать лишний раз шину данных тривиальной
           информацией;

    2) RQ - рабочий регистр АЛБ;

    3) R0..R15 - один из регистров общего назначения;

    4) RA,RB - РОН, номер которого определен в RA или RB;

    5) числовая константа;

    6) BUS_D - запись такого операнда говорит о том, что операнд будет
               считан  с  шины  данных.


                      ~11786.3. Задание сдвигов регистров.~
                      ───────────────────────────────

   6.3.1. ~1206Структурная схема выполнения сдвига на АЛБ~.
   6.3.2. ~1226Стандартные типы сдвигов~.
   6.3.3. ~1250Общие типы сдвигов~.

   Арифметико-логический блок,  на  котором  построено  АЛУ  микропро-
цессорного комплекса имеет в качестве одной из своих  функций  возмож-
ность одновременно с выполнением одной из арифметико-логических опера-
ций производить сдвиг регистра-приемника. Управление типом сдвига осу-
ществляется микрокомандой,  поступающей на входы MI(10-6) м/с ВР2. Сам
сдвиг задается микрокомандой MI(8) м/с ВС1.  При этом  можно  осущест-
влять и одновременный сдвиг рабочего регистра RQ. Для этого необходимо
перед операндом сдвига поставить оператор модификации

                                 "@"

который и указывает ассемблеру, что производится  одновременный  сдвиг
регистра-приемника и рабочего регистра RQ. Например:

                           ADD @SRA,R4,123H;

  Ассемблер позволяет определять любой из возможных типов сдвига, не-
посредствнно задавая его,  либо используя один из стандартных сдвигов.
Ниже приведены все возможные виды сдвигов и операнды,  с помощью кото-
рых их можно задавать.

             ~12066.3.1. Структурная схема выполнения сдвига на АЛБ.~
             ──────────────────────────────────────────────────
               ───────────┐            ┌────────────────────────
               ВР2        │            │                 4 x ВС1
               ═══    SLQ │<---------->│ RQ.0╟─────────────┐ ═══
                          │            │                   │
                          │            │                   │
                          │            │       ┌┬───────┬┐ │
                      SRQ │<---------->│RQ.15╟─┤│   RQ  │├─┘
                          │            │       └┴───────┴┘
                          │            │
                          │            │       ┌┬───────┬┐
                      SRB │<---------->│RB.15╟─┤│ РОН[B]│├─┐
                          │            │       └┴───────┴┘ │
                          │            │                   │
                          │            │                   │
                      SLB │<---------->│ RB.0╟─────────────┘
                          │            │


                 ~12266.3.2. Стандартные типы сдвигов.~
                 ────────────────────────────────

        │        логический       │        арифметический
        │                         │
        │          SRL            │              SRA
        │                         │  NO xor VO
        │     ┌┬───────┬┐  ┌──┐   │      │  ┌─┬───────┬┐
вправо  │  0─>││ РОН[B]││->│MC│   │      └─>│ │ РОН[B]││
        │     └┴───────┴┘  └──┘   │         └─┴───────┴┘
        │                         │
        │          SLL            │              SLA
        │                         │
        │  ┌──┐  ┌┬───────┬┐      │          ┌─┬───────┬┐
 влево  │  │MC│<-││ РОН[B]││<─ 0  │          │ │ РОН[B]││<── 0
        │  └──┘  └┴───────┴┘      │          └─┴───────┴┘

  При задании двойного стандартного сдвига необходимо писать соответст-
венно SRWL SLWL SRWA SLWA.

Например:       ADD SRA,R4,0;
                XOR SLWL,RQ,1010101010101010%;


                   ~12506.3.3. Общие типы сдвигов.~
                   ──────────────────────────
  Задаются типом сдига (SR - правый сдвиг, SL - левый сдвиг)  и  видом
сдвига. Вид сдвига задается его номером  (см. таблицу для BP2_MI.A-6),
указанным через точку непосредственно за типом сдвига, анпример:
                ADD SR.3, R0, R5, R3;
                XOR SL.18, R0, 10;
  Обратите внимание на то, что вид правых сдвигов (SR) задается  номе-
ром от 0 до 15, а вид левых сдвигов (SL) номером от 16 до 31.


                   ~12616.4. Входной перенос.~
                   ─────────────────────

   Входной перенос задается в командах первой подгруппы (ADD  и  SUB).
Этот  операнд  является необязательным и по умолчанию считается равным
нулю.  В случае явного задания переноса его необходимо указывать в ка-
честве  последнего операнда команды.  Задание операнда переноса влияет
на поле MI(5-0) блока управления сдвигами м/с ВР2 микрокоманды.  Здесь
следует  учитывать,  что  это же поле отвечает и за загрузку регистров
меток RM и RN м/с ВР2;  поэтому  будьте  аккуратны  в  одновременном
использовании команд арифметического сложения(вычитания) и команд заг-
рузки регистров меток,  так как может произойти добавление нежелатель-
ного входного переноса,  что исказит результат.  Транслятор ассемблера
контроля совместимости команд не ведет и ошибок при вышеуказанном слу-
чае выдавать не будет.

  Существуют следующие возможные сигналы входного переноса:

    1) Z - сигнал логического нуля;

    2) RM_C - бит С регистра метки RM;

    3) RN_C - бит С регистра метки RN.

  Можно  задавать  инверсию этих сигналов  с помощью  предшевствующего
оператора инверсии "NOT".
    Примеры:
                          ADD R1,RQ,R5,RM_C;
                          SUB  RQ,R4,not  Z;
                          ADD @SRA,R5,10,not RN_C;

  Использование операнда переноса требует полного задания команды.

                     ~12947. Команды передачи управления.~
                     ═══════════════════════════════

   Команды данной группы обрабатывают поле микрокоманды м/с ВУ4, кото-
рая является схемой управления 12-ти разрядным адресом  микрокоманд  и
выполняет 16 микрокоманд.

    7.1. ~1305Выбор адреса перехода~.
    7.2. ~1344Описание команд передачи управления~.
    7.3. ~1485Операнды задания условия~.

                    ~13057.1. Выбор адреса перехода.~
                    ───────────────────────────

   Многие команды ВУ4 выполняют модификацию счетчика микрокоманд,  вы-
полняя тем самым переход на новую микрокоманду, не находящуюся в памя-
ти микрокоманд непосредственно за выполняемой.  Другие  команды  могут
выполнять модификацию регистра адреса. Все адреса  и  данные  загрузки
поступают на ВУ4 с Шины Адреса Перехода (ШАВ).  На  ШАВ  данные  могут
поступать с трех буферов:
  - буфер V;
  - буфер M;
  - буфер P.
   Как видно из ниже приведенной схемы, каждый из этих буферов  комму-
тируется с различными источниками данных:
  - буфер V пересылает на ШАВ данные с ПЗУ векторов переходов м/с ВН1;
  - буфер M коммутирует ШАВ и Шину Данных (смотри директиву LINK M);
  - буфер Р пересылает на ШАВ данные с ПЗУ микрокоманд (смотри поле D);

          ~13237.1.1. Структурная схема выбора адреса перехода.~
          ────────────────────────────────────────────────
     ┌─────────┐
     │ ПЗУ ВП  │
     └────┬────┘
         ┌┘
 ════════╪═════════════╤════════════════════════════════╤══ BUS_D (16)
         └┐            │                                │
     ┌────┴────┐  ┌────┴────┐                      ┌────┴────┐
   ┌─o Буфер V │┌─o Буфер M │                    ┌─o Буфер K │
   │ └────┬────┘│ └────┬────┘                   OED└────┬────┘
   VE     │     ME     │                                │
   ═══════╧══════════╤═╧══════════════════╤═══ ШАВ(12)  │
                     │                    │             /16
   ┌─────────────────┴──────────┐    ┌────┴────┐        │
   │                        ВУ4 │  ┌─o Буфер P │        │
   │                            │  │ └────┬────┘  12    │
                                   PE     └───────/─────┤
                                                        │
                                              поле D ПЗУ│

               ~13447.2. Описание команд передачи управления.~
               ─────────────────────────────────────────

   Если при заданиии команды требуется указать условие ее  выполнения,
то оно ставится после мнемоники команды в качестве  первого  операнда;
если к тому же требуется указать и  непосредственный  адрес  перехода,
либо (для команды LDCT) задать новое значение регистра адреса  РА,  то
численное значение (метка) оперирует в команде в качестве второго опе-
ранда:

    1) JZ - переход к нулевому адресу;

              JZ;  \ безусловный переход  на нулевой адрес

    2) CJS - условный переход к подпрограмме по указанному адресу;
             адрес перехода поступает на ШАВ через буфер Р;

             CJS CT, START; \ если условие CT выполняется,
                            \ то перейти  на  подпрограмму по адресу
                            \ START, иначе продолжить вычисления

    3) JMAP - безусловный переход по указанному адресу,находящемуся на
              шине данных;
              адрес перехода поступает на ШАВ через буфер М;

              JMAP 100;  \ перейти на адрес 100

    4) CJP  - условный переход по указанному адресу;
              адрес перехода поступает на ШАВ через буфер Р;

              CJP not RDM, CP; \ ждем, пока память не выдаст сиг-
                               \ нал готовности

    5) PUSH - загрузка в стек счетчика микрокоманд,  и плюс к этому по
              выполнению указанного условия выполнение LDCT;
              значение загружаемого счетчика микрокоманд поступает на
              ШАВ через буфер М;

                   PUSH not CT, 10; \ запоминаем в стеке адрес следую-
                                    \ щей команды и загружаем в РА 10,
                                    \ если условие CT не выполняется;

              возможна безоперандная форма записи  команды  PUSH;  при
              этом условие принимается ложным и,  следовательно,  заг-
              рузки в РА не происходит.

    6) JSRP - переход к  одной из двух подпрограмм по адресу,  взятому
              либо из регистра адреса (если условие не выполнено), ли-
              бо по указанному адресу;
              адрес перехода поступает на ШАВ через буфер P;

                   JSRP IRQ0,53O;\ если условие выполняется, то перехо-
                                 \ дим на выполнение команды по адресу
                                 \ 43 (53o = 43), иначе

    7) CJV - условный переход по адресу из внешнего источника;
             адрес перехода поступает на ШАВ через буфер V;

                   CJV CT;\ если условие выполняется, то с ШАВ
                          \ считывается адрес следующей микрокоманды
                          \ попадающий туда из буфера V

    8) JRP  - аналогична команде JSRP, но без загрузки в стек адреса
              возврата;
              адрес перехода поступает на ШАВ через буфер P;

    9) RFCT - повторение цикла до тех пор,  пока не равен нулю регистр
              адреса (сравнение РА с нулем,  и если нет, то переход по
              адресу,  хранящемуся  на  вершине  стека с одновременным
              декрементированием РА);

                   PUSH NZ,10; \ запоминаем на вершине стека адрес на-
                               \ чала цикла с одновременной загрузкой в
                               \ РА числа проходов (РА выполняет роль
                               \ счетчика цикла)
                   ....

                   RFCT;       \ декрементируем РА, и пока не нуль пе-
                               \ реходим на начало цикла

   10) RPCT - повторение цикла до тех пор,  пока не равен нулю регистр
              адреса (сравнение РА с нулем,  и если нет, то переход по
              адресу, хранящемуся в памяти микрокоманд с одновременным
              декрементированием РА);
              адрес перехода поступает на ШАВ через буфер P;

                  RPCT петля; \ сравниваем РА с нулем и если РА <> 0,
                              \ то переходим на "петлю"

   11) CRTN - условный возврат из подпрограммы;

                  CRTN not NXORV; \ проверяем признак переполнения в
                                  \ системе с расширенной знаковой
                                  \ сеткой, и если переполнения нет -
                                  \ - возвращаемся из подпрограммы

   12) CJPP  -  условный  переход по указанному адресу и одновременное
                декрементирование указателя стека;
                адрес перехода поступает на ШАВ через буфер P;

                PUSH NZ,10;

                  .....

                  CJPP RM_C,NEXT; \ проверяем метку С регистра меток
                                  \ RM и по 1 выходим из цикла
                  ......

                  RFCT;

   13) LDCT - запись в регистр адреса РА;
              новое значение РА поступает на ШАВ через буфер Р;

                  LDCT value;  \ загружаем РА значением value

   14) LOOP - условное прекращение цикла (если условие  в  команде  не
              выполняется,  то адрес следующей микрокоманды выбирается
              с вершины стека, иначе выполняется следующая команда);

                  PUSH; \ запоминаем адрес начала цикла

                  ......

                  LOOP not CT; \ если на входе CT - 0, то возвращаемся
                               \ на начало цикла

   15) CONT  -  переход к выполнению следующей команды (выполняется по
              умолчанию);

   16) TWB  - условное ветвление по трем направлениям (РА сравнивается
              с нулем:  если не равен,  то РА декрементируется и далее
              выполняется LOOP,  иначе тот же LOOP,  но с выборкой ад-
              реса не из стека, а из памяти микрокоманд через буфер Р).

                  PUSH NZ,10;

                  .......

                  TWB NZ,NEXT; \ пока РА<>0 возвращаемя на начало цик-
                               \ ла; при РА=0 переходим на NEXT

                   ~14857.3. Операнды задания условия.~
                   ──────────────────────────────

   Операнды задания  условия  применяются  в таких командах,  как CJS,
CJP,  PUSH, JSRP, CJV, JRP, CRTN, CJPP, LOOP и TWB. Сигнал условия по-
дается  на вход ЛУ блока микропрограммного управления через восьмивхо-
довой мультиплексор MS,  два входа которого заранее предопределены как
Z и NZ (0 и 1), а остальные шесть входов могут коммутироваться различ-
ными сигналами (см.  задание коммутации условий при  помощи  директивы
LINK).  В команде при задании операнда условий можно использовать сле-
дующие предопределенные мнемоники:

    1)Z, NZ - условие определяется как заведомо ложное (истинное);

    2)ZO, CO, NO, VO  - признаки нуля,  переноса, знака и переполнения
                        по результату выполнения операци в АЛУ;

    3)RM_Z,RM_C,RM_N,RM_V - флажки Z, C, N и V,  хранящиеся в регистре
                            меток RM;

    4)RN_Z,RN_C,RN_N,RN_V - аналогично для RN;

    5)NXORV - признак переполнения для системы с двумя знаковыми раз-
              рядами;

    6)ZORC - условие устанавливается истинным при установлении  в  ре-
             зультате  операции  в  АЛБ  флажка нуля либо переполнения
             (ZORC = Z or C).

    7)L1,L2,L3,L4,L5,L6 - непосредственное задание номера входа  муль-
             типлексора условий, с которого будет считан  сигнал усло-
             вия. при этом не осуществляется установка самого сигнала.

  Ко всем  признакам  применимо  предварительное  написание  оператора
"not", что влияет на поле COM блока микропрограммного управления ВУ4.
  Все сигналы  необходимо  предварительно  связать  с  одним из входов
мультиплексора L1..L6 при помощи директивы LINK.

                      ~15238. Команды обработки прерываний.~
                      ════════════════════════════════

   Команды обработки прерываний заполняют поле микрокоманды  м/с  ВН1.
Микросхема КМ1804ВН1 - это 8-разрядная микропрограммируемая наращивае-
мая схема векторного приоритетного прерывания, которая производит при-
оритетную обработку запросов на прерывания,  поступающих по восьми ши-
нам от различных устройств.
  Ниже приведены команды управления м/с и виды их написания:

    1)RESET - команда очистки;  может быть без и однооперандной;

              a)безоперандная команда  RESET  проводит  общую очистку.
              При выпонении этой команды происходит обнуление регистра
              состояния  и триггер разрешения запроса прерывания пере-
              ходит в состояние, разрешающее выход запроса прерывания,
              т.  е.  система  прерывания отреагирует на запрос любого
              приоритета.

              б)RESET MR - очистка регистра маски(обнуление всех раз-
                             рядов регистра маски);  в результате  все
                             прерывания будут размаскированы.

              в)RESET IR   - очистка регистра прерывания.

    2)CLR - команда поразрядной очистки внутренних регистров микросхе-
            мы;  применяется по отношению  к  регистрам  прерываний  и
            маски:

            а)IR - может осуществляться сигналами с шины  данных,  ре-
            гистра маски и регистра вектора. Например:

              CLR IR ,00011000% ; \очищаем 4 и 5 разряды IR
              CLR IR , MR;   \очищаем те разряды регистра прерываний,
                             \для которых соответствуют единицы в ре-
                             \гистре маски
              CLR IR , VR ;  \происходит обнуление тех разрядов IR,
                             \которым соответсвует вектор прерывания,
                             \находящийся в регистре вектора

            б)MR   - осуществляется сигналами с шины данных.

    3)SET - команда поразрядной установки регистра маски. Например:

              SET MR , 11100000%;\маскируем прерывания, поступаю-
                                 \щие с 8,7 и 6 внешних устройств;
                                 \остальные разряды регистра маски
                                 \не затрагиваются

    4)READ - команда чтения регистров м/с;  применяется по отношению к
             регистрам маски,  состояния и вектора:

            а)READ MR;

            б)READ SR;

            в)READ VR;

             при выполнении этих команд на шину данных выдаются сигна-
             лы, отражающиеся состояние соответственно регистра маски,
             состояния и вектора.

    5)DI - запрещение запроса прерываний(происходит обнуление триггера
           разрешения запроса прерывания). (команда безоперандная)

    6)EI - разрешение запроса прерывания; команда действует противопо-
           ложно команде DI. (команда безоперандная)

  Для всех команд,  где в качестве второго операнда фигурирует числен-
ное  значение,  справедлива  и укороченная форма - без прямого задания
данных;  тогда данные на шину данных будут поступать не из памяти мик-
рокоманд,  а  формирующиеся в процессе выполнения микрокоманды на мик-
ропроцессорном комплекте. Например:

                  {OE_ALU;     \разрешаем выдачу на шину данных ре-
                               \зультата выполнения операции в АЛУ
                   XOR R1,R4;  \выполняем  операцию  в АЛУ
                   CLR MR;  }  \очищаем те разряды регистра  маски,
                               \соответствующие которым разряды R1 и
                               \R4 АЛУ не совпадают

  Все команды, которые считывают или выносят на шину данных какие-либо
значения, работают от младших разрядов шины; то есть, например, коман-
да

                   READ VR;

будет выдавать значение 3-разрядного регистра  вектора на три  младшие
разряда шины данных.

                 ~16139. Команда загрузки регистров LOAD.~
                 ═══════════════════════════════════

   Данная команда стоит особняком от всех других команд ассембера, так
как она задает загрузку служебных регистров, относящихся ко многим уз-
лам микропроцессорного комплекса. В зависимости от операнда, следующе-
го за командой, она может быть одно или двуоперандной:

    1)загрузка регистров задания операнда блока АЛУ:

                             LOAD RA;
                             LOAD RB;

      данная команда не требует в качестве второго операнда  указывать
      источник загрузки или непосредственный операнд, так как аппарат-
      но регистры подсоединены к шине данных и при подаче сигнала  за-
      писи в них будут загружено значение, которое в данный момент на-
      ходится на шине.

    2)загрузка регистров меток блока управления сдвигами:

                             LOAD  RM;
                             LOAD  RN;
     здесь в качестве второго операнда можно указывать следущие значе-
     ния:

      1)Z - загрузка во все четыре метки регистра нулей;

      2)NZ- загрузка во все четыре метки регистра  единиц;

      3)FLAGS -  загрузка  в  регистры  признаков выполнения последней
                 операции в блоке АЛУ; при использовании оператора мо-
                 дификации @ флаги будут загружаться в модифицированном
                 виде (см. таблицу загрузки регистров меток);

        кроме того  возможна  загрузка одного регистра другим. Примеры:

                    LOAD RM,Z;
                    LOAD  RN,RM;
                    XOR  R1,R5;
                    LOAD RM,FLAGS;

      Остальные виды загрузок регистров меток являются доступными при
      использовании команды FIELD.

    3)загрузка регистров маски и состояния блока обработки прерываний.
      Команда может быть одно и двуорперандной. Разница состоит в том,
      что при однооперандной команде регистры загружаются текущей  ин-
      формацией с шины данных, в то время как при непоcредственном за-
      дании операнда загрузки, он заносится в поле данных микрокоманды
      и считывается на шину данных оттуда. Например:

                    LOAD SR,7;      \регистр состояния трехразрядный,
                                    \помните, что попытка загрузить ту-
                                    \да число большее 7 вызовет ошибку
                    INC R1;
                    LOAD MR;        \загружаем в регистр маски инкре-
                                    \ментированное значение регистра
                                    \R1(точнее младшие его 8 разрядов)


              ~167410. Команда задания поля микрокоманды FIELD.~
              ════════════════════════════════════════════

   Эта команда является всеобьемлющей, то есть с ее помощью можно  за-
дать абсолютно все поля микрокоманды. После  команды  следует  указать
поле, которое Вы хотите модифицировать и, далее, через  запятую  запи-
сать все те подполя, которые входят  в  данное  поле.  Ниже  приведены
стандартные мнемоники полей и список входящих в них подполей:

   1) BUS_D - поле выдачи константы на  шину  данных  микропроцессора;
содержит поле D и поле OED. Пример написания:

              FIELD bus_d, 0fecdh, 0;

   2) BC1 - поле задания работы м/с ВС1; содержит поле BC1_MI.876, по-
ле BC1_MI.543, поле BC1_MI.210, поля A и B, поле OEY. Пример написания:

              FIELD bc1, 010%, 000%, 001%, 4h, 0bh, 1;

   что соответствует команде ассемблера ADD R10,R4;

   3) ВР2 - поле задания работы м/с ВР2; содержит поле BP2_MI.CB,  по-
ле BP2_MI.A-6, поле BP2_MI.5-0, поля E.C,Z,N,V, поля OECT,  CEN,  CEM,
SE. Пример написания:

              FIELD bp2, 0, 0, 6, 0,0,0,0, 1, 1,0, 1;

   что соответствует команде ассемблера LOAD RM, FLAGS;

   4) REGS - поле задания работы регистров выбора операндов  АЛУ;  со-
держит поля MSA, MSB, EWA и EWB. Пример написания:

             FIELD regs, 1,0, 1,1;
   что соответствует загрузке операнда А АЛУ из регистра RA;

   5) ALU - обобщенное поле задания команды  АЛУ,  содержащее  в  себе
последовательное перечисление полей BC1, BP2, REGS, то есть 21 операн-
да.

   6) BU4 - поле задания команды м/с ВУ4; содержит поле MI, поля  CCE,
COM, CI, RLD, а также поле MS. Пример написания:

             FIELD bu4, 0011%, 1, 1, 1, 1, 3;

   что соответствует команде ассемблера CJP not cond;
   где cond - сигнал, снимаемый с третьего входа мультиплексора  усло-
вий MS.

   7) BH1 - поле задания команды м/с ВН1; содержит поле MI, поле EINS,
поле EV. Пример написания:

             FIELD bh1, 1101%, 0, 1;

   что соответсвует команде ассемблера DI;

   8) CU - обобщенное поле задания блока микропрограммного  управления
и блока приоритетных прерываний, содержащее  в  себе  последовательное
описание полей BU4 и BH1.

   9) MEM - поле управляющих сигналов; содержит поля I, O, R, W, EWH и
EWL. Пример написания:

             FIELD mem, 1,1, 0,1, 1,1;

   что соответсвует команде ассемблера R;

   10) ABSOLUTE - полное поле задания микрокоманды, содержащее 38 опе-
рандов и включающее в себя последовательное описание полей BUS_D, ALU,
CU и MEM.

    Если Вы не хотите модифицировать то или иное поле микрокоманды, то
Вы можете упустить его, поставив в соответсвующем месте  пустую  запя-
тую, например:

             FIELD bus_d, , 0;

    что сответствует команде ассемблера OED, но для  константы  значе-
ние остается неизменным.


                        ~175411. Служебные команды.~
                        ══════════════════════

   Служебные команды  предназначены  для  выдачи на элементы микропро-
цессорного комплекса различных служебных сигналов, как то сигналы раз-
решения(запрета)  выдачи  данных  на  выходы  микросхемы или записи во
внутрение регистры и т.п. Все эти команды сугубо специализированы и не
имеют операндов.  Влияние оказывается на те поля микрокоманды, которые
не затрагиваются другими группами команд.

    1) Команда управления арифметико-логическим устройством на м/с ВС1:

      1. OEY   -  разрешить выдачу результата операции в АЛУ на шину
                  данных;  по умолчанию выдача данных  подавляется.

    2) Команды управления устройством управления сдвигом на м/с ВР2:

      1,2. CEM,CEN - команды разрешения записи в регистры RM и RN;
      3..6. CEM_C,CEM_Z,CEM_N,CEM_V  - запретить запись метки C(Z,N,V)
                                       в регистр меток RM.

    3) Команды управления устройством упраления на м/с ВУ4:

      1. RLD   - разрешение записи в регистр адреса/счетчика
      2. CCE   - разрешение подачи условия
      3. CI - запрещение формирования адреса следующей команды;

    4) Команды управления устройством обработки прерываний на м/с ВН1:

      1. EV - Разрешение выдачи адреса устройства прерывания  на  шину
              данных

    5) Команды управления внешними устройствами и памятью:

      1. R  - команда чтения из памяти
      2. W  - команда записи в память
      3. IN - команда приема с внешнего устройства
      4. OUT - команда записи во внешнее устройство
      5..6. EWH,EWL - команды записи соответственно в старшие и  млад-
                      шие разряды регистра адреса. Две команды введены
                      для случая, когда разрядность ШД < ША и записать
                      новый адрес в регистр адреса за один такт невоз-
                      можно.  Тогда сначала на шине  данных  формируют
                      младшую  часть адреса,  и,  подав сигнал EWL за-
                      писывают ее в регистр адреса, а затем аналогично
                      поступают со старшей частью формируемого адреса.
      7..8. EWA,EWB - команды записи в регистры управления  операндами
                      АЛБ RA и RB.

                       ~180312. Директивы ассемблера.~
                       ═════════════════════════

   Директивы не транслируются в исполнительные коды.  Они служат в ка-
честве указателей ассемблеру на то или иное действие которое он должен
произвести с операндами, приложенными к директиве. Рассмотрим директи-
вы, поддерживаемые ассемблером "COMANDOR" и правила работы с ними:
   В этом разднлн будут рассмотрены следующие директивы:

    12.1. ~1820Директива включения в транслируемый текст INCLUDE~.
    12.2. ~1830Директива  размещения исполнительного кода ORG~.
    12.3. ~1843Директива  задания метки и(или) соответствия EQU~.
    12.4. ~1859Директива задания макросов~.
    12.5. ~1885Директива задания значений определенных ячеек памяти DW~.
    12.6. ~1896Директива установки внутренних регистров комплекса ACCEPT~.
    12.7. ~1969Директива  задания  коммутации  условий для БМУ LINK~.

         ~182012.1. Директива включения в транслируемый текст INCLUDE.~
         ────────────────────────────────────────────────────────

  INCLUDE (+) - директива вставки в транслируемую программу текста  из
указывемого файла. Файл, задаваемый в директиве  должен  находиться  в
той же директории, что и транслируемый файл. Пример:

                           include macro.lib
                           + routine

          ~183012.2. Директива  размещения исполнительного кода ORG.~
          ─────────────────────────────────────────────────────

  ORG ($) - директива размещения исполнительного кода указывает ассем-
блеру на то, что ближайшая следующая за директивой микрокоманда  будет
размещаться в памяти микрокоманд по адресу, указанному после  директи-
вы ORG. Адрес не должен превышать последнего адресуемого поля микроко-
манд. Например:

                           org 010h
                           org start
                           $ 100

         ~184312.3. Директива  задания метки и(или) соответствия EQU.~
         ───────────────────────────────────────────────────────

  EQU (=) - директива задания меток и соответствий нужна Вам, если  Вы
хотите заменить какую либо числовую константу или стандартную мнемони-
ку ассемблера на более ясный для Вас эквивалент. Задание метки осущес-
твляется написанием ключевого слова EQU (=), имени метки и через  опе-
ратор разделения ":" эквивалента метки. Например:

                           equ start : 10
                           = сложить :add
                           equ операнд1 : r1
                           equ операнд2 : 10
                           $ start
                           {сложить операнд1, операнд2;}

                 ~185912.4. Директива задания макросов MACRO.~
                 ───────────────────────────────────────

  MACRO (#) - директива задания макросов позволяет Вам  конструировать
собственные команды и пользоваться ими в дальнейшем так же легко,  как
и стандартными командами ассемблера. Директива макроса задается с  по-
мощью ключевого слова MACRO, имени макроса с  перечислением  всех  его
формальных параметров и, через оператор разделения ":" - самого макро-
са, оформленного в виде стандартной команды ассемблера, то есть, внут-
ри операторов "{ }". Например:

     MACRO inc reg  :{ add reg, reg, z, not z; }
     # JC cond, addr:{ Field Const addr, 0; CJP cond; }
     # dec_RgQ      :{ sub Rq, Rq, z, not z; }

Имя макроса в дальнейшем становится для транслятора  обычной  стандар-
тной мнемоникой со всеми распространяющимися  на  нее  правами.  Имена
формальных оперндов макроса не могут быть зарезервированными  мнемони-
ками. В программе макрос задается указанием своего ключевого имени  и,
реальных операндов перечисленных через запятую в том же порядке, что и
при задании макроса. Например:

      { inc r4; jc not co, start;}
      .......
       start {dec_RgQ;}

      ~188512.5. Директива задания значений определенных ячеек памяти DW.~
      ──────────────────────────────────────────────────────────────

  DW - директива задания любых ячеек  памяти  из  нижних  256  адресов
(0..255), а также произвольных 32 ячеек  памяти  из  общего  адресного
пространства объемом в 2Мбайта необходимыми значениями. Например:

                   dw 03Fh:15
                   dw 124:1,2,3,4,5    \заносим  в  ячейки  с  адресом
                                       \начиная с 124 числа 1,2,3,4,5

    ~189612.6. Директива установки внутренних регистров комплекса ACCEPT.~
    ────────────────────────────────────────────────────────────────

  ACCEPT - директива установки ACCEPT поможет Вам сразу установить на-
чальное состояние тех внутренних регистров комплекта, которые Вам  по-
набобятся при работе. Здесь будут рассмотрены:
   12.6.1. ~1908Установка внутренних регистров ВС1 и ВР2~.
   12.6.2. ~1921Установка внутренних регистров ВУ4~.
   12.6.3. ~1933Установка состояния внешних устройств~.
   12.6.4. ~1953Установка внутренних регистров ВН1~.
   12.6.5. ~1962Установка быстродействия памяти~.

       ~190812.6.1. Установка внутренних регистров ВС1 и ВР2.~
       ────────────────────────────────────────────────
  Можно производить начальную установку следующих регистров:
  - рабочие регистры R0..R15 либо все вместе как POH;
  - регистр RQ;
  - регистры RM, RN;
  - регистры RA, RB.
  Например:
               ACCEPT POH: 1,2,3,4,5,6,7,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh
               ACCEPT RQ : 12
               ACCEPT RM: 0101%


          ~192112.6.2. Установка внутренних регистров ВУ4.~
          ───────────────────────────────────────────
  Можно производить начальную установку следующих регистров:
  - указатель стека SP;
  - ячейки стека STACK[1]..STACK[5] либо весь стек целиком - STACK;
  - регистр адреса-счетчика RAC;
  - регистр счетчика микрокоманд PCMK.
  Например:
               ACCPET SP : 3
               ACCEPT STACK[3] : 0FFCh
               ACCEPT PCMK : 10

      ~193312.6.3. Установка состояния внешних устройств.~
      ──────────────────────────────────────────────
  Можно устанавливать характеристики внешних устройств (DEV):
  - тип устройства: IN - ввода; OUT - вывода;
  - адрес регистра состояния в пределах 64Кb (max 0ffffh);
  - адрес регистра данных в пределах 64Кb (max 0ffffh);
  - время формирования сигнала "Завершение цикла" (max 0ffffh);
  - время формирования сигнала "Готовность" (max 0ffffh).
  Например:
               ACCEPT DEV[3]: IN,   \устройство ввода
                              0342h,\адрес регистра состояния в памяти
                              0344h,\адрес регистра данных
                              12,   \через сколько завершение цикла
                                    \работы
                              2     \интервал времени, через который
                                    \могут обновляться данные
  Кроме того для устройств ввода можно задавать внутрений буфер данных
DEV_BUF до 16 слов, например:
               ACCEPT DEV_BUF[3]: 1EF3h, 234Ah, 0E79h, 1285h

            ~195312.6.4. Установка внутренних регистров ВН1.~
            ───────────────────────────────────────────
  Можно производить начальную установку следующих регистров:
  - регистр масок RM;(max значение 0ffh)
  - регистр разрешения прерываний IR.
    (max значение 0ffh)
  Например:
               ACCEPT RM : 10111001%

            ~196212.6.5. Установка быстродействия памяти~.
            ────────────────────────────────────────
  Можно производить начальную установку быстродействия работы памяти
  с помощью мнемоники RDM_DELAY, например:
                 ACCEPT RDM_DELAY : 3
  установит быстродействие памяти в 3 такта работы устройств

     ~196912.7. Директива  задания  коммутации  условий для БМУ LINK.~
     ───────────────────────────────────────────────────────────

  LINK (&) - директива задания настройки  связей  комплекта  позволяет
программисту непосредственно в программе производить  все  необходимые
настройки системы:
   12.7.1. ~1982Настройка записи в регистр адреса~.
   12.7.2. ~2002Задание адреса перехода по вектору прерываний~.
   12.7.3. ~2019Настройка преобразователя адреса микрокоманды~.
   12.7.4. ~2029Настройка буфера V~.
   12.7.5. ~2040Настройка входов мультиплексора условий~.
   12.7.6. ~2050Настройка регистров задания операндов АЛУ~.

             ~198212.7.1. Настройка записи в регистр адреса.~
             ──────────────────────────────────────────
  Как известно, в данной системе регистр адреса является 20-ти разряд-
ным, что при 16-ти разрядной шине данных требует  двух  циклов  записи
информации в этот регистр; поэтому регистр подразделяется на две  час-
ти, каждая из которых управляется собственным сигналом записи:
  - EWH для записи в старшую часть,
  - EWL - в младшую.
  При настройке системы необходимо задать младший бит записи по сигна-
лу EWH, то есть, тем самым задать количество бит, записываемых по это-
му сигналу. Так как записываться может лишь до 16  бит,  то,  соответ-
ственно, стартовый бит может быть от 4-го до 16-го включительно.  Нап-
ример:

            LINK EWH : 11 \настраиваем запись в  регистр  адреса
                          \таким образом,  чтобы  и  по  сигналу
                          \EWH и по сигналу  EWL  было  записано
                          \по 10 бит  старшей  и  младшей  части
                          \адреса соответственно

     ~200212.7.2. Задание адреса перехода по вектору прерываний.~
     ──────────────────────────────────────────────────────
  В системе имеется возможность при появлении запроса на прерывание от
одного из 8-ми внешних устройств выдавать на шину данных адрес перехо-
дов на соответствующие подпрограммы обработки  прерывания.  8  адресов
хранятся в преобразователе выхода блока приоритетных прерываний, пред-
ставляющего из себя ПЗУ 16*16. Входом для данного ПЗУ является  вектор
внешнего устройства VEC[0]..VEC[7]. Задание адреса перехода можно осу-
ществить как отдельно для каждого вектора, так  и  для  всех  векторов
вместе:

            LINK VEC[3] : 0CDEFh
            LINK VEC    : 1111h,2222h,3333h,4444h,
                          5555h,6666h,7777h,8888h

   Максимальный адрес задания - 0FFFFh.

       ~201912.7.3. Настройка преобразователя адреса микрокоманды.~
       ──────────────────────────────────────────────────────
  Через 12-ти разрядный буфер М имеется возможность подавать на  внут-
реннюю шину адреса микрокоманды адрес с шины данных, причем  в  произ-
вольном порядке  следования  бит.  Задание  осуществляется  последова-
тельным перечислением 12-ти подключаемых на выходы буфера с  11  по  0
проводов с шины данных с 0 по 15, например:

            LINK M   : 4,5,6,7,8,9,10,11,12,13,14,15

                   ~202912.7.4. Настройка буфера V.~
                   ───────────────────────────
  Через 12-ти разрядный буфер V имеется возможность подавать на  внут-
реннюю шину адреса микрокоманды непосредственно  сигналы  запросов  на
прерывание IRQ0..IRQ7, кода условия CT, общего прерывания INT,  готов-
ности памяти и внешних устройств RDM и RDD,  а  также сигналы  Z и NZ.
При настройке Вам необходимо перечислить все 12 подключаемых сигналов,
например:
            LINK V   : Z,NZ,IRQ0,IRQ1,IRQ2,IRQ3,
                       IRQ4,IRQ5,IRQ6,IRQ7,CT,INT

        ~204012.7.5. Настройка входов мультиплексора условий.~
        ────────────────────────────────────────────────
  На входы мультиплексора условий L[1]..L[6]  можно  подавать  сигналы
запросов на прерывание IRQ0..IRQ7, кода условия CT, общего  прерывания
INT,готовности памяти и внешних устройств RDM и RDD, а также сигналы Z
и NZ. Задание осуществляется как  отдельно  для каждого входа условий,
так и общее, например:
            LINK L   : CT,INT,IRQ0,IRQ1,IRQ2,IRQ7
            LINK L[3]: CT

        ~205012.7.6. Настройка регистров задания операндов АЛУ.~
        ──────────────────────────────────────────────────
  4-х разрядные регистры АЛУ RA и RB позволяют подавать на входы выбо-
ра операндов в АЛУ данные непосредственно с шины данных, причем комму-
тация проводов шины данных на вход регистров может быть произвольной и
задается. Настройка коммутации проводов осуществляется аналогично нас-
тройке буфера М, например:

            LINK RA   : 11,12,13,14
            LINK RB   : 10,9,8,7


              ~2062Приложение 1: Таблица зарезервированных мнемоник.~
              ═════════════════════════════════════════════════

   1)директивы
     ─────────

     ~1830ORG~ ~1843EQU~ ~1969LINK~ ~1885DW~ ~1896ACCEPT~ ~1820INCLUDE~ ~1859MACRO~

   2)команды
     ───────

     ВС1  и  ВР2
     ~1108ADD~ ~1109SUB~ ~1110OR~ ~1111AND~ ~1112XOR~ ~1113NAND~ ~1115NXOR~

     ВУ4
     ~1354JZ~  ~1358CJS~ ~1365JMAP~ ~1371CJP~ ~1377PUSH~ ~1390JSRP~ ~1399CJV~ ~1406JRP~
     ~1410RFCT~ ~1424RPCT~ ~1433CRTN~ ~1440CJPP~ ~1454LDCT~ ~1459LOOP~ ~1470CONT~ ~1473TWB~

     ВН1
     ~1572READ~  ~1548CLR~ ~1565SET~ ~1533RESET~ ~1585DI~ ~1588EI~

     внешние устройства
     ~1788R~  ~1789W~  ~1790IN~ ~1791OUT~ ~1792EWH EWL~ ~1800EWA  EWB~

     запрет-разрешение
     ~1766OEY~ ~1771CEM  CEN~  ~1772CEM_C CEM_Z CEM_N CEM_V~ ~1777RLD~ ~1778CCE~ ~1779CI~ ~1783EV~

     прочие
     ~1613LOAD~ ~1674FIELD~

   3)операнды
     ────────

     операция в АЛУ
     ~1166RQ~ ~1162Z~ ~1168R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15~ ~1170RA RB~
     ~1174BUS_D~ ~1135NIL~

     задание типа сдвига
     ~1250SR SL~ ~1226SRA SLA SRL SLL SRWA SLWA SRWL SLWL~

     задание  переноса
     ~1279Z~ ~1281RM_C~ ~1283RN_C~

     задание выхода кода условий
     ~1497Z NZ~ ~1499ZO CO NO VO~
     ~1505RN_Z RN_C  RN_N  RN_V~
     ~1502RM_Z RM_C RM_N RM_V~ ~1507NXORV~ ~1544ZORC~

     команда  FIELD
     ~1740ABSOLUTE~ ~1683BUS_D~ ~1688BC1~ ~1695BP2~ ~1703REGS~ ~1709ALU~ ~1713BU4~ ~1722BH1~ ~1729CU~ ~1733MEM~

     операции  в устройстве обработки прерываний
     ~1523MR SR IR VR~

     операции загрузки регистров меток
     ~1632RM RN~ ~1643FLAGS~ ~1639Z~ ~1641NZ~

     задание коммутации условий
     ~2040CT INT RDM RDD IRQ0 IRQ1 IRQ2 IRQ3 IRQ4 IRQ5 IRQ6 IRQ7 Z NZ~

   4)прочие
     ──────

     ~1010CP~ NOT ~1185@~ . , ; :


                ~2128Приложение 2: Сообщения об ошибках.~
                ═══════════════════════════════════

    1) Ожидается "," ;
    2) Ожидается ";" ;
    3) Ожидается "." ;
    4) Ожидается ":" ;
    5) Ожидается "," либо ";" ;
    6) Мнемоника не распознана ;
    7) Директива не распознана ;
    8) Команда не распознана ;
    9) Метка не определена ;
    10)Двойное определение метки ;
    11)Недопустимое применение зарезервированной мнемоники ;
    12)Число слишком велико ;
    13)Непредвиденный конец файла ;
    14)Некорректный приемник результата в АЛУ ;
    15)Некорректное задание операндов в АЛУ ;
    16)Некорректный операнд сдвига ;
    17)Некорректный операнд переноса ;
    18)Для операнда условия не задана коммутация ;
    19)Некорректный операнд условия ;
    20)Некорректный операнд блока прерываний ;
    21)Некорректный операнд загрузки регистров метки ;
    22)Некорректный операнд поля ;
    23)Неверное применение операнда модификации;
    24)Повторное использование поля данных;
    25)Переполнение верхних адресов оперативной памяти;
    26)Ожидается "{";
    27)Некорректный операнд директивы LINK;
    28)Число факт. и форм. операндов макроса не совпадает;
    29)Некорректный операнд директивы ACCEPT;
    30)Перекрестное определение макросов;
    31)Неправильный параметр командной строки;
    32)зарезервировано для ошибок файловых операций;
    33)Ожидается операнд условия;
    34)Повторное размещение микрокоманды;
    35)Адрес размещения микрокоманд больше предельного.


          ~2168Приложение 3: Задание полей микрокоманды по умолчанию.~
          ══════════════════════════════════════════════════════

  1 )поле констант:
         -  D = 0;       (шина данных-передача данных в АЛУ: 0)
         -  OED=1;       (разрешение подачи данных с поля D на шину
                          данных:не разрешено)

  2)поле БОД:
    ВС1: -  MI = 64;     (микрокоманда: NOP; R+S+CI; A,Q)
         -  A = 0;       (адрес РОНа для записи в Rg A: R0)
         -  B = 0;       (адрес РОНa для записи/чтения Rg B: R0)
         -  OE = 1;      (разрешение выдачи результата на нишу данных:
                          не разрешено)
    ВР2: -  MI = 0;      (микрокоманда)
         -  E.Z = 0;     (разрешение записи меток в RM: разрешены)
         -  E.N = 0;
         -  E.C = 0;
         -  E.V = 0;
         -  OECT= 1;     (разрешение выдачи кода условия: не разрешен)
         -  CEM = 1;     (разрешение записи меток в Rg M и N: не раз-
                          решен)
         -  CEN = 1;
         -  SE  = 1;     (разрешение выполнения сдвига: не разрешен)
    Внешние регистры задания операнда АЛУ:
         -  MSA = 0;     (выбор истчника операндов в АЛУ (ПМК или РА,
                          РБ): ПМК)
         -  MSB = 0;
         -  EWA = 1;     (запись в регистры выбора операнда АЛУ: нет)
         -  EWB = 1;

  3)поле БМУ и БПП:
    ВУ4: -  MI = 14;     (Микрокоманда: CONT)
         -  CCE = 1;     (разрешение анализа условия: запрещен)
         -  COM = 1;     (инвертирование входа условия: инвертировать)
         -  CI = 1;      (формирование следующего адреса микрокоманды)
         -  RLD = 1;     (разрешение записи в регистр адреса/счетчика:
                          запрещен)
    Мультиплексор выбора сигнала условия:
         -  MS = 0;
    ВН1: -  MI = 0;      (Микрокоманда: RESET)
         -  EINS = 1;    (Разрешение приема инструкции: не разрешен)
         -  EV = 1;      (Разрешение выдачи адреса прерывания из ПЗУ
                          векторов на ШД: не разрешен).

  4)поле ОП, ВУ, РА:
    ВУ:  -  I =  1;      (сигнал чтения с внешнего устройства:
                          не разрешен)
         -  O = 1;       (сигнал записи на внешнее устройство:
                          не разрешен)
    ОП:  -  R = 1;       (сигнал чтения из памяти: не разрешен)
         -  W = 1;       (сигнал записи в память: не разрешен)
    РгА  -  EWH = 1;     (сигналы записи на регистр адреса старших
                          и младших разрядов: не разрешены)
         -  EWL = 1;


               ~2225Приложение 4: Пример написания программы.~
               ═════════════════════════════════════════

\ EXAMPLE.ESM
\ Программа выполняет следующие действия:
\ ---------------------------------------
\ 1) Выборка команды микропроцессора из памяти
\ 2) Распаковка команды и принятие решения о выполнении
\ 3) Выполнение команды в случае, если команда соответствует шаблону
\ 4) Формирование адреса следующей микрокоманды

\ ~2236Вид команды микропроцессора~
\ ---------------------------
\ ┌────┬────┬────────┬────────────────┐
\ │xxxx│xxxx│xxxxxxxx│xxxxxxxxxxxxxxxx│ - Длина 4 байта
\ └────┴────┴────────┴────────────────┘
\                         
\   │    │      │            │
\   │    │      │            └─── 1..15 - непосредственный операнд
\   │    │      └──────────────── 16..23- не используется
\   │    └─────────────────────── 24..27-РОН, хранящий адрес приемника
\   └──────────────────────────── 28..31- код операции

\ ~2248Примерный шаблон команды~
\ ------------------------
\ ┌────┬────┬────────┬────────────────┐
\ │0101│1xxx│........│xxxxxxxxxxxxxxxx│ - Длина 4 байта
\ └────┴────┴────────┴────────────────┘
\                         
\   │    │      │            │
\   │    │      │            └─── любое значение
\   │    │      └──────────────── не используется
\   │    └─────────────────────── любой из регистров R8..R15 блока АЛУ
\   └──────────────────────────── операция сложения

\ ~2260Начальные настройки~
\ -------------------
~1843EQU~ counter : ~2095R0~       \ пусть R0 служит счетчиком команд
~1896ACCEPT~ counter : 0FEh  \ пусть текущая команда расположена в памяти по
                       \ адресу 0FEh
~1885DW~ 0FEh : 5800h,0100h  \ команда процессора
~1896ACCEPT~ R8 : 0123h      \ по примеру РОН, хранящий адрес приемника - R8
                       \ пусть этот адрес будет 123h
~1885DW~ 0123h : 1111h       \ пусть ячейка-приемник содержит число 1111h
~1843EQU~ com_reg1 : ~2095R1~      \ пусть R1 служит регистром команды 1
~1843EQU~ com_reg2 : ~2095R2~      \ пусть R2 служит регистром команды 2
~1843EQU~ result   : ~2095R3~      \ пусть R3 служит буфером результата операции
~1969LINK~ ~2040L[1] : RDM~        \ коммутируем сигнал  готовности памяти на пер-
                       \ вый вход Мультиплексора Условий
~1969LINK~ ~2040L[2] : CT~         \ коммутируем сигнал признака выполнения опе-
                       \ рации в АЛУ
~1843EQU~ выборка    : 10    \ адрес подпрограммы выборки команды  микропро-
                       \ цессора из памяти
~1843EQU~ распаковка : 20    \ аналогично для п/п распаковки
~1843EQU~ выполнение : 30    \ аналогично для п/п выполнения
~1843EQU~ фаск       : 40    \ аналогично для п/п  формирования  адреса сле-
                       \ дующей команды
~1843EQU~ ошибка     : 50    \ п/п обработки кода операции отличного от
                       \ примерного
~1969LINK~ ~2050RB~ : 8,9,10,11    \ настраиваем RB на линии 8..11 ШД,  куда попа-
                       \ дает номер РОНа, хранящего адрес приемника

\ ~2287Макросы, используемые для часто повторяемых команд~
\ --------------------------------------------------
~1859MACRO~ MOV приемник, источник :
          {~1108ADD~ приемник, ~1162Z~, источник;}
~1859MACRO~ READ_MEM приемник :
          {~1788R~; ~2289MOV~ приемник, ~1174BUS_D~; ~1371CJP~ RDM, ~1010CP~;}
~1859MACRO~ WRITE_MEM источник :
          {~1789W~; ~2289MOV~ ~1124NIL~, источник; ~1764OEY~; ~1371CJP~ RDM, ~1010CP~;}

\ ~2296подпрограмма выборки команды микропрцессора из памяти~
\ -----------------------------------------------------
~1830ORG~ ~2276выборка~

{~2289MOV~ ~1124NIL~, ~2262counter~; ~1764OEY~; ~1792EWL~;} \читаем первый байт команды
{~1111AND~ ~1124NIL~, ~2262counter~, ~1162Z~; ~1764OEY~; ~1792EWH~;}
{~2291READ_MEM~ ~2269com_reg1~;}

{~1108ADD~ ~2262counter~, 1;}
{~2289MOV~ ~1124NIL~, ~2262counter~; ~1764OEY~; ~1792EWL~;} \читаем второй и третий байт команды
{~1111AND~ ~1124NIL~, ~2262counter~, ~1162Z~; ~1764OEY~; ~1792EWH~;}
{~2291READ_MEM~ ~2270com_reg2~;}
{~1109SUB~ ~2262counter~, ~1162Z~;}

{~1371CJP~ ~1497NZ~, ~2278распаковка~;} \переходим на п/п распаковки команды

\ ~2312подпрограмма распаковки команды микропроцессора~
\ -----------------------------------------------
~1830ORG~ ~2278распаковка~

{~1111AND~ ~2271result~, ~2269com_reg1~, 1111000000000000%;}
{~1112XOR~ ~2271result~, 0101000000000000%; ~1613LOAD~ ~1632RM~, ~1643FLAGS~;}
{~1371CJP~ ~1502not RM_Z~, ~2282ошибка~;}

{~2289MOV~ ~1124NIL~, ~2269com_reg1~; ~1764OEY~; ~1800WB~;} \записываем номер РОНа, хранящего адрес
                              \приемника результата в регистр RB
{~2289MOV~ ~1124NIL~, ~1170RB~; ~1764OEY~; ~1792EWL~;}  \читаем приемник результата в РОН - буфер
{~1111AND~ ~1124NIL~, ~2262counter~, ~1162Z~; ~1764OEY~; ~1792EWH~;}
{~2291READ_MEM~ ~2271result~;}

{~1371CJP~ ~1497NZ~, ~2279выполнение~;} \переходим на п/п выполнения команды

\ ~2328подпрограмма выполнения команды микропроцессора~
\ -----------------------------------------------
~1830ORG~ ~2279выполнение~

{~1108ADD~ ~2271result~, ~2270com_reg2~;}\выполняем операцию сложения

{~2289MOV~ ~1124NIL~, ~1170RB~; ~1764OEY~; ~1792EWL~;}  \записываем сформированный результат в
{~1111AND~ ~1124NIL~, ~2262counter~, ~1162Z~; ~1764OEY~; ~1792EWH~;}   \ячейку памяти, по адресу из RB
{~2293WRITE_MEM~ ~2271result~;}

{~1371CJP~ ~1497NZ~, ~2280фаск~;}        \переходим на п/п формирования адреса
                          \следующей команды

\ ~2341подпрограмма формирования адреса следующей команды микропроцессора~
\ ------------------------------------------------------------------
~1830ORG~ ~2280фаск~

{~1108ADD~ ~2262counter~, 4;} \ следующая команда микропроцессора находится по ад-
                  \ ресу, на 4 байта старше предыдущей
{~1371CJP~ ~1497NZ~, ~2276выборка~;}\ возвращаемся на этап выборки команды

\ ~2349подпрограмма обработки кода операции, отличного от примерного~
\ -------------------------------------------------------------
~1830ORG~ ~2282ошибка~

{~1371CJP~ ~1497NZ~, ~2280фаск~;}\ т.к. обработка ошибки не входит в функции данной
                  \ программы, то просто переходим на п/п формирова-
                  \ ния адреса следующей команды
\ конец программы EXAMPLE.ESM

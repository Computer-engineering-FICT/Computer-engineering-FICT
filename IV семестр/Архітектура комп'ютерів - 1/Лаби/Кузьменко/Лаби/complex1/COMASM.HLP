                          ╔═════════════╗
                          ║C O M P L E X║
                          ╚═════════════╝

   Программа эмуляции работы вычислительной системы построенной на
   ═══════════════════════════════════════════════════════════════
        базе микропрограммируемого секционированого комплекта
        ═════════════════════════════════════════════════════
                             серии КМ1804
                             ════════════

                   ╔═══════════════════════════════╗
                   ║    Структура микрокоманды.    ║
                   ╚═══════════════════════════════╝

 Память  микрокоманд  разработанной системы содержит  отдельные
 микрокоманды, каждая из которых  делится  на поля:

   1. ~0036Поле констант~:
                    ~0048адрес БМУ~;
                    ~0053константа БОД~;
   2. ~0085Поле БОД (блок обработки данных)~:
                    ~0092микросхема КМ1804 ВС1~;
                    ~0094микросхема КМ1804 ВР2~;
                    ~0105регистры адресов операндов РАА,РАВ~;
   3. ~0631Поле БМУ (блок микропрограммного управления)~:
                    ~0635микросхема КМ1804 ВУ4~;
                    ~0752мультиплексор условий~;
   4. ~0778Поле БПП (блок приоритетных прерываний)~;
                    ~0782мкросхема КМ1084 ВН1~;
   5. ~0867Поле управляющих сигналов~:
                    ~0873ОП  - оперативная память~;
                    ~0871УВВ - устройства ввода/вывда~;
                    ~0875РА  - регистр адреса~.

                       ┌──────────────────╖
                       │ 1.ПОЛЕ КОНСТАНТ. ║
                       ╘══════════════════╝
 Включает:
           ~0044D   - константа~;
           ~0066OED - разрешить выдачу константы~.


 ┌────────╖
 │ Поле D ║  КОНСТАНТА.
 ╘════════╝   ─────────┘
 Назначение.
        1) Младшие  12  разрядов  используются для формирования
           адресов переходов вырабатываемых БМУ. Данные разряды
           постоянно поступают на шину адреса ветвления, если в
           результате выполнения команды в БМУ (~0631микросхема ВУ4~)
           формируется сигнал PE=0;
        2) Все  16 разрядов могут быть использованы для задания
           констант,которые под управлением ~0066сигнала OED~=0 могут
           быть выданы на системную шину  данных.  Эта  особен-
           ность позволяет:
           -  во-первых, уменьшить разрядность ПЗУ  МК(микроко-
            манд) за счет  совмещения  полей;
           -   во-вторых, дает возможность загружать  необходи-
           мые константы, маски и т.п. в  любое  из  устройств,
           подключенное к системной шине данных.

 Примечание. Значения вводятся в  шестнадцатиричном  коде.
             При вводе новой команды задается нулевая константа.

 ┌────────╖
 │  OED   ║  РАЗРЕШИТЬ ВЫДАЧУ КОНСТАНТЫ НА ШИНУ АДРЕСА.
 ╘════════╝   ─────────────────────────────────────────┘
 Назначение.
           Разрешение выдачи всех шестнадцати  разрядов  ~0044поля D~
           на шину данных системы. Установка данного сигнала  в
           нулевое значение приводит к формированию на  систем-
           ной шине данных значения константы поля D.
 Уровень:  0 - Активный  (выдача разрешена);
           1 - Пассивный (выдача запрещена).
 Примечание.
           Значения вводятся в двоичном коде(значение 0 или 1).
           При вводе новой команды выдача константы из ПМК на шину данных
           запрещена.





             ┌───────────────────────────────────────╖
             │  2.ПОЛЕ БОД (блок обработки данных).  ║
             ╘═══════════════════════════════════════╝

 Блок обработки данных(далее БОД) предлагаемой системы построен
 с  использованием  следующих функциональных узлов:

    1) 4 микропроцессорных секции КМ1804ВС1,которые образуют
       основу 16-разрядного АЛУ.
    2) Схема управления состоянием и сдвигами КМ1804ВР2, которая
       предназначена  для  совместной  работы  с  процессорными
       элементами ВС1  и  обеспечивает замыкание данных  вокруг
       микропроцессорных секций. Данная микросхема обеспечивает
       функции  регистра  состояния  и  формирователя   сигнала
       переноса,  смесь   источников   входного  переноса  АЛУ,
       организовывает  32  типа  сдвигов (арифметические, логи-
       ческие, циклические), которые  могут  быть  обычной  или
       двойной  длины,  содержит   два   4-разрядных   регистра
       состояния, выполняет 16 операций по формированию сигнала
       условия.
    3) Микросхемы обрамления:
        4-разрядные регисты операндов (РАА,РАВ);
        Мультиплексоры  выбора  источника   операндов,  который
        позволяет  адресовать  регистры  участвующие в операции
        АЛУ либо из ПМК,либо по адреса,хранящемуся в РАА и РАВ.

 Для управления вышеперечисленными устройствами,каждая команда
 в ПМК содержит следующие поля.

 Включает:
           ~0092Микросхема КМ1804ВС1~:




           ~0140BC1_IM¤  - операция в ВС1~;
           ~0235A,B      - номера регистров АЛУ~;
           ~0250OEY      - разрешене выдачи результата из АЛУ~;

           ~0094Микросхема КМ1804ВР2~:
           ~0264BP2_IM¤  - операция в ВР2~;
           ~0536E.ZNCV   - побитное разрешение записи меток в RgM~;
           ~0551OECT     - разрешение выдачи кода условия~;
           ~0568CEM      - разрешение записи меток в RgM~;
           ~0568CEN      - разрешение записи меток в RgN~;
           ~0580SE       - разрешение выполнения сдвига~;

           ~0105Микросхемы обрамления~:
           ~0592MSA      - источник операндов в АЛУ (ПМК или РА)~;
           ~0592MSB      - источник операндов в АЛУ (ПМК или РB)~;
           ~0609WA       - запись в регистры операнда PA~;
           ~0609WB       - запись в регистры операнда PB~.



 ┌────────╖
 │ BC1_MI¤║  ПОЛЕ МИКРОКОМАНДЫ МИКРОСХЕМЫ ВС1.
 ╘════════╝   ────────────────────────────────┘
 Назначение.
           Задает операцию выполняемую в АЛУ. Данное  поле  со-
           держит несколько разделов (полей), каждое из  которых
           определяет характер выполняемой операции.
                1) ~0155Поле приемника результата в АЛУ~;
                2) ~0185Поле операции  в АЛУ~;
                3) ~0210Поле операндов в АЛУ~.
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤).


 ┌───────────╖
 │BC1_MI¤.876║  ПРИЕМНИК РЕЗУЛЬТАТА ОПЕРАЦИИ В АЛУ.
 ╘═══════════╝   ──────────────────────────────────┘
 Назначение.
           Поле приемника результата  в  АЛУ  (разряды  8,7,6).
           Определяет куда помещается результат операции.
           ┌───┬────────────────────────────────────────────────┐
           │MI │                                                │
           │876│   куда попадет результат выполнения операции   │
           ├───┼────────────────────────────────────────────────┤
           │000│   F -> Q                                       │
           │001│ результат операции в АЛУ не заносится ни в один│
           │   │ из внутренних регистров используется лишь кос- │
           │   │ венный эффект, например переустановленные флаж-│
           │   │ ки операций, либо выдача результата на шину    │
           │   │ данных                                         │
           │010│   F -> B и на шину выдается не результат, а    │
           │   │ значение регистра - операнда А                 │
           │011│   F -> B                                       │
           │100│   F/2 -> B, Q/2 -> Q                           │
           │101│   F/2 -> B                                     │
           │110│   2F -> B,  2Q -> Q                            │
           │111│   2F -> B                                      │
           └───┴────────────────────────────────────────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤).
           При вводе новой команды задается код 001.


 ┌───────────╖
 │BC1_MI¤.543║  ОПЕРАЦИЯ В АЛУ.
 ╘═══════════╝   ──────────────┘
 Назначение.
           Поле операции в АЛУ (разряды 5,4,3). Определяет  ха-
           рактер  преобразования  над  выбранными  операндами.
           ┌───┬──────┬───────────────┐
           │MI │мнемо-│               │
           │543│ ника │операция в АЛУ │
           ├───┼──────┼───────────────┤
           │000│ ADD  │   R+S+CI      │
           │001│ SUB  │   S-R-1+CI    │
           │010│ SUB  │   R-S-1+CI    │
           │011│ OR   │   R or S      │
           │100│ AND  │   R and S     │
           │101│ NAND │   not(R) and S│
           │110│ XOR  │   R xor S     │
           │111│ NXOR │   not(R xor S)│
           └───┴──────┴───────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤).
           При вводе новой команды задается  код  000


 ┌───────────╖
 │BC1_MI¤.210║  ПОЛЕ ОПЕРАНДОВ ОПЕРАЦИИ В АЛУ.
 ╘═══════════╝   ─────────────────────────────┘
 Назначение.
           Поле операндов в  АЛУ  (разряды  2,1,0).  Определяет
           ~0235операнды~, которые участвуют в  выполнении  операции.
           ┌───┬───────────┬──────┐
           │MI │           │      │
           │210│ мнемоника │R    S│
           ├───┼───────────┼──────┤
           │000│ Rx , RQ ; │A    Q│
           │001│ Rx , Rx ; │A    B│
           │010│ Z  , RQ ; │Z    Q│
           │011│ Z  , Rx ; │Z    B│
           │100│ Z  , Rx ; │Z    A│
           │101│ Val, Rx ; │D    A│
           │110│ Val, RQ ; │D    Q│
           │111│ Val, Z  ; │D    Z│
           └───┴───────────┴──────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤).
           При вводе новой команды задается  код  000


 ┌────────╖
 │  A, B  ║  НОМЕРА РЕГИСТРОВ АЛУ, ИСПОЛЬЗУЕМЫХ В ОПЕРАЦИИ.
 ╘════════╝   ─────────────────────────────────────────────┘
 Назначение.
           Поля определяют ~0210номера регистров  АЛУ~,  которые  ис-
           пользуются при выполнении операции. Значения из это-
           го поля поступают на входы  А  и  В  ~0092микросхемы  ВС1~
           соответственно. Условием  коммутации  этих  полей  на
           микросхему ВС1 являются  сигналы  на
           ~0592мультиплексорах выбора источника операндов~ MSA=0 и MSB=0.
 Примечание.
           Значения вводятся в шестнадцатиричном коде.
           При вводе новой команды задаются  нулевые РОНы


 ┌────────╖
 │  OEY   ║  РАЗРЕШЕНИЕ ВЫДАЧИ РЕЗУЛЬТАТА.
 ╘════════╝   ────────────────────────────┘
 Назначение.
           Разрешение выдачи результата из АЛУ  (~0092BC1~)  на  шину
           данных системы.
 Уровень : 0 - Активный  (выдача разрешена)
           1 - Пассивный  (выдача запрещена).
 Примечание.
           Значения вводятся в двоичном кода.
           При вводе новой команды выдача результата операции в
           АЛУ запрещена.


 ┌─────────╖
 │ BP2_MI¤ ║  ПОЛЕ МИКРОКОМАНДЫ МИКРОСХЕМЫ ВР2.
 ╘═════════╝   ────────────────────────────────┘
 Назначение.
           Задает микрокоманду выполняемую в устройстве  управ-
           ления состоянием и сдвигами ~0094КМ1804ВР2~ ,которая обес-
           печивает замыкание данных  вокруг  микропроцессорных
           секций (~0092КМ1804ВС1~). Поле содержит  несколько  разде-
           лов :
              1) ~0282Поле управления сигналами переноса CI~;
              2) ~0308Поле управления выполнением сдвигов~;
              3) ~0369Поле управления выхода кода условия~ и  загруз-
                 ки регистров меток.
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).


 ┌──────────╖
 │BP2_MI¤.CB║  УПРАВЛЕНИЕ СИГНАЛОМ СI.
 ╘══════════╝   ──────────────────────┘
 Назначение.
           Поле  управления  сигналами  переноса  CI   (разряды
           12,11). Значение этого поля  позволяет  коммутировать
           различные сигналы на вход СI  секции  АЛУ.
     ┌──┬──────┬───────────────────────────────────────────────┐
     │MI│мнемо-│                                               │
     │CB│ ника │      перенос, подаваемый на вход БОД          │
     ├──┼──────┼───────────────────────────────────────────────┤
     │00│  Z   │                    0                          │
     │01│  NZ  │                    1                          │
     │10│      │              не задействовано                 │
     │11│ RM_C │сигнал переноса задается  с выходов С регистров│
     │  │ RN_C │меток RgM и RgN по следующему порядку:         │
     │  │not   │при  MI.5 = 1 с RgM.C, иначе с RgN.C ;         │
     │  │  RM_C│при  MI.321 = 100 сигнал берется с инверсией;  │
     │  │  RN_C│при любой другой комбинации - без нее          │
     └──┴──────┴───────────────────────────────────────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).
           При вводе новой команды задается код 00


 ┌───────────╖
 │BP2_MI¤.A-6║  ПОЛЕ УПРАВЛЕНИЯ СДВИГОМ.
 ╘═══════════╝   ───────────────────────┘
 Назначение.
           Поле управления выполнения сдвигов (разряды 10-6).
 ┌─────┬────┬───────────────┬───────────────────────────────────────────┐
 │     │    │               │  формирование сигнала сдвига на регистры  │
 │  MI │    │               │          БОД   (при сигнале~0580 SE ~= 0 )      │
 │A9876│dec.│  мнемоника    ├──────────────┬──────────┬─────────────────┤
 │     │    │               │  на регистр  │на регистр│загрузка флажка С│
 │     │    │               │  прм.рез-та  │    RQ    │рег-ра меток RgM │
 ├─────┴────┴───────────────┴──────────────┴──────────┴─────────────────┤
 │~0320                  П Р А В Ы Е      С Д В И Г И                        ~│
 ├─────┬────┬───────────────┬──────────────┬──────────┬─────────────────┤
 │00000│ 00 │  SRL (SR.Z)   │SRB:=0        │SRQ:=0    │      нет        │
 │00001│ 01 │  SR.NZ        │SRB:=1        │SRQ:=1    │      нет        │
 │00010│ 02 │  SR.RM_N √    │SRB:=0        │SRQ:=RgM.N│   RgM.C:=SRB    │
 │00011│ 03 │               │SRB:=1        │SRQ:=SRB  │      нет        │
 │00100│ 04 │               │SRB:=RgM.C    │SRQ:=SRB  │      нет        │
 │00101│ 05 │  SR.RM_N      │SRB:=RgM.N    │SRQ:=SRB  │      нет        │
 │00110│ 06 │               │SRB:=0        │SRQ:=SRB  │      нет        │
 │00111│ 07 │  SR.RB0 √     │SRB:=0        │SRQ:=SRB  │   RgM.C:=SRQ    │
 │01000│ 08 │  SRC (SR.RB0) │SRB:=SRB      │SRQ:=SRQ  │   RgM.C:=SRB    │
 │01001│ 09 │  SR.RM_C      │SRB:=RgM.C    │SRQ:=SRQ  │   RgM.C:=SRB    │
 │01010│ 10 │  SR.RQ0 √     │SRB:=SRB      │SRQ:=SRQ  │      нет        │
 │01011│ 11 │  SR.CO        │SRB:=CO       │SRQ:=SRB  │      нет        │
 │01100│ 12 │               │SRB:=RgM.C    │SRQ:=SRB  │   RgM.C:=SRQ    │
 │01101│ 13 │  SR.RQ0       │SRB:=SRQ      │SRQ:=SRB  │   RgM.C:=SRQ    │
 │01110│ 14 │ SRA (SR.NXORV)│SRB:=NO xor VO│SRQ:=SRB  │      нет        │
 │01111│ 15 │               │SRB:=SRQ      │SRQ:=SRB  │      нет        │
 ├─────┴────┴───────────────┴──────────────┴──────────┴─────────────────┤
 │~0339                  Л Е В Ы Е        С Д В И Г И                        ~│
 ├─────┬────┬───────────────┬──────────────┬──────────┬─────────────────┤
 │10000│ 16 │               │SLB:=0        │SLQ:=0    │   RgM.C:=SLB    │
 │10001│ 17 │               │SLB:=1        │SLQ:=1    │   RgM.C:=SLB    │
 │10010│ 18 │SLL (SLA)(SL.Z)│SLB:=0        │SLQ:=0    │      нет        │
 │10011│ 19 │  SL.NZ        │SLB:=1        │SLQ:=1    │      нет        │
 │10100│ 20 │               │SLB:=SLQ      │SLQ:=0    │   RgM.C:=SLB    │
 │10101│ 21 │               │SLB:=SLQ      │SLQ:=1    │   RgM.C:=SLB    │
 │10110│ 22 │               │SLB:=SLQ      │SLQ:=0    │      нет        │
 │10111│ 23 │  SL.RQ15      │SLB:=SLQ      │SLQ:=1    │      нет        │
 │11000│ 24 │  SLC (SL.RB15)│SLB:=SLB      │SLQ:=SLQ  │   RgM.C:=SLB    │
 │     │    │   SL.RQ15 √   │              │          │                 │
 │11001│ 25 │               │SLB:=RgM.C    │SLQ:=SLB  │   RgM.C:=SLB    │
 │11010│ 26 │  SL.RB15 √    │SLB:=SLB      │SLQ:=SLB  │      нет        │
 │11011│ 27 │  SL.RM_C      │SLB:=RgM.C    │SLQ:=0    │      нет        │
 │11100│ 28 │               │SLB:=SLQ      │SLQ:=RgM.C│   RgM.C:=SLB    │
 │11101│ 29 │               │SLB:=SLQ      │SLQ:=SLB  │   RgM.C:=SLB    │
 │11110│ 30 │  SL.RM_C √    │SLB:=SLQ      │SLQ:=RgM.C│      нет        │
 │11111│ 31 │               │SLB:=SLQ      │SLQ:=SLB  │      нет        │
 └─────┴────┴───────────────┴──────────────┴──────────┴─────────────────┘
 Примечание: значок √ обозначает, что при написании заданной мнемоники
             сдвига при приемнике результата в RgQ будут вырабатываться
             данные коды;
             если мнемоника не задана, то нужно применять команду MASK.
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).
           При вводе новой команды задается код 00000


 ┌───────────╖
 │BP2_MI¤.5-0║  УСЛОВИЕ СТ или ЗАГРУЗКА РЕГИСТРОВ МЕТОК.
 ╘═══════════╝   ───────────────────────────────────────┘
 Назначение.
           Поле управления выхода кода условия и  загрузки  ре-
           гистров меток (разряды 5-0).Содержимое данного  поля
           может интерпритироваться различным образом:
             1)   ~0380формирование сигнала логического условия~
                  (~0551при сигнале OECT=0~);
             2)   ~0454операции загрузки регистров меток~.
                  (~0551при сигнале OECT=1~);
           ┌──────┬───┬──────┬────────────────────────────────────────┐
           │  MI  │   │мнемо-│формирование сигнала логического условия│
           │543210│dec│ ника │        (при сигнале ~0551OECT~ = 0 )         │
           │──────┼───┼──────┼────────────────────────────────────────┤
           │000000│ 00│      │CT:=RgN.Z or (RgN.N xor RgN.V);         │
           │000001│ 01│      │CT:=not(RgN.N xor RgN.V) and not(RgN.Z);│
           │000010│ 02│      │CT:=RgN.N xor RgN.V;                    │
           │000011│ 03│      │CT:=not(RgN.N xor RgN.V);               │
           │000100│ 04│ RN_Z │CT:=RgN.Z;                              │
           │000101│ 05│      │CT:=not(RgN.Z);                         │
           │000110│ 06│ RN_V │CT:=RgN.V;                              │
           │000111│ 07│      │CT:=not(RgN.V);                         │
           │001000│ 08│      │CT:=RgN.C or RgN.Z;                     │
           │001001│ 09│      │CT:=not(RgN.C) and not(RgN.Z);          │
           │001010│ 10│ RN_C │CT:=RgN.C;                              │
           │001011│ 11│      │CT:=not(RgN.C);                         │
           │001100│ 12│      │CT:=not(RgN.C) or RgN.Z;                │
           │001101│ 13│      │CT:=RgN.C and not(RgN.Z);               │
           │001110│ 14│      │CT:=NO xor RgM.N;                       │
           │001111│ 15│      │CT:=not(NO xor RgM.N);                  │
           │010000│ 16│      │CT:=RgN.Z or (RgN.N xor RgN.V);         │
           │010001│ 17│      │CT:=not(RgN.N xor RgN.V) and not(RgN.Z);│
           │010010│ 18│      │CT:=RgN.N xor RgN.V;                    │
           │010011│ 19│      │CT:=not(RgN.N xor RgN.V);               │
           │010100│ 20│      │CT:=RgN.Z;                              │
           │010101│ 21│      │CT:=not(RgN.Z);                         │
           │010110│ 22│      │CT:=RgN.V;                              │
           │010111│ 23│      │CT:=not(RgN.V);                         │
           │011000│ 24│      │CT:=RgN.C or RgN.Z;                     │
           │011001│ 25│      │CT:=not(RgN.C) and not(RgN.Z);          │
           │011010│ 26│      │CT:=RgN.C;                              │
           │011011│ 27│      │CT:=not(RgN.C);                         │
           │011100│ 28│      │CT:=not(RgN.C) or RgN.Z;                │
           │011101│ 29│      │CT:=RgN.C and not(RgN.Z);               │
           │011110│ 30│ RN_N │CT:=RgN.N;                              │
           │011111│ 31│      │CT:=not(NO xor RgM.N);                  │
           │100000│ 32│      │CT:=RgM.Z or (RgM.N xor RgM.V);         │
           │100001│ 33│      │CT:=not(RgM.N xor RgM.V) and not(RgM.Z);│
           │100010│ 34│      │CT:=RgM.N xor RgM.V;                    │
           │100011│ 35│      │CT:=not(RgM.N xor RgM.V);               │
           │100100│ 36│ RM_Z │CT:=RgM.Z;                              │
           │100101│ 37│      │CT:=not(RgM.Z);                         │
           │100110│ 38│ RM_V │CT:=RgM.V;                              │
           │100111│ 39│      │CT:=not(RgM.V);                         │
           │101000│ 40│      │CT:=RgM.C or RgM.Z;                     │
           │101001│ 41│      │CT:=not(RgM.C) and not(RgM.Z);          │
           │101010│ 42│ RM_C │CT:=RgM.C;                              │
           │101011│ 43│      │CT:=not(RgM.C);                         │
           │101100│ 44│      │CT:=not(RgM.C) or RgM.Z;                │
           │101101│ 45│      │CT:=RgM.C and not(RgM.Z);               │
           │101110│ 46│ RM_N │CT:=RgM.N;                              │
           │101111│ 47│      │CT:=not(RgM.N);                         │
           │110000│ 48│      │CT:=ZO or (NO xor VO);                  │
           │110001│ 49│      │CT:=not(NO xor VO) and not(ZO);         │
           │110010│ 40│ NXORV│CT:=NO xor VO;                          │
           │110011│ 51│      │CT:=not(NO xor VO);                     │
           │110100│ 52│ ZO   │CT:=ZO;                                 │
           │110101│ 53│      │CT:=not(ZO);                            │
           │110110│ 54│ VO   │CT:=VO;                                 │
           │110111│ 55│      │CT:=not(VO);                            │
           │111000│ 56│      │CT:=CO or ZO;                           │
           │111001│ 57│ CORZ │CT:=not(CO) and not(ZO);                │
           │111010│ 58│ CO   │CT:=CO;                                 │
           │111011│ 59│      │CT:=not(CO);                            │
           │111100│ 60│      │CT:=not(CO) or ZO;                      │
           │111101│ 61│      │CT:=CO and not(ZO);                     │
           │111110│ 62│ NO   │CT:=NO;                                 │
           │111111│ 63│      │CT:=not(NO);                            │
           └──────┴───┴──────┴────────────────────────────────────────┘
 Примечание: если мнемоника не задана, то нужно применять команду MASK.
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).
           При вводе новой команды задается код 000000
           ┌──────┬───┬─────────────────┬────────────────────────────────────────┐
           │  MI  │   │                 │   операции загрузки регистров меток    │
           │      │   │                 ├───────────────────┬────────────────────┤
           │543210│dec│   мнемоника     │ операции в RgN    │  операции в RgM    │
           │      │   │                 │   (при CEN=0)     │при CEM, E.C,Z,N,V=0│
           ├──────┼───┼─────────────────┼───────────────────┼────────────────────┤
           │000000│ 00│ LOAD RN,RM ;    │    RgN:=RgM;      │    нет загрузки    │
           │000001│ 01│ LOAD RM,NZ ;    │    RgN:=1111      │    RgM:=1111       │
           │      │   │ LOAD RN,NZ ;    │                   │                    │
           │000010│ 02│ LOAD RM,RN ;    │    RgN <--> RgM   │    RgM:=RgN        │
           │000011│ 03│ LOAD RM,Z ;     │    RgN:=0000      │    RgM:=0000       │
           │      │   │ LOAD RN,Z ;     │                   │                    │
           │000100│ 04│ LOAD RN,FLAGS ; │    RgN:=FLAGS     │ Z:=ZO N:=NO C<-->V │
           │000101│ 05│                 │    RgN:=FLAGS     │    RgM:=not RgM    │
           │000110│ 06│ LOAD  RM,FLAGS ; RgN:=FLAGS за искл.│    RgM:=FLAGS      │
           │000111│ 07│ LOAD @RN,FLAGS ; RgN.V:=RgN.V xor VO│    RgM:=FLAGS      │
           │001000│ 08│ LOAD @RM,FLAGS ;│    RgN.Z:=0        RgM:=FLAGS за искл. │
           │001001│ 09│                 │    RgN.Z:=1        RgM.C:=not CO       │
           │001010│ 10│                 │    RgN.C:=0       │    RgM:=FLAGS      │
           │001011│ 11│                 │    RgN.C:=1       │    RgM:=FLAGS      │
           │001100│ 12│                 │    RgN.N:=0       │    RgM:=FLAGS      │
           │001101│ 13│                 │    RgN.N:=1       │    RgM:=FLAGS      │
           │001110│ 14│                 │    RgN.V:=0       │    RgM:=FLAGS      │
           │001111│ 15│                 │    RgN.V:=1       │    RgM:=FLAGS      │
           │010000│ 16│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │010001│ 17│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │010010│ 18│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │010011│ 19│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │010100│ 20│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │010101│ 21│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │010110│ 22│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │010111│ 23│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │011000│ 24│                  RgN:=FLAGS за искл. RgM:=FLAGS за искл. │
           │011001│ 25│                  RgN.C:=not CO       RgM.C:=not CO       │
           │011010│ 26│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │011011│ 27│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │011100│ 28│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │011101│ 29│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │011110│ 30│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │011111│ 31│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100000│ 32│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100001│ 33│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100010│ 34│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100011│ 35│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100100│ 36│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100101│ 37│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100110│ 38│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │100111│ 39│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │101000│ 40│                  RgN:=FLAGS за искл. RgM:=FLAGS за искл. │
           │101001│ 41│                  RgN.C:=not CO       RgM.C:=not CO       │
           │101010│ 42│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │101011│ 43│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │101100│ 44│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │101101│ 45│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │101110│ 46│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │101111│ 47│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110000│ 48│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110001│ 49│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110010│ 40│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110011│ 51│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110100│ 52│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110101│ 53│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110110│ 54│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │110111│ 55│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │111000│ 56│                  RgN:=FLAGS за искл. RgM:=FLAGS за искл. │
           │111001│ 57│                  RgN.C:=not CO       RgM.C:=not CO       │
           │111010│ 58│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │111011│ 59│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │111100│ 60│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │111101│ 61│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │111110│ 62│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           │111111│ 63│                 │    RgN:=FLAGS     │    RgM:=FLAGS      │
           └──────┴───┴─────────────────┴───────────────────┴────────────────────┘
 Примечание: если мнемоника не задана, то нужно применять команду MASK;
             разорванные линии в таблице означают, что дана одна
             команда для двух кодов.
 Примечание.
           Значения вводятся в двоичном коде, на что указывает
           символ '¤' над идентификатором поля (IM¤).
           При вводе новой команды задается код 000000


 ┌─────────╖
 │E.C,Z,N,V║  ПОРАЗРЯДНОЕ РАЗРЕШЕНИЕ ЗАПИСИ В РЕГИСТР RgM.
 ╘═════════╝   ───────────────────────────────────────────┘
 Назначение.
           Разрешение записи меток в один из разрядов  регистра
           меток RgM ~0094микросхемы ВР2~. Запись осуществляется  при
           условии, что ~0568сигнал СЕМ=0~
 Уровни   :  0 - Активный  (запись разрешена)
             1 - Пассивный (запись запрещена).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды поразрядная запись для всех меток разрешена.



 ┌─────────╖
 │  OECT   ║  РАЗРЕШЕНИЕ ВЫДАЧИ КОДА УСЛОВИЯ НА ВЫХОД СТ.
 ╘═════════╝   ──────────────────────────────────────────┘
 Назначение.
           Разрешение выдачи кода условия на выход CT микросхе-
           мы ~0094КМ1804ВР2~. При этом формируемый сигнал на  выходе
           СТ определяется кодом в  ~0369поле  BP2_MI¤.5-0~  (разряды
           5-0 кода микрокоманды микросхемы ВР2). Сигнал логи-
           ческого условия формируется при OECT=0.
 Уровень :
           0 - Активный  (формирование разрешено)
           1 - Пассивный (формирование  запрещено).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды формирование логического ус-
           ловия запрещено.

 ┌─────────╖
 │ CEN,CEM ║  РАЗРЕШЕНИЕ ЗАПИСИ МЕТОК В РЕГСТИРЫ RgN/RgM.
 ╘═════════╝   ──────────────────────────────────────────┘
 Назначение.
           Разрешение записи меток в регистры меток RgN и RgM
           микросхемы ~0094МК1804ВР2~ соответственно.
 Уровень : 0 - Активный  (запись разрешена)
           1 - Пассивный (запись запрещена).
 Примечание.
           Значение вводится в двоичном кода.
           При вводе новой команды запись в регистры запрещена.

 ┌─────────╖
 │   SE    ║  РАЗРЕШЕНИЕ ВЫПОЛНЕНИЯ СДВИГА.
 ╘═════════╝   ────────────────────────────┘
 Назначение.
           Разрешение выполнения сдвига в микросхеме ~0094МК1804ВР2~.
 Уровень : 0 - Активный  (сдвиг разрешен)
           1 - Пассивный (сдвиг запрещен).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды сдвиги запрещены.


 ┌─────────╖
 │ MSA,MSB ║  ВЫБОР ИСТОЧНИКОВ АДРЕСА ОПЕРАНДОВ.
 ╘═════════╝   ─────────────────────────────────┘
 Назначение.
           Выбор истчника операндов в АЛУ (ПМК  или  РА).  Поле
           содержит сигналы управления  мультиплексором  выбора
           источника адреса операнда для операции в АЛУ.
 Значение : 0 - Номер регистра микросхемы КМ1804ВС1  извлекает-
                ся  из  ПМК;
            1 - Номер регистра микросхемы КМ1804ВС1  извлекает-
                ся из внешнего регистра.
 Примечание.
           Значения вводятся в двоичном коде.
           При вводе новой команды мультиплексор выбирает номер регистра из
           памяти микрокоманд.


 ┌─────────╖
 │  WA,WB  ║  ЗАПИСЬ ИНФОРМАЦИИ В РЕГИСТРЫ ВЫБОРА ОПЕРАНДОВ АЛУ.
 ╘═════════╝   ─────────────────────────────────────────────────┘
 Назначение.
           Сигнал низкого уровня обеспечивает  запись  информа-
           ции c системной шины данных в  4-разрядные  регистры
           (RA,RB) выбора операнда АЛУ.  Номера  разрядов  шины
           данных используемых для загрузки  регистров  опреде-
           ляются при настройке системы.
 Уровень : 0 - Активный  (запись);
           1 - Пассивный (хранение).
 Примечание.
           Значения вводятся в двоичном коде.
           При вводе новой команды запись в регистры запрещена.








      ┌───────────────────────────────────────────────────╖
      │  3. ПОЛЕ БМУ (блок микропрограммного управления). ║
      ╘═══════════════════════════════════════════════════╝

 Блок микропрограммного  управления  построен  с  использованием
 микросхемы  КМ1804ВУ4,  которая  предназначена  для  управления
 последовательностью  выборки микрокоманд из памяти  микрокоманд
 (ПМК).Микросхема обеспечивает формирование 12-разрядного адреса
 микрокоманды, т.е.  обьем ПМК может составлять 4096 слов.  Каж-
 дая микрокоманда, хранящаяся в ПМК содержит поля,  управляющие
 микросхемой КМ1804ВУ4 и обрамляющим оборудованием.

 Включает:
           Микросхема ВУ4:
           ~0654BУ4_MI¤ - Микрокоманда~;
           ~0698CCE     - Разрешение анализа условия~;
           ~0710COM     - Инвертирование входа условия~;
           ~0722CI      - Формирование адреса следующей микрокоманды~;
           ~0739RLD     - Безусловная загрузка регистра адреса/счетчика~;

           ~0752MS      - Мультиплексор выбора сигнала условия~.


 ┌───────────╖
 │BУ4_IM¤.4-0║  МИКРОКОМАНДА МИКРОСХЕМ КМ1804ВУ4.
 ╘═══════════╝   ────────────────────────────────┘
 Назначение.
           Поле микрокоманды ~0635микросхемы ВУ4~ (блок микропрограм-
           много управления). Соответствие между  кодом  опера-
           ции и выполняемой функцией приведено в таблице.
 ┌────┬─────────────────┬───────────────────────────────────────────────┐
 │ MI │                 │                                               │
 │3210│   Мнемоника     │      микрокоманда выполняемая на ВУ4          │
 ├────┼─────────────────┼───────────────────────────────────────────────┤
 │0000│ JZ ;            │переход к нулевому адресу                      │
 │0001│ CJS Cond,~0690Addr~ ; │условный переход к подпрограмме по  адресу из  │
 │    │                 │регистра микрокоманд                           │
 │0010│ JMAP Addr ;     │переход к адресу из дешифратора команд         │
 │0011│ CJP Cond,Addr ; │условный переход к адресу из регистра микроко- │
 │    │                 │манд                                           │
 │0100│ PUSH Cond,Addr ;│запись в стек и условная запись в регистр адре-│
 │    │   (PUSH ;)      │са                                             │
 │0101│ JSRP Cond,Addr ;│переход к одной из двух подпрограмм: по адресу │
 │    │                 │либо из РА, либо из регистра микрокоманд       │
 │0110│ CJV Cond ;      │условный переход к адресу из внешнего источника│
 │0111│ JRP Cond,Addr ; │переход к адресу, условно выбираемому либо из  │
 │    │                 │ РА,  либо из регистра микрокоманд             │
 │1000│ RFCT ;          │повтореное цикла, если счетчик РА <> 0         │
 │1001│ RPCT Addr ;     │повтореное адреса из регистра микрокоманд, если│
 │    │                 │счетчик РА <> 0                                │
 │1010│ CRTN Cond ;     │условный возврат из подпрограммы               │
 │1011│ CJPP Cond,Addr ;│условный переход к адресу из регистра микроко- │
 │    │                 │манд и считывание из стека                     │
 │1100│ LDCT Addr ;     │запись в РА                                    │
 │1101│ LOOP Cond ;     │условное прекращение цикла                     │
 │1110│ CONT ;          │продолжение работы                             │
 │1111│ TWB Cond,Addr ; │ветвление на три направления                   │
 └────┴─────────────────┴───────────────────────────────────────────────┘
 где Cond - проверяемое условие;
     ~0048Addr - подаваемые на шину адресa ветвления данные (12 разрядов)~

 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤).
           При вводе новой команды задается код 1110 (CONT).


 ┌────────╖
 │  CCE   ║  РАЗРЕШЕНИЕ АНАЛИЗА СИГНАЛА УСЛОВИЯ.
 ╘════════╝   ──────────────────────────────────┘
 Назначение.
           Разрешение анализа сигнала условия.
 Уровень:  0 - Пасивный (анализ запрещен)
           1 - Aктивный (анализ разрешен).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды анализ условия запрещен.


 ┌─────────╖
 │  COM    ║  ИНВЕРТИРОВАНИЕ ВХОДНОГО УСЛОВИЯ.
 ╘═════════╝   ───────────────────────────────┘
 Назначение.
           Инвертирование входного условия. Обеспечивает инвер-
           тирование анализируемого в БМУ сигнала.
 Уровень : 0 - Пасивный (инвертирование запрещено)
           1 - Aктивный (инвертирование разрешено).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды входное условие не инвертируется.

 ┌─────────╖
 │   CI    ║  СИГНАЛ ВЫЧИСЛЕНИЯ АДРЕСА СЛЕДУЮЩЕЙ МК.
 ╘═════════╝   ─────────────────────────────────────┘
 Назначение.
            Формирование адреса следующей микрокоманды. В  каж-
            дом такте к выходному адресу прибавляется  значение
            сигнала на входе СI, что обеспечивает  автоматичес-
            кое вычисление адреса следующей микрокоманды.
 Уровень : 0 - Пасивный (не формируется адрес следующей  микро-
               команды);
           1 - Aктивный (формируется адрес  следующей  микроко-
               манды);
 Примечание.
            Значение вводится в двоичном коде.
            При вводе новой команды инкремент регистра задан.


 ┌─────────╖
 │   RLD   ║  БЕЗУСЛОВНАЯ ЗАГРУЗКА РА/Сч.
 ╘═════════╝   ──────────────────────────┘
 Назначение.
           Безусловная загрузка регистра адреса/счетчика значе-
           ние с шины адреса ветвления.
 Уровень : 0 - Активный  (загрузка разрешена)
           1 - Пассивный (загрузка запрещена).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды запись в регистр адреса запрещена.


 ┌─────────╖
 │   MS    ║  МУЛЬТИПЛЕКСОР УСЛОВИЙ.
 ╘═════════╝   ─────────────────────┘
 Назначение.
           Мультиплексор выбора сигнала условия. Этот сигнал (от
           0 до 7) обеспечивае подачу на вход логического усло-
           вия одного из 8 сигналов,  настройка  которых  выпол-
           няется при комутации связей.
                ┌────────┬────────┐
                │управле-│  выход │
                │  ние   │   MS   │
                ├────────┼────────┤
                │   000  │  Z     │
                │001..110│ L1..L6 │
                │   111  │  NZ    │
                └────────┴────────┘
 Примечание.
           Ко входам с 1 по 6 возможно подлючение любых сигналов,
           предусмотренных в настройке.
           При вводе новой команды код выбора входа MS задан 000.






       ┌─────────────────────────────────────────────╖
       │ 4. ПОЛЕ БПП (болк приоритетных прерываний). ║
       ╘═════════════════════════════════════════════╝

 Микросхема  КМ1804ВН1 - это  8-разрядная  микропрограммируемая
 наращиваемая схема векторного приоритетного прерывания,  кото-
 рая производит приоритетную обработку запросов на  прерывания,
 поступающих по восьми шинам от различных устройств. Ниже  при-
 ведены поля, обеспечивающие управление работой БПП:

 Включает:
           ~0782Микросхема КМ1804ВН1~:
           ~0796BН1_MI¤ - Микрокоманда~;
           ~0832EINS    - Разрешение приема инструкции~;
           ~0845EV      - Разрешение выдачи константы  ПЗУ  векторов~
                     на ШД.


 ┌─────────╖
 │ BH1_MI¤ ║  МИКРОКОМАНДА МИКРОСХЕМЫ КМ1804ВН1.
 ╘═════════╝   ─────────────────────────────────┘
 Назначение.
           Поле микрокоманды микросхемы ~0782КМ1804ВН1~ (блок приори-
           тетных прерываний). Соответствие между кодом  опера-
           ции и выполняемой функцией приведено в таблице.
           ┌────┬─────────────┬─────────────────────────────────┐
           │ MI │             │микрокоманда, выполняемая на ВН1 │
           │3210│  мнемоника  │   (при сигнале EINS = 0 )       │
           ├────┼─────────────┼─────────────────────────────────┤
           │0000│ RESET ;     │общая очистка                    │
           │0001│ RESET IR ;  │очистка IR                       │
           │0010│ CLR IR,Val ;│очистка IR сигналами с шины маски│
           │0011│ CLR IR,MR ; │очистка IR под управлением MR    │
           │0100│ CLR IR,VR ; │очистка IR под управлением VR    │
           │0101│ READ VR ;   │чтение VR                        │
           │0110│ READ SR ;   │чтение SR                        │
           │0111│ ERAD MR ;   │чтение MR                        │
           │1000│             │установка MR                     │
           │1001│ LOAD SR,Val;│загрузка SR                      │
           │1010│ CLR MR,Val ;│поразрядная очистка MR           │
           │1011│ SET MR,Val ;│поразрядная установка MR         │
           │1100│ RESET MR ;  │очистка MR                       │
           │1101│ DI ;        │запрет запроса прерывания        │
           │1110│ LOAD MR,Val;│загрузка MR                      │
           │1111│ EI;         │разрешение запроса прерывания    │
           └────┴─────────────┴─────────────────────────────────┘
 Примечание.
           Значения вводятся в двоичном коде, на что  указывает
           символ '¤'над идентификатором поля (IM¤). При  вводе
           новой команды в это поле  записывается  код  команды
           общая очистка, но при этом ~0886сигнал EINS~=1, что приво-
           дит к тому, что инструкция не выполняется.


 ┌─────────╖
 │  EINS   ║  РАЗРЕШЕНИЕ ПРИЕМА ИНСТРУКЦИИ.
 ╘═════════╝   ────────────────────────────┘
 Назначение.
           Разрешение приема инструкции. Обеспечивает  прием  к
           выполнению инструкции заданной в ~0796поле ВН1_IM¤~.
 Уровень : 1 - Пасивный (микрокоманда на ~0782ВН1~ не выполняется);
           0 - Aктивный (микрокоманда на ВН1 выполняется).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды подача кода команды на м/с
           КМ1804ВН1 запрещена.

 ┌─────────╖
 │   EV    ║  РАЗРЕШЕНИЕ ВЫДАЧИ КОНСТАНТЫ ИЗ ПЗУ ВЕКТОРОВ.
 ╘═════════╝   ───────────────────────────────────────────┘
 Назначение.
           Активный уровень сигнала обеспечивает выдачу  16-раз-
           рядной константы из 8-адресного ПЗУ векторов на сис-
           темную шину данных. Адресом для ПЗУ является  3-раз-
           рядный вектор, ~0782выдаваем КПП~  (контроллер  приоритет-
           ных прерываний). Значения констант, хранимых в  ПЗУ,
           заносятся при настройке системы.

 Уровень : 1 - Пасивный (константа не выдается, т.к. выходы ПЗУ
               находятся в третьем  состоянии);
           0 - Aктивный (выдача константы).
 Примечание.
           Значение вводится в двоичном коде.
           При вводе новой команды выдача константы запрещена.





               ┌───────────────────────────────╖
               │  5. Поле управляющих сигналов.║
               ╘═══════════════════════════════╝
 Включает:
           I   - сигнал чтения с внешнего устройства;
           O   - сигнал записи на внешнее устройство;
           R   - сигнал чтения из памяти;
           W   - сигнал записи в память;
           EWH - сигнал записи в старшие разряды регистра адреса;
           EWL - сигнал записи в младшие разряды регистра адреса.











                           ╔═══════════════╗
                           ║~1001C O M A N D O R~║
                           ╚═══════════════╝

   Мнемонический двухпроходный ассемблер учебной системы "COMPLEX"
   ═══════════════════════════════════════════════════════════════

                               ОПИСАНИЕ
                               ════════

                              Содержание
                              ══════════

 ~0999Предисловие~.
 1. ~1019Исходный файл~.
    - Правила написания:
      1) ~1023о написании отдельных мнемоник~;
      2) ~1028о формате исходного файла~;
      3) ~1035об использовании национального алфавита~.
2. ~1061Директивы ассемблера~.
      1) ~1067директива  размещения исполнительного кода ORG~;
      2) ~1075директива  задания метки и(или) соответствия EQU~;
      3) ~1092директива  задания  коммутации  условий для БМУ LINK~.
3. ~1143Числовые константы~.
    - ~1149Виды констант~.
4. ~1160Метки~.
    - ~1165Правила написания~.
5. ~1183Комментарии~.
6. ~1200Структура задания микрокоманды~.
    - Микрокоманда по умолчанию:
      1) ~1212поле констант~;
      2) ~1216поле БОД~;
      3) ~1238поле БМУ и БПП~;
      4) ~1251поле ОП, ВУ, РА~.
7. ~1262Структура команд ассемблера~.
    - Группы команд:
      1) ~1292арифметико-логические команды~;
      2) ~1511команды передачи управления~;
      3) ~1644команды задания режимов работы устройств~;
      4) команды разрешения-запрета (защелки).
    - Правила написания:
      1) ~1279об операторе задания микрокоманды~;
      2) ~1281об имени команды~;
      3) ~1283об операндах команды~;
      4) ~1288об операторе разделения операндов~;
      5) ~1290об операторе конца команды~.
8. ~1292Арифметико-логические команды~.
  8.1. ~1З21задание сдвигов регистров~.
    - ~1331об использовании оператора модификации сдвига~;
    - ~1344как происходит сдвиг в БОД~;
    - ~1362виды стандартных сдвигов~;
    - ~1379задание общего типа сдвига~.
  8.2. ~1421Задание приемника результата~.
    - ~1425о задании приемника с использованием внешнего регистра RB~.
  8.3. ~1432Задание операндов, над которыми выполняется операция~.
    - ~1440о задании одного из операндов по умолчанию~.
  8.4. ~1462Задание входного переноса~.
    - ~1467о возможных труднораспознаваемых ошибках при задании переноса~;
    - ~1476об использовании оператора инверсии подаваемого переноса~.
9. ~1511Команды передачи управления~.
  9.1. ~1616Операнды задания условия~.
    - ~1639о задании инверсии условия~.
10. ~1644Команды обработки прерываний~.
11. ~1711Команда загрузки регистров LOAD~.
      1) ~1717загрузка регистров задания операнда блока АЛУ~;
      2) ~1725загрузка регистров меток блока управления сдвигами~;
      3) ~загрузка регистров маски  и  состояния  блока  обработки прерываний~;
12. ~1756Команда задания поля микрокоманды  MASK~.
      1) ~1763полное поле микрокоманды АЛУ~;
      2) ~1766поле приемника  результата в АЛУ~;
      3) ~1768поле операции в АЛУ~;
      4) ~1769поле операндов в АЛУ~;
      5) ~1770номер первого РОНа в АЛУ~;
      6) ~1771номер второго РОНа в АЛУ~;
      7) ~1772поле констант~;
      8) ~1773полное поле микрокоманды устройства управления сдвигами~;
      9) ~1775поле управления сигналами  переноса  CI~;
      10) ~1777поле управления  выполнением  сдвигов~;
      11) ~1781поле управления  выхода кода условия~;
      12) ~1781поле загрузки регистров меток~;
      13) ~1784поле микрокоманды устройсва обработки прерываний~;
      14) ~1787поле микрокоманды устройства управления~;
      15) ~1790поле мультиплексора задания условия~.
13.  ~1794Служебные  команды~.
      1) ~1803управление выходом АЛБ~;
      2) ~1807управление устройством управления сдвигом на м/с ВР2~;
      3) ~1811управление устройством упраления на м/с ВУ4~;
      4) ~1815управление устройством обработки  прерываний  на  м/с ВН1~;
      5) ~1818управление внешними устройствами и памятью~.
 Приложение 1:
    - ~1832Таблица зарезервированных мнемоник~:
      1) ~1834директивы~;
      2) ~1837команды~;
      3) ~1852операнды~;
      4) ~1874прочие~.
 Приложение 2:
    - ~1878сообщения об ошибках~.
 Приложение 3:
    - ~1905Пример написания программы~.












                         Предисловие.
                         ────────────
  Мнемонический двухпроходный  ассемблер  "COMANDOR"  предназначен для
облегчения кропотливого труда программиста  по  написанию  микрокоманд
микропроцессорной системы "COMPLEX",  отладке и выполнению программ на
программном  эмуляторе и быстрому внесению изменений в исходный текст.
  Результатом работы  ассемблера  по  трансляции  исходного текстового
файла является файл данных с расширением  '.pmk',  являющийся  в  свою
очередь  исходным  для программного эмулятора микропроцессорного комп-
лекса.
  Процесс трансляции исходного файла осуществляется в два прохода.  Во
время первого прохода происходит определение объема  выходного  файла,
формируются таблицы меток и соответствий, а также проводится предвари-
тельный синтаксический анализ. Во время второго прохода непосредствен-
но  формируются коды микрокоманд.  В случае обнаружения синтаксической
либо семантической ошибки в исходном тексте процесс трансляции прекра-
щается с выдачей сообщения о характере ошибки и строки текста,  на ко-
торой она была обнаружена. Список всех сообщений об ошибках приведен в
приложении 2 - в таблице сообщений об ошибках.

                         1. Исходный файл.
                         ────────────────-
   В качестве исходного файла для трансляции берется обычный текстовый
файл, для которого справедливы следующие нормы написания:
    1) все  цельные  мнемоники должны писаться слитно,  различия между
       заглавными и строчными буквами алфавита  ассемблер  не  делает,
       поэтому мнемоники
               'ADD' 'AdD' 'ADd' 'Add' 'aDD'
       являются идентичными и ассемблером не различаются;
    2) между отдельными мнемониками,  цифровыми константами,  метками,
       соответствиями и комментариями может быть сколько угодно незна-
       чащих символов и управляющих знаков,  таких как пробел, табуля-
       ция,  возврат каретки, перевод строки и т.п., никаких ограниче-
       ний на размещение команд по тексту не налагается; это позволяет
       программисту достаточно свободно относиться к тексту пограммы с
       точки зрения ее внешнего вида;
    3) следует  обратить внимание на то,что хотя ассемблер и поддержи-
       вает верхнюю часть таблицы символов ASCII,  в  которую  включен
       национальный алфавит, но все стандартные мнемоники, приведенные
       в приложении 1 - таблице зарезервированных мнемоник  оттрансли-
       рованы для латинского алфавита, и поэтому следует аккуратно от-
       носиться к набивке мнемоник,  имеющих в своем составе  символы,
       одинаково пишущиеся, но имеющие разную кодировку. Данное прави-
       ло однако не означает,  что программист должен вообще  избегать
       национального алфавита, кроме как для написания поясняющих ком-
       ментариев,  что приходится сплошь и рядом видеть в таких языках
       программирования,  которые были изначально ориентированы только
       на англоязычного пользователя.  С  помощью  структуры  меток  и
       соответствий  пользователь может в любом месте своего исходного
       файла задать понятное для него обозначение и использовать его в
       дальнейшем  на  равне со стандартной мнемоникой языка.  Поэтому
       такая, например, команда, как
                       Сложить операнд1,  операнд2; не будет содержать
       никаких ошибок и будет правильно оттранслирована при  том,  ко-
       нечно,  условии,  что все приведенные в примере мнемоники будут
       заранее соответсвующим образом описаны.
  Строгое придерживание правил написания команд, аккуратность в наборе
текста программы будут гарантировать быструю трансляцию  и  отладку  -
практика свидетельствует, что большинство ошибок возникает прежде все-
го из-за небрежного стиля написания и неточного знания самого  объекта
разработки.

                           2. Директивы ассемблера.
                           ───────────────────────-
   Директивы не транслируются в исполнительные коды.  Они служат в ка-
честве указателей ассемблеру на то или иное действие которое он должен
произвести с операндами, приложенными к директиве. Рассмотрим директи-
вы, поддерживаемые данным ассемблером и правила работы с ними:
    1)ORG директива  размещения исполнительного кода ORG либо $ указы-
       вает ассемблеру на то,  что ближайшая следующая  за  директивой
       микрокоманда  будет размещаться в памяти микрокоманд по адресу,
       указанному после директивы ORG.  Адрес задается в виде числовой
       константы либо ранее определенной метки. Адрес не должен превы-
       шать последнего адресуемого поля  микрокоманд.  Ниже  приведены
       несколько примеров задания размещения:
                         org 010h org start $ 100
    2)EQU директива  задания метки и(или) соответствия EQU либо # ука-
       зывает ассемблеру на то,  что он должен запомнить следующую  за
       директивой мнемонику в качестве метки(соответствия) и, встречая
       ее в дальнейшем,  считать метку за числовую константу,  а соот-
       ветсвие  за  ту мнемонику,  которая была задана после директивы
       EQU. Соответствия служат для замены стандартных мнемоник команд
       и  операндов  на  более подходящий для программиста эквивалент,
       яснее отражающий в данном контексте смысл поизводимых действий.
       Задание  метки  осуществляется  написанием  ключевого слова EQU
       (#),  имени метки и через оператор разделения  ":"  эквивалента
       метки. Например:
                           equ start : 10
                           equ add : сложить
                           equ r4 : операнд1
                           equ операнд2 : 10
                           $ start
                           {сложить операнд1, операнд2;}
    3)LINK директива  задания  коммутации  условий для БМУ LINK либо @
       позволяет прямо в исходном тексте программы приводить необходи-
       мую для эмулятора информацию по коммутации сигналов на мультип-
       лексоре задания условий MS, а также, при дальнейшем использова-
       нии  этих  сигналов  в качестве признаков переходов,  оказывает
       влияние на задание номера входа условия в поле MS.BY4  микроко-
       манды. Написание директивы LINK в основном аналогично директиве
       EQU. В качестве первого операнда должен указываться номер входа
       мультиплексора L1..L6,  а затем, после оператора разделения ":"
       операнд коммутируемого сигнала. Коммутироваться могут следующие
       сигналы:
       1)IRQ0..IRQ7  -  сигнал прерывания с одного из восьми подключа-
                        емых внешних устройств;  в программе при зада-
                      нии  условия  необходимо указывать вход мультип-
                      лексора L1..L6;
       2)RD_MEM, RD_IO  - сигналы подтверждения готовности из памяти и
                         с внешних устройств; задание в программе ана-
                         логично     заданию    сигналов    прерывания
                         IRQ0..IRQ7.
       3) BP2_CT - сигнал выхода кода условия с блока управления сдви-
                   гами; в дальнейшем, в программе при задании условия
                   выполнения какой-либо операции на БМУ необхоимо бу-
                   дет указывать не эту мнемонику,  а  непосредственно
                   сигнал, который коммутируется на м/с ВР2 и выдается
                   через выход  CT.  Подробнее  об  операндах  задания
                   условия  написано  в разделе 9.1.  данного описания
                   (операнды  задания  условия),  а  здесь   приведены
                   несколько  примеров  задания директивы LINK в прог-
                   рамме и ее дальнейшего использования:
                   LINK L1 : BP2_CT \сигнал  выхода  кода  условия  CT
                                    \скоммутирован на  первый вход  MS
                   LINK L4 : IRQ3   \четвертый   вход   мультиплексора
                                    \скоммутирован  с запросом третье-
                                    \го внешнего  устройства на преры-
                                    \вание
                   ..............

                   PUSH NZ,10;      \запоминаем на стеке адрес текущей
                                    \команды и загружаем 10 в РА
                   .....

                   CJPP RM_C,next;  \проверяем метку С регистра  меток
                                    \RgM и по 1 выходим из цикла
                   ......

                   RFCT;            \возвращаемся  на  вершину   цикла
                                    \пока РА не равно нулю
                   ......
           next


                         3. Числовые константы.
                         ──────────────────────
   Числовые константы применяются при задании числовых операндов,  ад-
ресов переходов  и загрузочных констант.  Признаком константы является
  цифра в начале мнемоники.  Ассемблер различает четыре основные формы
  задания чисел:
    1) десятичная форма;
    2) шестнадцатиричная форма задается символом 'H' на конце констан-
       ты;
    3) восьмеричная  форма  задается  символом 'O' на конце константы;
    4) двоичная форма задается символом '%' на  конце  константы;  Все
       константы не должны превышать размера машинного слова:
       (10) -   65535
       (16)   -  0FFFFh
       (8)  -  177777O
       (2)  -  1111111111111111%

                            4. Метки.
                            ─────────
   Метки служат для замены часто  используемых  констант  на  символи-
ческий  эквивалент  с  целью повышения читабельности исходного текста.
Основные правила написания меток:
    1) символы, которые не могу входить в состав метки:
                  '#','$','('..'/','['..']','{'..'}'
    2) метка не может начинаться начинаться с цифры;
    3) признаком конца метки служит любой следующий разделитель:
       ',',';','{','}','.',#32(пробел),#13(возврат каретки),
       #9(табуляция);
    4) метка не должна совпадать с зарезервированной мнемоникой коман-
       ды  или операнда (смотри приложение 1 - таблицу зарезервирован-
       ных мнемоник);
    5) длина метки при задании может быть произвольной,  но ассеммблер
       распознает только первые десять символов; поэтому при использо-
       вании  метки  длиной более десяти символов при трансляции могут
       возникать непредвиденные ошибки;
  Примеры написания меток: - Loop
                           - First_go
                           - Метка_1
                           - Слишком_длинная_метка_и_поэтому_неверная

                           5. Комментарии.
                           ──────────────-
   Комментарии используются для пояснения работы той или иной команды,
либо всей программы в целом, а также для "закомментирования" какой-ли-
бо проверочной команды.
  Признаком начала комментария служит символ '\'.  Далее ассемблер иг-
норирует все встречающиеся символы до следующего  '\'  либо  до  конца
строки. Например:
     \ краткий пример программы
     { add RB,X,Z;  } \записываем X в R10
     { add R11,Y,Z; } \записываем Y в R11
     { add RQ,R10,Z; \переписываем X в RQ
       cjp l1,compute; } \если число положительное то переходим на вы-
                         \числение
     { sub RQ,Z,RQ;  } \иначе   приводим  X  к  положительному   числу
     { sub R11,Z,R11; }\преобразуем Y для правильного знака результата

                6. Структура задания микрокоманды.
                ─────────────────────────────────-
   Память микрокоманд микропроцессорного комплекса для которого разра-
батывался данный ассемблер содержит отдельные микрокоманды,  каждая из
которых  делится  на поля.  Команда ассемблера задает то или иное поле
микрокоманды. Вся микрокоманда задается оператором задания микрокоман-
ды,  который описывается с помощью пары фигурных скобок { ... }. Таким
образом совокупность команд ассемблера,  ограниченная оператором зада-
ния  микрокоманды  представляет  из  себя  одну микрокоманду микропро-
цессорного комплекса. Внутри скобок может содержаться любое количество
команд ассемблера, либо ни одной. Пустая микрокоманда означает задание
полей по умолчанию:
  1)поле констант:
         -  D = 0;       (шина данных-передача данных в АЛУ: 0)
         -  OED=1;       (разрешение подачи данных с поля D на шину
                          данных:не разрешено)
  2)поле БОД:
    ВС1: -  MI = 64;     (микрокоманда: NOP; R+S+CI; A,Q)
         -  A = 0;       (адрес РОНа для записи в Rg A: R0)
         -  B = 0;       (адрес РОНa для записи/чтения Rg B: R0)
         -  OE = 1;      (разрешение выдачи результата на нишу данных:
                          не разрешено)
    ВР2: -  MI = 0;      (микрокоманда)
         -  E.Z = 0;     (разрешение записи меток в RgM: разрешены)
         -  E.N = 0;
         -  E.C = 0;
         -  E.V = 0;
         -  OECT= 1;     (разрешение выдачи кода условия: не разрешен)
         -  CEM = 1;     (разрешение записи меток в Rg M и N: не раз-
                          решен)
         -  CEN = 1;
         -  SE  = 1;     (разрешение выполнения сдвига: не разрешен)
    Внешние регистры задания операнда АЛУ:
         -  MSA = 0;     (выбор истчника операндов в АЛУ (ПМК или РА,
                          РБ): ПМК)
         -  MSB = 0;
         -  WA = 1;      (запись в регистры выбора операнда АЛУ: нет)
         -  WB = 1;
  3)поле БМУ и БПП:
    ВУ4: -  MI = 14;     (Микрокоманда: CONT)
         -  CCE = 1;     (разрешение анализа условия: запрещен)
         -  COM = 1;     (инвертирование входа условия: инвертировать)
         -  CI = 1;      (формирование следующего адреса микрокоманды)
         -  RLD = 1;     (разрешение записи в регистр адреса/счетчика:
                          запрещен)
    Мультиплексор выбора сигнала условия:
         -  MS = 0;
    ВН1: -  MI = 0;      (Микрокоманда: RESET)
         -  EINS = 1;    (Разрешение приема инструкции: не разрешен)
         -  EV = 1;      (Разрешение выдачи адреса прерывания из ПЗУ
                          векторов на ШД: не разрешен).
  4)поле ОП, ВУ, РА:
    ВУ:  -  I =  1;      (сигнал чтения с внешнего устройства:
                          не разрешен)
         -  O = 1;       (сигнал записи на внешнее устройство:
                          не разрешен)
    ОП:  -  R = 1;       (сигнал чтения из памяти: не разрешен)
         -  W = 1;       (сигнал записи в память: не разрешен)
    РгА  -  EWH = 1;     (сигналы записи на регистр адреса старших
                          и младших разрядов: не разрешены)
         -  EWL = 1;

                  7. Структура команд ассемблера.
                  ──────────────────────────────-
   Все команды ассемблера можно разделить в зависимости от  того,  для
каких устройств микропроцессорного комплекса они разработаны.  Поэтому
мы можем условно выделить все команды в следующие группы:
    1) арифметико-логические команды;
    2) команды передачи управления;
    3) команды задания режимов работы устройств;
    4) команды разрешения-запрета (защелки).
  эти команды различаются между собой не только в правилах  написания,
что включает в себя строгость задания операндов, совместимость  внутри
группы и т.д., но и по формированию кодов отдельных полей  микрокоман-
ды. Так одни команды могут строго задавать какое-либо поле микрокоман-
ды, в то время как другие лишь модифицируют это поле.  Более  подробно
правила написания каждой команды будут  рассмотрены  в  дальнейшем,  а
здесь стоит остановиться на общей для всех команд методике их  написа-
ния:
    1) все  команды ассемблера должны помещаться внутри операторов за-
       дания микрокоманды '{}';
    2) команда должна начинаться с имени команды, которое является за-
       резервированной мнемоникой;
    3) команда  может быть безоперандной или может содержать от одного
       до пяти операндов; между именем команды и первым операндом дол-
       жен  быть  хотя-бы один разделитель,  в качестве которого могут
       служить следующие символы:  #32(пробел),  #13(возврат каретки),
       #9(табуляция), #10(перевод строки);
    4) операнды разделяются между собой оператором разделения операндов
        ',';
    5) команда обязана заканчиваться оператором конца команды ';';

                     8. Арифметико-логические команды.
                     ────────────────────────────────-
   Арифметико-логические команды  служат  для выполнения микроопераций
сложения, вычитания, поразрядных логических операций, операций сдвига,
загрузки,  инвентирования  отдельных  регистров Арифметико Логического
Блока, построенного на четырех микросхемах ВС1 и одной м/с ВР2 и др.
  Всего есть 10 команд,  форматы  которых  будут  рассмотрены в данном
разделе:
    1)ADD  - арифметическое сложение;
    2)SUB  - арифметическое вычитание;
    3)OR   - логическое сложение;
    4)AND  - логическое умножение;
    5)XOR  - логическое вычитание(исключающее "ИЛИ");
    6)NAND - логическое  умножение при котором первый опранд берется с
             инверсией;
    7)NXOR - логическое вычитание при котором результат инвертируется;
    8)MOV  - загрузка рабочих регистров блока  АЛУ ( отличается от ко-
             манды LOAD загрузки  служебных  регистров)
             (команда  MOV dest,src идентична команде ADD dest,src,z);
    9)INC  - инкрементирование регистра
             (команда INC dest идентична ADD dest,1);
    10)DEC - декрементирование регистра
             (команда DEC dest идентична SUB dest,1).
  Эти команды можно условно разбить на три подгруппы:
    1) команды арифметического сложения и вычитания ADD и SUB;
    2) команды логических операций OR, AND, XOR, NAND, NXOR;
    3) команды,  производные от команд арифметической группы MOV, INC,
       DEC.
  Все 10 арифметико-логических команд в качестве первого операнда  мо-
гут иметь необязательный опеанд задания сдвига и операнд  задания  ре-
гистра-приемника результата.

                      8.1. Задание сдвигов регистров.
                      ──────────────────────────────-
   Арифметико-логический блок,  на  котором  построено  АЛУ  микропро-
цессорного комплекса имеет в качестве одной из своих  функций  возмож-
ность одновременно с выполнением одной из арифметико-логических опера-
ций производить сдвиг регистра-приемника. Управление типом сдвига осу-
ществляется микрокомандой,  поступающей на входы MI(10-6) м/с ВР2. Сам
сдвиг задается микрокомандой MI(8) м/с ВС1.  При этом  можно  осущест-
влять и одновременный сдвиг рабочего регистра RQ. Для этого необходимо
перед операндом сдвига поставить оператор модификации
                           "@"
который и указывает ассемблеру, что производится  одновременный  сдвиг
регистра-приемника и рабочего регистра RQ. Например:
               MOV @SRA,R4,123H;
               SUB @ SR.Z , RQ , R5 , R3 ;
  Ассемблер позволяет определять любой из возможных типов сдвига, не-
посредствнно задавая его,  либо используя один из стандартных сдвигов.
Ниже приведены все возможные виды сдвигов и операнды,  с помощью кото-
рых их можно задавать.

                  Структурная схема выполнения сдвига на АЛБ
               ───────────┐            ┌────────────────────────
               ВР2        │            │                 4 x ВС1
               ═══    SLQ │<---------->│ RQ.0╟─────────────┐ ═══
                          │            │                   │
                          │            │                   │
                          │            │       ┌┬───────┬┐ │
                      SRQ │<---------->│RQ.15╟─┤│   RQ  │├─┘
                          │            │       └┴───────┴┘
                          │            │
                          │            │       ┌┬───────┬┐
                      SRB │<---------->│RB.15╟─┤│ РОН[B]│├─┐
                          │            │       └┴───────┴┘ │
                          │            │                   │
                          │            │                   │
                      SLB │<---------->│ RB.0╟─────────────┘
                          │            │

                      Стандартные типы сдвигов.
      │      логический     │    циклический   │  арифметический
      │                     │                  │
      │        SRL          │      SRC         │        SRA
      │                     │┌──────────────┐  │┌───┐
      │    ┌┬───────┬┐      ││  ┌┬───────┬┐ │  ││  ┌┴┬───────┬┐
вправо│0──>││ РОН[B]││      │└─>││ РОН[B]│├─┘  │└─>│ │ РОН[B]││
      │    └┴───────┴┘      │   └┴───────┴┘    │   └─┴───────┴┘
      │                     │                  │
      │        SLL          │      SLC         │        SLA
      │                     │ ┌──────────────┐ │ ┌───┐
      │    ┌┬───────┬┐      │ │ ┌┬───────┬┐  │ │ │  ┌┴┬───────┬┐
 влево│    ││ РОН[B]││<── 0 │ └─┤│ РОН[B]││<─┘ │ └─>│ │ РОН[B]││<── 0
      │    └┴───────┴┘      │   └┴───────┴┘    │    └─┴───────┴┘

Например:       ADD SRA,R4,0;
                XOR SLC,RQ,1010101010101010%;
  Общие типы сдвигов. Общие операнды сдвигов задаются, если ни один из
стандартных типов сдвига не подходит, либо в программе нужно специаль-
но  подчеркнуть именно такой сдвиг регистра по отношению к стандартно-
му.  Правила написания операнда общего сдвига несколько отличаются  от
написания  стандартного сдвига,  так как кроме непосредственно задания
вида сдвига (правый или левый) необходимо еще  задать  вид  вдвигаемой
информации.  Поэтому необходимо действовать,  согласуясь со следующими
положениями:
    1) задается вид сдвига - SR  для  сдвига  вправо  и  SL для левого
       сдвига;
    2) без какого-либо пробела либо другого незначащего знака ставится
       оператор задания типа сдвига ".";
    3) снова без пропуска задается вдвигаемый бит.
       Например: ADD SL.Z, R7 , R7 ; \ умножаем R7 на четыре
                 MOV SR.RM_C,RQ,R12;
Возможны следующие варианты операндов вдвигаемой в  регистры  информа-
ции:
┌─────────┬──────────────────────────────────────────────────────────┐
│         │            Вид     вдвигаемой     информации             │
│  Вид    ├─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬────┬─────┤
│ сдвига  │  Z  │ NZ  │ RM_C│ RM_N│RBO  │ RB15│RQ0  │ RQ15│ CO │NXORV│
├─────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼────┼─────┤
│правый SR│есть │есть │есть │есть │есть │ нет │есть │ нет │есть│есть │                                                            │
├─────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼────┼─────┤
│левый SL │есть │есть │есть │ нет │ нет │есть │ нет │есть │ нет│ нет │
└─────────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴────┴─────┘
    где Z и NZ - сигналы логического нуля и единицы;
        RM_C и RM_N - биты C и N регистра меток RgM  блока  управления
        сдвигами;
        RB0, RB15, RQ0, RQ15 - младший и старший  биты  соответственно
        регистра общего назначения РОН[В] и рабочего регистра RQ;
        СО - выходной перенос, сформировавшийся в результате  выполне-
        ния на АЛБ  операции;
        NXORV - данная мнемоника обозначает  подачу  сигнала,  равного
        результату операции исключающего "или" над признаками знака  и
        переполнения результата операции на АЛБ, то есть  NXORV  иден-
        тично N xor V.
  Несмотря на все многообразие рассмотренных видов сдвига в  арифмети-
ко-логических командах оказалось невозможно охватить все 32  (!)  воз-
можных сдвига, выполняемых в БОД. Для задания  любого  сдвига  следует
применять команду MASK BP2_IA6.

                 8.2. Задание приемника результата.
                 ──────────────────────────────────
   В качестве приемника результата могут выступать следующие операнды:
                      RQ, R0..R15,  RB.
   Если задан операнд RB,  то подразумевается,  что на четырехразрядню
параллельную шину адреса РОН (порт В) подается адрес,  снимаемый через
мультиплексор выбора адреса РОН с регистра адреса RB. Например, если в
регистре RB хранится 8, и мы задаем команду
                          MOV RB,10;  то это означает,  что в  регистр
общего назначения R8 будет занесено число 10.

         8.3. Задание операндов, над которыми выполняется операция.
         ─────────────────────────────────────────────────────────-
   Любая из  десяти  вышеперечисленных  команд   позволяет   выполнять
действия над двумя операндами и помещать результат операции в регистр,
в общем случае не совпадающий с операндами,  над которыми операция вы-
полнялась. Например,
                       ADD RQ,R1,R2;
                       XOR R10,R4,15.
   Но зачастую  приемник результата  одновременно  является и одним из
рабочих операндов. Тогда можно опускать написание этого операнда дваж-
ды, и ассемблер сам возьмет на себя задачу доопределения операндов ко-
манды. Например:
                  SUB RQ,RQ,1;
                  SUB  RQ,1;\вторая команда полностью идентична первой
  Вот возможные операнды, которые можно указывать при задании команды:
    1) Z - "внутренний" нуль,  специально реализованный в м/с ВС1  для
           того, чтобы не загружать лишний раз шину данных тривиальной
           информацией;
    2) RQ - рабочий регистр АЛБ;
    3) R0..R15 - один из регистров общего назначения;  обратате внима-
                 ние,  что, например, R13 - это самостоятельная мнемо-
                 ника,  и написание ее в виде R 13 недопустимо и ведет
                 к ошибке;
    4) RA,  RB - регистр общего назначения,  номер которого берется не
                из  поля  микрокоманды,  а с выходов регистров RA и RB
                микропроцессорной системы. Информация в данные регист-
                ры  заносится с шины данных по управлением сигналов из
                ПМК;
    5) числовая константа либо метка, ее заменяющая.

                   8.4. Задание входного переноса.
                   ──────────────────────────────-
   Входной перенос задается в командах первой подгруппы (ADD  и  SUB).
Этот  операнд  является необязательным и по умолчанию считается равным
нулю.  В случае явного задания переноса его необходимо указывать в ка-
честве  последнего операнда команды.  Задание операнда переноса влияет
на поле MI(5-0) блока управления сдвигами м/с ВР2 микрокоманды.  Здесь
следует  учитывать,  что  это же поле отвечает и за загрузку регистров
меток RgM и RgN м/с ВР2;  поэтому  будьте  аккуратны  в  одновременном
использовании команд арифметического сложения(вычитания) и команд заг-
рузки регистров меток,  так как может произойти добавление нежелатель-
ного входного переноса,  что исказит результат.  Транслятор ассемблера
контроля совместимости команд не ведет и ошибок при вышеуказанном слу-
чае выдавать не будет.
  Существуют следующие возможные сигналы входного переноса:
    1) Z - сигнал логического нуля;
    2) RM_C - бит С регистра метки RgM;
    3) RN_C - бит С регистра метки RgN.  Кроме того можно задавать ин-
              версию этих сигналов с помощью предшевствующего операто-
              ра инверсии "NOT". Например:
                          ADD R1,RQ,R5,RM_C;
                          SUB  RQ,R4,not  Z;
                          ADD @SRA,R5,10,not RN_C;
  Все эти сигналы можно подавать в инверсном состоянии, для чего перед
ними следует записать оператор инверсии 'NOT'.
  Еще раз обратите внимание,  что входной перенос задается только  для
команд ADD и SUB, и задание его для любой другой команды рассматривае-
мой группы не приведет ни к чему, кроме выдачи ошибки транслятором.
  Остается отметить  такую деталь:  операнд Z может использоваться как
при задании операнда операции,  так и при задании сигнала входного пе-
реноса.  Поэтому  - - это единственный случай,  когда требуется полная
форма задания команды без пропусков операндов операции,  так как иначе
транслятор  будет  рассматривать сигнал переноса как операнд операции,
что может в одних случаях привести к выдаче сообщения об ошибке
                  "Некорректное задание  операндов  АЛУ",
а в  других  случаях к генерированию неверного кода микрокоманды.  Для
случая инверсии переноса с помощью оператора "NOT" таких ошибок не бу-
дет,  так  как  транслятор однозначно понимает следующий за оператором
"NOT" операнд - как сигнал переноса. Примеры:
                          ADD R1,R4,Z,Z;
                          SUB RQ,R5,not Z;
                          ADD R12,Z,Z;      \ ошибка!!!
  Чтобы избегать  такого  рода ошибок запомните,  что задание нулевого
переноса происходит транслятором по умолчанию,  так что последний при-
мер можно записать без ошибок вот так:
                          ADD R12,Z;
или в полной форме, что также правильно:
                          ADD R12,R12,Z,Z;

                     9. Команды передачи управления.
                     ──────────────────────────────-
   Команды данной группы обрабатывают поле микрокоманды м/с ВУ4, кото-
рая является  схемой управления 12-ти разраядным адресом микрокоманд и
выполняет 16 микрокоманд.  Если при заданиии команды требуется указать
условие  ее выполнения,  то оно ставится после мнемоники команды в ка-
честве первого операнда;  если к  тому  же  требуется  указать  и  не-
посредственный  адрес  перехода,  либо (для команды LDCT) задать новое
значение регистра адреса РА, то численное значение (метка) оперирует в
команде в качестве второго операнда:
    1) JZ - переход к нулевому адресу;
              JZ;  \ безусловный переход  на нулевой адрес
    2) CJS - условный переход к подпрограмме по указанному адресу;
             CJS L1, START; \ если условие L1 выполняется,
                            \ то перейти  на  подпрограмму по адресу
                            \ START, иначе продолжить вычисления
    3) JMAP - безусловный переход по указанному адресу;
              JMAP 100;  \ перейти на адрес 100
    4) CJP  - аналогична  команде CJS, но без  загрузки в стек  адреса
              возврата;
    5) PUSH - загрузка в стек счетчика микрокоманд,  и плюс к этому по
              выполнению указанного условия выполнение LDCT;
                   PUSH not L2, 10; \ запоминаем в стеке адрес следую-
                                    \ щей команды и загружаем в РА 10,
                                    \ если условие L2 не выполняется;
              возможна безоперандная форма записи  команды  PUSH;  при
              этом условие принимается ложным и,  следовательно,  заг-
              рузки в РА не происходит.
    6) JSRP  - переход к одной из двух подпрограмм по адресу,  взятому
              либо из регистра адреса (если условие не выполнено), ли-
              бо по указанному адресу;
                   JSRP L5, 53o; \ если условие выполняется, то перехо-
                                 \ дим на выполнение команды по адресу
                                 \ 43 (53o = 43), иначе
    7) CJV - условный переход по адресу из внешнего источника;
                   CJV L3;\ если условие выполняется, то с шины данных
                          \ считывается адрес следующей микрокоманды
    8) JRP  - аналогична команде JSRP, но без загрузки в стек адреса
              возврата;
    9) RFCT - повторение цикла до тех пор,  пока не равен нулю регистр
              адреса (сравнение РА с нулем,  и если нет, то переход по
              адресу,  хранящемуся  на  вершине  стека с одновременным
              декрементированием РА);
                   PUSH NZ,10; \ запоминаем на вершине стека адрес на-
                               \ чала цикла с одновременной загрузкой в
                               \ РА числа проходов (РА выполняет роль
                               \ счетчика цикла)
                   ....

                   RFCT;       \ декрементируем РА, и пока не нуль пе-
                               \ реходим на начало цикла
   10) RPCT - аналогична команде RFCT с той разницей,  что адрес пере-
              хода берется не с вершины стека,  а из  памяти  микроко-
              манд;
                  RPCT петля; \ сравниваем РА с нулем и если РА <> 0,
                              \ то переходим на "петлю"
   11) CRTN - условный возврат из подпрограммы;
                  CRTN not NXORV; \ проверяем признак переполнения в
                                  \ системе с расширенной знаковой
                                  \ сеткой, и если переполнения нет -
                                  \ - возвращаемся из подпрограммы
   12) CJPP  -  условный  переход по указанному адресу и одновременное
              декрементирование указателя стека;
                  PUSH NZ,10;

                  .....

                  CJPP RM_C,NEXT; \ проверяем метку С регистра меток
                                  \ RgM и по 1 выходим из цикла
                  ......

                  RFCT;
   13) LDCT - запись в регистр адреса РА;
                  LDCT value;  \ загружаем РА значением value
   14) LOOP - условное прекращение цикла (если условие  в  команде  не
              выполняется,  то адрес следующей микрокоманды выбирается
              с вершины стека, иначе выполняется следующая команда);
                  PUSH; \ запоминаем адрес начала цикла

                  ......

                  LOOP not L1; \ если на входе L1 - 0, то возвращаемся
                               \ на начало цикла
   15) CONT  -  переход к выполнению следующей команды (выполняется по
              умолчанию);
   16) TWB  - условное ветвление по трем направлениям (РА сравнивается
              с нулем:  если не равен,  то РА декрементируется и далее
              выполняется LOOP,  иначе тот же LOOP,  но с выборкой ад-
              реса не из стека, а из памяти микрокоманд).
                  PUSH NZ,10;

                  .......

                  TWB NZ,NEXT; \ пока РА<>0 возвращаемя на начало цик-
                               \ ла; при РА=0 переходим на NEXT

                   9.1. Операнды задания условия.
                   ─────────────────────────────-
   Операнды задания  условия  применяются  в таких командах,  как CJS,
CJP,  PUSH, JSRP, CJV, JRP, CRTN, CJPP, LOOP и TWB. Сигнал условия по-
дается  на вход ЛУ блока микропрограммного управления через восьмивхо-
довой мультиплексор MS,  два входа которого заранее предопределены как
Z и NZ (0 и 1), а остальные шесть входов могут коммутироваться различ-
ными сигналами (см.  задание коммутации условий при  помощи  директивы
LINK).  В команде при задании операнда условий можно использовать сле-
дующие предопределенные мнемоники:
    1)Z, NZ - условие определяется как заведомо ложное (истинное);
    2)L1..L6 - сигнал условия снимается с одного из входов мультиплек-
               сора;
    3)ZO, ZC, ZN, ZV  - признаки нуля,  переноса, знака и переполнения
                        по результату выполнения операци в АЛУ;
    4)RM_Z,RM_C,RM_N,RM_V - флажки Z, C, N и V,  хранящиеся в регистре
                            меток RgM;
    5)RN_Z,RN_C,RN_N,RN_V - аналогично для RgN;
    6)NXORV - признак переполнения для системы с двумя знаковыми раз-
              рядами;
    7)ZORC - условие устанавливается истинным при установлении  в  ре-
             зультате  операции  в  АЛБ  флажка нуля либо переполнения
             (ZORC = Z or C).
  Ко всем  признакам  применимо  предварительное  написание  оператора
"not", что влияет на поле COM блока микропрограммного управления ВУ4.
  Все сигналы  необходимо  предварительно  связать  с  одним из входов
мультиплексора L1..L6 при помощи директивы LINK.

                      10. Команды обработки прерываний.
                      ────────────────────────────────-
   Команды обработки прерываний заполняют поле микрокоманды  м/с  ВН1.
Микросхема КМ1804ВН1 - это 8-разрядная микропрограммируемая наращивае-
мая схема векторного приоритетного прерывания, которая производит при-
оритетную обработку запросов на прерывания,  поступающих по восьми ши-
нам от различных устройств.
  Ниже приведены команды управления м/с и виды их написания:
    1)RESET - команда очистки;  может быть без и однооперандной;
              a)безоперандная команда  RESET  проводит  общую очистку.
              При выпонении этой команды происходит обнуление регистра
              состояния  и триггер разрешения запроса прерывания пере-
              ходит в состояние, разрешающее выход запроса прерывания,
              т.  е.  система  прерывания отреагирует на запрос любого
              приоритета.
              б)RESET MR - очистка регистра маски(обнуление всех раз-
                             рядов регистра маски);  в результате  все
                             прерывания будут размаскированы.
              в)RESET IR   - очистка регистра прерывания.
    2)CLR - команда поразрядной очистки внутренних регистров микросхе-
            мы;  применяется по отношению  к  регистрам  прерываний  и
            маски:
            а)IR - может осуществляться сигналами с шины  данных,  ре-
            гистра маски и регистра вектора. Например:
              CLR IR ,00011000% ; \очищаем 4 и 5 разряды IR
              CLR IR , MR;   \очищаем те разряды регистра прерываний,
                             \для которых соответствуют единицы в ре-
                             \гистре маски
              CLR IR , VR ;  \происходит обнуление тех разрядов IR,
                             \которым соответсвует вектор прерывания,
                             \находящийся в регистре вектора
            б)MR   - осуществляется сигналами с шины данных.
    3)SET - команда поразрядной установки регистра маски. Например:
              SET MR , 11100000%;\маскируем прерывания, поступаю-
                                 \щие с 8,7 и 6 внешних устройств;
                                 \остальные разряды регистра маски
                                 \не затрагиваются
    4)READ - команда чтения регистров м/с;  применяется по отношению к
             регистрам маски,  состояния и вектора:
            а)READ MR;
            б)READ SR;
            в)READ VR;
             при выполнении этих команд на шину данных выдаются сигна-
             лы, отражающиеся состояние соответственно регистра маски,
             состояния и вектора.
    5)DI - запрещение запроса прерываний(происходит обнуление триггера
           разрешения запроса прерывания). (команда безоперандная)
    6)EI - разрешение запроса прерывания; команда действует противопо-
           ложно команде DI. (команда безоперандная)
  Для всех команд,  где в качестве второго операнда фигурирует числен-
ное  значение,  справедлива  и укороченная форма - без прямого задания
данных;  тогда данные на шину данных будут поступать не из памяти мик-
рокоманд,  а  формирующиеся в процессе выполнения микрокоманды на мик-
ропроцессорном комплекте. Например:
                  {OE_ALU;     \разрешаем выдачу на шину данных ре-
                               \зультата выполнения операции в АЛУ
                   XOR R1,R4;  \выполняем  операцию  в АЛУ
                   CLR MR;  }  \очищаем те разряды регистра  маски,
                               \соответствующие которым разряды R1 и
                               \R4 АЛУ не совпадают
  Все команды, которые считывают или выносят на шину данных какие-либо
значения, работают от младших разрядов шины; то есть, например, коман-
да
                   READ VR;
будет выдавать значение 3-разрядного регистра  вектора на три  младшие
разряда шины данных.

                 11. Команда загрузки регистров LOAD.
                 ───────────────────────────────────-
   Данная команда стоит особняком от всех других команд ассембера, так
как она задает загрузку служебных регистров, относящихся ко многим уз-
лам микропроцессорного комплекса. В зависимости от операнда, следующе-
го за командой, она может быть одно или двуоперандной:
    1)загрузка регистров задания операнда блока АЛУ:
       - LOAD RA;
       - LOAD RB;
      данная команда не требует в качестве второго операнда  указывать
      источник загрузки или непосредственный операнд, так как аппарат-
      но регистры подсоединены к шине данных и при подаче сигнала  за-
      писи в них будут загружено значение, которое в данный момент на-
      ходится на шине.
    2)загрузка регистров меток блока управления сдвигами:
       - LOAD  RM;  LOAD  RN;  здесь в качестве второго операнда можно
      указывать следущие значения:
      1)Z - загрузка во все четыре метки регистра нулей;
      2)NZ- загрузка во все четыре метки регистра  единиц;
      3)FLAGS -  загрузка  в  регистры  признаков выполнения последней
                 операции в блоке АЛУ; при использовании оператора мо-
                 дификации @ флаги будут загружаться в модифицированном
                 виде (см. таблицу загрузки регистров меток);
        кроме того  возможна  загрузка одного регистра другим. Примеры:
                    LOAD RM,Z;
                    LOAD  RN,RM;
                    XOR  R1,R5;
                    LOAD RM,FLAGS;
      Остальные виды загрузок регистров меток являются доступными при
      использовании команды MASK.
    3)загрузка регистров маски и состояния блока обработки прерываний.
      Команда может быть одно и двуорперандной. Разница состоит в том,
      что при однооперандной команде регистры загружаются текущей  ин-
      формацией с шины данных, в то время как при непоcредственном за-
      дании операнда загрузки, он заносится в поле данных микрокоманды
      и считывается на шину данных оттуда. Например:
                    LOAD SR,7;      \регистр состояния трехразрядный,
                                    \помните, что попытка загрузить ту-
                                    \да число большее 7 вызовет ошибку
                    INC R1;
                    LOAD MR;        \загружаем в регистр маски инкре-
                                    \ментированное значение регистра
                                    \R1(точнее младшие его 8 разрядов)


              12. Команда задания поля микрокоманды MASK.
              ──────────────────────────────────────────-
   Эта команда  охватывает  в себе все те функции,  которые по тем или
иным причинам не оказались задействованы с помощью стандартных  команд
ассемблера. Команда двуопенрандная, где первый операнд - имя поля мик-
рокоманды, а второй - непосредственное значение. Ниже приведены мнемо-
ники имен полей и несколько примеров использования команды:
    1)BC1_INS - поле микрокоманды АЛУ (максимальное значение - 1FFh);
                здесь можно задавать все поле целиком, коме этого есть
                команды задания отдельных подполей микрокоманды АЛУ
    2)BC1_I86 - поле приемника  результата в АЛУ ( максимальное значе-
                ние - 7);
    3)BC1_I53 - поле операции в АЛУ (максимальное значение - 7);
    4)BC1_I20 - поле операндов в АЛУ (максимальное значение  - 7);
    5)BC1_A - номер первого РОНа в АЛУ ( максимальное значение - 15 );
    6)BC1_B - номер второго РОНа в АЛУ ( максимальное значение - 15 );
    7)DATA - поле констант ( максимальное значение - 0FFFFh );
    8)BP2_INS -  поле  микрокоманды  устройства  управления   сдвигами
                 (максимальное значение - 1FFFh);
    9)BP2_ICB - поле управления сигналами  переноса  CI  (максимальное
                значение - 3 );
    10)BP2_IA6 -  поле  управления  выполнением  сдвигов (максимальное
                  значение - 31);
                  смотри структурную схему выполднения сдвига на АЛБ

    11 - 12)BP2_I50 - поле управления выхода кода условия  и  загрузки
                  регистров меток (максимальное значение - 63);

    13)BH1_INS -  поле  микрокоманды  устройсва  обработки  прерываний
                  (максимальное значение - 15);

    14)BU4_INS - поле микрокоманды устройства управления (максимальное
                 значение - 15);

    15)BU4_MS - поле мультиплексора задания условия (максимальное зна-
                чение - 7);


                        13. Служебные команды.
                        ─────────────────────-
   Служебные команды  предназначены  для  выдачи на элементы микропро-
цессорного комплекса различных служебных сигналов, как то сигналы раз-
решения(запрета)  выдачи  данных  на  выходы  микросхемы или записи во
внутрение регистры и т.п. Все эти команды сугубо специализированы и не
имеют операндов.  Влияние оказывается на те поля микрокоманды, которые
не затрагиваются другими группами команд.

    1) Команда управления арифметико-логическим устройством на м/с ВС1:
      1. OE_ALU  -  разрешить выдачу результата операции в АЛУ на шину
                  данных;  по умолчанию выдача данных  подавляется(см.
                  раздел 6: Структура задания микрокоманды).
    2) Команды управления устройством управления сдвигом на м/с ВР2:
      1,2. CEM,CEN - команды разрешения записи в регистры RgM и RgN;
      3..6. CEM_C,CEM_Z,CEM_N,CEM_V  - запретить запись метки C(Z,N,V)
                                       в регистр меток RgM.
    3) Команды управления устройством упраления на м/с ВУ4:
      1. RLD   - разрешение записи в регистр адреса/счетчика
      2. CCE   - разрешение подачи условия
      3. CI - запрещение формирования адреса следующей команды;
    4) Команды управления устройством обработки прерываний на м/с ВН1:
      1. EV - Разрешение выдачи адреса устройства прерывания  на  шину
              данных
    5) Команды управления внешними устройствами и памятью:
      1. RD - команда чтения из памяти
      2. WR - команда записи в память
      3. IN - команда приема с внешнего устройства
      4. OUT - команда записи во внешнее устройство
      5..6. EWH,EWL - команды записи соответственно в старшие и  млад-
                      шие разряды регистра адреса. Две команды введены
                      для случая, когда разрядность ШД < ША и записать
                      новый адрес в регистр адреса за один такт невоз-
                      можно.  Тогда сначала на шине  данных  формируют
                      младшую  часть адреса,  и,  подав сигнал EWL за-
                      писывают ее в регистр адреса, а затем аналогично
                      поступают со старшей частью формируемого адреса.

              Приложение 1: Таблица зарезервированных мнемоник.
              ────────────────────────────────────────────────-
   1)директивы
     ────────-
     ~1067ORG~ ~1075EQU~ ~1092LINK~ DEF
   2)команды
     ──────-
     команды  ВС1  и  ВР2
     ~1300ADD~ ~1301SUB~ ~1302OR~ ~1303AND~ ~1304XOR~ ~1305NAND~ ~1307NXOR~ ~1308MOV~ ~1311INC~ ~1313DEC~
     команды ВУ4
     ~1530JZ~  ~1532CJS~ ~1536JMAP~ ~1538CJP~ ~1540PUSH~ ~1548JSRP~ ~1554CJV~ ~1557JRP~
     ~1559RFCT~ ~1571RPCT~ ~1576CRTN~ ~1581CJPP~ ~1592LDCT~ ~1594LOOP~ ~1603CONT~ ~1605TWB~
     команды ВН1
     ~1681READ~  ~1663CLR~ ~1676SET~ ~1652RESET~ ~1689DI~ ~1691EI~
     команды внешних устройств
     ~1818RD WR IN OUT EWH EWL~
     команды запрета-разрешения
     ~1803OE_ALU~ ~1807CEM  CEN  CEM_C CEM_Z CEM_N CEM_V~ ~1811RLD CCE CI~ ~1815EV~
     прочие команды
     ~1711LOAD~ ~1756MASK~
   3)операнды
     ───────-
     операнды  операции в АЛУ
     RQ Z R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 RA RB
     операнды задания типа сдвига
     SR SL SRA SLA SRL SLL SRC SLC
     операнды задания сдвига
     Z NZ RM_C RM_N RB0 RB15 RQ0 RQ15 CO NXORV
     операнды задания  переноса  Z RN_C RM_C
     операнды задания входа мультипексора условий
     Z L1 L2 L3 L4 L5 L6 NZ
     операнды задания выхода кода условий
     ZO CO NO VO RN_Z RN_C RN_N RN_V RM_Z RM_C RM_N RM_V NXORV ZORC
     операнды  команды  MASK
     BC1_INS BC1_I86 BC1_I53 BC1_I20 BC1_A BC1_B DATA BP2_INS BP2_ICB
     BP2_IA6 BP2_I50 BH1_INS BU4_INS BU4_MS
     операнды  операции  в устройстве обработки прерываний
     MR SR IR VR
     операнды операции загрузки регистров меток
     RGM RGN FLAGS Z NZ
     операнды задания коммутации условий
     BP2_CT RD_MEM RD_IO IRQ0 IRQ1 IRQ2 IRQ3 IRQ4 IRQ5 IRQ6 IRQ7
   4)прочие
     ─────-
     NOT @ . , ; :

                Приложение 2: Сообщения об ошибках.
                ──────────────────────────────────-
    1) Ожидается "," ;
    2) Ожидается ";" ;
    3) Ожидается "." ;
    4) Ожидается ":" ;
    5) Ожидается "," либо ";" ;
    6) Мнемоника не распознана ;
    7) Директива не распознана ;
    8) Команда не распознана ;
    9) Метка не определена ;
    10)Двойное определение метки ;
    11)Недопустимое применение зарезервированной мнемоники ;
    12)Число слишком велико ;
    13)Непредвиденный конец файла ;
    14)Некорректный приемник результата в АЛУ ;
    15)Некорректное задание операндов в АЛУ ;
    16)Некорректный операнд сдвига ;
    17)Некорректный операнд переноса ;
    18)Для операнда условия не задана коммутация ;
    19)Некорректный операнд условия ;
    20)Некорректный операнд блока прерываний ;
    21)Некорректный операнд загрузки регистров метки ;
    22)Некорректный операнд маски ;
    23)Неверное применение операнда модификации;
    24)Повторное использование поля данных.

            Приложение 3: Пример написания программы.
            ────────────────────────────────────────-
\Программа умножения шестнадцатиричных беззнаковых чисел
\---------------------------------------------------------------------
\Способ умножения : четвертый - умножение  выполняется со старших раз-
\                               рядов множителя, сумма  частичных про-
\                               изведений остается неподвижной, а мно-
\                               жимое сдвигается вправо.
\---------------------------------------------------------------------
\Формула, по которой производится умножение:
\                      -1        -2            -i            -n
\         Z=(...((0+Y*2  *x )+Y*2  *x )+...+Y*2  *x )+...+Y*2  *x .
\                          1         2             i             n
\---------------------------------------------------------------------
\исходные данные:
\                 операнд X: R11
\                 операнд Y: старшая часть - R10
\                            младшая часть - RQ
\               результат Z: старшая часть - R4
\                            младшая часть - R5
\---------------------------------------------------------------------
                equ X :  01f0H \ устанавливаем эквивалентность X=496
                equ Y :  01f0H \ устанавливаем эквивалентность Y=496
               link l1:  BP2_CT \ устанавливаем коммутацию сигнала ус-
                                \ловия, подаваемого с м/с ВР2 на  пер-
                                \вый вход мультиплексора условий
\---------------------------------------------------------------------
               {mov R11,X;}  \заносим  операнд  Х
               {mov R10,Y;}  \заносим операнд Y; так как в процессе
                             \вычислений множимое будет сдвигаться
                             \вправо, то Y необходимо занести в стар-
                             \шую часть регистровой пары R10:RQ
               {mov RQ,0;}   \обнуляем  старшую  часть  множимого
               {mov R4,0;}   \обнуляем приемник результата
               {mov R5,0;}
               {push NZ,16;} \загружаем в регистр адреса - счетчика
                             \кол-во итераций и заносим на вершину
                             \стека адрес начала цикла
               {mov @ srl,R10,R10;\осуществляем сдвиг регистровой пары
                                  \R10:RQ
                mask  BP2_IA6,6;} \во вдвигаемый разряд RQ заносится
                                  \выдвинутый разряд из R10
               {add R11,R11; \удваиваем  операнд Х и вылавливаем выд-
                             \вигаемый старший разряд во флажке пере-
                             \носа CO
                cjp not CO,обход;}\если флаг переноса не установлен,
                                  \т.е. xi=0, то обходим прибавление
                                  \к результату сдвинутого регистра Y
               {add R5,RQ;   \складываем  младшие  части  Y  и  Z
               load RgM,FLAGS;}   \одновременно запоминаем возможный
                                  \сигнал переноса в регистре флагов
                                  \RgM ВР2
               {add R4,R10,RM_C;} \складываем старшие части Y и Z,
                                  \учитывая полученный в предыдущей
                                  \операции перенос
         обход {rfct;}       \декрементируем регистр адреса-счетчика
                             \и по не нулю уходим на начало цикла
\---------------------------------------------------------------------
\в результате выполнения умножения над такими числами результат должен
\получиться следующим:
\               результат Z: старшая часть - R4=0С100h
\                            младшая часть - R5=00003h
\                            т.е.            Z=246,046

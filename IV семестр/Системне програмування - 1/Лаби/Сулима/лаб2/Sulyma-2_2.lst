Microsoft (R) Macro Assembler Version 6.14.8444		    09/20/16 22:28:31
Sulyma-2_2.asm						     Page 1 - 1


				.586
				.model flat, stdcall
				option casemap :none
					
					  include \masm32\macros\macros.asm
			      C comment * -----------------------------------------------------------------
			      C         Preprocessor code for high level language simulation in MASM32
			      C 
			      C                           Updated 2nd December 2011
			      C          ---------------------------------------------------------------- *
			      C 
			      C   ; *******************************************************************
			      C   ; The following block of macros are macro functions that are designed
			      C   ; to be called by other macros. In part they function as a library of
			      C   ; components for writing other macros without having to repeatedly
			      C   ; reproduce the same capacity. Effectively macro code reuse.
			      C   ; *******************************************************************
			      C 
			      C   ; -----------------------------------------------------------
			      C   ; This macro replaces quoted text with a DATA section OFFSET
			      C   ; and returns it in OFFSET "name" format. It is used by other
			      C   ; macros that handle optional quoted text as a parameter.
			      C   ; NOTE that while this macro behaves identically on single
			      C   ; byte characters, it now supports 2 byte characters if the
			      C   ; __UNICODE__ equate is set.
			      C   ; -----------------------------------------------------------
			      C     reparg MACRO arg
			      C       LOCAL nustr
			      C       LOCAL quot
			      C         quot SUBSTR <arg>,1,1
			      C       IFIDN quot,<">                ;; if 1st char = "
			      C 
			      C         IFNDEF __UNICODE__
			      C           .data
			      C             nustr db arg,0          ;; write arg to .DATA section
			      C           .code
			      C           EXITM <OFFSET nustr>      ;; append name to OFFSET operator
			      C         ELSE
			      C           EXITM <uni$(arg)>         ;; use the "uni$()" macro
			      C         ENDIF
			      C 
			      C       ELSE
			      C         EXITM <arg>                 ;; else return arg
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; -------------------------------------
			      C   ; variation returns address in register
			      C   ; so it can be assigned to a variable.
			      C   ; -------------------------------------
			      C     repargv MACRO arg
			      C       LOCAL nustr
			      C         quot SUBSTR <arg>,1,1
			      C       IFIDN quot,<">            ;; if 1st char = "
			      C         .data
			      C           nustr db arg,0        ;; write arg to .DATA section
			      C         .code
			      C         mov eax, OFFSET nustr
			      C         EXITM <eax>             ; return data section offset in eax
			      C       ELSE
			      C         mov eax, arg
			      C         EXITM <eax>             ; else return arg
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; -----------------------------------------------------------
			      C   ; replace a quoted string with its OFFSET in the data section
			      C   ; -----------------------------------------------------------
			      C     repargof MACRO arg
			      C       LOCAL nustr
			      C         quot SUBSTR <arg>,1,1
			      C       IFIDN quot,<">            ;; if 1st char = "
			      C         .data
			      C           nustr db arg,0        ;; write arg to .DATA section
			      C         .code
			      C         EXITM <OFFSET nustr>    ;; append name to OFFSET operator
			      C       ELSE
			      C         EXITM <arg>             ;; else return arg
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; -------------------------------------------------------
			      C   ; This is a parameter checking macro. It is used to test
			      C   ; if a parameter in a macro is a quoted string when a
			      C   ; quoted string should not be used as a parameter. If it
			      C   ; is a user defined error message is displayed at
			      C   ; assembly time so that the error can be fixed.
			      C   ; -------------------------------------------------------
			      C     tstarg MACRO arg
			      C       quot SUBSTR <arg>,1,1
			      C       IFIDN quot,<">            ;; if 1st char = "
			      C         % echo *****************
			      C         % echo QUOTED TEXT ERROR
			      C         % echo *****************
			      C         % echo argument = arg
			      C         % echo valid memory buffer address required
			      C         % echo *****************
			      C         .ERR
			      C         EXITM <arg>
			      C       ELSE
			      C         EXITM <arg>             ;; else return arg
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; -----------------------------------------------
			      C   ; count the number of arguments passed to a macro
			      C   ; This is a slightly modified 1990 MASM 6.0 macro
			      C   ; -----------------------------------------------
			      C     argcount MACRO args:VARARG
			      C       LOCAL cnt
			      C       cnt = 0
			      C       FOR item, <args>
			      C         cnt = cnt + 1
			      C       ENDM
			      C       EXITM %cnt                ;; return as a number
			      C     ENDM
			      C 
			      C   ; ---------------------------------------------------
			      C   ; return an arguments specified in "num" from a macro
			      C   ; argument list or "-1" if the number is out of range
			      C   ; ---------------------------------------------------
			      C     getarg MACRO num:REQ,args:VARARG
			      C       LOCAL cnt, txt
			      C       cnt = 0
			      C       FOR arg, <args>
			      C         cnt = cnt + 1
			      C         IF cnt EQ num
			      C           txt TEXTEQU <arg>     ;; set "txt" to content of arg num
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IFNDEF txt
			      C         txt TEXTEQU <-1>        ;; return -1 if num out of range
			      C       ENDIF
			      C       EXITM txt
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; -------------
			      C   ; expand prefix
			      C   ; -------------
			      C     expand_prefix MACRO txtitm
			      C       LOCAL prefix1,wrd,nu,varname
			      C 
			      C       prefix1 SUBSTR <txtitm>,1,1
			      C 
			      C    ; usable characters are "&" "*" "@" "#" "?" "^" "~" "`" "/"
			      C 
			      C         IFIDN prefix1,<&>                   ;; reference operator
			      C           nu SUBSTR <txtitm>,2
			      C           wrd CATSTR <ADDR >,nu
			      C           EXITM <wrd>
			      C         ENDIF
			      C 
			      C         IFIDN prefix1,<*>                   ;; indirection operator
			      C           nu SUBSTR <txtitm>,2
			      C           .data?
			      C             varname dd ?
			      C           .code
			      C           push ebx
			      C           mov ebx, nu
			      C           mov ebx, [ebx]                    ; dereference variable in EBX
			      C           mov varname, ebx
			      C           pop ebx
			      C           EXITM <varname>
			      C         ENDIF
			      C 
			      C       EXITM <txtitm>                        ;; exit with original argument
			      C     ENDM
			      C 
			      C   ; ----------------------------------------------------------------
			      C   ; invoke enhancement. Add quoted text support to any procedure
			      C   ; or API call by using this macro instead of the standard invoke.
			      C   ; LIMITATION : quoted text must be plain text only, no ascii 
			      C   ; values or macro reserved characters IE <>!() etc ..
			      C   ; use chr$() or cfm$() for requirements of this type.
			      C   ; ----------------------------------------------------------------
			      C     fn MACRO FuncName:REQ,args:VARARG
			      C       p@arg equ <invoke FuncName>           ;; construct invoke and function name
			      C       FOR var,<args>                        ;; loop through all arguments
			      C         p@arg CATSTR p@arg,<,expand_prefix(reparg(var))>   ;; replace quotes and append p@arg
			      C       ENDM
			      C       p@arg                                 ;; write the invoke macro
			      C     ENDM
			      C 
			      C   ; ------------------------------------------------
			      C   ; Function return value version of the above macro
			      C   ; ------------------------------------------------
			      C     rv MACRO FuncName:REQ,args:VARARG
			      C       the@arg equ <invoke FuncName>         ;; construct invoke and function name
			      C       FOR var,<args>                        ;; loop through all arguments
			      C         the@arg CATSTR the@arg,<,expand_prefix(reparg(var))>   ;; replace quotes and append the@arg
			      C       ENDM
			      C       the@arg                               ;; write the invoke macro
			      C       EXITM <eax>                           ; EAX as the return value
			      C     ENDM
			      C 
			      C   ; ---------------------------------------------------
			      C   ; The two following versions support C style escapes.
			      C   ; ---------------------------------------------------
			      C     fnc MACRO FuncName:REQ,args:VARARG
			      C       the@arg equ <invoke FuncName>         ;; construct invoke and function name
			      C       FOR var,<args>                        ;; loop through all arguments
			      C         the@arg CATSTR the@arg,<,expand_prefix(cfm$(var))> ;; replace quotes and append the@arg
			      C       ENDM
			      C       the@arg                               ;; write the invoke macro
			      C     ENDM
			      C 
			      C     rvc MACRO FuncName:REQ,args:VARARG
			      C       the@arg equ <invoke FuncName>         ;; construct invoke and function name
			      C       FOR var,<args>                        ;; loop through all arguments
			      C         the@arg CATSTR the@arg,<,expand_prefix(cfm$(var))> ;; replace quotes and append the@arg
			      C       ENDM
			      C       the@arg                               ;; write the invoke macro
			      C       EXITM <eax>                           ;; EAX as the return value
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     ; -----------------------------------------
			      C     ; MSVCRT ASCII & UNICODE integer conversion
			      C     ; -----------------------------------------
			      C       ustr$ MACRO number
			      C         LOCAL buffer
			      C         .data?
			      C           buffer TCHAR 40 dup (?)
			      C           align 4
			      C         .code
			      C         IFNDEF __UNICODE__
			      C           invoke crt__itoa,number,ADDR buffer,10
			      C         ELSE
			      C           invoke crt__itow,number,ADDR buffer,10
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       sstr$ MACRO number
			      C         LOCAL buffer
			      C         .data?
			      C           buffer TCHAR 40 dup (?)
			      C           align 4
			      C         .code
			      C         IFNDEF __UNICODE__
			      C           invoke crt__ltoa,number,ADDR buffer,10
			      C         ELSE
			      C           invoke crt__ltow,number,ADDR buffer,10
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       uval MACRO lpstring
			      C         IFNDEF __UNICODE__
			      C           invoke crt_atoi,reparg(lpstring)
			      C         ELSE
			      C           invoke crt__wtoi,reparg(lpstring)
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C 
 = uval			      C       val equ <uval>
			      C 
			      C       sval MACRO lpstring
			      C         IFNDEF __UNICODE__
			      C           invoke crt_atol,reparg(lpstring)
			      C         ELSE
			      C           invoke crt__wtol,reparg(lpstring)
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C     ; ---------------------------------
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     A2WDAT MACRO quoted@@text,dataname:VARARG
			      C 
			      C  ; ------------------------------------------------------
			      C 
			      C  ;     ASCII literal string to UNICODE "dw" conversion.
			      C  ;     The macro has the ASCII character range 0 - 255
			      C  ;     and will convert 1 byte characters in the quoted
			      C  ;     string to 2 byte UNICODE characters written as "dw"
			      C  ;     in the initialised data section.
			      C  ;     The final string length is dictated by the MASM line
			      C  ;     length limit and is set at 240 characters.
			      C  ; 
			      C  ;     This MACRO is primarily designed to be called by
			      C  ;     other macros, it does not create a .DATA section
			      C  ;     and it does not terminate the string data it writes.
			      C  ; 
			      C  ;     This characteristic is so the macro can be called
			      C  ;     repeatedly by another macro. The calling macro
			      C  ;     then terminates the string when it has no more
			      C  ;     to write.
			      C  ; 
			      C  ;     The optional dataname label is designed to be used
			      C  ;     on the first call and ommitted on subsequent calls
			      C  ;     when adding text to the original label address.
			      C  ; 
			      C  ;     You can write a .DATA section entry in this manner.
			      C  ; 
			      C  ;     .data
			      C  ;       A2WDAT "First block of text", mytext
			      C  ;       A2WDAT "Second block of text"
			      C  ;       A2WDAT "Third block of text"
			      C  ;       A2WDAT "Fourth block of text"
			      C  ;       dw 0
			      C  ;     .code
			      C  ; 
			      C  ;     mov eax, OFFSET mytext
			      C 
			      C  ; ------------------------------------------------------
			      C 
			      C       LOCAL s_l_e_n
			      C       LOCAL c_n_t_r
			      C       ; LOCAL item
			      C       LOCAL add@str1
			      C       LOCAL isquot
			      C       LOCAL argz
			      C 
			      C       LOCAL lcnt
			      C       LOCAL char
			      C       LOCAL cntr
			      C 
			      C       LOCAL new@str1
			      C 
			      C       LOCAL slice@1
			      C       LOCAL slice@2
			      C       LOCAL slice@3
			      C       LOCAL slice@4
			      C       LOCAL slice@5
			      C       LOCAL slice@6
			      C 
			      C       add@str1 equ <>
			      C 
			      C       new@str1 equ <>
			      C 
			      C       slice@1 equ <>
			      C       slice@2 equ <>
			      C       slice@3 equ <>
			      C       slice@4 equ <>
			      C       slice@5 equ <>
			      C       slice@6 equ <>
			      C 
			      C       s_l_e_n SIZESTR <quoted@@text>
			      C  ;       item TEXTEQU %(s_l_e_n)
			      C  ;       % echo string length = item characters
			      C 
			      C       if s_l_e_n gt 240
			      C         echo ------------------------------------------
			      C         echo *** STRING EXCEEDS 240 character limit ***
			      C         echo ------------------------------------------
			      C       .ERR
			      C       EXITM
			      C       endif
			      C 
			      C       isquot SUBSTR <quoted@@text>,1,1
			      C       IFDIF isquot,<">
			      C         echo -----------------------------
			      C         echo *** MISSING LEADING QUOTE ***
			      C         echo -----------------------------
			      C       .ERR
			      C       EXITM
			      C       ENDIF
			      C 
			      C       isquot SUBSTR <quoted@@text>,s_l_e_n,1
			      C       IFDIF isquot,<">
			      C         echo ------------------------------
			      C         echo *** MISSING TRAILING QUOTE ***
			      C         echo ------------------------------
			      C       .ERR
			      C       EXITM
			      C       ENDIF
			      C 
			      C     ; ============================================
			      C 
			      C       lcnt SIZESTR <quoted@@text>
			      C       lcnt = lcnt - 2
			      C       cntr = 2
			      C 
			      C       c_n_t_r = 0
			      C 
			      C       :lpstart
			      C 
			      C         argz SUBSTR <quoted@@text>,cntr,1
			      C 
			      C           if c_n_t_r lt 1
			      C             slice@1 CATSTR slice@1,<">,argz,<">
			      C             goto nxt
			      C           elseif c_n_t_r lt 40
			      C             slice@1 CATSTR slice@1,<,">,argz,<">
			      C             goto nxt
			      C 
			      C           elseif c_n_t_r lt 41
			      C             slice@2 CATSTR slice@2,<">,argz,<">
			      C             goto nxt
			      C           elseif c_n_t_r lt 80
			      C             slice@2 CATSTR slice@2,<,">,argz,<">
			      C             goto nxt
			      C 
			      C           elseif c_n_t_r lt 81
			      C             slice@3 CATSTR slice@3,<">,argz,<">
			      C             goto nxt
			      C           elseif c_n_t_r lt 120
			      C             slice@3 CATSTR slice@3,<,">,argz,<">
			      C             goto nxt
			      C 
			      C           elseif c_n_t_r lt 121
			      C             slice@4 CATSTR slice@4,<">,argz,<">
			      C             goto nxt
			      C           elseif c_n_t_r lt 160
			      C             slice@4 CATSTR slice@4,<,">,argz,<">
			      C             goto nxt
			      C 
			      C           elseif c_n_t_r lt 161
			      C             slice@5 CATSTR slice@5,<">,argz,<">
			      C             goto nxt
			      C          elseif c_n_t_r lt 200
			      C             slice@5 CATSTR slice@5,<,">,argz,<">
			      C             goto nxt
			      C 
			      C           elseif c_n_t_r lt 201
			      C             slice@6 CATSTR slice@6,<">,argz,<">
			      C             goto nxt
			      C           elseif c_n_t_r lt 240
			      C             slice@6 CATSTR slice@6,<,">,argz,<">
			      C             goto nxt
			      C           endif
			      C 
			      C       :nxt
			      C         c_n_t_r = c_n_t_r + 1
			      C 
			      C         cntr = cntr + 1
			      C         lcnt = lcnt - 1
			      C         if lcnt ne 0
			      C           goto lpstart
			      C         endif
			      C 
			      C     ; ============================================
			      C 
			      C     ; ---------------------------------------------------------
			      C     ; add a label if one is supplied else add a normal DW entry
			      C     ; ---------------------------------------------------------
			      C     IFDIF <dataname>,<>
			      C       % s_l_e_n SIZESTR <slice@1>
			      C       if s_l_e_n ne 0
			      C         slice@1 CATSTR <dataname dw >,slice@1
			      C         slice@1
			      C       endif
			      C     ELSE
			      C       % s_l_e_n SIZESTR <slice@1>
			      C       if s_l_e_n ne 0
			      C         slice@1 CATSTR <dw >,slice@1
			      C         slice@1
			      C       endif
			      C     ENDIF
			      C     ; ---------------------------------------------------------
			      C 
			      C       % s_l_e_n SIZESTR <slice@2>
			      C       if s_l_e_n ne 0
			      C         slice@2 CATSTR <dw >,slice@2
			      C         slice@2
			      C       endif
			      C 
			      C       % s_l_e_n SIZESTR <slice@3>
			      C       if s_l_e_n ne 0
			      C         slice@3 CATSTR <dw >,slice@3
			      C         slice@3
			      C       endif
			      C 
			      C       % s_l_e_n SIZESTR <slice@4>
			      C       if s_l_e_n ne 0
			      C         slice@4 CATSTR <dw >,slice@4
			      C         slice@4
			      C       endif
			      C 
			      C       % s_l_e_n SIZESTR <slice@5>
			      C       if s_l_e_n ne 0
			      C         slice@5 CATSTR <dw >,slice@5
			      C         slice@5
			      C       endif
			      C 
			      C       % s_l_e_n SIZESTR <slice@6>
			      C       if s_l_e_n ne 0
			      C         slice@6 CATSTR <dw >,slice@6
			      C         slice@6
			      C       endif
			      C 
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     WSTR MACRO lblname,arglist:VARARG
			      C 
			      C       LOCAL qflg                    ; quote flag
			      C       LOCAL isqt                    ; 1st character
			      C       LOCAL arg                     ; FOR loop argument
			      C 
			      C       qflg = 0                      ;; clear quote flag
			      C       .data                         ; write data to the DATA section
			      C 
			      C       for arg, <arglist>
			      C         isqt SUBSTR <arg>,1,1       ;; get 1st character
			      C           IFIDN isqt,<">            ;; test if its a quote
			      C             IF qflg eq 0            ;; if 1st arg, add label
			      C               A2WDAT arg,lblname    ;; write data section first entry
			      C             ENDIF
			      C             IF qflg eq 1            ;; else just write data
			      C               A2WDAT arg            ;; write subsequent entry
			      C             ENDIF
			      C           ENDIF
			      C 
			      C           IFDIF isqt,<">            ;; if not quoted
			      C             IF qflg eq 0            ;; if 1st arg, add label
			      C               lblname dw arg        ;; write data section first entry as DW number
			      C             ENDIF
			      C             IF qflg eq 1            ;; if 1st arg, add label
			      C               dw arg                ;; write subsequent entry as DW number
			      C             ENDIF
			      C           ENDIF
			      C         qflg = 1                    ;; set flag for non 1st char
			      C       ENDM
			      C 
			      C       dw 0                          ;; terminate data entry
			      C       align 4                       ; 4 byte align after terminator
			      C     .code                           ; change back to CODE section
			      C 
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     uni$ MACRO arglist:VARARG
			      C       LOCAL DATA@NAME
			      C       WSTR DATA@NAME,arglist
			      C       EXITM <OFFSET DATA@NAME>
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     ; --------------------------------
			      C     ; initialised GLOBAL string value
			      C     ; --------------------------------
			      C 
			      C     ; -------------------------------------------------------
			      C     ; The dataname passed to STRING is addressed as an OFFSET
			      C     ; mov eax, OFFSET data_label
			      C     ; -------------------------------------------------------
			      C       STRING MACRO data_label,quoted_text:VARARG
			      C         IFNDEF __UNICODE__
			      C           .data
			      C             data_label db quoted_text,0
			      C             align 4
			      C           .code
			      C         ELSE
			      C           WSTR data_label,quoted_text,0
			      C         ENDIF
			      C       ENDM
			      C 
			      C     ; -------------------------------------------------------------------
			      C     ; The dataname passed to STRADD is addressed as a POINTER to the data
			      C     ; mov eax, data_label
			      C     ; -------------------------------------------------------------------
			      C       STRADD MACRO data_label,args:VARARG
			      C         LOCAL dataname
			      C         IFNDEF __UNICODE__
			      C           .data
			      C             dataname db args
			      C             align 4
			      C             data_label dd dataname
			      C           .code
			      C         ELSE
			      C           WSTR dataname,args
			      C           .data
			      C           align 4
			      C           data_label dd dataname
			      C           .code
			      C         ENDIF
			      C       ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; ********************************************************
			      C   ; format a C style string complete with escape characters
			      C   ; and return the offset of the result to the calling macro
			      C   ;
			      C   ; 3 versions are presented here,
			      C   ; 1. acfm$ = ASCII only version
			      C   ; 2. ucfm$ = UNICODE only version
			      C   ; 3. cfm$  = Either ASCII or UNICODE depending on the
			      C   ;    __UNICODE__ equate being present in the source file
			      C   ;
			      C   ; This allows you to force either ASCII, UNICODE or either
			      C   ; depending on the presence of the __UNICODE__ equate
			      C   ; ********************************************************
			      C 
			      C   ; ********************************************************
			      C   ;   branchless ASCII version of cfm$ with no ELSE clauses.
			      C   ; ********************************************************
			      C 
			      C     acfm$ MACRO txt:VARARG
			      C 
			      C       LOCAL ch1,char,nu$,tmp,flag,lbuf,rbuf,cpos,sln
			      C       ch1 equ <>
			      C       nu$ equ <>
			      C       flag = 0
			      C 
			      C       ch1 SUBSTR <txt>,1,1              ;; check if 1st character is a quote
			      C       IFDIF ch1,<">
			      C         EXITM <txt>                     ;; exit with original "txt" if it is not
			      C       ENDIF
			      C 
			      C       FORC char,<txt>                   ;; scan through characters in "txt"
			      C 
			      C         IFIDN <char>,<\>                ;; increment the flag if "\" escape character
			      C           flag = flag + 1
			      C         ENDIF
			      C 
			      C       ; -----------------------------------------------
			      C 
			      C         IF flag EQ 0                    ;; <<< if flag = 0 then normal APPEND character
			      C           nu$ CATSTR nu$,<char>
			      C         ENDIF
			      C 
			      C         IF flag EQ 1                    ;; <<< if flag = 1 then perform replacement
			      C           IFIDN <char>,<n>
			      C             nu$ CATSTR nu$,<",13,10,">  ;; \n = CRLF
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<t>
			      C             nu$ CATSTR nu$,<",9,">      ;; \t = TAB
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<q>
			      C             nu$ CATSTR nu$,<",34,">     ;; \q = quote
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<0>
			      C             nu$ CATSTR nu$,<",0,">      ;; \0 = embedded zero
			      C             flag = 0
			      C           ENDIF
			      C 
			      C        ; ---------------------
			      C        ; masm specific escapes
			      C        ; ---------------------
			      C           IFIDN <char>,<l>
			      C             nu$ CATSTR nu$,<",60,">     ;; \l = <
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<r>
			      C             nu$ CATSTR nu$,<",62,">     ;; \r = >
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<x>
			      C             nu$ CATSTR nu$,<",33,">     ;; \x = !
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<a>
			      C             nu$ CATSTR nu$,<",40,">     ;; \a = (
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<b>
			      C             nu$ CATSTR nu$,<",41,">     ;; \b = )
			      C             flag = 0
			      C           ENDIF
			      C         ENDIF
			      C 
			      C         IF flag EQ 2                    ;; <<< if flag = 2 APPEND the "\" character
			      C           IFIDN <char>,<\>
			      C             nu$ CATSTR nu$,<",92,">     ;; \\ = \
			      C             flag = 0
			      C           ENDIF
			      C         ENDIF
			      C 
			      C       ; -----------------------------------------------
			      C 
			      C       ENDM
			      C 
			      C     ; ---------------------------------------------
			      C     ; strip any embedded <"",> characters sequences
			      C     ; ---------------------------------------------
			      C         nu$ CATSTR nu$,<,0,0,0>                 ;; append trailing zeros
			      C 
			      C         cpos INSTR nu$,<"",>                    ;; test for leading junk
			      C         IF cpos EQ 1
			      C           nu$ SUBSTR nu$,4                      ;; chomp off any leading junk
			      C         ENDIF
			      C 
			      C         cpos INSTR nu$,<"",>
			      C 
			      C         WHILE cpos
			      C           lbuf SUBSTR nu$,1,cpos-1              ;; read text before junk
			      C           rbuf SUBSTR nu$,cpos+3                ;; read text after junk
			      C           nu$ equ <>                            ;; clear nu$
			      C           nu$ CATSTR lbuf,rbuf                  ;; concantenate the two
			      C           cpos INSTR nu$,<"",>                  ;; reload cpos for next iteration
			      C         ENDM
			      C 
			      C         sln SIZESTR nu$
			      C         nu$ SUBSTR nu$,1,sln-6                  ;; trim off tail padding
			      C 
			      C         .data
			      C           tmp db nu$,0
			      C           align 4
			      C         .code
			      C         EXITM <OFFSET tmp>                      ;; return the DATA section OFFSET
			      C 
			      C     ENDM
			      C 
			      C   ; **********************************************************
			      C   ;   branchless UNICODE version of cfm$ with no ELSE clauses.
			      C   ; **********************************************************
			      C 
			      C     ucfm$ MACRO txt:VARARG
			      C 
			      C       LOCAL ch1,char,nu$,tmp,flag,lbuf,rbuf,cpos,sln
			      C       ch1 equ <>
			      C       nu$ equ <>
			      C       flag = 0
			      C 
			      C       ch1 SUBSTR <txt>,1,1              ;; check if 1st character is a quote
			      C       IFDIF ch1,<">
			      C         EXITM <txt>                     ;; exit with original "txt" if it is not
			      C       ENDIF
			      C 
			      C       FORC char,<txt>                   ;; scan through characters in "txt"
			      C 
			      C         IFIDN <char>,<\>                ;; increment the flag if "\" escape character
			      C           flag = flag + 1
			      C         ENDIF
			      C 
			      C       ; -----------------------------------------------
			      C 
			      C         IF flag EQ 0                    ;; <<< if flag = 0 then normal APPEND character
			      C           nu$ CATSTR nu$,<char>
			      C         ENDIF
			      C 
			      C         IF flag EQ 1                    ;; <<< if flag = 1 then perform replacement
			      C           IFIDN <char>,<n>
			      C             nu$ CATSTR nu$,<",13,10,">  ;; \n = CRLF
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<t>
			      C             nu$ CATSTR nu$,<",9,">      ;; \t = TAB
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<q>
			      C             nu$ CATSTR nu$,<",34,">     ;; \q = quote
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<0>
			      C             nu$ CATSTR nu$,<",0,">      ;; \0 = embedded zero
			      C             flag = 0
			      C           ENDIF
			      C 
			      C        ; ---------------------
			      C        ; masm specific escapes
			      C        ; ---------------------
			      C           IFIDN <char>,<l>
			      C             nu$ CATSTR nu$,<",60,">     ;; \l = <
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<r>
			      C             nu$ CATSTR nu$,<",62,">     ;; \r = >
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<x>
			      C             nu$ CATSTR nu$,<",33,">     ;; \x = !
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<a>
			      C             nu$ CATSTR nu$,<",40,">     ;; \a = (
			      C             flag = 0
			      C           ENDIF
			      C           IFIDN <char>,<b>
			      C             nu$ CATSTR nu$,<",41,">     ;; \b = )
			      C             flag = 0
			      C           ENDIF
			      C         ENDIF
			      C 
			      C         IF flag EQ 2                    ;; <<< if flag = 2 APPEND the "\" character
			      C           IFIDN <char>,<\>
			      C             nu$ CATSTR nu$,<",92,">     ;; \\ = \
			      C             flag = 0
			      C           ENDIF
			      C         ENDIF
			      C 
			      C       ; -----------------------------------------------
			      C 
			      C       ENDM
			      C 
			      C     ; ---------------------------------------------
			      C     ; strip any embedded <"",> characters sequences
			      C     ; ---------------------------------------------
			      C         nu$ CATSTR nu$,<,0,0,0>                 ;; append trailing zeros
			      C 
			      C         cpos INSTR nu$,<"",>                    ;; test for leading junk
			      C         IF cpos EQ 1
			      C           nu$ SUBSTR nu$,4                      ;; chomp off any leading junk
			      C         ENDIF
			      C 
			      C         cpos INSTR nu$,<"",>
			      C 
			      C         WHILE cpos
			      C           lbuf SUBSTR nu$,1,cpos-1              ;; read text before junk
			      C           rbuf SUBSTR nu$,cpos+3                ;; read text after junk
			      C           nu$ equ <>                            ;; clear nu$
			      C           nu$ CATSTR lbuf,rbuf                  ;; concantenate the two
			      C           cpos INSTR nu$,<"",>                  ;; reload cpos for next iteration
			      C         ENDM
			      C 
			      C         sln SIZESTR nu$
			      C         nu$ SUBSTR nu$,1,sln-6                  ;; trim off tail padding
			      C 
			      C         % WSTR tmp,nu$
			      C         EXITM <OFFSET tmp>                      ;; return the DATA section OFFSET
			      C 
			      C     ENDM
			      C 
			      C   ; ****************************************************
			      C   ; ****************************************************
			      C 
			      C     cfm$ MACRO txt:VARARG
			      C       IFDEF __UNICODE__
			      C         EXITM <ucfm$(txt)>                      ;; UNICODE only version
			      C       ENDIF
			      C       EXITM <acfm$(txt)>                        ;; ASCII only version
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; --------------------------------------------------------------
			      C   ; This macro is written to behave as closely as possible to the
			      C   ; C runtime function "printf". The lack of return value is
			      C   ; to allow the closest method to writing C code. It supports
			      C   ; both ASCII and UNICODE and uses the C runtime function
			      C   ; "wprintf" to provide the UNICODE support.
			      C   ;
			      C   ; printf("%d\t%d\t%Xh\n", 123, 456, 1024);
			      C   ;
			      C   ; The return value is available in the EAX register if required.
			      C   ; The original ASCII version was written by Michael Webster.
			      C   ; --------------------------------------------------------------
			      C 
			      C     printf MACRO format:REQ, args:VARARG
			      C       IFNDEF __UNICODE__
			      C         IFNB <args>
			      C           fn crt_printf, cfm$(format), args
			      C         ELSE
			      C           fn crt_printf, cfm$(format)
			      C         ENDIF
			      C         EXITM <>
			      C       ELSE
			      C         IFNB <args>
			      C           fn crt_wprintf, cfm$(format), args
			      C         ELSE
			      C           fn crt_wprintf, cfm$(format)
			      C         ENDIF
			      C         EXITM <>
			      C       ENDIF
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C comment * -------------------------------------------------------
			      C         Each of the following macros has its own dedicated 260
			      C         CHARACTER buffer. The OFFSET returned by each macro can be
			      C         used directly in code but if the macro is called again
			      C         the data in the dedicated buffer will be overwritten
			      C         with the new result.
			      C 
			      C         mov str1, ptr$(buffer)
			      C         mov str2, pth$()
			      C 
			      C         invoke szCopy str2,str1 ; ASCII
			      C         invoke ucCopy str2,str1 ; UNICODE
			      C 
			      C           or the macro
			      C 
			      C         cst str2, str1          ; __UNICODE__ aware
			      C 
			      C         Empty brackets should be used with these macros as they
			      C         take no parameters. pth$() CurDir$() etc ...
			      C         ------------------------------------------------------- *
			      C 
			      C       pth$ MACRO            ;; application path OFFSET returned
			      C         IFNDEF pth__equate__flag
			      C         .data?
			      C             pth__260_CHAR__buffer TCHAR MAX_PATH dup (?)
			      C         .code
			      C         pth__equate__flag equ <1>
			      C         ENDIF
			      C         IFNDEF __UNICODE__
			      C           invoke GetAppPath,ADDR pth__260_CHAR__buffer
			      C         ELSE
			      C           invoke GetAppPathW
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       CurDir$ MACRO
			      C         IFNDEF cdir__equate__flag
			      C         .data?
			      C             cdir__260_CHAR__buffer TCHAR MAX_PATH dup (?)
			      C         .code
			      C         cdir__equate__flag equ <1>
			      C         ENDIF
			      C         invoke GetCurrentDirectory,MAX_PATH,ADDR cdir__260_CHAR__buffer
			      C         mov eax, OFFSET cdir__260_CHAR__buffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       SysDir$ MACRO
			      C         IFNDEF sys__equate__flag
			      C         .data?
			      C             sysdir__260_CHAR__buffer TCHAR MAX_PATH dup (?)
			      C         .code
			      C         sys__equate__flag equ <1>
			      C         ENDIF
			      C         invoke GetSystemDirectory,ADDR sysdir__260_CHAR__buffer,MAX_PATH
			      C         mov eax, OFFSET sysdir__260_CHAR__buffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       WinDir$ MACRO
			      C         IFNDEF wdir__equate__flag
			      C         .data?
			      C             windir__260_CHAR__buffer TCHAR MAX_PATH dup (?)
			      C         .code
			      C         wdir__equate__flag equ <1>
			      C         ENDIF
			      C         invoke GetWindowsDirectory,ADDR windir__260_CHAR__buffer,MAX_PATH
			      C         mov eax, OFFSET windir__260_CHAR__buffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; ******************************************
			      C   ; DOS style directory manipulation macros  *
			      C   ; The parameters passed to these directory *
			      C   ; macros should be zero terminated string  *
			      C   ; addresses.                               *
			      C   ; ******************************************
			      C       chdir MACRO pathname
			      C         invoke SetCurrentDirectory,reparg(pathname)
			      C       ENDM
 = chdir		      C       CHDIR equ <chdir>
			      C 
			      C       mkdir MACRO dirname
			      C         invoke CreateDirectory,reparg(dirname),NULL
			      C       ENDM
 = mkdir		      C       MKDIR equ <mkdir>
			      C 
			      C       rndir MACRO oldname,newname
			      C         invoke MoveFile,reparg(oldname),reparg(newname)
			      C       ENDM
 = rndir		      C       RNDIR equ <rndir>
			      C 
			      C       rmdir MACRO dirname
			      C         invoke RemoveDirectory,reparg(dirname)
			      C       ENDM
 = rmdir		      C       RMDIR equ <rmdir>
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     ascii MACRO quoted_text:VARARG
			      C       LOCAL txtname
			      C       .data
			      C         txtname db quoted_text,0
			      C       .code
			      C       EXITM <OFFSET txtname>
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     ; ******************************************************
			      C     ; BASIC style conversions from string to 32 bit integer
			      C     ; ******************************************************
			      C 
			      C       hval MACRO lpstring       ; hex string to unsigned 32 bit integer
			      C         invoke htodw, reparg(lpstring)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; ********************************
			      C     ; BASIC string function emulation
			      C     ; ********************************
			      C       add$ MACRO lpSource,lpAppend
			      C         IFNDEF __UNICODE__
			      C           invoke szCatStr,tstarg(lpSource),reparg(lpAppend)
			      C           EXITM <eax>
			      C         ELSE
			      C           push esi
			      C           mov esi, tstarg(lpSource)
			      C           invoke ucCatStr,tstarg(lpSource),reparg(lpAppend)
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       append$ MACRO string,buffer,location
			      C         IFNDEF __UNICODE__
			      C           invoke szappend,string,reparg(buffer),location
			      C         ELSE
			      C           invoke ucappend,string,reparg(buffer),location
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C   ; -----------------------------------------
			      C   ; non branching version with no ELSE clause
			      C   ; -----------------------------------------
			      C       chr$ MACRO any_text:VARARG
			      C         LOCAL txtname
			      C         .data
			      C           IFDEF __UNICODE__
			      C             WSTR txtname,any_text
			      C             align 4
			      C             .code
			      C             EXITM <OFFSET txtname>
			      C           ENDIF
			      C 
			      C           txtname db any_text,0
			      C           align 4
			      C           .code
			      C           EXITM <OFFSET txtname>
			      C       ENDM
			      C 
			      C       cmp$ MACRO arg1,arg2
			      C         invoke lstrcmp,reparg(arg1),reparg(arg2)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       cmpi$ MACRO arg1,arg2
			      C         invoke lstrcmpi,reparg(arg1),reparg(arg2)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       ptr$ MACRO buffer
			      C         lea eax, buffer
			      C         mov WORD PTR [eax], 0
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       len MACRO lpString
			      C         IFNDEF __UNICODE__
			      C           invoke szLen,reparg(lpString)
			      C         ELSE
			      C           invoke ucLen,reparg(lpString)
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       find$ MACRO spos,lpMainString,lpSubString
			      C         IFNDEF __UNICODE__
			      C           invoke InString,spos,reparg(lpMainString),reparg(lpSubString)
			      C           EXITM <eax>
			      C         ELSE
			      C           invoke ucFind,spos,reparg(lpMainString),reparg(lpSubString)
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
 = find$		      C       istring equ <find$>
			      C 
			      C       ucase$ MACRO lpString
			      C         IFNDEF __UNICODE__
			      C           invoke szUpper,reparg(lpString)
			      C           EXITM <eax>
			      C         ELSE
			      C           push esi
			      C           mov esi, reparg(lpString)
			      C           fn CharUpperBuff,esi,rv(ucLen,esi)
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       lcase$ MACRO lpString
			      C         IFNDEF __UNICODE__
			      C           invoke szLower,reparg(lpString)
			      C         EXITM <eax>
			      C         ELSE
			      C           push esi
			      C           mov esi, reparg(lpString)
			      C           fn CharLowerBuff,esi,rv(ucLen,esi)
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       left$ MACRO lpString,slen
			      C         IFNDEF __UNICODE__
			      C           invoke szLeft,reparg(lpString),reparg(lpString),slen
			      C         ELSE
			      C           push esi
			      C           mov esi, reparg(lpString)
			      C           invoke ucLeft,esi,esi,slen
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       right$ MACRO lpString,slen
			      C         IFNDEF __UNICODE__
			      C           invoke szRight,reparg(lpString),reparg(lpString),slen
			      C           EXITM <eax>
			      C         ELSE
			      C           push esi
			      C           mov esi, reparg(lpString)
			      C           invoke ucRight,esi,esi,slen
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       rev$ MACRO lpString
			      C         IFNDEF __UNICODE__
			      C           invoke szRev,reparg(lpString),reparg(lpString)
			      C           EXITM <eax>
			      C         ELSE
			      C           push esi
			      C           mov esi, reparg(lpString)
			      C           invoke ucRev,esi,esi
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       ltrim$ MACRO lpString
			      C         IFNDEF __UNICODE__
			      C           invoke szLtrim,reparg(lpString),reparg(lpString)
			      C           mov eax, ecx
			      C           EXITM <eax>
			      C         ELSE
			      C           push esi
			      C           mov esi, reparg(lpString)
			      C           invoke ucLtrim,esi,esi
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       rtrim$ MACRO lpString
			      C         IFNDEF __UNICODE__
			      C           invoke szRtrim,reparg(lpString),reparg(lpString)
			      C           mov eax, ecx
			      C           EXITM <eax>
			      C         ELSE
			      C           push esi
			      C           mov esi, reparg(lpString)
			      C           invoke ucRtrim,esi,esi
			      C           mov eax, esi
			      C           pop esi
			      C           EXITM <eax>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       trim$ MACRO lpString
			      C         IFNDEF __UNICODE__
			      C           invoke szTrim,reparg(lpString)
			      C           mov eax, ecx
			      C           EXITM <eax>
			      C         ELSE
			      C           EXITM <ltrim$(rtrim$(lpString))>
			      C         ENDIF
			      C       ENDM
			      C 
			      C       remove$ MACRO src,substr
			      C         IFDEF __UNICODE__
			      C           invoke ucRemove,reparg(src),reparg(src),reparg(substr)
			      C           EXITM <eax>
			      C         ENDIF
			      C         invoke szRemove,reparg(src),reparg(src),reparg(substr)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       uhex$ MACRO DDvalue   ;; unsigned DWORD to hex string
			      C         LOCAL rvstring
			      C         .data
			      C           rvstring db 12 dup (0)
			      C         align 4
			      C         .code
			      C         invoke dw2hex,DDvalue,ADDR rvstring
			      C         EXITM <OFFSET rvstring>
			      C       ENDM
			      C 
			      C     ; ----------------------------------
			      C     ; API string functions from KERNEL32
			      C     ; ----------------------------------
			      C       lstrcat$ MACRO arg1,arg2
			      C         invoke lstrcat,tstarg(arg1),reparg(arg2)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       lstrcmp$ MACRO arg1,arg2
			      C         invoke lstrcmp,reparg(arg1),reparg(arg2)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       lstrcmpi$ MACRO arg1,arg2
			      C         invoke lstrcmpi,reparg(arg1),reparg(arg2)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       lstrcpy$ MACRO arg1,arg2
			      C         invoke lstrcpy,tstarg(arg1),reparg(arg2)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       lstrcpyn$ MACRO arg1,arg2,ccnt
			      C         invoke lstrcpyn,tstarg(arg1),reparg(arg2),ccnt
			      C         EXITM <eax>
			      C       ENDM
			      C     ; ----------------------------------
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; ------------------------------------------------------
			      C   ; macro for concantenating strings using the szMultiCat
			      C   ; procedure written by Alexander Yackubtchik.
			      C   ;
			      C   ; USAGE strcat buffer,str1,str2,str3 etc ...
			      C   ; 
			      C   ; buffer must be large enough to contain all of the
			      C   ; strings to append. Limit is set by maximum line
			      C   ; length in MASM.
			      C   ; ------------------------------------------------------
			      C     strcat MACRO arguments:VARARG
			      C     LOCAL txt
			      C     LOCAL pcount
			      C       IFNDEF __UNICODE__
			      C         txt equ <invoke szMultiCat,>        ;; ANSI lead string
			      C       ELSE
			      C         txt equ <invoke ucMultiCat,>        ;; UNICODE lead string
			      C       ENDIF
			      C         pcount = 0
			      C           FOR arg, <arguments>
			      C             pcount = pcount + 1             ;; count arguments
			      C           ENDM
			      C         % pcount = pcount - 1               ;; dec 1 for 1st arg
			      C         txt CATSTR txt,%pcount              ;; append number to lead string
			      C           FOR arg, <arguments>
			      C             txt CATSTR txt,<,>,reparg(arg)
			      C           ENDM
			      C         txt                                 ;; put result in code
			      C     ENDM
			      C 
			      C   ; ----------------------------------------------
			      C   ; this version is used in the function position
			      C   ; ----------------------------------------------
			      C     cat$ MACRO arguments:VARARG
			      C       LOCAL txt
			      C       LOCAL spare
			      C       LOCAL pcount
			      C         spare equ <>
			      C           FOR arg, <arguments>
			      C             spare CATSTR spare,tstarg(arg)  ;; test if 1st arg is quoted text
			      C             EXITM                           ;; and produce error if it is
			      C           ENDM
			      C         IFNDEF __UNICODE__
			      C           txt equ <invoke szMultiCat,>      ;; ANSI lead string
			      C         ELSE
			      C           txt equ <invoke ucMultiCat,>      ;; UNICODE lead string
			      C         ENDIF
			      C         pcount = 0
			      C           FOR arg, <arguments>
			      C             pcount = pcount + 1             ;; count arguments
			      C           ENDM
			      C         % pcount = pcount - 1               ;; dec 1 for 1st arg
			      C         txt CATSTR txt,%pcount              ;; append number to lead string
			      C           FOR arg, <arguments>
			      C             txt CATSTR txt,<,>,reparg(arg)
			      C           ENDM
			      C         txt                                 ;; put result in code
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; -------------------------------------------------
			      C   ; UNICODE aware API based environment string macros
			      C   ; -------------------------------------------------
			      C     envget$ MACRO str1
			      C       IFNDEF get@@env@@buffer
			      C         .data?
			      C           buffer@@1024 TCHAR 1024 dup (?)
			      C         .code
			      C         get@@env@@buffer equ 1
			      C       ENDIF
			      C       mov DWORD PTR buffer@@1024[0], 0  ;; clear buffer each call
			      C       fn GetEnvironmentVariable,reparg(str1),OFFSET buffer@@1024,1024
			      C       EXITM <OFFSET buffer@@1024>
			      C     ENDM
			      C 
			      C     envset$ MACRO evar,evalue
			      C       IFIDN <evalue>,<0>
			      C         fn SetEnvironmentVariable,reparg(evar),NULL
			      C       ELSE
			      C         fn SetEnvironmentVariable,reparg(evar),reparg(evalue)
			      C       ENDIF
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C   ; ---------------------------------------
			      C   ; Legacy MSVCRT environment string macros
			      C   ; ---------------------------------------
			      C     env$ MACRO item
			      C       invoke crt_getenv,reparg(item)
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     setenv MACRO value
			      C       invoke crt__putenv,reparg(value)
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C     ; -------------------------------------------
			      C     ;             Pseudo mnemonics.
			      C     ; These macros emulate assembler mnemonics
			      C     ; but perform higher level operations not
			      C     ; directly supported by the instruction set
			      C     ; NOTE: The parameter order is the normal
			      C     ; assembler order of,
			      C     ; instruction/destination/source
			      C     ; -------------------------------------------
			      C 
			      C     ; --------------------------
			      C     ; szstring to szstring copy
			      C     ; --------------------------
			      C       cst MACRO arg1,arg2
			      C         IFNDEF __UNICODE__
			      C           invoke szCopy,reparg(arg2),tstarg(arg1)
			      C         ELSE
			      C           invoke ucCopy,reparg(arg2),tstarg(arg1)
			      C         ENDIF
			      C       ENDM
			      C 
			      C     ; ----------------------------
			      C     ; memory to memory assignment
			      C     ; ----------------------------
			      C       m2m MACRO M1, M2
			      C         push M2
			      C         pop  M1
			      C       ENDM
			      C 
			      C     ; --------------------------------------------------
			      C     ; memory to memory assignment using the EAX register
			      C     ; --------------------------------------------------
			      C       mrm MACRO m1, m2
			      C         mov eax, m2
			      C         mov m1, eax
			      C       ENDM
			      C 
			      C     ; *******************************************
			      C     ;             String Assign                 *
			      C     ; Assign quoted text to a locally declared  *
			      C     ; string handle (DWORD variable) in a proc  *
			      C     ; to effectively have a LOCAL scope strings *
			      C     ; EXAMPLE :                                 *
			      C     ; sas MyVar,"This is an assigned string"    *
			      C     ; *******************************************
			      C       sas MACRO var,quoted_text:VARARG
			      C         LOCAL txtname
			      C         IFNDEF __UNICODE__
			      C         .data
			      C           txtname db quoted_text,0
			      C           align 4
			      C         .code
			      C         ELSE
			      C           WSTR txtname,quoted_text
			      C         ENDIF
			      C         mov var, OFFSET txtname
			      C       ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; -------------------------
			      C   ; determine an operand type
			      C   ; -------------------------
			      C     op_type MACRO arg:REQ
			      C       LOCAL result
			      C       result = opattr(arg)
			      C         IF result eq 37         ;; label, either local or global
			      C           EXITM %1
			      C         ELSEIF result eq 42     ;; GLOBAL var
			      C           EXITM %2
			      C         ELSEIF result eq 98     ;; LOCAL  var
			      C           EXITM %3
			      C         ELSEIF result eq 36     ;; immediate operand or constant
			      C           EXITM %4
			      C         ELSEIF result eq 48     ;; register
			      C           EXITM %5
			      C         ELSEIF result eq 805    ;; local procedure in code
			      C           EXITM %6
			      C         ELSEIF result eq 933    ;; external procedure or API call
			      C           EXITM %7
			      C         ENDIF
			      C       EXITM %0                  ;; anything else
			      C     ENDM
			      C 
			      C     ; *************************************
			      C     ; Return a register size in BYTES or  *
			      C     ; 0 if the argument is not a register *
			      C     ; *************************************
			      C     regsize MACRO item
			      C       LOCAL rval,ln
			      C       rval = 0
			      C       ln SIZESTR <item>
			      C     
			      C       IF ln EQ 2
			      C         goto two
			      C       ELSEIF ln EQ 3
			      C         goto three
			      C       ELSEIF ln EQ 4
			      C         goto four
			      C       ELSEIF ln EQ 5
			      C         goto five
			      C       ELSEIF ln EQ 6
			      C         goto six
			      C       ELSEIF ln EQ 8
			      C         goto eight
			      C       ELSE
			      C         goto notreg
			      C       ENDIF
			      C     
			      C     :two
			      C       for arg,<al,ah,bl,bh,cl,ch,dl,dh>
			      C         IFIDNI <arg>,<item>
			      C           rval = 1
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C     
			      C       for arg,<ax,bx,cx,dx,sp,bp,si,di>
			      C         IFIDNI <arg>,<item>
			      C           rval = 2
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C       goto notreg
			      C     
			      C     :three
			      C       for arg,<eax,ebx,ecx,edx,esp,ebp,esi,edi>
			      C         IFIDNI <arg>,<item>
			      C           rval = 4
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C     
			      C       for arg,<st0,st1,st2,st3,st4,st5,st6,st7>
			      C         IFIDNI <arg>,<item>
			      C           rval = 10
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C     
			      C       for arg,<mm0,mm1,mm2,mm3,mm4,mm5,mm6,mm7>
			      C         IFIDNI <arg>,<item>
			      C           rval = 8
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C       goto notreg
			      C     
			      C     :four
			      C       for arg,<xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7>
			      C         IFIDNI <arg>,<item>
			      C           rval = 16
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C       goto notreg
			      C     
			      C     :five
			      C       for arg,<mm(0),mm(1),mm(2),mm(3),mm(4),mm(5),mm(6),mm(7)>
			      C         IFIDNI <arg>,<item>
			      C           rval = 8
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C     
			      C       for arg,<st(0),st(1),st(2),st(3),st(4),st(5),st(6),st(7)>
			      C         IFIDNI <arg>,<item>
			      C           rval = 10
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C       goto notreg
			      C     
			      C     :six
			      C       for arg,<xmm(0),xmm(1),xmm(2),xmm(3),xmm(4),xmm(5),xmm(6),xmm(7)>
			      C         IFIDNI <arg>,<item>
			      C           rval = 16
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF
			      C       
			      C     :eight
			      C       for arg,<edx::eax,ecx::ebx>
			      C         IFIDNI <arg>,<item>
			      C           rval = 8
			      C           EXITM
			      C         ENDIF
			      C       ENDM
			      C       IF rval NE 0
			      C         EXITM %rval
			      C       ENDIF  
			      C     
			      C     :notreg
			      C       EXITM %rval
			      C     ENDM
			      C 
			      C ;---------------------------------------------------
			      C 
			      C     issize MACRO var:req, bytes:req
			      C         LOCAL rval
			      C         rval = regsize(var) 
			      C         IFE rval ; if not a register use SIZE 
			      C             IF SIZE var EQ bytes
			      C                 EXITM <1>
			      C             ELSE
			      C                 EXITM <0>
			      C             ENDIF
			      C         ELSE   ; it's a register       
			      C             IF rval EQ bytes
			      C                 EXITM <1>        
			      C             ELSE
			      C                 EXITM <0>
			      C             ENDIF    
			      C         ENDIF
			      C     ENDM
			      C 
			      C ; ----------------------------------------------
			      C 
			      C     isregister MACRO var:req
			      C         IF regsize(var)
			      C             EXITM <1>
			      C         ELSE
			      C             EXITM <0>
			      C         ENDIF    
			      C     ENDM    
			      C 
			      C   ; -----------------------------------------------------
			      C   ; "catargs" takes 3 arguments.
			      C   ; 1.  the NAME of the calling macro for error reporting
			      C   ; 2.  the ADDRESS of the memory allocated for the text
			      C   ; 3.  the ARGUMENTLIST of strings passed to the caller
			      C   ; -----------------------------------------------------
			      C     catargs MACRO mname,mem,args:VARARG
			      C       LOCAL lcnt,var                        ; LOCAL loop counter
			      C 
			      C       lcnt = argcount(args)                 ;; get the VARARG argument count
			      C       REPEAT lcnt
			      C 
			      C       var equ repargof(getarg(lcnt,args))
			      C       ; -------------------------------------------------
			      C       ; if argument is a register, display error and stop
			      C       ; -------------------------------------------------
			      C         IF op_type(repargof(getarg(lcnt,args))) EQ 4
			      C           echo -------------------------------------------
			      C         % echo Argument num2str(lcnt) INVALID OPERAND in mname
			      C           echo ERROR Register or register return
			      C           echo value not allowed in this context
			      C           echo Valid options must be memory operands.
			      C           echo They can occur in the following forms,
			      C           echo *        1. quoted text
			      C           echo *        2. zero terminated string address
			      C           echo *        3. macro that returns an OFFSET
			      C           echo *        4. built in character operators
			      C           echo -------------------------------------------
			      C         .err
			      C         ENDIF
			      C         IFIDN var,<lb>                      ;; ( notation
			      C           IFNDEF @left_bracket@
			      C             .data
			      C               @left_bracket@ db "(",0
			      C             .code
			      C           ENDIF
			      C           push OFFSET @left_bracket@
			      C           goto overit
			      C         ENDIF
			      C         IFIDN var,<rb>                      ;; ) notation
			      C           IFNDEF @right_bracket@
			      C             .data
			      C               @right_bracket@ db ")",0
			      C             .code
			      C           ENDIF
			      C           push OFFSET @right_bracket@
			      C           goto overit
			      C         ENDIF
			      C         IFIDN var,<la>                      ;; < notation
			      C           IFNDEF @left_angle@
			      C             .data
			      C               @left_angle@ db "<",0
			      C             .code
			      C           ENDIF
			      C           push OFFSET @left_angle@
			      C           goto overit
			      C         ENDIF
			      C         IFIDN var,<ra>                      ;; > notation
			      C           IFNDEF @right_angle@
			      C             .data
			      C               @right_angle@ db ">",0
			      C             .code
			      C           ENDIF
			      C           push OFFSET @right_angle@
			      C           goto overit
			      C         ENDIF
			      C         IFIDN var,<q>                       ;; quote notation
			      C           IFNDEF @quote@
			      C             .data
			      C               @quote@ db 34,0
			      C             .code
			      C           ENDIF
			      C           push OFFSET @quote@
			      C           goto overit
			      C         ENDIF
			      C         IFIDN var,<n>                       ;; newline notation
			      C           IFNDEF @nln@
			      C             .data
			      C               @nln@ db 13,10,0
			      C             .code
			      C           ENDIF
			      C           push OFFSET @nln@
			      C           goto overit
			      C         ENDIF
			      C         IFIDN var,<t>                       ;; tab notation
			      C           IFNDEF @tab@
			      C             .data
			      C               @tab@ db 9,0
			      C             .code
			      C           endif
			      C           push offset @tab@
			      C           goto overit
			      C         ENDIF
			      C         push var                            ;; push current argument
			      C       :overit
			      C         lcnt = lcnt - 1
			      C       ENDM
			      C 
			      C       push mem                              ;; push the buffer address
			      C       push argcount(args)                   ;; push the argument count
			      C       call szMultiCat                       ;; call the C calling procedure
			      C       add esp, argcount(args)*4+8           ;; correct the stack
			      C     ENDM
			      C 
			      C   ; ******************************************************
			      C   ; num2str feeds a numeric macro value through a seperate
			      C   ; macro to force a text return value. It is useful for
			      C   ; displaying loop based debugging info and for display
			      C   ; purposes with error reporting.
			      C   ; NOTE :
			      C   ; prefix the "echo" to display this result with "%"
			      C   ; EXAMPLE :
			      C   ; % echo num2str(arg)
			      C   ; ******************************************************
			      C     num2str MACRO arg
			      C       EXITM % arg
			      C     ENDM
			      C 
			      C   ; ====================================
			      C 
			      C     arralloc$ MACRO member_count        ;; create a new empty array
			      C       EXITM <rv(arralloc,member_count)>
			      C     ENDM
			      C 
			      C     arrealloc$ MACRO arr,cnt            ;; change the size of an existing array
			      C       EXITM <rv(arrealloc,arr,cnt)>
			      C     ENDM
			      C 
			      C     arrfree$ MACRO arr                  ;; destroy an array freeing all of the memory it uses
			      C       EXITM <rv(arrfree,arr)>
			      C     ENDM
			      C 
			      C   ; ====================================
			      C 
			      C     arrset$ MACRO arr,indx,ptxt         ;; write text data to an array member
			      C       EXITM <rv(arrset,arr,indx,reparg(ptxt))>
			      C     ENDM
			      C 
			      C     arrbin$ MACRO arr,indx,psrc,lsrc    ;; write binary data to an array member
			      C       EXITM <rv(arrbin,arr,indx,psrc,lsrc>)
			      C     ENDM
			      C 
			      C     arrtxt$ MACRO ptxt                  ;; load multiline text buffer into array
			      C       EXITM <rv(arrtxt,ptxt)>
			      C     ENDM
			      C 
			      C     arrfile$ MACRO file_name            ;; load multiline text file into array
			      C       EXITM <rv(arrfile,reparg(file_name))>
			      C     ENDM
			      C 
			      C   ; ====================================
			      C 
			      C     arrget$ MACRO arr,indx              ;; get the address of an array member
			      C       EXITM <rv(arrget,arr,indx)>
			      C     ENDM
			      C 
			      C     arrcnt$ MACRO arr                   ;; get the stored member count
			      C       EXITM <rv(arrcnt,arr)>
			      C     ENDM
			      C 
			      C     arrlen$ MACRO arr,indx              ;; get the stored length of a single member
			      C       EXITM <rv(arrlen,arr,indx)>
			      C     ENDM
			      C 
			      C     arrtotal$ MACRO arr,crlf            ;; calculate entire array storage
			      C       EXITM <rv(arrtotal,arr,crlf)>     ;; with or without trailing CRLF
			      C     ENDM
			      C 
			      C ; ====================================
			      C 
			      C     arr2file$ MACRO arr,ptxt            ;; write array to text file with CRLF line termination
			      C       EXITM <rv(arr2file,parr,reparg(ptxt))>    ;; returning written file length
			      C     ENDM
			      C 
			      C     arr2mem$ MACRO arr,pmem             ;; binary write array to memory with
			      C       EXITM <rv(arr2mem,arr,pmem)>      ;; no trailing CRLF
			      C     ENDM
			      C 
			      C     arr2text$ MACRO arr,pmem            ;; write array to text buffer
			      C       EXITM <rv(arr2text,arr,pmem)>
			      C     ENDM
			      C 
			      C ; ====================================
			      C 
			      C     arrtrunc$ MACRO arr,indx            ;; truncate an existing array
			      C       EXITM <rv(arrtrunc,arr,indx)>
			      C     ENDM
			      C 
			      C     arrextnd$ MACRO arr,indx            ;; extend an existing array
			      C       EXITM <rv(arrextnd,arr,indx)>
			      C     ENDM
			      C 
			      C ; ====================================
			      C 
			      C     ; ----------------------------------------------------------------------
			      C     ; A macro that encapsulates GetLastError() and FormatMessage() to return
			      C     ; the system based error string for debugging API functions that return
			      C     ; error information with the GetLastError() API call.
			      C     ; ----------------------------------------------------------------------
			      C       LastError$ MACRO
			      C         IFNDEF @@_e_r_r_o_r_@@
			      C           .data?
			      C             @@_e_r_r_o_r_@@ db 1024 dup (?)
			      C           .code
			      C         ENDIF
			      C         pushad
			      C         pushfd
			      C         invoke GetLastError
			      C         mov edi,eax
			      C         invoke FormatMessage,FORMAT_MESSAGE_FROM_SYSTEM,
			      C                              NULL,edi,0,ADDR @@_e_r_r_o_r_@@,1024,NULL
			      C         popfd
			      C         popad
			      C         EXITM <OFFSET @@_e_r_r_o_r_@@>
			      C       ENDM
			      C 
			      C     ; --------------------------------------------
			      C     ; the following two macros are for prototyping
			      C     ; direct addresses with a known argument list.
			      C     ; --------------------------------------------
			      C       SPROTO MACRO func_addr:REQ,arglist:VARARG     ;; STDCALL version
			      C         LOCAL lp,var
			      C         .data?
			      C           func_addr dd ?
			      C         .const
			      C         var typedef PROTO STDCALL arglist
			      C         lp TYPEDEF PTR var
			      C         EXITM <equ <(TYPE lp) PTR func_addr>>
			      C       ENDM
			      C 
			      C       CPROTO MACRO func_addr:REQ,arglist:VARARG     ;; C calling version
			      C         LOCAL lp,var
			      C         .data?
			      C           func_addr dd ?
			      C         .const
			      C         var typedef PROTO C arglist
			      C         lp TYPEDEF PTR var
			      C         EXITM <equ <(TYPE lp) PTR func_addr>>
			      C       ENDM
			      C 
			      C   ; ------------------------------------------------------
			      C   ; turn stackframe off and on for low overhead procedures
			      C   ; ------------------------------------------------------
			      C     stackframe MACRO arg
			      C       IFIDN <on>,<arg>
			      C         OPTION PROLOGUE:PrologueDef
			      C         OPTION EPILOGUE:EpilogueDef
			      C       ELSEIFIDN <off>,<arg>
			      C         OPTION PROLOGUE:NONE
			      C         OPTION EPILOGUE:NONE
			      C       ELSE
			      C         echo -----------------------------------
			      C         echo ERROR IN "stackframe" MACRO
			      C         echo Incorrect Argument Supplied
			      C         echo Options 
			      C         echo 1. off Turn default stack frame off
			      C         echo 2. on  Restore stack frame defaults
			      C         echo SYNTAX : frame on/off
			      C         echo -----------------------------------
			      C         .err
			      C       ENDIF
			      C     ENDM
			      C 
			      C comment * ------------------------------------------
			      C     jmp_table is used for arrays of label addresses
			      C     MASM supports writing the label name directly
			      C     into the .DATA section.
			      C     EXAMPLE:
			      C     jmp_table name,lbl1,lbl2,lbl3,lbl4
			      C         ------------------------------------------ *
			      C     jmp_table MACRO name,args:VARARG
			      C       .data
			      C         align 4
			      C         name dd args
			      C       .code
			      C     ENDM
			      C 
			      C     ; *******************
			      C     ; DATA DECLARATIONS *
			      C     ; *******************
			      C 
			      C     ; -------------------------------------
			      C     ; initialised GLOBAL value of any type
			      C     ; -------------------------------------
			      C       GLOBAL MACRO variable:VARARG
			      C       .data
			      C       align 4
			      C         variable
			      C       .code
			      C       ENDM
			      C 
			      C     ; --------------------------------
			      C     ; initialise floating point vaues
			      C     ; --------------------------------
			      C       FLOAT4 MACRO name,value
			      C         .data
			      C         align 4
			      C           name REAL4 value
			      C         .code
			      C       ENDM
			      C 
			      C       FLOAT8 MACRO name,value
			      C         .data
			      C         align 4
			      C           name REAL8 value
			      C         .code
			      C       ENDM
			      C 
			      C       FLOAT10 MACRO name,value
			      C         .data
			      C         align 4
			      C           name REAL10 value
			      C         .code
			      C       ENDM
			      C 
			      C     ; **********************************************************
			      C     ; function style macros for direct insertion of data types *
			      C     ; **********************************************************
			      C 
			      C       FP4 MACRO value
			      C         LOCAL vname
			      C         .data
			      C         align 4
			      C           vname REAL4 value
			      C         .code
			      C         EXITM <vname>
			      C       ENDM
			      C 
			      C       FP8 MACRO value
			      C         LOCAL vname
			      C         .data
			      C         align 4
			      C           vname REAL8 value
			      C         .code
			      C         EXITM <vname>
			      C       ENDM
			      C 
			      C       FP10 MACRO value
			      C         LOCAL vname
			      C         .data
			      C         align 4
			      C           vname REAL10 value
			      C         .code
			      C         EXITM <vname>
			      C       ENDM
			      C 
			      C     ; --------------------------------------------
			      C     ; FLD does not accept immediate operands. These
			      C     ; macros emulate loading an immediate value by
			      C     ; loading the value into the .DATA section.
			      C     ; EXAMPLE : fld8 1234.56789
			      C     ; --------------------------------------------
			      C       fld4 MACRO fpvalue
			      C         LOCAL name
			      C         .data
			      C           name REAL4 fpvalue
			      C           align 4
			      C         .code
			      C         fld name
			      C       ENDM
			      C 
			      C       fld8 MACRO fpvalue
			      C         LOCAL name
			      C         .data
			      C           name REAL8 fpvalue
			      C           align 4
			      C         .code
			      C         fld name
			      C       ENDM
			      C 
			      C       fld10 MACRO fpvalue
			      C         LOCAL name
			      C         .data
			      C           name REAL10 fpvalue
			      C           align 4
			      C         .code
			      C         fld name
			      C       ENDM
			      C     ; --------------------------------------------
			      C 
			      C     ; **********************************************
			      C     ; The original concept for the following macro *
			      C     ; was designed by "huh" from New Zealand.      *
			      C     ; **********************************************
			      C 
			      C     ; ---------------------
			      C     ; literal string MACRO
			      C     ; ---------------------
			      C       literal MACRO quoted_text:VARARG
			      C         LOCAL local_text
			      C         .data
			      C           local_text db quoted_text,0
			      C         align 4
			      C         .code
			      C         EXITM <local_text>
			      C       ENDM
			      C     ; --------------------------------
			      C     ; string address in INVOKE format
			      C     ; --------------------------------
			      C       SADD MACRO quoted_text:VARARG
			      C         EXITM <ADDR literal(quoted_text)>
			      C       ENDM
			      C     ; --------------------------------
			      C     ; string OFFSET for manual coding
			      C     ; --------------------------------
			      C       CTXT MACRO quoted_text:VARARG
			      C         EXITM <offset literal(quoted_text)>
			      C       ENDM
			      C 
			      C     ; -----------------------------------------------------
			      C     ; string address embedded directly in the code section
			      C     ; -----------------------------------------------------
			      C       CADD MACRO quoted_text:VARARG
			      C         LOCAL vname,lbl
			      C           jmp lbl
			      C             vname db quoted_text,0
			      C           align 4
			      C           lbl:
			      C         EXITM <ADDR vname>
			      C       ENDM
			      C 
			      C     ; --------------------------------------------------
			      C     ; Macro for placing an assembler instruction either
			      C     ; within another or within a procedure call
			      C     ; --------------------------------------------------
			      C 
			      C     ASM MACRO parameter1,source
			      C       LOCAL mnemonic
			      C       LOCAL dest
			      C       LOCAL poz
			      C 
			      C       % poz INSTR 1,<parameter1>,< >             ;; get the space position
			      C       mnemonic SUBSTR <parameter1>, 1, poz-1     ;; get the mnemonic
			      C       dest SUBSTR <parameter1>, poz+1            ;; get the first argument
			      C 
			      C       mnemonic dest, source
			      C 
			      C       EXITM <dest>
			      C     ENDM
			      C 
			      C     ; ------------------------------------------------------------
			      C     ; Macro for nesting function calls in other invoke statements
			      C     ; ------------------------------------------------------------
			      C       FUNC MACRO parameters:VARARG
			      C         invoke parameters
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; -----------------------------------
			      C     ; create a font and return its handle
			      C     ; -----------------------------------
			      C       GetFontHandle MACRO fnam:REQ,fsiz:REQ,fwgt:REQ
			      C         invoke RetFontHandle,reparg(fnam),fsiz,fwgt
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C   ; **************
			      C   ; File IO Macros
			      C   ; **************
			      C   ; ---------------------------------------------------------------------
			      C   ; create a new file with read / write access and return the file handle
			      C   ; ---------------------------------------------------------------------
			      C     fcreate MACRO filename
			      C       invoke CreateFileA,reparg(filename),GENERIC_READ or GENERIC_WRITE,
			      C                         NULL,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL
			      C       EXITM <eax>       ; return file handle
			      C     ENDM
			      C 
			      C     fcreateW MACRO filename
			      C       invoke CreateFileW,reparg(filename),GENERIC_READ or GENERIC_WRITE,
			      C                         NULL,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL
			      C       EXITM <eax>       ; return file handle
			      C     ENDM
			      C 
			      C   ; ------------------
			      C   ; delete a disk file
			      C   ; ------------------
			      C     fdelete MACRO filename
			      C       invoke DeleteFileA,reparg(filename)
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     fdeleteW MACRO filename
			      C       invoke DeleteFileW,reparg(filename)
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C   ; ------------------------------
			      C   ; flush open file buffer to disk
			      C   ; ------------------------------
			      C     fflush MACRO hfile
			      C       invoke FlushFileBuffers,hfile
			      C     ENDM
			      C 
			      C   ; -------------------------------------------------------------------------
			      C   ; open an existing file with read / write access and return the file handle
			      C   ; -------------------------------------------------------------------------
			      C     fopen MACRO filename
			      C       invoke CreateFileA,reparg(filename),GENERIC_READ or GENERIC_WRITE,
			      C                         NULL,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL
			      C       EXITM <eax>       ; return file handle
			      C     ENDM
			      C 
			      C     fopenW MACRO filename
			      C       invoke CreateFileW,reparg(filename),GENERIC_READ or GENERIC_WRITE,
			      C                         NULL,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL
			      C       EXITM <eax>       ; return file handle
			      C     ENDM
			      C 
			      C 
			      C   ; ------------------
			      C   ; close an open file
			      C   ; ------------------
			      C     fclose MACRO arg:REQ
			      C       invoke CloseHandle,arg
			      C     ENDM
			      C 
			      C   ; ------------------------------------------------
			      C   ; read data from an open file into a memory buffer
			      C   ; ------------------------------------------------
			      C     fread MACRO hFile,buffer,bcnt
			      C       LOCAL var
			      C       .data?
			      C         var dd ?
			      C       .code
			      C       invoke ReadFile,hFile,buffer,bcnt,ADDR var,NULL
			      C       mov eax, var
			      C       EXITM <eax>       ; return bytes read
			      C     ENDM
			      C 
			      C   ; ----------------------------------------
			      C   ; write data from a buffer to an open file
			      C   ; ----------------------------------------
			      C     fwrite MACRO hFile,buffer,bcnt
			      C       LOCAL var
			      C       .data?
			      C         var dd ?
			      C       .code
			      C       invoke WriteFile,hFile,buffer,bcnt,ADDR var,NULL
			      C       mov eax, var
			      C       EXITM <eax>       ; return bytes written
			      C     ENDM
			      C 
			      C   ; ----------------------------------------------------
			      C   ; write a line of zero terminated text to an open file
			      C   ; ----------------------------------------------------
			      C     fprint MACRO hFile:REQ,text:VARARG  ;; zero terminated text
			      C       LOCAL var
			      C       LOCAL pst
			      C       .data?
			      C         var dd ?
			      C         pst dd ?
			      C       .code
			      C       mov pst, repargv(text)
			      C       invoke WriteFile,hFile,pst,len(pst),ADDR var,NULL
			      C       invoke WriteFile,hFile,chr$(13,10),2,ADDR var,NULL
			      C     ENDM
			      C 
			      C   ; ---------------------------------
			      C   ; write zero terminated text with C
			      C   ; style formatting to an open file.
			      C   ; ---------------------------------
			      C     fprintc MACRO hFile:REQ,text:VARARG  ;; zero terminated text
			      C       LOCAL var
			      C       LOCAL pst
			      C       .data?
			      C         var dd ?
			      C         pst dd ?
			      C       .code
			      C       mov pst, cfm$(text)
			      C       invoke WriteFile,hFile,pst,len(pst),ADDR var,NULL
			      C     ENDM
			      C 
			      C   ; ------------------------------------
			      C   ; set the position of the file pointer
			      C   ; ------------------------------------
			      C     fseek MACRO hFile,distance,location
			      C       IFIDN <location>,<BEGIN>
			      C         var equ <FILE_BEGIN>
			      C       ELSEIFIDN <location>,<CURRENT>
			      C         var equ <FILE_CURRENT>
			      C       ELSEIFIDN <location>,<END>
			      C         var equ <FILE_END>
			      C       ELSE
			      C         var equ <location>
			      C       ENDIF
			      C       invoke SetFilePointer,hFile,distance,0,var
			      C       EXITM <eax>               ; return current file offset
			      C     ENDM
			      C 
			      C   ; ------------------------------------------------
			      C   ; set end of file at current file pointer location
			      C   ; ------------------------------------------------
			      C     fseteof MACRO hFile
			      C       invoke SetEndOfFile,hFile
			      C     ENDM
			      C 
			      C   ; -------------------------------
			      C   ; return the size of an open file
			      C   ; -------------------------------
			      C     fsize MACRO hFile
			      C       invoke GetFileSize,hFile,NULL
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C   ; ---------------------------------------
			      C   ; extended formatting version writes text
			      C   ; to the current file pointer location
			      C   ; ---------------------------------------
			      C     ftext MACRO hFile:REQ,args:VARARG
			      C       push esi                              ; preserve ESI
			      C       mov esi, alloc(16384)                 ;; allocate 16k of buffer
			      C       catargs ftext,esi,args                ;; write ALL args to a single string
			      C       push eax                              ; make 4 bytes on the stack
			      C       invoke WriteFile,hFile,esi,len(esi),esp,NULL
			      C       pop eax                               ; release the 4 bytes
			      C       free esi                              ;; free the memory buffer
			      C       pop esi                               ; restore ESI
			      C     ENDM
			      C 
			      C   ; -----------------------
			      C   ; test if file exists
			      C   ; return values
			      C   ; 1 = file exists
			      C   ; 0 = file does not exist
			      C   ; -----------------------
			      C     fexist MACRO name_of_file
			      C       IFNDEF __UNICODE__
			      C         EXITM <rv(exist,name_of_file)>
			      C       ELSE
			      C         EXITM <rv(existW,name_of_file)>
			      C       ENDIF
			      C     ENDM
			      C   ; -----------------------
			      C 
			      C   ; ----------------------------------------------------------
			      C   ; function position macros that takes a DWORD parameter and
			      C   ; returns the address of the buffer that holds the result.
			      C   ; The return format is for use within the INVOKE syntax.
			      C   ; ----------------------------------------------------------
			      C     str$ MACRO DDvalue
			      C       LOCAL rvstring
			      C       .data
			      C         rvstring db 20 dup (0)
			      C         align 4
			      C       .code
			      C       invoke dwtoa,DDvalue,ADDR rvstring
			      C       EXITM <ADDR rvstring>
			      C     ENDM
			      C 
			      C     hex$ MACRO DDvalue
			      C       LOCAL rvstring
			      C       .data
			      C         rvstring db 12 dup (0)
			      C         align 4
			      C       .code
			      C       invoke dw2hex,DDvalue,ADDR rvstring
			      C       EXITM <ADDR rvstring>
			      C     ENDM
			      C 
			      C     ; ---------------------------------------------------------------
			      C     ; Get command line arg specified by "argnum" starting at arg 1
			      C     ; Test the return values with the following to determine results
			      C     ; 1 = successful operation
			      C     ; 2 = no argument exists at specified arg number
			      C     ; 3 = non matching quotation marks
			      C     ; 4 = empty quotation marks
			      C     ; test the return value in ECX
			      C     ; ---------------------------------------------------------------
			      C 
			      C       cmd$ MACRO argnum
			      C         LOCAL argbuffer
			      C         .data?
			      C           argbuffer db MAX_PATH dup (?)
			      C         .code
			      C         invoke GetCL,argnum, ADDR argbuffer
			      C         mov ecx, eax
			      C         mov eax, OFFSET argbuffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C   ; --------------------------------------------------------
			      C   ; Get the UNICODE command line argument specified by the
			      C   ; 1 based argument number. 1 = arg1, 2 = arg2 etc ....
			      C   ;
			      C   ; The result is returned as an OFFSET to a buffer.
			      C   ;
			      C   ; Testing RETURN VALUES in EAX
			      C   ; < 0 = buffer not large enough for selected arg
			      C   ;   0 = arg not found
			      C   ; > 0 = arg number read from command tail
			      C   ;
			      C   ; NOTE that a negative return value in EAX indicates
			      C   ; buffer over-run protection if and when a command line is
			      C   ; longer than the MAX_PATH constant.
			      C   ; --------------------------------------------------------
			      C 
			      C       ucCmd$ MACRO argnum
			      C         IFNDEF ucl_@_buffer
			      C           .data?
			      C             uc_@_cl_@_buffer TCHAR MAX_PATH dup (?)
			      C           .code
			      C           ucl_@_buffer equ 1
			      C         ENDIF 
			      C         fn ucGetCL,OFFSET uc_@_cl_@_buffer,MAX_PATH,argnum
			      C         EXITM <OFFSET uc_@_cl_@_buffer>
			      C       ENDM
			      C 
			      C 
			      C     ; **************************
			      C     ; memory allocation macros *
			      C     ; **************************
			      C 
			      C     comment * --------------------------------------------------    
			      C             Two macros for allocating and freeing OLE memory.
			      C             stralloc returns the handle/address of the string
			      C             memory in eax. alloc$ acts in the same way but is
			      C             used in the function position. strfree uses the
			      C             handle to free memory after use.
			      C     
			      C             NOTE that you must use the following INCLUDE &
			      C             LIB files with these two macros.
			      C     
			      C             include \MASM32\include\oleaut32.inc
			      C             includelib \MASM32\LIB\oleaut32.lib
			      C             -------------------------------------------------- *
			      C 
			      C       alloc$ MACRO ln
			      C         invoke SysAllocStringByteLen,0,ln
			      C         mov BYTE PTR [eax], 0
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       free$ MACRO strhandle
			      C         invoke SysFreeString,strhandle
			      C       ENDM
			      C 
			      C       stralloc MACRO ln
			      C         invoke SysAllocStringByteLen,0,ln
			      C       ENDM
			      C 
			      C       strfree MACRO strhandle
			      C         invoke SysFreeString,strhandle
			      C       ENDM
			      C 
			      C comment * ------------------------------------------------
			      C     The following 2 macros are for general purpose memory
			      C     allocation where fine granularity in memory is required
			      C     or where the memory attribute "execute" is useful.
			      C     ------------------------------------------------------ *
			      C 
			      C       alloc MACRO bytecount
			      C         invoke GlobalAlloc,GMEM_FIXED or GMEM_ZEROINIT,bytecount
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       free MACRO hmemory
			      C         invoke GlobalFree,hmemory
			      C       ENDM
			      C 
			      C comment * ---------------------------------------------------------
			      C         Heap allocation and deallocation macros. On later versions
			      C         of Windows HeapAlloc() appears to be faster on small
			      C         allocations than GlobalAlloc() using the GMEM_FIXED flag.
			      C         --------------------------------------------------------- *
			      C 
			      C       halloc MACRO bytecount
			      C         EXITM <rv(HeapAlloc,rv(GetProcessHeap),0,bytecount)>
			      C       ENDM
			      C 
			      C       hsize MACRO hmem
			      C         invoke HeapSize,rv(GetProcessHeap),0,hmem
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       hfree MACRO memory
			      C         invoke HeapFree,rv(GetProcessHeap),0,memory
			      C       ENDM
			      C 
			      C     ; ************************************************************
			      C     ;                      File Input macros                     *
			      C     ;                                                            *
			      C     ; 3 versions are presented here.                             *
			      C     ;                                                            *
			      C     ; 1. InputFile      determined by the __UNICODE__ equate.    *
			      C     ; 2. InputFileA     ASCII only version.                      *
			      C     ; 3. InputFileW     UNICODE only version.                    *
			      C     ;                                                            *
			      C     ; NOTE: With the address returned by InputFile that contains *
			      C     ; the data in the file, it must be deallocated using the API *
			      C     ; function GlobalFree() or the macro "free".                 *
			      C     ; EXAMPLE: invoke GlobalFree,pMem                            *
			      C     ;                                                            *
			      C     ; If you specify either the ASCII or UNICODE version of the  *
			      C     ; macro you must match the text type for the file name       *
			      C     ; to the macro being called.                                 *
			      C     ;                                                            *
			      C     ; For ASCII use the "ascii()" macro.                         *
			      C     ; for UNICODE use either the "uni$()" or the "uc$()" macro.  *
			      C     ;                                                            *
			      C     ; If you are providing an address instead of a literal       *
			      C     ; string, the text must be in the matching format for either *
			      C     ; ASCII or UNICODE.                                          *
			      C     ;                                                            *
			      C     ; ************************************************************
			      C 
			      C       InputFileA MACRO lpFile
			      C       ; ----------------------------------------------------------
			      C       ; The untidy data? names are to avoid duplication in normal
			      C       ; code. The two values are reused by each call to the macro
			      C       ; ----------------------------------------------------------
			      C         IFNDEF ipf@@flagA           ;; if the flag is not defined
			      C           .data?
			      C             ipf@__@mem@__@PtrA dd ? ;; write 2 DWORD variables to
			      C             ipf@__file__@lenA dd ?  ;; the uninitialised data section
			      C           .code
			      C           ipf@@flagA equ <1>        ;; define the flag
			      C         ENDIF
			      C 
			      C         invoke read_disk_file,reparg(lpFile),
			      C                ADDR ipf@__@mem@__@PtrA,
			      C                ADDR ipf@__file__@lenA
			      C 
			      C         mov ecx, ipf@__file__@lenA   ;; file length returned in ECX
			      C         mov eax, ipf@__@mem@__@PtrA  ;; address of memory returned in EAX
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       InputFileW MACRO lpFile
			      C       ; ----------------------------------------------------------
			      C       ; The untidy data? names are to avoid duplication in normal
			      C       ; code. The two values are reused by each call to the macro
			      C       ; ----------------------------------------------------------
			      C         IFNDEF ipf@@flagW           ;; if the flag is not defined
			      C           .data?
			      C             ipf@__@mem@__@PtrW dd ? ;; write 2 DWORD variables to
			      C             ipf@__file__@lenW dd ?  ;; the uninitialised data section
			      C           .code
			      C           ipf@@flagW equ <1>        ;; define the flag
			      C         ENDIF
			      C 
			      C         invoke read_disk_fileW,reparg(lpFile),
			      C                ADDR ipf@__@mem@__@PtrW,
			      C                ADDR ipf@__file__@lenW
			      C 
			      C         mov ecx, ipf@__file__@lenW  ;; file length returned in ECX
			      C         mov eax, ipf@__@mem@__@PtrW ;; address of memory returned in EAX
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       InputFile MACRO lpFile
			      C         IFNDEF __UNICODE__
			      C           EXITM <InputFileA(lpFile)>
			      C         ENDIF
			      C         EXITM <InputFileW(lpFile)>
			      C       ENDM
			      C 
			      C     ; ************************************************************
			      C     ;                     File Output macros                     *
			      C     ;                                                            *
			      C     ; 3 versions are presented here.                             *
			      C     ;                                                            *
			      C     ; 1. OutputFile     determined by the __UNICODE__ equate.    *
			      C     ; 2. OutputFileA    ASCII only version                       *
			      C     ; 3. OutputFileW    UNICODE only version                     *
			      C     ;                                                            *
			      C     ; If you specify either the ASCII or UNICODE version of the  *
			      C     ; macro you must match the text type for the file name       *
			      C     ; to the macro being called.                                 *
			      C     ;                                                            *
			      C     ; For ASCII use the "ascii()" macro.                         *
			      C     ; for UNICODE use either the "uni$()" or the "uc$()" macro.  *
			      C     ;                                                            *
			      C     ; If you are providing an address instead of a literal       *
			      C     ; string, the text must be in the matching format for either *
			      C     ; ASCII or UNICODE.                                          *
			      C     ;                                                            *
			      C     ; ************************************************************
			      C 
			      C       OutputFileA MACRO lpFile,lpMem,lof
			      C         invoke write_disk_file,reparg(lpFile),lpMem,lof
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       OutputFileW MACRO lpFile,lpMem,lof
			      C         invoke write_disk_fileW,reparg(lpFile),lpMem,lof
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       OutputFile MACRO lpFile,lpMem,lof
			      C         IFNDEF __UNICODE__
			      C           invoke write_disk_file,reparg(lpFile),lpMem,lof
			      C           EXITM <eax>
			      C         ENDIF
			      C         invoke write_disk_fileW,reparg(lpFile),lpMem,lof
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; -----------------------------------------
			      C     ; common dialog file open and close macros.
			      C     ; Return value in both is the OFFSET of a
			      C     ; 260 byte dedicated buffer in the .DATA?
			      C     ; section in EAX.
			      C     ; -----------------------------------------
			      C       OpenFileDlg MACRO hWin,hInstance,lpTitle,lpPattern
			      C         invoke OpenFileDialog,hWin,hInstance,reparg(lpTitle),reparg(lpPattern)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       SaveFileDlg MACRO hWin,hInstance,lpTitle,lpPattern
			      C         invoke SaveFileDialog,hWin,hInstance,reparg(lpTitle),reparg(lpPattern)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; ----------------------------------------------------------
			      C     ; load a library and get the procedure address in one macro
			      C     ; return value for the proc address in in EAX. Both DLL and
			      C     ; procedure name are enclosed in quotation marks.
			      C     ;
			      C     ; EXAMPLE : LoadProcAddress "mydll.dll","myproc"
			      C     ;           proc address in EAX
			      C     ;           library handle in ECX
			      C     ;
			      C     ; EXAMPLE : mov lpProc, GetDllProc("mydll.dll","myproc")
			      C     ;           library handle in ECX
			      C     ; ----------------------------------------------------------
			      C 
			      C       LoadProcAddress MACRO libname_text1,procname_text2
			      C         LOCAL library_name
			      C         LOCAL proc_name
			      C           .data
			      C             library_name db libname_text1,0
			      C             proc_name db procname_text2,0
			      C           align 4
			      C           .code
			      C         invoke LoadLibrary,ADDR library_name
			      C         mov ecx, eax
			      C         invoke GetProcAddress,eax,ADDR proc_name
			      C       ENDM
			      C 
			      C       GetDllProc MACRO libname_text1,procname_text2
			      C         LOCAL library_name
			      C         LOCAL proc_name
			      C           .data
			      C             library_name db libname_text1,0
			      C             proc_name db procname_text2,0
			      C           align 4
			      C           .code
			      C         invoke LoadLibrary,ADDR library_name
			      C         mov ecx, eax
			      C         invoke GetProcAddress,eax,ADDR proc_name
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; **********************************
			      C     ; control flow macro by Greg Falen *
			      C     ; **********************************
			      C 
			      C     ; ----------------------
			      C     ; Switch/Case emulation
			      C     ; ----------------------
 = 			      C     $casflg equ <>
 = 			      C     $casvar equ <>
 = 			      C     $casstk equ <>
			      C     
			      C     switch macro _var:req, _reg:=<eax>
			      C         mov _reg, _var
			      C         $casstk catstr <_reg>, <#>, $casflg, <#>, $casstk
			      C         $casvar equ _reg
			      C         $casflg equ <0>         ;; 0 = emit an .if, 1 an .elseif
			      C     endm
			      C     
			      C     case macro _args:vararg     ;; like Pascal: case id1. id4 .. id8, lparam, ...
			      C                                 ; does an or (case1 || case2 || case3...)
			      C       $cas textequ <>
			      C       irp $v, <_args>         ;; for each case
			      C           t@ instr <$v>, <..> ;; range ?
			      C           if t@               ;; yes
			      C               $LB substr <$v>, 1, t@-1                  ;; lbound = left portion
			      C               $LB catstr <(>, $casvar, <!>=>, $LB, <)>  ;; ($casvar >= lbound)
			      C               $UB substr <$v>, t@+2                     ;; ubound = right portion
			      C               $UB catstr <(>, $casvar, <!<=>, $UB, <)>  ;; ($casvar <= ubound)
			      C               $t catstr <(>, $LB, <&&> , $UB,<)>        ;; (($casvar >= $lb) && ($casvar <= $ub))
			      C           else    ;; no, it's a value (var/const)
			      C               $t catstr <(>, $casvar, <==>, <$v>, <)>   ;; ($casvar == value)
			      C           endif
			      C           $cas catstr <|| >, $t, $cas                   ;; or this case w/ others
			      C       endm
			      C       $cas substr $cas, 3 ;; lose the extra "|| " in front
			      C         ifidn $casflg, <0> ;; 0 = 1'st case
			      C             % .if $cas ;; emit ".if"
			      C         else ;; all others
			      C             % .elseif $cas ;; emit ".elseif"
			      C         endif
			      C         $casflg equ <1> ;; NOT 1'st
			      C     endm
			      C     
			      C     default macro _default:vararg
			      C         .else
			      C         _default
			      C     endm
			      C     
			      C     endsw macro _cmd:vararg
			      C         ifidn $casstk, <>
			      C             .err <Endsw w/o Switch>
			      C         else
			      C             t@ instr $casstk, <#>
			      C             $casvar substr $casstk, 1, t@-1
			      C             $casstk substr $casstk, t@+1
			      C             t@ instr $casstk, <#>
			      C             $casflg substr $casstk, 1, t@-1
			      C             ifidn $casstk, <#>
			      C                 $casstk equ <>
			      C             else
			      C                 $casstk substr $casstk, t@+1
			      C             endif
			      C             .endif
			      C         endif
			      C     endm
			      C 
			      C   ; --------------------------------------------------
			      C   ; equates for name and case variation in macro names
			      C   ; --------------------------------------------------
 = case			      C     Case equ <case>
 = case			      C     CASE equ <case>
 = switch		      C     Switch equ <switch>
 = switch		      C     SWITCH equ <switch>
			      C 
 = endsw		      C     Endsw equ <endsw>
 = endsw		      C     EndSw equ <endsw>
 = endsw		      C     ENDSW equ <endsw>
			      C 
 = switch		      C     Select equ <switch>
			      C     ;; select equ <switch>
 = switch		      C     SELECT equ <switch>
			      C 
 = endsw		      C     Endsel equ <endsw>
 = endsw		      C     endsel equ <endsw>
 = endsw		      C     ENDSEL equ <endsw>
			      C 
 = default		      C     Default equ <default>
 = default		      C     DEFAULT equ <default>
			      C 
 = default		      C     CaseElse equ <default>
 = default		      C     Caseelse equ <default>
 = default		      C     CASEELSE equ <default>
 = default		      C     caseelse equ <default>
			      C 
			      C comment * ------------------------------------------------
			      C         The following macro system for a string comparison
			      C         switch block was designed by Michael Webster.
			      C         --------------------------------------------------
			      C SYNTAX:
			      C 
			      C     switch$ string_address          ; adress of zero terminated string
			      C 
			      C       case$ "quoted text"           ; first string to test against
			      C         ; your code here
			      C 
			      C       case$ "another quoted text"   ; optional additional quoted text
			      C         ; your code here
			      C 
			      C       else$                         ; optional default processing
			      C         ; default code here
			      C 
			      C     endsw$
			      C 
			      C         ------------------------------------------------ *
			      C 
			      C ; 
			      C ; Macros for storing and retrieving text macros, based on
			      C ; the $casstk code from Greg Falen's Switch/Case macros.
			      C ; 
			      C 
 = #			      C     $text_stack$ equ <#>
			      C 
			      C     pushtext MACRO name:req
			      C         $text_stack$ CATSTR <name>, <#>, $text_stack$
			      C     ENDM
			      C 
			      C     poptext MACRO name:req
			      C         LOCAL pos
			      C         pos INSTR $text_stack$, <#>
			      C         name SUBSTR $text_stack$, 1, pos-1
			      C         $text_stack$ SUBSTR $text_stack$, pos+1
			      C     ENDM
			      C 
			      C ; 
			      C ; Macros to implement a string-comparison specific
			      C ; Switch/Case construct. Multiple instances and
			      C ; nesting supported.
			      C ; 
			      C 
 = 			      C     $test_val$ equ <>
 = 			      C     $end_sw$ equ <>
 = 			      C     $sw_state$ equ <>
 = 00000000		      C     _sw_cnt_ = 0
			      C 
			      C     switch$ MACRO lpstring:REQ
			      C         pushtext $test_val$                 ;; Preserve globals for previous Switch/Case.
			      C         pushtext $sw_state$
			      C         pushtext $end_sw$
			      C 
			      C         $test_val$ equ <lpstring>           ;; Copy string address for this Select/Case
			      C                                             ; to global so case$ can access it.             
			      C         $sw_state$ equ <>                   ;; Set state global to starting value.
			      C         _sw_cnt_ = _sw_cnt_ + 1             ; Generate a unique exit label for this
			      C         $end_sw$ CATSTR <end_sw>, %_sw_cnt_ ;; Select/Case and preserve it.
			      C         pushtext $end_sw$
			      C     ENDM
			      C 
			      C     case$ MACRO quoted_text:REQ
			      C         ; The case statements will be any statements between the case$ and the following case$,
			      C         ; else$, or endsw$.
			      C         ;
			      C         ; If this is a following case$, emit a jump to the exit label for this Select/Case and
			      C         ; terminate the .IF block.
			      C         ;; --------------------------------
			      C         IFIDN $sw_state$, <if>
			      C           poptext $end_sw$                  ;; Because there could have been an intervening
			      C           pushtext $end_sw$                 ;; Switch/Case we need to recover the correct
			      C           jmp   $end_sw$                    ;; exit label for this Switch/Case.
			      C           .ENDIF
			      C         ENDIF
			      C         ; --------------------------------
			      C         ; Start a new .IF block and update the state global.
			      C 
			      C 
			      C         IFNDEF __UNICODE__
			      C           .IF rv(szCmp, $test_val$, chr$(quoted_text)) != 0
			      C         ELSE
			      C           .IF rv(ucCmp, $test_val$, chr$(quoted_text)) != 0
			      C         ENDIF
			      C 
			      C 
			      C         $sw_state$ equ <if>
			      C     ENDM
			      C 
			      C     else$ MACRO
			      C         IFIDN $sw_state$, <if>              ;; If following a case$, emit a jump to the exit
			      C           poptext $end_sw$                  ;; label for this Select/Case and terminate the .IF
			      C           pushtext $end_sw$                 ;; block. The jump is necessary, whenever the case
			      C           jmp   $end_sw$                    ;; for the .IF block being terminated is true, to
			      C           .ENDIF                            ; bypass the else statements that follow.
			      C           $sw_state$ equ <>                 ;; The state global must be updated to stop the
			      C         ENDIF                               ; endsw$ from terminatinmg the .IF block.
			      C     ENDM
			      C 
			      C     endsw$ MACRO
			      C         IFIDN $sw_state$, <if>              ;; If following a case$, terminate the .IF block.
			      C           .ENDIF
			      C         ENDIF
			      C 
			      C         poptext $end_sw$                    ;; Remove the exit label from the stack.
			      C 
			      C       $end_sw$:
			      C 
			      C         poptext $end_sw$                    ;; Recover gobals for previous Switch/Case.
			      C         poptext $sw_state$
			      C         poptext $test_val$
			      C     ENDM
			      C 
			      C ; 
			      C 
			      C comment * ----------------------------------------------------
			      C         The following macro system for a string comparison
			      C         switch block was designed by Michael Webster. It has
			      C         been slightly modified for case INSENSITIVE comparison.
			      C         ----------------------------------------------------- *
			      C 
			      C ; 
			      C ; Macros for storing and retrieving text macros, based on
			      C ; the $casstk code from Greg Falen's Switch/Case macros.
			      C ; 
			      C 
 = #			      C     $text_stacki$ equ <#>
			      C 
			      C     pushtexti MACRO name:req
			      C         $text_stacki$ CATSTR <name>, <#>, $text_stacki$
			      C     ENDM
			      C 
			      C     poptexti MACRO name:req
			      C         LOCAL pos
			      C         pos INSTR $text_stacki$, <#>
			      C         name SUBSTR $text_stacki$, 1, pos-1
			      C         $text_stacki$ SUBSTR $text_stacki$, pos+1
			      C     ENDM
			      C 
			      C ; 
			      C ; Macros to implement a string-comparison specific
			      C ; Switch/Case construct. Multiple instances and
			      C ; nesting supported.
			      C ; 
			      C 
 = 			      C     $test_vali$ equ <>
 = 			      C     $end_swi$ equ <>
 = 			      C     $sw_statei$ equ <>
 = 00000000		      C     _sw_cnti_ = 0
			      C 
			      C     switchi$ MACRO lpstring:REQ
			      C 
			      C         pushtexti $test_vali$                ;; Preserve globals for previous Switch/Case.
			      C         pushtexti $sw_statei$
			      C         pushtexti $end_swi$
			      C 
			      C         $test_vali$ equ <lpstring>           ;; Copy string address for this Select/Case
			      C                                              ; to global so case$ can access it.             
			      C         $sw_statei$ equ <>                   ;; Set state global to starting value.
			      C         _sw_cnti_ = _sw_cnti_ + 1            ; Generate a unique exit label for this
			      C         $end_swi$ CATSTR <end_swi>, %_sw_cnt_ ;; Select/Case and preserve it.
			      C         pushtexti $end_swi$
			      C     ENDM
			      C 
			      C     casei$ MACRO quoted_text:REQ
			      C         ; The case statements will be any statements between the case$ and the following case$,
			      C         ; else$, or endsw$.
			      C         ;
			      C         ; If this is a following case$, emit a jump to the exit label for this Select/Case and
			      C         ; terminate the .IF block.
			      C         ; --------------------------------
			      C         IFIDN $sw_statei$, <if>
			      C           poptexti $end_swi$                 ;; Because there could have been an intervening
			      C           pushtexti $end_swi$                ;; Switch/Case we need to recover the correct
			      C           jmp   $end_swi$                    ;; exit label for this Switch/Case.
			      C           .ENDIF
			      C         ENDIF
			      C         ; --------------------------------
			      C         ; Start a new .IF block and update the state global.
			      C 
			      C         ; *******************************************
			      C         IFNDEF __UNICODE__
			      C           .if rv(Cmpi,$test_vali$,chr$(quoted_text)) == 0
			      C         ELSE
			      C           .if rv(lstrcmpi,$test_vali$,chr$(quoted_text)) == 0
			      C         ENDIF
			      C         ; *******************************************
			      C 
			      C         $sw_statei$ equ <if>
			      C     ENDM
			      C 
			      C     elsei$ MACRO
			      C         IFIDN $sw_statei$, <if>              ;; If following a case$, emit a jump to the exit
			      C           poptexti $end_swi$                 ;; label for this Select/Case and terminate the .IF
			      C           pushtexti $end_swi$                ;; block. The jump is necessary, whenever the case
			      C           jmp   $end_swi$                    ;; for the .IF block being terminated is true, to
			      C           .ENDIF                             ; bypass the else statements that follow.
			      C           $sw_statei$ equ <>                 ;; The state global must be updated to stop the
			      C         ENDIF                                ; endsw$ from terminatinmg the .IF block.
			      C     ENDM
			      C 
			      C     endswi$ MACRO
			      C         IFIDN $sw_statei$, <if>              ;; If following a case$, terminate the .IF block.
			      C           .ENDIF
			      C         ENDIF
			      C 
			      C         poptexti $end_swi$                   ;; Remove the exit label from the stack.
			      C 
			      C       $end_swi$:
			      C 
			      C         poptexti $end_swi$                   ;; Recover gobals for previous Switch/Case.
			      C         poptexti $sw_statei$
			      C         poptexti $test_vali$
			      C     ENDM
			      C 
			      C ; 
			      C 
			      C 
			      C     ; -------------------------------------------------------------------
			      C     ; The following 2 macros are for limiting the size of a window while
			      C     ; it is being resized. They are to be used in the WM_SIZING message.
			      C     ; -------------------------------------------------------------------
			      C     LimitWindowWidth MACRO wdth
			      C         LOCAL label
			      C         mov eax, lParam
			      C         mov ecx, (RECT PTR [eax]).right
			      C         sub ecx, (RECT PTR [eax]).left
			      C         cmp ecx, wdth
			      C         jg label
			      C       .if wParam == WMSZ_RIGHT || wParam == WMSZ_BOTTOMRIGHT || wParam == WMSZ_TOPRIGHT
			      C         mov ecx, (RECT PTR [eax]).left
			      C         add ecx, wdth
			      C         mov (RECT PTR [eax]).right, ecx
			      C       .elseif wParam == WMSZ_LEFT || wParam == WMSZ_BOTTOMLEFT || wParam == WMSZ_TOPLEFT
			      C         mov ecx, (RECT PTR [eax]).right
			      C         sub ecx, wdth
			      C         mov (RECT PTR [eax]).left, ecx
			      C       .endif
			      C       label:
			      C     ENDM
			      C 
			      C     LimitWindowHeight MACRO whgt
			      C         LOCAL label
			      C         mov eax, lParam
			      C         mov ecx, (RECT PTR [eax]).bottom
			      C         sub ecx, (RECT PTR [eax]).top
			      C         cmp ecx, whgt
			      C         jg label
			      C       .if wParam == WMSZ_TOP || wParam == WMSZ_TOPLEFT || wParam == WMSZ_TOPRIGHT
			      C         mov ecx, (RECT PTR [eax]).bottom
			      C         sub ecx, whgt
			      C         mov (RECT PTR [eax]).top, ecx
			      C       .elseif wParam == WMSZ_BOTTOM || wParam == WMSZ_BOTTOMLEFT || wParam == WMSZ_BOTTOMRIGHT
			      C         mov ecx, (RECT PTR [eax]).top
			      C         add ecx, whgt
			      C         mov (RECT PTR [eax]).bottom, ecx
			      C       .endif
			      C       label:
			      C     ENDM
			      C 
			      C     MsgBox MACRO hndl,txtmsg,titlemsg,styl
			      C       invoke MessageBox,hndl,reparg(txtmsg),reparg(titlemsg),styl
			      C     ENDM
			      C 
			      C     ; ************************************
			      C     ; console mode text input and output *
			      C     ; ************************************
			      C 
			      C     cls MACRO                       ;; clear screen
			      C       invoke ClearScreen
			      C     ENDM
			      C 
			      C     print MACRO arg1:REQ,varname:VARARG      ;; display zero terminated string
			      C         IFNDEF __UNICODE__
			      C           invoke StdOut,expand_prefix(reparg(arg1))
			      C         ELSE
			      C           invoke StdOutW,expand_prefix(reparg(arg1))
			      C         ENDIF
			      C       IFNB <varname>
			      C         IFNDEF __UNICODE__
			      C           invoke StdOut,chr$(varname)
			      C         ELSE
			      C           invoke StdOutW,chr$(varname)
			      C         ENDIF
			      C       ENDIF
			      C     ENDM
			      C 
			      C     printc MACRO text:VARARG
			      C       print cfm$(text)
			      C     ENDM
			      C 
			      C     ccout MACRO text:VARARG
			      C       print cfm$(text)
			      C     ENDM
			      C 
			      C comment * -----------------------------------------
			      C         Extended version of "print" with additional
			      C         character notation support.
			      C         
			      C           n = newline
			      C           t = tab
			      C           q = quote
			      C           lb = (
			      C           rb = )
			      C           la = <
			      C           ra = >
			      C 
			      C         ----------------------------------------- *
			      C 
			      C     cprint MACRO args:VARARG
			      C       push esi
			      C       mov esi, alloc(16384)
			      C       catargs cprint,esi,args
			      C       invoke StdOut,esi
			      C       free esi
			      C       pop esi
			      C     ENDM
			      C 
			      C     write MACRO quoted_text:VARARG  ;; display quoted text
			      C       LOCAL txt
			      C       .data
			      C         txt db quoted_text,0
			      C         align 4
			      C       .code
			      C       invoke StdOut,ADDR txt
			      C     ENDM
			      C 
			      C     loc MACRO xc,yc                 ;; set cursor position
			      C       invoke locate,xc,yc
			      C     ENDM
			      C 
			      C comment * -------------------------------------
			      C 
			      C     use the "input" macro as follows,
			      C 
			      C     If you want a prompt use this version
			      C     mov lpstring, input("Type text here : ")
			      C 
			      C     If you don't need a prompt use the following
			      C     mov lpstring, input()
			      C 
			      C     NOTE : The "lpstring" is a preallocated
			      C            DWORD variable that is either LOCAL
			      C            or declared in the .DATA or .DATA?
			      C            section. Any legal name is OK.
			      C 
			      C     LIMITATION : MASM uses < > internally in its
			      C     macros so if you wish to use these symbols
			      C     in a prompt, you must use the ascii value
			      C     and not use the symbol literally.
			      C 
			      C     EXAMPLE mov var, input("Enter number here ",62," ")
			      C 
			      C     ------------------------------------------- *
			      C 
			      C     input MACRO prompt:VARARG
			      C       LOCAL txt
			      C       LOCAL buffer
			      C       IFNB <prompt>
			      C         .data
			      C           txt db prompt, 0
			      C           align 4
			      C         .data?
			      C           buffer TCHAR 260 dup (?)
			      C           align 4
			      C         .code
			      C         IFNDEF __UNICODE__
			      C           invoke StdOut,ADDR txt
			      C           invoke StdIn,ADDR buffer,260
			      C         ELSE
			      C           invoke StdOutW,uni$(prompt)
			      C           invoke StdInW,ADDR buffer,260
			      C         ENDIF
			      C         EXITM <OFFSET buffer>
			      C       ELSE
			      C         .data?
			      C           buffer TCHAR 260 dup (?)
			      C           align 4
			      C         .code
			      C         IFNDEF __UNICODE__
			      C           invoke StdIn,ADDR buffer,260
			      C         ELSE
			      C           invoke StdInW,ADDR buffer,260
			      C         ENDIF
			      C         EXITM <OFFSET buffer>
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; --------------------------------------------------------
			      C   ; exit macro with an optional return value for ExitProcess
			      C   ; --------------------------------------------------------
			      C     exit MACRO optional_return_value
			      C       IFNDEF optional_return_value
			      C         invoke ExitProcess, 0
			      C       ELSE
			      C         invoke ExitProcess,optional_return_value
			      C       ENDIF
			      C     ENDM
			      C 
			      C     ;; ------------------------------------------------------
			      C     ;; display user defined text, default text or none if
			      C     ;; NULL is specified and wait for a keystroke to continue
			      C     ;; ------------------------------------------------------
			      C     inkey MACRO user_text:VARARG
			      C       IFDIF <user_text>,<NULL>                  ;; if user text not "NULL"
			      C         IFNB <user_text>                        ;; if user text not blank
			      C           print user_text                       ;; print user defined text
			      C         ELSE                                    ;; else
			      C           print "Press any key to continue ..." ;; print default text
			      C         ENDIF
			      C       ENDIF
			      C       call wait_key
			      C       print chr$(13,10)
			      C     ENDM
			      C 
			      C     ;; ---------------------------------------------------
			      C     ;; wait for a keystroke and return its scancode in EAX
			      C     ;; ---------------------------------------------------
			      C     getkey MACRO
			      C       call ret_key
			      C     ENDM
			      C 
			      C     SetConsoleCaption MACRO title_text:VARARG
			      C       invoke SetConsoleTitle,reparg(title_text)
			      C     ENDM
			      C 
			      C     GetConsoleCaption$ MACRO
			      C       IFNDEF @@_console_caption_buffer_@@
			      C       .data?
			      C         @@_console_caption_buffer_@@ db 260 dup (?)
			      C       .code
			      C       ENDIF
			      C       invoke GetConsoleTitle,ADDR @@_console_caption_buffer_@@,260
			      C       EXITM <OFFSET @@_console_caption_buffer_@@>
			      C     ENDM
			      C 
			      C 
			      C     ; **************************
			      C     ; Application startup code *
			      C     ; **************************
			      C 
			      C       AppStart MACRO
			      C         .code
			      C         start:
			      C         invoke GetModuleHandle, NULL
			      C         mov hInstance, eax
			      C 
			      C         invoke GetCommandLine
			      C         mov CommandLine, eax
			      C 
			      C         invoke InitCommonControls
			      C 
			      C         invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT
			      C         invoke ExitProcess,eax
			      C       ENDM
			      C 
			      C     ; --------------------------------------------------------------
			      C     ; Specifies processor, memory model & case sensitive option.
			      C     ; The parameter "Processor" should be in the form ".386" etc..
			      C     ; EXAMPLE : AppModel .586
			      C     ; --------------------------------------------------------------
			      C       AppModel MACRO Processor
			      C         Processor             ;; Processor type
			      C         .model flat, stdcall  ; 32 bit memory model
			      C         option casemap :none  ;; case sensitive
			      C       ENDM
			      C 
			      C     ; --------------------------------------------
			      C     ; The following two macros must be used as a
			      C     ; pair and can only be used once in a module.
			      C     ; Additional code for processing within the
			      C     ; message loop can be placed between them.
			      C     ;
			      C     ; The single parameter passed to both macros
			      C     ; is the name of the MSG structure and must be
			      C     ; the same in both macros.
			      C     ; --------------------------------------------
			      C 
			      C       BeginMessageLoop MACRO mStruct
			      C         MessageLoopStart:
			      C           invoke GetMessage,ADDR mStruct,NULL,0,0
			      C           cmp eax, 0
			      C           je MessageLoopExit
			      C       ENDM
			      C 
			      C       EndMessageLoop MACRO mStruct
			      C           invoke TranslateMessage, ADDR mStruct
			      C           invoke DispatchMessage,  ADDR mStruct
			      C           jmp MessageLoopStart
			      C         MessageLoopExit:
			      C       ENDM
			      C 
			      C     ; ********************************************
			      C     ; align memory                               *
			      C     ; reg has the address of the memory to align *
			      C     ; number is the required alignment           *
			      C     ; EXAMPLE : memalign esi, 16                 *
			      C     ; ********************************************
			      C 
			      C       memalign MACRO reg, number
			      C         add reg, number - 1
			      C         and reg, -number
			      C       ENDM
			      C 
			      C ; ---------------------------------------------------------------------
			      C ;
			      C ; The GLOBALS macro is for allocating uninitialised data in the .DATA?
			      C ; section. It is designed to take multiple definitions to make
			      C ; allocating uninitialised data more intuitive while coding.
			      C ;
			      C ; EXAMPLE: GLOBALS item1 dd ?,\
			      C ;                  item2 dd ?,\
			      C ;                  item3 dw ?,\
			      C ;                  item4 db 128 dup (?)
			      C ;
			      C ; ---------------------------------------------------------------------
			      C 
			      C       GLOBALS MACRO var1,var2,var3,var4,var5,var6,var7,var8,var9,var0,
			      C                     varA,varB,varC,varD,varE,varF,varG,varH,varI,varJ
			      C         .data?
			      C           align 4
			      C           var1
			      C           var2
			      C           var3
			      C           var4
			      C           var5
			      C           var6
			      C           var7
			      C           var8
			      C           var9
			      C           var0
			      C           varA
			      C           varB
			      C           varC
			      C           varD
			      C           varE
			      C           varF
			      C           varG
			      C           varH
			      C           varI
			      C           varJ
			      C         .code
			      C       ENDM
			      C 
			      C     ; **********************
			      C     ; miscellaneous macros *
			      C     ; **********************
			      C 
			      C       ShellAboutBox MACRO handle,IconHandle,quoted_Text_1,quoted_Text_2:VARARG
			      C         LOCAL AboutTitle,AboutMsg,buffer
			      C 
			      C         .data
			      C           align 4
			      C           buffer db 128 dup (0)
			      C           AboutTitle db quoted_Text_1,0
			      C           AboutMsg   db quoted_Text_2,0
			      C           align 4
			      C         .code
			      C 
			      C         mov esi, offset AboutTitle
			      C         mov edi, offset buffer
			      C         mov ecx, lengthof AboutTitle
			      C         rep movsb
			      C         
			      C         invoke ShellAbout,handle,ADDR buffer,ADDR AboutMsg,IconHandle
			      C       ENDM
			      C 
			      C ; ------------------------------------------------------------------
			      C ; macro for making STDCALL procedure and API calls.
			      C ; ------------------------------------------------------------------
			      C 
			      C     Scall MACRO name:REQ,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12, \
			      C                      p13,p14,p15,p16,p17,p18,p19,p20,p21,p22
			      C 
			      C     ; ---------------------------------------
			      C     ; loop through arguments backwards, push
			      C     ; NON blank ones and call the function.
			      C     ; ---------------------------------------
			      C 
			      C       FOR arg,<p22,p21,p20,p19,p18,p17,p16,p15,p14,p13,\
			      C                p12,p11,p10,p9,p8,p7,p6,p5,p4,p3,p2,p1>
			      C         IFNB <arg>    ;; If not blank
			      C           push arg    ;; push parameter
			      C         ENDIF
			      C       ENDM
			      C 
			      C       call name       ;; call the procedure
			      C 
			      C     ENDM
			      C 
			      C     ; -------------------------------
			      C     ; pascal calling convention macro
			      C     ; left to right push
			      C     ; -------------------------------
			      C       Pcall MACRO name:REQ,items:VARARG
			      C         LOCAL arg
			      C         FOR arg,<items>
			      C           push arg
			      C         ENDM
			      C           call name
			      C       ENDM
			      C 
			      C     ; ---------------------------------------
			      C     ; Append literal string to end of buffer
			      C     ; ---------------------------------------
			      C       Append MACRO buffer,text
			      C         LOCAL szTxt
			      C         .data
			      C           szTxt db text,0
			      C           align 4
			      C         .code
			      C         invoke szCatStr,ADDR buffer,ADDR szTxt
			      C       ENDM
			      C 
			      C     ; ---------------------------
			      C     ; Put ascii zero at 1st byte
			      C     ; ---------------------------
			      C       zero1 MACRO membuf
			      C         mov membuf[0], 0
			      C       ENDM
			      C 
			      C     ; -------------------------------------------
			      C     ; put zero terminated string in .data section
			      C     ; alternative to the szText MACRO
			      C     ; -------------------------------------------
			      C       dsText MACRO Name, Text:VARARG
			      C       .data
			      C         Name db Text,0
			      C         align 4
			      C       .code
			      C       ENDM
			      C 
			      C     ; -------------------------------
			      C     ; make 2 WORD values into a DWORD
			      C     ; result in eax
			      C     ; -------------------------------
			      C       MAKEDWORD MACRO LoWord,HiWord
			      C         mov ax, HiWord
			      C         ror eax, 16
			      C         mov ax, LoWord
			      C       ENDM
			      C 
			      C     ; -----------------------------
			      C     ; return IMMEDIATE value in eax
			      C     ; -----------------------------
			      C       retval MACRO var
			      C         IF var EQ 0
			      C           xor eax, eax  ; slightly more efficient for zero
			      C         ELSE
			      C           mov eax, var  ;; place value in eax
			      C         ENDIF
			      C         ret
			      C       ENDM
			      C 
			      C     ; ------------------------
			      C     ; inline memory copy macro
			      C     ; ------------------------
			      C       Mcopy MACRO lpSource,lpDest,len
			      C         mov esi, lpSource
			      C         mov edi, lpDest
			      C         mov ecx, len
			      C         rep movsb
			      C       ENDM
			      C 
			      C     ; -----------------------------------
			      C     ; INPUT red, green & blue BYTE values
			      C     ; OUTPUT DWORD COLORREF value in eax
			      C     ; -----------------------------------
			      C       RGB MACRO red, green, blue
			      C         xor eax, eax
			      C         mov ah, blue    ; blue
			      C         mov al, green   ; green
			      C         rol eax, 8
			      C         mov al, red     ; red
			      C       ENDM
			      C 
			      C     ; ------------------------------------------------
			      C     ; The following macro were written by Ron Thomas
			      C     ; ------------------------------------------------
			      C     ; Retrieves the low word from double word argument
			      C     ; ------------------------------------------------
			      C       LOWORD MACRO bigword  
			      C         mov  eax,bigword
			      C         and  eax,0FFFFh     ; Set to low word 
			      C       ENDM
			      C 
			      C     ; ----------------------
			      C     ; fast lodsb replacement
			      C     ; ----------------------
			      C       lob MACRO
			      C         mov al, [esi]
			      C         inc esi
			      C       ENDM
			      C 
			      C     ; ----------------------
			      C     ; fast stosb replacement
			      C     ; ----------------------
			      C       stb MACRO
			      C         mov [edi], al
			      C         inc edi
			      C       ENDM
			      C 
			      C     ; ----------------------------
			      C     ; code section text insertion
			      C     ; ----------------------------
			      C       szText MACRO Name, Text:VARARG
			      C         LOCAL lbl
			      C           jmp lbl
			      C             Name db Text,0
			      C           lbl:
			      C         ENDM
			      C 
			      C       return MACRO arg
			      C         mov eax, arg
			      C         ret
			      C       ENDM
			      C 
			      C       SingleInstanceOnly MACRO lpClassName
			      C         invoke FindWindow,lpClassName,NULL
			      C         cmp eax, 0
			      C         je @F
			      C           push eax
			      C           invoke ShowWindow,eax,SW_RESTORE
			      C           pop eax
			      C           invoke SetForegroundWindow,eax
			      C           mov eax, 0
			      C           ret
			      C         @@:
			      C       ENDM
			      C 
			      C     ; macro encapsulates the MAX_PATH size buffer and returns its OFFSET
			      C 
			      C       DropFileName MACRO wordparam
			      C         IFNDEF df@@name
			      C           .data?
			      C             dfname TCHAR MAX_PATH dup (?)
			      C           .code
			      C         df@@name equ 1
			      C         ENDIF
			      C         invoke DragQueryFile,wordparam,0,ADDR dfname,SIZEOF dfname
			      C         EXITM <OFFSET dfname>
			      C       ENDM
			      C 
			      C 
			      C     ; returns the handle of a control where its ID is known
			      C 
			      C       hDlgItem MACRO pHwnd,ctlID
			      C         LOCAL retval
			      C         .data?
			      C           retval dd ?
			      C         .code
			      C         invoke GetDlgItem,pHwnd,ctlID
			      C         mov retval, eax
			      C         EXITM <retval>
			      C       ENDM
			      C 
			      C   ; ----------------------------------------
			      C   ; chtype$() will accept either a BYTE sized
			      C   ; register or the address of a BYTE as a
			      C   ; memory operand.
			      C   ; The result is returned in a memory operand
			      C   ; as a BYTE PTR to the character class in the
			      C   ; table.
			      C   ; You would normally use this macro with
			      C   ;
			      C   ;     movzx ecx, chtype$([ebp+4])
			      C   ;     cmp chtype$([esp+4]), 2
			      C   ;     cmp chtype$(ah), dl
			      C   ;
			      C   ; ----------------------------------------
			      C     chtype$ MACRO character
			      C       IFNDEF chtyptbl
			      C         EXTERNDEF chtyptbl:DWORD         ;; load table if not already loaded
			      C       ENDIF
			      C       movzx eax, BYTE PTR character      ;; zero extend character to 32 bit reg
			      C       EXITM <BYTE PTR [eax+chtyptbl]>    ; place the table access in a 32 bit memory operand
			      C     ENDM
			      C 
			      C   ; ********************
			      C   ; Line reading macros.
			      C   ; ********************
			      C 
			      C     linein$ MACRO source,buffer,spos
			      C       invoke readline,source,buffer,spos
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     lineout$ MACRO source,buffer,spos,op_crlf
			      C       invoke writeline,reparg(source),buffer,spos,op_crlf
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     tstline$ MACRO lpstr
			      C       invoke tstline,reparg(lpstr)
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C   ; -----------------------------------
			      C   ; UNICODE string functions and macros
			      C   ; -----------------------------------
			      C 
			      C     uadd$ MACRO wstr1,wstr2
			      C       invoke ucCatStr,wstr1,wstr2
			      C       EXITM <wstr1>
			      C     ENDM
			      C 
			      C     uptr$ MACRO lpbuffer
			      C       lea eax, lpbuffer
			      C       mov WORD PTR [eax], 0
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     ucmp$ MACRO wstr1,wstr2
			      C       invoke ucCmp,wstr1,wstr2
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     ucopy$ MACRO wstr1,wstr2
			      C       invoke ucCopy,wstr1,wstr2
			      C     ENDM
			      C 
			      C     ulen$ MACRO lpwstr
			      C       invoke ucLen,lpwstr
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     ulcase$ MACRO lpwstr
			      C       invoke CharLowerBuffW,lpwstr,ulen$(lpwstr)
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C     uucase$ MACRO lpwstr
			      C       invoke CharUpperBuffW,lpwstr,ulen$(lpwstr)
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C     uleft$ MACRO lpwstr,ccount
			      C       invoke ucLeft,lpwstr,lpwstr,ccount
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C     umid$ MACRO lpwstr,spos,ln
			      C       invoke ucMid,lpwstr,lpwstr,spos,ln
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C     uright$ MACRO lpwstr,ccount
			      C       invoke ucRight,lpwstr,lpwstr,ccount
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C     urev$ MACRO lpwstr
			      C       invoke ucRev,lpwstr,lpwstr
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C     ultrim$ MACRO lpwstr
			      C       invoke ucLtrim,lpwstr,lpwstr
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C     urtrim$ MACRO lpwstr
			      C       invoke ucRtrim,lpwstr,lpwstr
			      C       EXITM <lpwstr>
			      C     ENDM
			      C 
			      C ; ====================================
			      C 
			      C ; 
			      C 
 = LOCAL		      C     LOCALVAR equ <LOCAL>
			      C 
			      C     ; ----------------------------------
			      C     ; macros for creating menu bar items
			      C     ; ----------------------------------
			      C 
			      C     TxtItem MACRO tID, cID, strng
			      C       mov tbb.iBitmap,   I_IMAGENONE
			      C       mov tbb.idCommand, cID
			      C       mov tbb.fsStyle,   BTNS_BUTTON or BTNS_AUTOSIZE
			      C       mov tbb.iString,   tID
			      C       fn SendMessage,TBhWnd,TB_ADDBUTTONS,1,ADDR tbb
			      C       fn SendMessage,TBhWnd,TB_ADDSTRING,0,chr$(strng,0,0)
			      C     ENDM
			      C 
			      C     ; ------------------------------
			      C 
			      C     TxtSeperator MACRO
			      C       mov tbb.iBitmap,   I_IMAGENONE
			      C       mov tbb.idCommand, 0
			      C       mov tbb.fsStyle,   BTNS_SEP ;; or BTNS_AUTOSIZE   ; << extra spacing
			      C       invoke SendMessage,TBhWnd,TB_ADDBUTTONS,1,ADDR tbb
			      C     ENDM
			      C 
			      C     ; ------------------------------
			      C 
			      C     TB_BEGIND MACRO pHandle
			      C 
			      C     LOCALVAR TBhWnd    :DWORD
			      C     LOCALVAR tbb       :TBBUTTON
			      C 
			      C       invoke CreateWindowEx,0,
			      C                             chr$("ToolbarWindow32"),
			      C                             NULL,
			      C                             WS_CHILD or WS_VISIBLE or TBSTYLE_TOOLTIPS or \
			      C                             TBSTYLE_FLAT or TBSTYLE_LIST or \
			      C                             TBSTYLE_TRANSPARENT,
			      C                             0,0,500,20,
			      C                             pHandle,NULL,
			      C                             hInstance,NULL
			      C       mov TBhWnd, eax
			      C 
			      C       invoke SendMessage,TBhWnd,TB_BUTTONSTRUCTSIZE,sizeof TBBUTTON,0
			      C       invoke SendMessage,TBhWnd,TB_SETINDENT,5,0
			      C 
			      C       mov tbb.fsState,   TBSTATE_ENABLED
			      C       mov tbb.dwData,    0
			      C       mov tbb.iString,   0
			      C     ENDM
			      C 
			      C     ; ------------------------------
			      C 
			      C     TB_BEGIN MACRO pHandle
			      C 
			      C     LOCALVAR TBhWnd    :DWORD
			      C     LOCALVAR tbb       :TBBUTTON
			      C 
			      C       invoke CreateWindowEx,0,
			      C                             chr$("ToolbarWindow32"),
			      C                             NULL,
			      C                             WS_CHILD or WS_VISIBLE or TBSTYLE_TOOLTIPS or \
			      C                             TBSTYLE_FLAT or TBSTYLE_LIST or \
			      C                             TBSTYLE_TRANSPARENT or CCS_NODIVIDER,
			      C                             0,0,500,20,
			      C                             pHandle,NULL,
			      C                             hInstance,NULL
			      C       mov TBhWnd, eax
			      C 
			      C       invoke SendMessage,TBhWnd,TB_BUTTONSTRUCTSIZE,sizeof TBBUTTON,0
			      C       invoke SendMessage,TBhWnd,TB_SETINDENT,5,0
			      C 
			      C       mov tbb.fsState,   TBSTATE_ENABLED
			      C       mov tbb.dwData,    0
			      C       mov tbb.iString,   0
			      C     ENDM
			      C 
			      C     ; ------------------------------
			      C 
			      C     TB_END MACRO
			      C       mov eax, TBhWnd
			      C       ret
			      C     ENDM
			      C 
			      C     ; ------------------------------
			      C 
			      C ; 
			      C 
			      C     date$ MACRO
			      C       IFNDEF @_@_current_local_date_@_@
			      C         .data?
			      C           @_@_current_local_date_@_@ TCHAR 128 dup (?)
			      C         .code
			      C       ENDIF
			      C       invoke GetDateFormat,LOCALE_USER_DEFAULT,DATE_LONGDATE,
			      C                            NULL,NULL,ADDR @_@_current_local_date_@_@,128
			      C       EXITM <OFFSET @_@_current_local_date_@_@>
			      C     ENDM
			      C 
			      C     time$ MACRO
			      C       IFNDEF @_@_current_local_time_@_@
			      C         .data?
			      C           @_@_current_local_time_@_@ TCHAR 128 dup (?)
			      C         .code
			      C       ENDIF
			      C       invoke GetTimeFormat,LOCALE_USER_DEFAULT,NULL,NULL,NULL,
			      C                            ADDR @_@_current_local_time_@_@,128
			      C       EXITM <OFFSET @_@_current_local_time_@_@>
			      C     ENDM
			      C 
			      C   ; --------------------------------------------------------
			      C   ; useful macro for adding padding directly in source code.
			      C   ; --------------------------------------------------------
			      C     nops MACRO cnt:REQ
			      C       REPEAT cnt
			      C         nop
			      C       ENDM
			      C     ENDM
			      C 
			      C comment * -----------------------------------------------------------------
			      C 
			      C    NOTES on DDPROTO macro
			      C 
			      C    This macro is for producing prototypes for functions where the start
			      C    address is known and the parameter count is known. It requires a named
			      C    DWORD sized entry in the .DATA or .DATA? section which has the start
			      C    address written to it before the function is called.
			      C 
			      C         EXAMPLE:
			      C         .data?
			      C           user32_msgbox dd ?            ; << The named variable
			      C 
			      C         msgbox DDPROTO(user32_msgbox,4) ; create prototype
			      C 
			      C         This is expanded to the following. The TYPEDEF refers to
			      C         the macro "pr4" in the WINDOWS.INC file.
			      C 
			      C         pt4 TYPEDEF PTR pr4
			      C         msgbox equ <(TYPE pt4) PTR user32_msgbox>
			      C 
			      C         The address must be written to the DWORD variable before it can
			      C         be called. This can be LoadLibrary/GetProcAddress or it can be
			      C         an address recovered from a virtual table in a DLL or any other
			      C         viable means of obtaining the start address of a function to call.
			      C 
			      C         invoke msgbox,hWnd,ADDR message_text, ADDR title_text,MB_OK
			      C 
			      C         ----------------------------------------------------------------- *
			      C 
			      C       DDPROTO MACRO lpFunction,pcount
			      C         LOCAL txt1,txt2
			      C         txt1 equ <pr>
			      C         txt1 CATSTR txt1,%pcount
			      C         txt2 equ <pt>
			      C         txt2 CATSTR txt2,%pcount
			      C         txt2 TYPEDEF PTR txt1
			      C         EXITM <equ <(TYPE txt2) PTR lpFunction>>
			      C       ENDM
			      C 
			      C comment * ==================================================================
			      C 
			      C      The following macros create a text stack and retrieve text items from
			      C      that stack.
			      C 
			      C  1.  pushtxt textitem   ; place text item on text stack
			      C  2.  poptxt [lbl]       ; retrieve last text item and write it to the souce file
			      C  3.  poptxt$()          ; return last text item on the stack to caller.
			      C 
			      C      Both versions of poptxt remove the item from the stack. The optional
			      C      parameter "lbl" for the statement version "poptxt" writes a colon after the
			      C      txt item in the source file so it is a label.
			      C 
			      C      ptdbg equ <1>   use this equate to display stack text items for debugging macros.
			      C 
			      C      NOTES : The text stack macros have been tested and are reliable but they are
			      C      subject to undocumented behavour with the characteristics of at least some
			      C      of the internal loop code and similar macro operators. The tested effect under
			      C      a FOR loop is that the main equate that stores the text data as a stack is
			      C      initialised back to an empty string when called from a FOR loop. Where you need loop
			      C      code when using these text stack macros, you are safer using a label and testing
			      C      the variable with an IF operator.
			      C 
			      C      var = 10               ;; set the variable to a value
			      C    :label                   ;; write a macro label
			      C 
			      C      ; your macro code here
			      C 
			      C      var = var - 1          ;; decrement variable
			      C      IF var NE 0            ;; test if its zero
			      C        goto label           ;; jump back to label if its not
			      C      ENDIF
			      C 
			      C      The mangled names for the string equate and the depth indicator are to reduce
			      C      the chance of a name clash with other symbols used in the source file.
			      C 
			      C         ================================================================= *
			      C 
			      C     pushtxt MACRO arg
			      C       IFNDEF @_txt_stack_@
			      C         @_txt_stack_@ equ <>                        ;; allocate text buffer as equate
			      C         @_s_d_i_@ = 0                               ;; allocate stack depth indicator
			      C       ENDIF
			      C       IFNDEF ptdbg
			      C         ptdbg equ <0>                               ;; debug equate, set to 1 for display
			      C       ENDIF
			      C       @_txt_stack_@ CATSTR <arg^>,@_txt_stack_@     ;; prepend new arg to front of stack
			      C       @_s_d_i_@ = @_s_d_i_@ + 1                     ;; increment depth counter
			      C       IF ptdbg
			      C       % echo arg
			      C       ENDIF
			      C     ENDM
			      C 
			      C     poptxt MACRO extra:VARARG                       ;; "extra" arg if used must be "lbl" (without quotes)
			      C       LOCAL txt,num,sln
			      C       nop
			      C       num INSTR @_txt_stack_@,<^>                   ;; get 1st delimiter location
			      C       num = num + 1
			      C       txt SUBSTR @_txt_stack_@,1,num-2              ;; read text back off stack
			      C       IF ptdbg
			      C       % echo txt
			      C       ENDIF
			      C       @_s_d_i_@ = @_s_d_i_@ - 1                     ;; decrement stack item count
			      C       IF @_s_d_i_@ NE 0                             ;; if stack depth NOT zero
			      C         sln SIZESTR @_txt_stack_@                   ;; get current stack length
			      C         @_txt_stack_@ SUBSTR @_txt_stack_@, \
			      C                              num,sln-num+1          ;; remove current item from stack
			      C       ELSE
			      C         @_txt_stack_@ equ <>                        ;; empty the stack on last arg
			      C       ENDIF
			      C       IFIDNI <lbl>,<extra>
			      C         txt CATSTR txt,<:>                          ;; append a colon if its a label
			      C         txt                                         ;; then write txt to source file
			      C       ELSE
			      C         txt                                         ;; write txt to source file
			      C       ENDIF
			      C     ENDM
			      C 
			      C     poptxt$ MACRO
			      C       LOCAL txt,num,sln
			      C       num INSTR @_txt_stack_@,<^>                   ;; get 1st delimiter location
			      C       num = num + 1
			      C       txt SUBSTR @_txt_stack_@,1,num-2              ;; read text back off stack
			      C       IF ptdbg
			      C       % echo txt
			      C       ENDIF
			      C       @_s_d_i_@ = @_s_d_i_@ - 1                     ;; decrement stack item count
			      C       IF @_s_d_i_@ NE 0                             ;; if stack depth NOT zero
			      C         sln SIZESTR @_txt_stack_@                   ;; get current stack length
			      C         @_txt_stack_@ SUBSTR @_txt_stack_@, \
			      C                              num,sln-num+1          ;; remove current item from stack
			      C       ELSE
			      C         @_txt_stack_@ equ <>                        ;; empty the stack on last arg
			      C       ENDIF
			      C       EXITM <txt>
			      C     ENDM
			      C 
			      C  ; *************************************************************************
			      C 
			      C   ; --------------------------------------
			      C   ; save registers in left to right order.
			      C   ; --------------------------------------
			      C     pushr MACRO regs:VARARG
			      C       LOCAL cnt,lpc,lbl
			      C       cnt = argcount(regs)
			      C       lpc = 0
			      C     :lbl
			      C       pushtxt getarg(lpc+1,regs)
			      C       push getarg(lpc+1,regs)
			      C       lpc = lpc + 1
			      C       IF lpc NE cnt
			      C         goto lbl
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; --------------------------------------------
			      C   ; restore the same registers in reverse order.
			      C   ; --------------------------------------------
			      C     popr MACRO
			      C       LOCAL lbl
			      C     :lbl
			      C       pop poptxt$()
			      C       IF @_s_d_i_@ GT 0
			      C         goto lbl
			      C       ENDIF
			      C     ENDM
			      C 
			      C  ; *************************************************************************
			      C 
			      C     MakeIP MACRO arg1,arg2,arg3,arg4
			      C         mov ah, arg1
			      C         mov al, arg2
			      C         rol eax, 16
			      C         mov ah, arg3
			      C         mov al, arg4
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C 
			      C comment * -------------------------------------------------
			      C 
			      C         The "uselib" macro allows names that are used for
			      C         both include files and library file to be used in a
			      C         list without extensions. Note the following order
			      C         of include files where WINDOWS.INC should be
			      C         included first then the main macro file BEFORE this
			      C         macro is called.
			      C 
			      C         include \masm32\include\windows.inc
			      C         include \masm32\macros\macros.asm
			      C         uselib masm32,gdi32,user32,kernel32,Comctl32,comdlg32,shell32,oleaut32,msvcrt
			      C 
			      C         ------------------------------------------------- *
			      C 
			      C     uselib MACRO args:VARARG
			      C       LOCAL acnt,buffer,var,lbl,libb,incc,buf1,buf2
			      C       acnt = argcount(args)
			      C       incc equ <include \masm32\include\>
			      C       libb equ <includelib \masm32\lib\>
			      C       var = 1
			      C     :lbl
			      C       buffer equ getarg(var,args)
			      C 
			      C       buf1 equ <>
			      C       buf1 CATSTR buf1,incc,buffer,<.inc>
			      C       buf1
			      C       ; % echo buf1
			      C 
			      C       buf2 equ <>
			      C       buf2 CATSTR buf2,libb,buffer,<.lib>
			      C       buf2
			      C       ; % echo buf2
			      C 
			      C       var = var + 1
			      C       IF var LE acnt
			      C         goto lbl
			      C       ENDIF
			      C     ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
			      C   ; *************************************************
			      C   ; The following numeric to string conversions were
			      C   ; written by Greg Lyon using the "sprintf" function
			      C   ; in the standard C runtime DLL MSVCRT.DLL
			      C   ; *************************************************
			      C 
			      C     ubyte$ MACRO ubytevalue:req
			      C         ; unsigned byte
			      C         LOCAL buffer, ubtmp
			      C         .data?
			      C             ubtmp  BYTE ?
			      C             buffer BYTE 4 dup(?)
			      C         IFNDEF ubfmt    
			      C         .data    
			      C             ubfmt  BYTE "%hhu", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(ubytevalue, 1)
			      C                 echo ----------------------
			      C                 echo ubyte$ - requires BYTE
			      C                 echo ----------------------
			      C                 .ERR
			      C             ENDIF               
			      C             mov    buffer[0], 0
			      C             IF isregister(ubytevalue)
			      C                 mov   ubtmp, ubytevalue
			      C                 movzx eax, ubtmp
			      C             ELSE
			      C                 mov   al, ubytevalue
			      C                 movzx eax, al
			      C             ENDIF    
			      C             invoke crt_sprintf, ADDR buffer, ADDR ubfmt, eax
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     sbyte$ MACRO sbytevalue:req
			      C         ; signed byte
			      C         LOCAL buffer, sbtmp
			      C         .data?
			      C             sbtmp  SBYTE ?
			      C             buffer BYTE  8 dup(?)
			      C         IFNDEF sbfmt     
			      C         .data    
			      C             sbfmt  BYTE "%hhd", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(sbytevalue, 1)
			      C                 echo -----------------------
			      C                 echo sbyte$ - requires SBYTE
			      C                 echo -----------------------
			      C                 .ERR
			      C             ENDIF               
			      C             mov    buffer[0], 0
			      C             IF isregister(sbytevalue)
			      C                 mov   sbtmp, sbytevalue
			      C                 movsx eax, sbtmp
			      C             ELSE     
			      C                 mov   al, sbytevalue
			      C                 movsx eax, al
			      C             ENDIF    
			      C             invoke crt_sprintf, ADDR buffer, ADDR sbfmt, eax
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     xbyte$ MACRO xbytevalue:req
			      C         ; unsigned hex byte
			      C         LOCAL buffer, xbtmp
			      C         .data?
			      C             xbtmp  BYTE ?
			      C             buffer BYTE 4 dup(?)
			      C         IFNDEF xbfmt    
			      C         .data    
			      C             xbfmt  BYTE "%hhX", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(xbytevalue, 1)
			      C                 echo ----------------------
			      C                 echo xbyte$ - requires BYTE
			      C                 echo ----------------------
			      C                 .ERR
			      C             ENDIF                
			      C             mov buffer[0], 0
			      C             IF isregister(xbytevalue)
			      C                 mov   xbtmp, xbytevalue
			      C                 movzx eax, xbtmp
			      C             ELSE
			      C                 mov   al, xbytevalue
			      C                 movzx eax, al
			      C             ENDIF    
			      C             invoke crt_sprintf, ADDR buffer, ADDR xbfmt, eax 
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     uword$ MACRO uwordvalue:req
			      C         ; unsigned word
			      C         LOCAL buffer, uwtmp
			      C         .data?
			      C             uwtmp  WORD ?
			      C             buffer BYTE 8 dup(?)
			      C         IFNDEF uwfmt    
			      C         .data    
			      C             uwfmt  BYTE "%hu", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(uwordvalue, 2)
			      C                 echo ----------------------
			      C                 echo uword$ - requires WORD
			      C                 echo ----------------------
			      C                 .ERR
			      C             ENDIF            
			      C             mov   buffer[0], 0
			      C             IF isregister(uwordvalue)
			      C                 mov   uwtmp, uwordvalue
			      C                 movzx eax, uwtmp
			      C             ELSE       
			      C                 mov   ax, uwordvalue
			      C                 movzx eax, ax
			      C             ENDIF    
			      C             invoke crt_sprintf, ADDR buffer, ADDR uwfmt, eax
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     sword$ MACRO swordvalue:req
			      C         ; signed word
			      C         LOCAL buffer, swtmp
			      C         .data?
			      C             swtmp  SWORD ? 
			      C             buffer BYTE  8 dup(?)
			      C         IFNDEF swfmt    
			      C         .data    
			      C             swfmt  BYTE "%hd", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(swordvalue, 2)
			      C                 echo -----------------------
			      C                 echo sword$ - requires SWORD
			      C                 echo -----------------------
			      C                 .ERR
			      C             ENDIF            
			      C             mov   buffer[0], 0
			      C             IF isregister(swordvalue)
			      C                 mov   swtmp, swordvalue
			      C                 movsx eax, swtmp
			      C             ELSE    
			      C                 mov   ax, swordvalue
			      C                 movsx eax, ax
			      C             ENDIF    
			      C             invoke crt_sprintf, ADDR buffer, ADDR swfmt, eax
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     xword$ MACRO xwordvalue:req
			      C         ; unsigned hex word
			      C         LOCAL buffer, xwtmp
			      C         .data?
			      C             xwtmp  WORD ?
			      C             buffer BYTE 8 dup(?)
			      C         IFNDEF xwfmt    
			      C         .data    
			      C             xwfmt  BYTE "%hX", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(xwordvalue, 2)
			      C                 echo ----------------------
			      C                 echo xword$ - requires WORD
			      C                 echo ----------------------
			      C                 .ERR
			      C             ENDIF        
			      C             mov   buffer[0], 0
			      C             IF isregister(xwordvalue)
			      C                 mov   xwtmp, xwordvalue
			      C                 movzx eax, xwtmp
			      C             ELSE               
			      C                 mov   ax, xwordvalue
			      C                 movzx eax, ax
			      C             ENDIF    
			      C             invoke crt_sprintf, ADDR buffer, ADDR xwfmt, eax
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     udword$ MACRO udwordvalue:req
			      C         ; unsigned dword
			      C         LOCAL buffer, udtmp
			      C         .data?
			      C             udtmp  DWORD ?
			      C             buffer BYTE  12 dup(?)
			      C         IFNDEF udfmt    
			      C         .data    
			      C             udfmt  BYTE "%lu", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(udwordvalue, 4)
			      C                 echo ------------------------
			      C                 echo udword$ - requires DWORD
			      C                 echo ------------------------
			      C                 .ERR
			      C             ENDIF    
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR udfmt, udwordvalue
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     sdword$ MACRO sdwordvalue:req
			      C         ; signed dword
			      C         LOCAL buffer, sdtmp
			      C         .data?
			      C             sdtmp  SDWORD ?
			      C             buffer BYTE   12 dup(?)
			      C         IFNDEF sdfmt    
			      C         .data    
			      C             sdfmt BYTE "%ld", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(sdwordvalue, 4)
			      C                 echo -------------------------
			      C                 echo sdword$ - requires SDWORD
			      C                 echo -------------------------
			      C                 .ERR
			      C             ENDIF        
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR sdfmt, sdwordvalue
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     xdword$ MACRO xdwordvalue:req
			      C         ; unsigned hex dword
			      C         LOCAL buffer, xdtmp
			      C         .data?
			      C             xdtmp  DWORD ?
			      C             buffer BYTE  12 dup(?)
			      C         IFNDEF xdfmt    
			      C         .data    
			      C             xdfmt BYTE "%lX", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(xdwordvalue, 4)
			      C                 echo ------------------------
			      C                 echo xdword$ - requires DWORD
			      C                 echo ------------------------
			      C                 .ERR
			      C             ENDIF        
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR xdfmt, xdwordvalue 
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     uqword$ MACRO uqwordvalue:req
			      C         ; unsigned qword
			      C         LOCAL buffer
			      C         .data?
			      C             buffer BYTE 24 dup(?)
			      C         IFNDEF uqwfmt    
			      C         .data    
			      C             uqwfmt BYTE "%I64u", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(uqwordvalue, 8)
			      C                 echo ------------------------
			      C                 echo uqword$ - requires QWORD
			      C                 echo ------------------------
			      C                 .ERR
			      C             ENDIF        
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR uqwfmt, uqwordvalue
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     sqword$ MACRO sqwordvalue:req
			      C         ; signed qword
			      C         LOCAL buffer
			      C         .data?
			      C             buffer BYTE 24 dup(?)
			      C         IFNDEF sqwfmt    
			      C         .data    
			      C             sqwfmt BYTE "%I64d", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(sqwordvalue, 8)
			      C                 echo ------------------------
			      C                 echo sqword$ - requires QWORD
			      C                 echo ------------------------
			      C                 .ERR
			      C             ENDIF            
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR sqwfmt, sqwordvalue
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     xqword$ MACRO xqwordvalue:req
			      C         ; unsigned hex qword
			      C         LOCAL buffer
			      C         .data?
			      C             buffer BYTE 20 dup(?)
			      C         IFNDEF xqwfmt    
			      C         .data    
			      C             xqwfmt BYTE "%I64X", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(xqwordvalue, 8)
			      C                 echo ------------------------
			      C                 echo xqword$ - requires QWORD
			      C                 echo ------------------------
			      C                 .ERR
			      C             ENDIF            
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR xqwfmt, xqwordvalue
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     real4$ MACRO r4value:req
			      C         LOCAL buffer, r8value, r4tmp
			      C         .data?
			      C             r4tmp   REAL4 ?
			      C             r8value REAL8 ?
			      C             buffer  BYTE  48 dup(?)
			      C         IFNDEF r8fmt    
			      C         .data
			      C             r8fmt   BYTE "%lf", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(r4value, 4)
			      C                 echo ------------------------
			      C                 echo real4$ - requires REAL4
			      C                 echo ------------------------
			      C                 .ERR
			      C             ENDIF            
			      C             IF isregister(r4value)
			      C                 push   r4value
			      C                 pop    r4tmp
			      C                 finit
			      C                 fld    r4tmp
			      C             ELSE
			      C                 finit
			      C                 fld    r4value
			      C             ENDIF    
			      C             fstp   r8value
			      C             fwait
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR r8fmt, r8value
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     real8$ MACRO r8value:req
			      C         LOCAL buffer
			      C         .data?
			      C             buffer BYTE 320 dup(?)
			      C         IFNDEF r8fmt    
			      C         .data    
			      C             r8fmt  BYTE "%lf", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(r8value, 8)
			      C                 echo ------------------------
			      C                 echo real8$ - requires REAL8
			      C                 echo ------------------------
			      C                 .ERR
			      C             ENDIF            
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR r8fmt, r8value
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C     
			      C     ; ----------------------------------------------
			      C     
			      C     real10$ MACRO r10value:req
			      C         LOCAL buffer, r8value
			      C         .data?
			      C             r8value REAL8 ?
			      C             buffer  BYTE  320 dup(?)
			      C         IFNDEF r8fmt    
			      C         .data    
			      C             r8fmt   BYTE "%lf", 0
			      C         ENDIF    
			      C         .code
			      C             IFE issize(r10value, 10)
			      C                 echo -------------------------
			      C                 echo real10$ - requires REAL10
			      C                 echo -------------------------
			      C                 .ERR
			      C             ENDIF        
			      C             fld    r10value
			      C             fstp   r8value
			      C             fwait
			      C             mov    buffer[0], 0
			      C             invoke crt_sprintf, ADDR buffer, ADDR r8fmt, r8value
			      C             EXITM <OFFSET buffer>
			      C     ENDM
			      C 
			      C   ; ------------------------
			      C   ; sscanf conversion macros
			      C   ; ------------------------
			      C     a2ub MACRO pStr:req
			      C         LOCAL ub
			      C         .data 
			      C            ub BYTE 0    
			      C         IFNDEF ubfmt   
			      C         .const
			      C             ubfmt BYTE "%hhu",0
			      C         ENDIF  
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR ubfmt, ADDR ub
			      C         EXITM <OFFSET ub>
			      C     ENDM  
			      C     ;---------------------------------------
			      C     a2sb MACRO pStr:req
			      C         LOCAL sb
			      C         .data 
			      C            sb SBYTE 0    
			      C         IFNDEF sbfmt   
			      C         .const
			      C             sbfmt BYTE "%hhd",0
			      C         ENDIF  
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR sbfmt, ADDR sb
			      C         EXITM <OFFSET sb>
			      C     ENDM  
			      C     ;---------------------------------------
			      C     h2ub MACRO pStr:req
			      C         LOCAL ub
			      C         .data 
			      C            ub BYTE 0    
			      C         IFNDEF xbfmt   
			      C         .const
			      C             xbfmt BYTE "%hhX",0
			      C         ENDIF  
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR xbfmt, ADDR ub
			      C         EXITM <OFFSET ub>
			      C     ENDM  
			      C     ;---------------------------------------
			      C     a2uw MACRO pStr:req
			      C         LOCAL uw
			      C         .data 
			      C            uw WORD 0    
			      C         IFNDEF uwfmt   
			      C         .const
			      C             uwfmt BYTE "%hu",0
			      C         ENDIF 
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR uwfmt, ADDR uw
			      C         EXITM <OFFSET uw>
			      C     ENDM   
			      C     ;---------------------------------------
			      C     a2sw MACRO pStr:req
			      C         LOCAL sw
			      C         .data 
			      C            sw SWORD 0    
			      C         IFNDEF swfmt   
			      C         .const
			      C             swfmt BYTE "%hd",0
			      C         ENDIF  
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR swfmt, ADDR sw
			      C         EXITM <OFFSET sw>
			      C     ENDM   
			      C     ;---------------------------------------
			      C     h2uw MACRO pStr:req
			      C         LOCAL uw
			      C         .data 
			      C            uw WORD 0    
			      C         IFNDEF xwfmt   
			      C         .const
			      C             xwfmt BYTE "%hX",0
			      C         ENDIF 
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR xwfmt, ADDR uw
			      C         EXITM <OFFSET uw>
			      C     ENDM   
			      C     ;---------------------------------------
			      C     a2ud MACRO pStr:req
			      C         LOCAL ud
			      C         .data 
			      C             ud DWORD 0    
			      C         IFNDEF udfmt   
			      C         .const
			      C             udfmt BYTE "%u",0
			      C         ENDIF 
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR udfmt, ADDR ud
			      C         EXITM <OFFSET ud>
			      C     ENDM   
			      C     ;---------------------------------------
			      C     a2sd MACRO pStr:req
			      C         LOCAL sd
			      C         .data 
			      C            sd SDWORD 0    
			      C         IFNDEF sdfmt   
			      C         .const
			      C             sdfmt BYTE "%d",0
			      C         ENDIF    
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR sdfmt, ADDR sd
			      C         EXITM <OFFSET sd>
			      C     ENDM   
			      C     ;---------------------------------------
			      C     h2ud MACRO pStr:req
			      C         LOCAL ud
			      C         .data 
			      C             ud DWORD 0    
			      C         IFNDEF xdfmt   
			      C         .const
			      C             xdfmt BYTE "%X",0
			      C         ENDIF 
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR xdfmt, ADDR ud
			      C         EXITM <OFFSET ud>    
			      C     ENDM   
			      C     ;---------------------------------------
			      C     a2uq MACRO pStr:req
			      C         LOCAL uq
			      C         .data 
			      C            align 8
			      C            uq QWORD 0    
			      C         IFNDEF uqfmt   
			      C         .const
			      C             uqfmt BYTE "%I64u",0
			      C         ENDIF   
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR uqfmt, ADDR uq
			      C         EXITM <OFFSET uq>
			      C     ENDM   
			      C     ;---------------------------------------
			      C     a2sq MACRO pStr:req
			      C         LOCAL sq
			      C         .data 
			      C            align 8
			      C            sq QWORD ?    
			      C         IFNDEF sqfmt   
			      C         .const
			      C             sqfmt BYTE "%I64d",0
			      C         ENDIF   
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR sqfmt, ADDR sq
			      C         EXITM <OFFSET sq>
			      C     ENDM   
			      C     ;-------------------------------------------
			      C     h2uq MACRO pStr:req
			      C         LOCAL uq
			      C         .data 
			      C            align 8
			      C            uq QWORD 0    
			      C         IFNDEF xqfmt   
			      C         .const
			      C             xqfmt BYTE "%I64X",0
			      C         ENDIF   
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR xqfmt, ADDR uq
			      C         EXITM <OFFSET uq>
			      C     ENDM   
			      C     ;---------------------------------------
			      C     a2r4 MACRO pStr:req
			      C         LOCAL r4
			      C         .data
			      C           r4 REAL4 0.0
			      C         IFNDEF r4fmt   
			      C         .const
			      C             r4fmt BYTE "%f",0
			      C         ENDIF   
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR r4fmt, ADDR r4 
			      C         EXITM <OFFSET r4>
			      C     ENDM   
			      C     ;-------------------------------------------
			      C     a2r8 MACRO pStr:req
			      C         LOCAL r8
			      C         .data
			      C           align 8
			      C           r8 REAL8 0.0
			      C         IFNDEF r8fmt   
			      C         .const
			      C             r8fmt BYTE "%lf",0
			      C         ENDIF
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR r8fmt, ADDR r8 
			      C         EXITM <OFFSET r8>
			      C     ENDM   
			      C     ;--------------------------------------------
			      C     a2r10 MACRO pStr:req
			      C         LOCAL r8, r10
			      C         .data
			      C            align 16
			      C            r10 REAL10 0.0
			      C            r8  REAL8  0.0
			      C         IFNDEF r8fmt
			      C         .data
			      C             r8fmt BYTE "%lf",0
			      C         ENDIF
			      C         .code
			      C         invoke crt_sscanf, pStr, ADDR r8fmt, ADDR r8
			      C         finit
			      C         fld r8
			      C         fstp r10
			      C         EXITM <OFFSET r10>
			      C     ENDM
			      C     ;--------------------------------------------
			      C 
			      C ; --------------------------------
			      C ; convert numbers to string output
			      C ; --------------------------------
			      C ; naming convention for wsprintf based macros.
			      C ;
			      C ; prefix
			      C ; ------
			      C ; u = unsigned
			      C ; s = signed
			      C ; x = hex
			      C ;
			      C ; data size
			      C ; ---------
			      C ; db = byte      8 bit
			      C ; dw = word     16 bit
			      C ; dd = dword    32 bit
			      C ; dq = qword    64 bit
			      C ;
			      C ; data output type
			      C ; ----------------
			      C ; trailing "$" = string output.
			      C ;
			      C ; EXAMPLE : udb$ = string output for unsigned byte value.
			      C ;
			      C ; -----------------------------------------------
			      C ; The following macros were designed by Greg Lyon.
			      C ; -----------------------------------------------
			      C udb$ MACRO ubytevalue:req
			      C     ; unsigned byte
			      C     LOCAL buffer, ubtmp
			      C     .DATA?
			      C         ubtmp  BYTE ?
			      C         buffer BYTE 4 dup(?)
			      C     IFNDEF ubfmt   
			      C     .DATA   
			      C         ubfmt  BYTE "%u", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(ubytevalue, 1)
			      C             ECHO ----------------------
			      C             ECHO udb$ - requires BYTE
			      C             ECHO ----------------------
			      C             .ERR
			      C         ENDIF               
			      C         mov buffer[0], 0
			      C         IF isregister(ubytevalue)
			      C             mov   ubtmp, ubytevalue
			      C             movzx eax, ubtmp
			      C         ELSE
			      C             mov   al, ubytevalue
			      C             movzx eax, al
			      C         ENDIF   
			      C         INVOKE wsprintf, ADDR buffer, ADDR ubfmt, eax
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C sdb$ MACRO sbytevalue:req
			      C     ; signed byte
			      C     LOCAL buffer, sbtmp
			      C     .DATA?
			      C         sbtmp  SBYTE ?
			      C         buffer BYTE  8 dup(?)
			      C     IFNDEF sbfmt     
			      C     .DATA   
			      C         sbfmt  BYTE "%d", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(sbytevalue, 1)
			      C             ECHO -----------------------
			      C             ECHO sdb$ - requires SBYTE
			      C             ECHO -----------------------
			      C             .ERR
			      C         ENDIF               
			      C         mov    buffer[0], 0
			      C         IF isregister(sbytevalue)
			      C             mov   sbtmp, sbytevalue
			      C             movsx eax, sbtmp
			      C         ELSE     
			      C             mov   al, sbytevalue
			      C             movsx eax, al
			      C         ENDIF   
			      C         INVOKE wsprintf, ADDR buffer, ADDR sbfmt, eax
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C xdb$ MACRO xbytevalue:req
			      C     ; unsigned hex byte
			      C     LOCAL buffer, xbtmp
			      C     .DATA?
			      C         xbtmp  BYTE ?
			      C         buffer BYTE 4 dup(?)
			      C     IFNDEF xbfmt   
			      C     .DATA   
			      C         xbfmt  BYTE "%X", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(xbytevalue, 1)
			      C             ECHO ----------------------
			      C             ECHO xdb$ - requires BYTE
			      C             ECHO ----------------------
			      C             .ERR
			      C         ENDIF               
			      C         mov buffer[0], 0
			      C         IF isregister(xbytevalue)
			      C             mov   xbtmp, xbytevalue
			      C             movzx eax, xbtmp
			      C         ELSE
			      C             mov   al, xbytevalue
			      C             movzx eax, al
			      C         ENDIF   
			      C         INVOKE wsprintf, ADDR buffer, ADDR xbfmt, eax
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C udw$ MACRO uwordvalue:req
			      C     ; unsigned word
			      C     LOCAL buffer, uwtmp
			      C     .DATA?
			      C         uwtmp  WORD ?
			      C         buffer BYTE 8 dup(?)
			      C     IFNDEF uwfmt   
			      C     .DATA   
			      C         uwfmt  BYTE "%hu", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(uwordvalue, 2)
			      C             ECHO ----------------------
			      C             ECHO udw$ - requires WORD
			      C             ECHO ----------------------
			      C             .ERR
			      C         ENDIF           
			      C         mov   buffer[0], 0
			      C         IF isregister(uwordvalue)
			      C             mov   uwtmp, uwordvalue
			      C             movzx eax, uwtmp
			      C         ELSE       
			      C             mov   ax, uwordvalue
			      C             movzx eax, ax
			      C         ENDIF   
			      C         INVOKE wsprintf, ADDR buffer, ADDR uwfmt, eax
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C sdw$ MACRO swordvalue:req
			      C     ; signed word
			      C     LOCAL buffer, swtmp
			      C     .DATA?
			      C         swtmp  SWORD ?
			      C         buffer BYTE  8 dup(?)
			      C     IFNDEF swfmt   
			      C     .DATA   
			      C         swfmt  BYTE "%hd", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(swordvalue, 2)
			      C             ECHO -----------------------
			      C             ECHO sdw$ - requires SWORD
			      C             ECHO -----------------------
			      C             .ERR
			      C         ENDIF           
			      C         mov   buffer[0], 0
			      C         IF isregister(swordvalue)
			      C             mov   swtmp, swordvalue
			      C             movsx eax, swtmp
			      C         ELSE   
			      C             mov   ax, swordvalue
			      C             movsx eax, ax
			      C         ENDIF   
			      C         INVOKE wsprintf, ADDR buffer, ADDR swfmt, eax
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C xdw$ MACRO xwordvalue:req
			      C     ; unsigned hex word
			      C     LOCAL buffer, xwtmp
			      C     .DATA?
			      C         xwtmp  WORD ?
			      C         buffer BYTE 8 dup(?)
			      C     IFNDEF xwfmt   
			      C     .DATA   
			      C         xwfmt  BYTE "%hX", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(xwordvalue, 2)
			      C             ECHO ----------------------
			      C             ECHO xdw$ - requires WORD
			      C             ECHO ----------------------
			      C             .ERR
			      C         ENDIF       
			      C         mov   buffer[0], 0
			      C         IF isregister(xwordvalue)
			      C             mov   xwtmp, xwordvalue
			      C             movzx eax, xwtmp
			      C         ELSE               
			      C             mov   ax, xwordvalue
			      C             movzx eax, ax
			      C         ENDIF   
			      C         INVOKE wsprintf, ADDR buffer, ADDR xwfmt, eax
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C udd$ MACRO udwordvalue:req
			      C     ; unsigned dword
			      C     LOCAL buffer
			      C     .DATA?
			      C         buffer BYTE  12 dup(?)
			      C     IFNDEF udfmt   
			      C     .DATA   
			      C         udfmt  BYTE "%lu", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(udwordvalue, 4)
			      C             ECHO ------------------------
			      C             ECHO udd$ - requires DWORD
			      C             ECHO ------------------------
			      C             .ERR
			      C         ENDIF   
			      C         mov    buffer[0], 0
			      C         INVOKE wsprintf, ADDR buffer, ADDR udfmt, udwordvalue
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C sdd$ MACRO sdwordvalue:req
			      C     ; signed dword
			      C     LOCAL buffer
			      C     .DATA?
			      C          buffer BYTE   12 dup(?)
			      C     IFNDEF sdfmt   
			      C     .DATA   
			      C         sdfmt BYTE "%ld", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(sdwordvalue, 4)
			      C             ECHO -------------------------
			      C             ECHO sdd$ - requires SDWORD
			      C             ECHO -------------------------
			      C             .ERR
			      C         ENDIF       
			      C         mov    buffer[0], 0
			      C         INVOKE wsprintf, ADDR buffer, ADDR sdfmt, sdwordvalue
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C xdd$ MACRO xdwordvalue:req
			      C     ; unsigned hex dword
			      C     LOCAL buffer
			      C     .DATA?
			      C         buffer BYTE  12 dup(?)
			      C     IFNDEF xdfmt   
			      C     .DATA   
			      C         xdfmt BYTE "%lX", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(xdwordvalue, 4)
			      C             ECHO ------------------------
			      C             ECHO xdd$ - requires DWORD
			      C             ECHO ------------------------
			      C             .ERR
			      C         ENDIF       
			      C         mov    buffer[0], 0
			      C         INVOKE wsprintf, ADDR buffer, ADDR xdfmt, xdwordvalue
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C udq$ MACRO uqwordvalue:req
			      C     ; unsigned qword
			      C     LOCAL buffer
			      C     .DATA?
			      C         buffer BYTE 24 dup(?)
			      C     IFNDEF uqwfmt   
			      C     .DATA   
			      C         uqwfmt BYTE "%I64u", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(uqwordvalue, 8)
			      C             ECHO ------------------------
			      C             ECHO udq$ - requires QWORD
			      C             ECHO ------------------------
			      C             .ERR
			      C         ENDIF       
			      C         mov    buffer[0], 0
			      C         INVOKE wsprintf, ADDR buffer, ADDR uqwfmt, uqwordvalue
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C sdq$ MACRO sqwordvalue:req
			      C     ; signed qword
			      C     LOCAL buffer
			      C     .DATA?
			      C         buffer BYTE 24 dup(?)
			      C     IFNDEF sqwfmt   
			      C     .DATA   
			      C         sqwfmt BYTE "%I64d", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(sqwordvalue, 8)
			      C             ECHO ------------------------
			      C             ECHO sdq$ - requires QWORD
			      C             ECHO ------------------------
			      C             .ERR
			      C         ENDIF           
			      C         mov    buffer[0], 0
			      C         INVOKE wsprintf, ADDR buffer, ADDR sqwfmt, sqwordvalue
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C xdq$ MACRO xqwordvalue:req
			      C     ; unsigned hex qword
			      C     LOCAL buffer
			      C     .DATA?
			      C         buffer BYTE 20 dup(?)
			      C     IFNDEF xqwfmt   
			      C     .DATA   
			      C         xqwfmt BYTE "%I64X", 0
			      C     ENDIF   
			      C     .CODE
			      C         IFE issize(xqwordvalue, 8)
			      C             ECHO ------------------------
			      C             ECHO xdq$ - requires QWORD
			      C             ECHO ------------------------
			      C             .ERR
			      C         ENDIF           
			      C         mov    buffer[0], 0
			      C         INVOKE wsprintf, ADDR buffer, ADDR xqwfmt, xqwordvalue
			      C         EXITM <OFFSET buffer>
			      C ENDM
			      C ; ----------------------------------------------
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
 = UCCSTR		      C UC  TEXTEQU <UCCSTR>
 = UCCSTR		      C UCC TEXTEQU <UCCSTR>
			      C 
			      C ;/********************************************************************/
			      C ;/*                     fnx - macro procedure                        */
			      C ;/* This macro enhanced the INVOKE-directive:                        */
			      C ;/*   - It adds support for quoted ASCII or unicode strings.         */
			      C ;/*     The strings can be either enclosed by double quotes or by    */
			      C ;/*     single quotation marks.                                      */
			      C ;/*     The kind of created string (Unicode or ASCII) depends on the */
			      C ;/*     __UNICODE__ equate. If this equte is defined and has a       */
			      C ;/*     nonzero value, a unicode string is created. However, creation*/
			      C ;/*     of Unicode strings can be forced by using the 'L'-prefix:    */
			      C ;/*                 L"my string" or L'my string'                     */
			      C ;/*     ASCII strings can be forced by using the A-prefix:           */
			      C ;/*                 A"my string" or A'my string'                     */
			      C ;/*     MASM's reserved characters like exclamation marks, angel     */
			      C ;/*     brackets and single brackets [,...] can not be used.         */
			      C ;/*     (use fncx for escape sequences support)                      */
			      C ;/*   - ADDR-expressions can be shorten by using a ampersand '&':    */
			      C ;/*         fn MessageBoxW,0,&wsz[0],L'xyz',0                        */
			      C ;/*   - Pointers to DWORDs can be dereferenced, if they are leaded   */
			      C ;/*     by '*' (like dereferencing in c/c++):                        */
			      C ;/*                fnx MesageBox,0,*ppchar,...                       */
			      C ;/*   - a optional destination can be specified in front of the      */
			      C ;/*     function:                                                    */
			      C ;/*         fn dest=FncName,...                                      */
			      C ;/*                                                                  */
			      C ;/* Example:                                                         */
			      C ;/*     fnx MessageBoxW,0,L"my string",&wsz[0],0                     */
			      C ;/*     fnx hWnd = CreateWindowEx,...                                */
			      C ;/*                                                     qWord, 2011  */
			      C ;/********************************************************************/
			      C fnx MACRO FncName:req,args:VARARG
			      C 
			      C     ;/* check if a optional destination is specified */
			      C     fnex_flag = 0
			      C     IF @InStr(1,<&FncName>,<=>)
			      C         fnex_flag = 1
			      C         fnex_dest SUBSTR <&FncName>,1,@InStr(1,<&FncName>,<=>)-1
			      C         fnex_arg TEXTEQU <invoke >,@SubStr(<&FncName>,@InStr(1,<&FncName>,<=>)+1)
			      C     ELSE    
			      C         fnex_arg TEXTEQU <invoke FncName>
			      C     ENDIF
			      C 
			      C     ;/* process argument list and append it to the invoke-call */
			      C     fnex_arg CATSTR fnex_arg,repargs(0,&args)
			      C 
			      C     ;/* place the function call */
			      C     fnex_arg
			      C 
			      C     ;/* if available, fill the specified destination */    
			      C     IF fnex_flag EQ 1
			      C         mov fnex_dest,eax
			      C     ENDIF
			      C endm
			      C 
			      C 
			      C ;/********************************************************************/
			      C ;/*                     fncx - macro procedure                       */
			      C ;/* This macro behave like the fnx-macros, except, that it adds      */
			      C ;/* support for escape sequences:                                    */
			      C ;/*     \\  ->  "\"                                                  */
			      C ;/*     \t  ->  tab                                                  */
			      C ;/*     \n  ->  new line (13,10)                                     */
			      C ;/*     \x  ->  "!"                                                  */
			      C ;/*     \a  ->  "("                                                  */
			      C ;/*     \b  ->  ")"                                                  */
			      C ;/*     \l  ->  "<"                                                  */
			      C ;/*     \r  ->  ">"                                                  */
			      C ;/*     \p  ->  "%"                                                  */
			      C ;/*     \A  ->  "&"                                                  */
			      C ;/*     \q  ->  double quote '"'                                     */
			      C ;/*     \0  ->  zero                                                 */
			      C ;/* Example:                                                         */
			      C ;/*     fncx MessageBox,0,"my string\n",&wsz[0],0                    */
			      C ;/*                                                     qWord, 2011  */
			      C ;/********************************************************************/
			      C fncx MACRO FncName:req,args:VARARG
			      C 
			      C     ;/* check if a optional destination is specified */
			      C     fnex_flag = 0
			      C     IF @InStr(1,<&FncName>,<=>)
			      C         fnex_flag = 1
			      C         fnex_dest SUBSTR <&FncName>,1,@InStr(1,<&FncName>,<=>)-1
			      C         fnex_arg TEXTEQU <invoke >,@SubStr(<&FncName>,@InStr(1,<&FncName>,<=>)+1)
			      C     ELSE    
			      C         fnex_arg TEXTEQU <invoke FncName>
			      C     ENDIF
			      C 
			      C     ;/* process argument list and append it to the invoke-call */
			      C     fnex_arg CATSTR fnex_arg,repargs(1,&args)
			      C 
			      C     ;/* place the function call */
			      C     fnex_arg
			      C 
			      C     ;/* if available, fill the specified destination */    
			      C     IF fnex_flag EQ 1
			      C         mov fnex_dest,eax
			      C     ENDIF
			      C endm
			      C 
			      C ;/********************************************************************/
			      C ;/*                     rvx - macro function                         */
			      C ;/* This macro is the function-version of the fnx-macro.             */
			      C ;/*                                                                  */
			      C ;/* Example:                                                         */
			      C ;/*      mov edi,rv(myFunction,L"my string",&wsz[0],...)             */
			      C ;/*      .break .if !rv(dest=myFunction,...)                         */
			      C ;/*                                                     qWord, 2011  */
			      C ;/********************************************************************/
			      C rvx MACRO FncName:req,args:VARARG
			      C     
			      C     ;/* check if a optional destination is specified */
			      C     rvex_flag = 0
			      C     IF @InStr(1,<&FncName>,<=>)
			      C         rvex_flag = 1
			      C         rvex_dest SUBSTR <&FncName>,1,@InStr(1,<&FncName>,<=>)-1
			      C         rvex_arg TEXTEQU <invoke >,@SubStr(<&FncName>,@InStr(1,<&FncName>,<=>)+1)
			      C     ELSE    
			      C         rvex_arg TEXTEQU <invoke FncName>
			      C     ENDIF
			      C 
			      C     ;/* process argument list and append it to the invoke-call */
			      C     rvex_arg CATSTR rvex_arg,repargs(0,&args)
			      C     
			      C     ;/* place the function call */
			      C     rvex_arg
			      C     
			      C     ;/* if available, fill the specified destination */
			      C     IF rvex_flag EQ 1
			      C         mov rvex_dest,eax
			      C     ENDIF
			      C     EXITM <eax>
			      C endm
			      C 
			      C ;/********************************************************************/
			      C ;/*                     rvcx - macro function                        */
			      C ;/* This macro behave like the rvx-macros, except, that it adds      */
			      C ;/* support for escape sequences:                                    */
			      C ;/*     \\  ->  "\"                                                  */
			      C ;/*     \t  ->  tab                                                  */
			      C ;/*     \n  ->  new line (13,10)                                     */
			      C ;/*     \x  ->  "!"                                                  */
			      C ;/*     \a  ->  "("                                                  */
			      C ;/*     \b  ->  ")"                                                  */
			      C ;/*     \l  ->  "<"                                                  */
			      C ;/*     \r  ->  ">"                                                  */
			      C ;/*     \p  ->  "%"                                                  */
			      C ;/*     \A  ->  "&"                                                  */
			      C ;/*     \q  ->  double quote '"'                                     */
			      C ;/*     \0  ->  zero                                                 */
			      C ;/* Example:                                                         */
			      C ;/*     mov edi,rv(myFunction,L"my string\x\n",&wsz[0],...)          */
			      C ;/*                                                     qWord, 2011  */
			      C ;/********************************************************************/
			      C rvcx MACRO FncName:req,args:VARARG
			      C     
			      C     ;/* check if a optional destination is specified */
			      C     rvex_flag = 0
			      C     IF @InStr(1,<&FncName>,<=>)
			      C         rvex_flag = 1
			      C         rvex_dest SUBSTR <&FncName>,1,@InStr(1,<&FncName>,<=>)-1
			      C         rvex_arg TEXTEQU <invoke >,@SubStr(<&FncName>,@InStr(1,<&FncName>,<=>)+1)
			      C     ELSE    
			      C         rvex_arg TEXTEQU <invoke FncName>
			      C     ENDIF
			      C 
			      C     ;/* process argument list and append it to the invoke-call */
			      C     rvex_arg CATSTR rvex_arg,repargs(1,&args)
			      C     
			      C     ;/* place the function call */
			      C     rvex_arg
			      C     
			      C     ;/* if available, fill the specified destination */
			      C     IF rvex_flag EQ 1
			      C         mov rvex_dest,eax
			      C     ENDIF
			      C     EXITM <eax>
			      C endm
			      C 
			      C ;/******************************************************************/ 
			      C ;/*                 repargs , macro function                       */
			      C ;/* Parse the arguments list 'args' and replace:                   */
			      C ;/*     - String literals by the corresponding OFFSET-expression   */
			      C ;/*       after creating an anonym string in the .data-section     */
			      C ;/*     - leading ampersands (&) by the ADDR operator              */
			      C ;/*     - dereferencing of pointers, if the leading char. is a '*' */
			      C ;/* All other arguments are left untouched.                        */
			      C ;/*                                                                */
			      C ;/* Parameter:   cstr: indicates whether to support escape         */
			      C ;/*                    sequences in string literals or not {0,1}   */
			      C ;/*              args: arguments to parse                          */
			      C ;/* Details:                                                       */
			      C ;/*     This macro creates, according to the __UNICODE__-equate,   */
			      C ;/*     either ASCII or Unicode strings. However, Unicode strings  */
			      C ;/*     can be forced by using the 'L'-Prefix:                     */
			      C ;/*       L"my unicode string"  or L'my "quoted" string'           */
			      C ;/*     ASCII string can be forced by the 'A'-prefix:              */
			      C ;/*       A"my ASCII string"  or A'xyz 1234 '                      */
			      C ;/*     Furthermore, ampersands are replaced by <ADDR >, if they   */
			      C ;/*     are the first character of the argument:                   */
			      C ;/*        ..., &sz[0],...    ->   ..., ADDR sz[0],...             */
			      C ;/*     If the leading char. is a <*>, the argument is             */
			      C ;/*     interpreted as a pointer to a DWORD, which is loaded:      */
			      C ;/*         mov pchar, chr$("xyz")                                 */
			      C ;/*         lea eax,pchar                                          */
			      C ;/*         mov ppchar,eax                                         */
			      C ;/*         fn MessageBox,0,*ppchar,...                            */
			      C ;/*                                                                */
			      C ;/* Return:                                                        */
			      C ;/*     The processed argument list. If a nonempty list is passed  */
			      C ;/*     to the macro, the returned list is always leaded           */
			      C ;/*     by a comma:                                                */
			      C ;/*         <arg1,arg2,...> -> <,newArg1,newArg2,...>              */
			      C ;/*     The number of arguments in list is stored in               */
			      C ;/*     the equate repargs_cntr.                                   */
			      C ;/*                                                                */
			      C ;/* Remarks:                                                       */
			      C ;/*     This macro is designed to process arguments lists for      */
			      C ;/*     the INVOKE-directive.                                      */
			      C ;/*     The macro assumes to be called from the .code-section      */
			      C ;/*                                                                */
			      C ;/* Example:                                                       */
			      C ;/*     invk_txt TEXTEQU <invoke FncName>                          */
			      C ;/*     invk_txt CATSTR invk_txt,repargs(ArgumentList)             */
			      C ;/*     invk_txt                                                   */
			      C ;/*                                                                */
			      C ;/*                                                  qWord, 2011   */
			      C ;/******************************************************************/ 
			      C repargs MACRO cstr:=<0>,args:VARARG
			      C     
			      C     ;/* initialize global counter which */
			      C     ;/* is used for label-creation.      */
			      C     IFNDEF repargs_glb_cntr
			      C         repargs_glb_cntr = 0
			      C     ENDIF
			      C 
			      C     repargs_unicode = 0
			      C     IFDEF __UNICODE__
			      C         IF __UNICODE__
			      C             repargs_unicode = 1
			      C         ENDIF
			      C     ENDIF
			      C     
			      C     ;/* count arguments (needed for dereferencing operator) */
			      C     repargs_nargs = 0
			      C     FOR arg,<&args>
			      C         repargs_nargs = repargs_nargs + 1
			      C     ENDM
			      C     repargs_eax_saved = 0
			      C 
			      C     repargs_cntr = 0
			      C     repargs_args TEXTEQU <>
			      C     FOR arg,<&args>
			      C         repargs_txt  TEXTEQU <&arg>
			      C        
			      C         ;/* analyze current argument */
			      C         repargs_pos1 INSTR 1,<&arg>,<">
			      C         repargs_pos2 INSTR 1,<&arg>,<'>
			      C         repargs_pos3 INSTR 1,<&arg>,<L">
			      C         repargs_pos4 INSTR 1,<&arg>,<L'>
			      C         repargs_pos5 INSTR 1,<&arg>,<A">
			      C         repargs_pos6 INSTR 1,<&arg>,<A'>
			      C         repargs_pos7 INSTR 1,<&arg>,<!&>
			      C         repargs_pos8 INSTR 1,<&arg>,<*>
			      C 
			      C         IF repargs_pos1 EQ 1 OR repargs_pos2 EQ 1
			      C             repargs_str_type = 1                       ; ASCII
			      C             IF repargs_unicode
			      C                 repargs_str_type = 2                   ; Unicode
			      C             ENDIF
			      C         ELSEIF repargs_pos3 EQ 1 OR repargs_pos4 EQ 1
			      C             repargs_str_type = 2                       ; Unicode
			      C             repargs_txt SUBSTR repargs_txt,2           ; remove prefix
			      C         ELSEIF repargs_pos5 EQ 1 OR repargs_pos6 EQ 1
			      C             repargs_str_type = 1                       ; ASCII
			      C             repargs_txt SUBSTR repargs_txt,2           ; remove prefix
			      C         ELSE
			      C             repargs_str_type = 0                       ; no string
			      C         ENDIF
			      C         
			      C         IF repargs_str_type EQ 1
			      C             ;/ create ASCII string */
			      C             .data
			      C                 IF @SizeStr(<%repargs_txt>) GT 2
			      C                     IFE cstr
			      C                         @CatStr(<$$_szlbl_>,%repargs_glb_cntr) db repargs_txt,0
			      C                     ELSE
			      C                         ?cstr? @CatStr(<$$_szlbl_>,%repargs_glb_cntr),<%repargs_txt>,0
			      C                     ENDIF
			      C                 ELSE
			      C                     @CatStr(<$$_szlbl_>,%repargs_glb_cntr) db 0
			      C                 ENDIF               
			      C             .code
			      C             repargs_args TEXTEQU repargs_args,<,OFFSET $$_szlbl_>,%repargs_glb_cntr
			      C             repargs_glb_cntr = repargs_glb_cntr + 1
			      C         ELSEIF repargs_str_type EQ 2
			      C             ;/* create Unicode string */
			      C             .data
			      C                 IF @SizeStr(<%repargs_txt>) GT 2
			      C                     IFE cstr
			      C                         UCSTR @CatStr(<$$_wszlbl_>,%repargs_glb_cntr),<%repargs_txt>,0
			      C                     ELSE
			      C                         UCCSTR @CatStr(<$$_wszlbl_>,%repargs_glb_cntr),<%repargs_txt>,0
			      C                     ENDIF
			      C                 ELSE
			      C                     @CatStr(<$$_wszlbl_>,%repargs_glb_cntr) dw 0
			      C                 ENDIF
			      C             .code
			      C             repargs_args TEXTEQU repargs_args,<,OFFSET $$_wszlbl_>,%repargs_glb_cntr
			      C             repargs_glb_cntr = repargs_glb_cntr + 1
			      C         ELSEIF repargs_pos7 EQ 1
			      C             ;/* replace '&' with <ADDR > and append argument to list */
			      C             repargs_args TEXTEQU repargs_args,<,>,<ADDR >,@SubStr(%repargs_txt,2,)
			      C         ELSEIF repargs_pos8 EQ 1
			      C             ;/* dereference operator '*' */
			      C 
			      C             repargs_txt SUBSTR repargs_txt,2  ; remove <*>
			      C 
			      C             ;/* register ? */
			      C             IF ((OPATTR repargs_txt) AND 10000y) NE 0
			      C                 repargs_args TEXTEQU repargs_args,<,>,<DWORD ptr [>,repargs_txt,<]>
			      C             ELSE
			      C                 IFE repargs_eax_saved
			      C                     mov DWORD ptr [esp-4],eax
			      C                     repargs_eax_saved = 1
			      C                 ENDIF
			      C                 mov eax,repargs_txt
			      C                 mov eax,[eax]
			      C                 mov DWORD ptr [esp-2*repargs_nargs*4+repargs_cntr*4],eax
			      C                 repargs_args TEXTEQU repargs_args,<,>,<DWORD ptr [esp->,%(repargs_nargs*4+4),<]>
			      C             ENDIF
			      C         ELSE
			      C             ;/* record unprocessed argument */
			      C             repargs_args TEXTEQU repargs_args,<,>,repargs_txt
			      C         ENDIF
			      C         repargs_cntr = repargs_cntr + 1
			      C     ENDM
			      C     IF repargs_eax_saved
			      C         mov eax,DWORD ptr [esp-4]
			      C     ENDIF
			      C     EXITM repargs_args
			      C endm
			      C 
			      C 
			      C ;/*****************************************************************/
			      C ;/*             UCSTR - macro procedure                           */
			      C ;/* This macro creates a Unicode string in the current segment    */
			      C ;/* Parameters:                                                   */
			      C ;/*    lbl:    [optional] name of string                          */
			      C ;/*    args:   one ore more string literals, either enclosed by   */
			      C ;/*            single quotation marks or by double quotes.        */
			      C ;/*            Constants can also be used, blank arguments        */
			      C ;/*            force an error. The maximal number of characters   */
			      C ;/*            is something about 240.                            */
			      C ;/*                                                               */
			      C ;/* Remarks:   A termination zero must add by user!               */
			      C ;/*            Named strings can be used with the SIZEOF and      */
			      C ;/*            LENGTHOF operator. This macro wont work with       */
			      C ;/*            angle brackets and exclemation marks.              */
			      C ;/* Example:                                                      */
			      C ;/*          UCSTR myStr, "my string",13,10,'"quoted"',0          */
			      C ;/*                                                  qWord, 2011  */
			      C ;/*****************************************************************/
			      C UCSTR MACRO lbl,args:VARARG
			      C     
			      C     ;/* initialize counter used for label creation */
			      C     IFNDEF ucstr_lbl_cntr
			      C         ucstr_lbl_cntr = 0
			      C     ENDIF
			      C     
			      C     ;/* if required, create a label */
			      C     IFB <&lbl>
			      C         ucstr_lbl TEXTEQU <$$_WSTR_>,%ucstr_lbl_cntr
			      C         ucstr_lbl_cntr = ucstr_lbl_cntr + 1
			      C     ELSE
			      C         ucstr_lbl TEXTEQU <&lbl>
			      C     ENDIF
			      C 
			      C     ucstr_size = 0
			      C     ucstr_flg = 0  ; 0 => invalid argument
			      C                    ; 1 => double quotes are used
			      C                    ; 2 => single quotation marks are used
			      C                    ; 3 => constant 
			      C     ucstr_iarg = 1
			      C 
			      C     ;/* The following loop count the number of required WCHAR's */
			      C     FOR _arg,<&args>
			      C         ;/* loop through all characters */
			      C         ucstr_flg = 0
			      C         FORC char,<&_arg>
			      C             IF ucstr_flg NE 0
			      C                 ucstr_pos INSTR 1,<"'>,<&char>
			      C                 ;/* end of quoted string reached? */
			      C                 IF ucstr_pos EQ ucstr_flg
			      C                     EXITM
			      C                 ENDIF
			      C                 ucstr_size = ucstr_size + 1
			      C             ELSE
			      C                 ;/* This part is only one time executet for each argument _arg. */
			      C                 ;/* It determine wheter a string litreal, a numeric constant or */
			      C                 ;/* an invalid arguemten is present.                            */
			      C                 ucstr_flg INSTR 1,<"'>,<&char>
			      C                 IFE ucstr_flg
			      C                     ;/* constant value ? */
			      C                     IF (OPATTR _arg) AND 100y
			      C                         ucstr_flg = 3
			      C                     ENDIF
			      C                     EXITM
			      C                 ENDIF
			      C             ENDIF
			      C         ENDM
			      C         IF ucstr_flg EQ 3
			      C             ;/* numeric constant */
			      C             ucstr_size = ucstr_size + 1
			      C         ELSEIFE ucstr_flg
			      C             ;/* invalid argument detected -> exit */
			      C             EXITM
			      C         ENDIF
			      C         ucstr_iarg = ucstr_iarg + 1     
			      C     ENDM
			      C     IFE ucstr_flg
			      C     %   .err <invalid string specifier : argument : @CatStr(%ucstr_iarg)>
			      C         EXITM
			      C     ENDIF
			      C     
			      C     ;/* allocate string in current segment */
			      C     align 2
			      C     ucstr_lbl WORD ucstr_size dup (?)
			      C     org $-ucstr_size*2
			      C     
			      C     ;/* This loop is nearly identically to the one above, excpet that char. are emitted */
			      C     FOR _arg,<&args>
			      C         ucstr_flg = 0
			      C         FORC char,<&_arg>
			      C             IF ucstr_flg NE 0
			      C                 ucstr_pos INSTR 1,<"'>,<&char>
			      C                 IF ucstr_pos EQ ucstr_flg
			      C                     EXITM
			      C                 ELSE
			      C                     ucstr_char CATSTR <dw >,ucstr_quote,<&char>,ucstr_quote
			      C                     ucstr_char
			      C                 ENDIF
			      C             ELSE
			      C                 ucstr_flg INSTR 1,<"'>,<&char>
			      C                 IFE ucstr_flg
			      C                     IF (OPATTR _arg) AND 100y
			      C                         ucstr_flg = 3
			      C                     ENDIF
			      C                     EXITM
			      C                 ENDIF
			      C                 ucstr_quote TEXTEQU <&char>
			      C             ENDIF
			      C         ENDM
			      C         IF ucstr_flg EQ 3
			      C             dw _arg
			      C         ELSEIFE ucstr_flg
			      C             EXITM
			      C         ENDIF
			      C         ucstr_iarg = ucstr_iarg + 1     
			      C     ENDM
			      C 
			      C endm
			      C 
			      C ;/***************************************************/
			      C ;/*               uc$ , macro function              */
			      C ;/* This macro is the function-version of UCSTR.    */
			      C ;/* In contrast to UCSTR, the created string is     */
			      C ;/* zero terminated. The macro assumes to be called */
			      C ;/* from the .code-section and places the string    */
			      C ;/* in the .data-section.                           */
			      C ;/* Example:                                        */
			      C ;/*      mov esi,uc$("my string",13,10,'xxyz')      */
			      C ;/*                                    qWord, 2011  */
			      C ;/***************************************************/
			      C uc$ MACRO args:VARARG
			      C     .data
			      C         UCSTR ,args,0
			      C     .code
			      C     ucsz_retval TEXTEQU <OFFSET >,ucstr_lbl
			      C     EXITM ucsz_retval
			      C endm
			      C 
			      C ;/*****************************************************************/
			      C ;/*             UCCSTR - macro procedure                          */
			      C ;/* This macro creates a Unicode string in the current segment    */
			      C ;/* This macro is identically to the UCSTR-macro, except, that it */
			      C ;/* adds support for some escape sequences:                       */
			      C ;/*     \\  ->  "\"                                               */
			      C ;/*     \t  ->  tab                                               */
			      C ;/*     \n  ->  new line (13,10)                                  */
			      C ;/*     \x  ->  "!"                                               */
			      C ;/*     \a  ->  "("                                               */
			      C ;/*     \b  ->  ")"                                               */
			      C ;/*     \l  ->  "<"                                               */
			      C ;/*     \r  ->  ">"                                               */
			      C ;/*     \p  ->  "%"                                               */
			      C ;/*     \A  ->  "&"                                               */
			      C ;/*     \q  ->  double quote '"'                                  */
			      C ;/*     \0  ->  zero-word                                         */
			      C ;/*                                                               */
			      C ;/* Example:                                                      */
			      C ;/*       UCCSTR myStr, "line 1\nline2\nI'm here\x",0             */
			      C ;/*                                                  qWord, 2011  */
			      C ;/*****************************************************************/
			      C UCCSTR MACRO lbl,args:VARARG
			      C 
			      C     IFNDEF uccstr_lbl_cntr
			      C         uccstr_lbl_cntr = 0
			      C     ENDIF
			      C     IFB <&lbl>
			      C         uccstr_lbl TEXTEQU <anonym_WSTR_>,%uccstr_lbl_cntr
			      C         uccstr_lbl_cntr = uccstr_lbl_cntr + 1
			      C     ELSE
			      C         uccstr_lbl TEXTEQU <&lbl>
			      C     ENDIF
			      C 
			      C     uccstr_size = 0
			      C     uccstr_flg = 0
			      C     uccstr_iarg = 1
			      C     uccstr_esc = 0
			      C     FOR _arg,<args>
			      C         uccstr_flg = 0
			      C         FORC char,<&_arg>
			      C             IF uccstr_flg NE 0
			      C                 uccstr_pos INSTR 1,<"'\>,<&char>
			      C                 IF uccstr_pos EQ uccstr_flg
			      C                     EXITM
			      C                 ELSEIF uccstr_pos EQ 3 AND uccstr_esc EQ 0
			      C                 uccstr_esc = 1
			      C                 ELSE
			      C                     IF uccstr_esc
			      C                         uccstr_pos INSTR 1,<\0ablrxqtpAn>,<&char>
			      C                         
			      C                         IFE uccstr_pos
			      C                             uccstr_flg=0
			      C                             EXITM
			      C                         ENDIF
			      C                         uccstr_size = uccstr_size + uccstr_pos/12
			      C                         uccstr_esc = 0
			      C                     ENDIF
			      C                     uccstr_size = uccstr_size + 1
			      C                 ENDIF
			      C             ELSE
			      C                 uccstr_flg INSTR 1,<"'>,<&char>
			      C                 IFE uccstr_flg
			      C                     IF (OPATTR _arg) AND 100y
			      C                         uccstr_flg = 3
			      C                     ENDIF
			      C                     EXITM
			      C                 ENDIF
			      C             ENDIF
			      C         ENDM
			      C         IF uccstr_flg EQ 0 OR uccstr_esc NE 0
			      C             EXITM
			      C         ELSEIF uccstr_flg EQ 3
			      C             uccstr_size = uccstr_size + 1
			      C         ENDIF       
			      C         uccstr_iarg = uccstr_iarg + 1
			      C     ENDM
			      C     IF uccstr_flg EQ 0 OR uccstr_esc NE 0
			      C         IF uccstr_esc
			      C         %   .err <invalid escape sequence : argument : @CatStr(%uccstr_iarg)>
			      C         ELSE
			      C         %   .err <invalid string specifier : argument : @CatStr(%uccstr_iarg)>
			      C         ENDIF
			      C         EXITM
			      C     ENDIF
			      C     
			      C     align 2
			      C     uccstr_lbl WORD uccstr_size dup (?)
			      C     org $-uccstr_size*2
			      C     
			      C     uccstr_esc = 0
			      C     FOR _arg,<&args>
			      C         uccstr_flg = 0
			      C         FORC char,<&_arg>
			      C             IF uccstr_flg NE 0
			      C                 uccstr_pos INSTR 1,<"'\>,<&char>
			      C                 IF uccstr_pos EQ uccstr_flg
			      C                     EXITM
			      C                 ELSEIF uccstr_pos EQ 3 AND uccstr_esc EQ 0
			      C                     uccstr_esc = 1
			      C                 ELSE
			      C                     IFE uccstr_esc
			      C                         uccstr_char CATSTR <dw >,uccstr_quote,<&char>,uccstr_quote
			      C                         uccstr_char
			      C                     ELSE
			      C                         uccstr_pos INSTR 1,<\0ablrxqtpAn>,<&char>
			      C                         IFE uccstr_pos
			      C                             uccstr_flg=0
			      C                             EXITM
			      C                         ENDIF
			      C                         uccstr_char SUBSTR <  5ch00h28h29h3ch3eh21h22h09h25h26h0ah,0dh>,uccstr_pos*3,3+4*(uccstr_pos/12)
			      C                         uccstr_esc = 0
			      C                         dw uccstr_char
			      C                     ENDIF
			      C                 ENDIF
			      C             ELSE
			      C                 uccstr_flg INSTR 1,<"'>,<&char>
			      C                 IFE uccstr_flg
			      C                     IF (OPATTR _arg) AND 100y
			      C                         uccstr_flg = 3
			      C                     ENDIF
			      C                     EXITM
			      C                 ENDIF
			      C                 uccstr_quote TEXTEQU <&char>
			      C             ENDIF
			      C         ENDM
			      C         IF uccstr_flg EQ 3
			      C             dw _arg
			      C         ENDIF       
			      C     ENDM
			      C 
			      C endm
			      C 
			      C ;/* internal: ASCII-counterpart of UCCSTR */
			      C ?cstr? MACRO lbl,args:VARARG
			      C 
			      C     IFNDEF ?cstr?_lbl_cntr
			      C         ?cstr?_lbl_cntr = 0
			      C     ENDIF
			      C     IFB <&lbl>
			      C         ?cstr?_lbl TEXTEQU <anonym_WSTR_>,%?cstr?_lbl_cntr
			      C         ?cstr?_lbl_cntr = ?cstr?_lbl_cntr + 1
			      C     ELSE
			      C         ?cstr?_lbl TEXTEQU <&lbl>
			      C     ENDIF
			      C 
			      C     ?cstr?_size = 0
			      C     ?cstr?_flg = 0
			      C     ?cstr?_iarg = 1
			      C     ?cstr?_esc = 0
			      C     FOR _arg,<args>
			      C         ?cstr?_flg = 0
			      C         FORC char,<&_arg>
			      C             IF ?cstr?_flg NE 0
			      C                 ?cstr?_pos INSTR 1,<"'\>,<&char>
			      C                 IF ?cstr?_pos EQ ?cstr?_flg
			      C                     EXITM
			      C                 ELSEIF ?cstr?_pos EQ 3 AND ?cstr?_esc EQ 0
			      C                 ?cstr?_esc = 1
			      C                 ELSE
			      C                     IF ?cstr?_esc
			      C                         ?cstr?_pos INSTR 1,<\0ablrxqtpAn>,<&char>
			      C                         
			      C                         IFE ?cstr?_pos
			      C                             ?cstr?_flg=0
			      C                             EXITM
			      C                         ENDIF
			      C                         ?cstr?_size = ?cstr?_size + ?cstr?_pos/12
			      C                         ?cstr?_esc = 0
			      C                     ENDIF
			      C                     ?cstr?_size = ?cstr?_size + 1
			      C                 ENDIF
			      C             ELSE
			      C                 ?cstr?_flg INSTR 1,<"'>,<&char>
			      C                 IFE ?cstr?_flg
			      C                     IF (OPATTR _arg) AND 100y
			      C                         ?cstr?_flg = 3
			      C                     ENDIF
			      C                     EXITM
			      C                 ENDIF
			      C             ENDIF
			      C         ENDM
			      C         IF ?cstr?_flg EQ 0 OR ?cstr?_esc NE 0
			      C             EXITM
			      C         ELSEIF ?cstr?_flg EQ 3
			      C             ?cstr?_size = ?cstr?_size + 1
			      C         ENDIF       
			      C         ?cstr?_iarg = ?cstr?_iarg + 1
			      C     ENDM
			      C     IF ?cstr?_flg EQ 0 OR ?cstr?_esc NE 0
			      C         IF ?cstr?_esc
			      C         %   .err <invalid escape sequence : argument : @CatStr(%?cstr?_iarg)>
			      C         ELSE
			      C         %   .err <invalid string specifier : argument : @CatStr(%?cstr?_iarg)>
			      C         ENDIF
			      C         EXITM
			      C     ENDIF
			      C     
			      C     ?cstr?_lbl BYTE ?cstr?_size dup (?)
			      C     org $-?cstr?_size
			      C     
			      C     ?cstr?_esc = 0
			      C     FOR _arg,<&args>
			      C         ?cstr?_flg = 0
			      C         FORC char,<&_arg>
			      C             IF ?cstr?_flg NE 0
			      C                 ?cstr?_pos INSTR 1,<"'\>,<&char>
			      C                 IF ?cstr?_pos EQ ?cstr?_flg
			      C                     EXITM
			      C                 ELSEIF ?cstr?_pos EQ 3 AND ?cstr?_esc EQ 0
			      C                     ?cstr?_esc = 1
			      C                 ELSE
			      C                     IFE ?cstr?_esc
			      C                         ?cstr?_char CATSTR <db >,?cstr?_quote,<&char>,?cstr?_quote
			      C                         ?cstr?_char
			      C                     ELSE
			      C                         ?cstr?_pos INSTR 1,<\0ablrxqtpAn>,<&char>
			      C                         IFE ?cstr?_pos
			      C                             ?cstr?_flg=0
			      C                             EXITM
			      C                         ENDIF
			      C                         ?cstr?_char SUBSTR <  5ch00h28h29h3ch3eh21h22h09h25h26h0ah,0dh>,?cstr?_pos*3,3+4*(?cstr?_pos/12)
			      C                         ?cstr?_esc = 0
			      C                         db ?cstr?_char
			      C                     ENDIF
			      C                 ENDIF
			      C             ELSE
			      C                 ?cstr?_flg INSTR 1,<"'>,<&char>
			      C                 IFE ?cstr?_flg
			      C                     IF (OPATTR _arg) AND 100y
			      C                         ?cstr?_flg = 3
			      C                     ENDIF
			      C                     EXITM
			      C                 ENDIF
			      C                 ?cstr?_quote TEXTEQU <&char>
			      C             ENDIF
			      C         ENDM
			      C         IF ?cstr?_flg EQ 3
			      C             db _arg
			      C         ENDIF       
			      C     ENDM
			      C endm
			      C 
			      C ;/***************************************************/
			      C ;/*               ucc$ , macro function             */
			      C ;/* This macro is the function-version of UCCSTR.   */
			      C ;/* In contrast to UCCSTR, the created string is    */
			      C ;/* zero terminated. The macro assumes to be called */
			      C ;/* from the .code-section and places the string    */
			      C ;/* in the .data-section.                           */
			      C ;/*     mov esi,ucc$("\lHello World\r\n:-\b")       */
			      C ;/*                                    qWord, 2011  */
			      C ;/***************************************************/
			      C ucc$ MACRO args:VARARG
			      C     .data
			      C         UCCSTR ,args,0
			      C     .code
			      C     uccsz_retval TEXTEQU <OFFSET >,uccstr_lbl
			      C     EXITM uccsz_retval
			      C ENDM
			      C 
			      C ; いいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい
			      C 
					  
					  include \masm32\include\masm32.inc
			      C comment * 
			      C            Include file for procedures in the MASM32 library
			      C            *
			      C 
			      C IFNDEF MASM32_INC
 = 1			      C MASM32_INC equ <1>
			      C 
			      C ; for both --> arg num, buffer
			      C ArgCl  PROTO :DWORD,:DWORD   ; GUI mode version
			      C ArgClC PROTO :DWORD,:DWORD   ; console mode version
			      C 
			      C GetCL       PROTO :DWORD,:DWORD ; 128 byte buffer version
			      C getcl_ex    PROTO :DWORD,:DWORD ; unlimited size version
			      C 
			      C Alloc       PROTO :DWORD
			      C Free        PROTO :DWORD
			      C 
			      C comment * --------------------------
			      C         numeric and text conversions
			      C         ---------------------------- *
			      C a2dw   PROTO :DWORD
			      C atodw  PROTO :DWORD          ; return value in eax
			      C htodw  PROTO :DWORD          ; return value in eax
			      C dwtoa  PROTO :DWORD,:DWORD   ; value - buffer
			      C dw2a   PROTO :DWORD,:DWORD
			      C dw2hex PROTO :DWORD,:DWORD
			      C 
			      C ustr2dw PROTO :DWORD
			      C udw2str PROTO :DWORD,:DWORD
			      C 
			      C GetErrDescription PROTO :DWORD
			      C 
			      C comment * -----------------------------------
			      C         string and floating point conversions
			      C         ------------------------------------- *
			      C FloatToStr  proto stdcall fpin:QWORD, szDbl:PTR CHAR
			      C FloatToStr2	proto	stdcall fpin:QWORD, szDbl:PTR CHAR
			      C StrToFloat	proto	stdcall szIn:PTR BYTE, fpout:PTR DWORD
			      C 
			      C comment * ---------------
			      C         search algorithms
			      C         ----------------- *
			      C InString  PROTO :DWORD,:DWORD,:DWORD                    ; StartPos-lpszString-lpszSubStr
			      C BinSearch PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD      ; classic scanner
			      C partial   PROTO :DWORD,:DWORD,:DWORD                    ; partial matching algorithm using * as wildcard
			      C 
			      C ; Boyer Moore based algorithms
			      C ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			      C BMBinSearch  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD   ; complete BM
			      C BMHBinsearch PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD   ; horspool variation
			      C SBMBinSearch PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD   ; simplified version
			      C WordCount    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C comment * ---------------------------
			      C         encryption algorithms for
			      C         "one shot" or "one pass" pads
			      C         ----------------------------- *
			      C XorData PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C RolData PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C RorData PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C StrLen PROTO :DWORD ; Agner Fog's high speed string length algo
			      C 
			      C comment * ------------------------------------
			      C         zero terminated string procedures have
			      C         been renamed for consistency. Equates
			      C         to the old names are below.
			      C         -------------------------------------- *
			      C 
			      C     szappend    PROTO :DWORD,:DWORD,:DWORD
			      C     szCatStr    PROTO :DWORD,:DWORD
			      C     szCmp       PROTO :DWORD,:DWORD
			      C     szCmpi      PROTO :DWORD,:DWORD,:DWORD
			      C     Cmpi        PROTO :DWORD,:DWORD
			      C     szCopy      PROTO :DWORD,:DWORD
			      C     szLeft      PROTO :DWORD,:DWORD,:DWORD
			      C     szLen       PROTO :DWORD
			      C     szLower     PROTO :DWORD
			      C     szLtrim     PROTO :DWORD,:DWORD
			      C     szMid       PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     szMultiCat  PROTO C :DWORD,:DWORD,:VARARG
			      C     szMonoSpace PROTO :DWORD
			      C     szRemove    PROTO :DWORD,:DWORD,:DWORD
			      C     szRep       PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     szRev       PROTO :DWORD,:DWORD
			      C     szRight     PROTO :DWORD,:DWORD,:DWORD
			      C     szRtrim     PROTO :DWORD,:DWORD
			      C     szTrim      PROTO :DWORD
			      C     szUpper     PROTO :DWORD
			      C     szWcnt      PROTO :DWORD,:DWORD
			      C 
			      C comment * ---------------------------------
			      C         the equates for the old names must
			      C         be put after the prototypes for the
			      C         procedures they are mapped to.
			      C         ----------------------------------- *
			      C 
 = szLen		      C     lnstr   equ <szLen>
 = szCmp		      C     cmpstr  equ <szCmp>
 = szCmpi		      C     cmpsi   equ <szCmpi>
 = szRev		      C     revstr  equ <szRev>
 = szLower		      C     lcase   equ <szLower>
 = szUpper		      C     ucase   equ <szUpper>
 = szLtrim		      C     ltrim   equ <szLtrim>
 = szRtrim		      C     rtrim   equ <szRtrim>
 = szTrim		      C     trim    equ <szTrim>
 = szLeft		      C     lstr    equ <szLeft>
 = szRight		      C     rstr    equ <szRight>
 = szMid		      C     midstr  equ <szMid>
			      C 
			      C ; ---------------------------------
			      C ; self contained "shell" procedures
			      C ; ---------------------------------
			      C shell       PROTO :DWORD                ; failsafe version
			      C shell_ex    PROTO :DWORD,:DWORD         ; version with priority control
			      C 
			      C StripRangeI PROTO :DWORD,:DWORD,:BYTE,:BYTE
			      C StripRangeX PROTO :DWORD,:DWORD,:BYTE,:BYTE
			      C 
			      C MemCopy PROTO :DWORD,:DWORD,:DWORD  ; source - dest - length
			      C memfill PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C GetAppPath   PROTO :DWORD           ; buffer has app path
			      C GetAppPathW  PROTO                  ; UNICODE version
			      C 
			      C NameFromPath PROTO :DWORD,:DWORD
			      C NameFromPathW PROTO :DWORD,:DWORD   ; UNICODE version
			      C 
			      C GetPathOnly  PROTO :DWORD,:DWORD
			      C GetPathOnlyW PROTO :DWORD,:DWORD    ; UNICODE version
			      C 
			      C exist       PROTO :DWORD
			      C existW      PROTO :DWORD            ; UNICODE version
			      C 
			      C filesize    PROTO :DWORD
			      C filesizeW   PROTO :DWORD            ; UNICODE version
			      C 
			      C FrameCtrl   PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C FrameWindow PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C FrameGrp    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C Frame3D PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C line    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C circle  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C DisplayBmp   PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DisplayIcon  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C VerticalTile PROTO :DWORD,:DWORD,:DWORD
			      C SetBMcolor   PROTO :DWORD,:DWORD
			      C 
			      C BmpButton    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C StdOut       PROTO :DWORD
			      C StdOutW      PROTO :DWORD           ; UNICODE version
			      C 
			      C StdErr       PROTO :DWORD
			      C StdErrW      PROTO :DWORD           ; UNICODE version
			      C 
			      C StdIn        PROTO :DWORD,:DWORD
			      C StdInW       PROTO :DWORD,:DWORD    ; UNICODE version
			      C 
			      C locate       PROTO :DWORD,:DWORD
			      C ClearScreen  PROTO
			      C StripLF      PROTO :DWORD
			      C wait_key     PROTO
			      C ret_key      PROTO
			      C 
			      C BrowseForFolder PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C FontDialog      PROTO :DWORD,:DWORD,:DWORD
			      C ColorDialog     PROTO :DWORD,:DWORD,:DWORD
			      C PageSetupDialog PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C PrintDialog     PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C Read_File_In    PROTO :DWORD,:DWORD
			      C ofCallBack      PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C Write_To_Disk   PROTO :DWORD,:DWORD
			      C sfCallBack      PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C RichEd1         PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C RichEd2         PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C GetPercent      PROTO :DWORD,:DWORD
			      C IntMul          PROTO :DWORD,:DWORD
			      C IntDiv          PROTO :DWORD,:DWORD
			      C IntSqrt         PROTO :DWORD
			      C 
			      C nrandom         PROTO :DWORD
			      C nseed           PROTO :DWORD
			      C 
			      C ; ---------------------------------
			      C ; prototypes for pre-built dialogs
			      C ; ---------------------------------
			      C GetTextInput    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C AboutBox        PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetFile         PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C LoadList        PROTO :DWORD,:DWORD
			      C IPtoString      PROTO :DWORD,:DWORD
			      C GetIP           PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C ; ----------------------------------------
			      C ; Ernie Murphy's image loading procedures
			      C ; ----------------------------------------
			      C comment * ---------------------------------------------------------------
			      C With functions BitmapFromMemory, BitmapFromFile and BitmapFromResource
			      C the statements :
			      C         invoke CoInitialize, NULL   ; at the beginning of the source code
			      C         invoke CoUninitialize       ; at the end of the source code
			      C should be included to initialize and uninitiaize COM
			      C         --------------------------------------------------------------- *
			      C BitmapFromFile          PROTO :DWORD
			      C BitmapFromMemory        PROTO :DWORD,:DWORD
			      C BitmapFromPicture       PROTO :DWORD
			      C BitmapFromResource      PROTO :DWORD,:DWORD
			      C 
			      C ; -------------------
			      C ; file IO procedures
			      C ; -------------------
			      C read_disk_file   PROTO :DWORD,:DWORD,:DWORD
			      C read_disk_fileW  PROTO :DWORD,:DWORD,:DWORD     ; UNICODE version
			      C 
			      C write_disk_file  PROTO :DWORD,:DWORD,:DWORD
			      C write_disk_fileW PROTO :DWORD,:DWORD,:DWORD     ; UNICODE version
			      C 
			      C ; ------------------------------
			      C ; memory mapped file procedures
			      C ; ------------------------------
			      C CloseMMF  PROTO :DWORD,:DWORD
			      C CreateMMF PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C ; ----------------
			      C ; sort procedures
			      C ; ----------------
			      C nrQsortA PROTO :DWORD,:DWORD
			      C nrQsortD PROTO :DWORD,:DWORD
			      C 
			      C CombSortA PROTO :DWORD,:DWORD
			      C CombSortD PROTO :DWORD,:DWORD
			      C 
			      C testreg PROTO
			      C 
			      C HexDump   PROTO :DWORD,:DWORD,:DWORD
			      C AsciiDump PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C ; ------------------------------------------
			      C ; ascii and 32 bit long integer conversions
			      C ; ------------------------------------------
			      C atol PROTO :DWORD
			      C ltoa PROTO :DWORD,:DWORD
			      C 
			      C ; ----------------------------
			      C ; File open and close dialogs
			      C ; ----------------------------
			      C OpenFileDialog PROTO :DWORD, :DWORD, :DWORD, :DWORD
			      C SaveFileDialog PROTO :DWORD, :DWORD, :DWORD, :DWORD
			      C 
			      C ; ------------------
			      C ; ascii to wide char
			      C ; ------------------
			      C a2wc        PROTO :DWORD
			      C 
			      C ; ---------------------------
			      C ; array arithmetic procedures
			      C ; ---------------------------
			      C arr_add PROTO :DWORD,:DWORD,:DWORD
			      C arr_mul PROTO :DWORD,:DWORD,:DWORD
			      C arr_sub PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C ; -------------------
			      C ; create dynamic aray
			      C ; -------------------
			      C create_array PROTO :DWORD,:DWORD
			      C 
			      C ; ----------------------------------------------------
			      C ; count all bytes in a file and write results to array
			      C ; ----------------------------------------------------
			      C byte_count  PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C ; -----------------------------------------------------
			      C ; load list box with formatted drive and volume strings
			      C ; -----------------------------------------------------
			      C load_drives PROTO :DWORD
			      C 
			      C   ; -------------------------------------
			      C   ; C style character testing procedures.
			      C   ; -------------------------------------
			      C     isalpha  PROTO :BYTE
			      C     isupper  PROTO :BYTE
			      C     islower  PROTO :BYTE
			      C     isnumber PROTO :BYTE
			      C     isalphanum PROTO :BYTE
			      C 
			      C   ; ---------------------------------
			      C   ; hybrid quick / cisort string sort
			      C   ; ---------------------------------
			      C     assort   PROTO :DWORD,:DWORD,:DWORD
			      C     dssort   PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C   ; --------------------------------------------------
			      C   ; high speed quick sort with recursion depth limiter
			      C   ; This algorithm is used by the above hybrid.
			      C   ; --------------------------------------------------
			      C     asqsort  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C     dsqsort  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C   ; -----------------------------------------------------
			      C   ; comb / insertion sort hybrid used by the above hybrid.
			      C   ; -----------------------------------------------------
			      C     acisort PROTO :DWORD,:DWORD
			      C     dcisort PROTO :DWORD,:DWORD
			      C 
			      C   ; -----------------------------------
			      C   ; insertion sort for the above hybrid
			      C   ; -----------------------------------
			      C     aissort PROTO :DWORD,:DWORD
			      C     dissort PROTO :DWORD,:DWORD
			      C                                                                                                         
			      C   ; ----------------------------------------------
			      C   ; high safety margin comb / cocktail shaker sort
			      C   ; ----------------------------------------------
			      C     ccsorta  PROTO :DWORD,:DWORD
			      C     ccsortd  PROTO :DWORD,:DWORD
			      C 
			      C   ; -----------------
			      C   ; Quick string sort
			      C   ; -----------------
			      C     qssorta  PROTO :DWORD,:DWORD,:DWORD
			      C     qssortd  PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C   ; -----------------
			      C   ; Shell string sort
			      C   ; -----------------
			      C     ssorta   PROTO :DWORD,:DWORD,:DWORD
			      C     ssortd   PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C   ; ----------------
			      C   ; Comb string sort
			      C   ; ----------------
			      C     cstsorta PROTO :DWORD,:DWORD
			      C     cstsortd PROTO :DWORD,:DWORD
			      C 
			      C   ; -----------------------
			      C   ; traditional bubble sort
			      C   ; -----------------------
			      C     bstsorta PROTO :DWORD,:DWORD,:DWORD
			      C     bstsortd PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C   ; -----------------------------------------------
			      C   ; read and write lines of text to and from memory
			      C   ; -----------------------------------------------
			      C     readline   PROTO :DWORD,:DWORD,:DWORD
			      C     writeline  PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     tstline    PROTO :DWORD
			      C     parse_line PROTO :DWORD,:DWORD
			      C     lfcnt      PROTO :DWORD
			      C 
			      C   ; -------------------------
			      C   ; UNICODE string procedures
			      C   ; -------------------------
			      C     ucappend  PROTO :DWORD,:DWORD,:DWORD
			      C     ucArgByNum PROTO :DWORD,:DWORD,:DWORD
			      C     ucCatStr  PROTO :DWORD,:DWORD
			      C     ucCopy    PROTO :DWORD,:DWORD
			      C     ucCmdTail PROTO
			      C     ucCmp     PROTO :DWORD,:DWORD
			      C     ucFind    PROTO :DWORD,:DWORD,:DWORD
			      C     ucGetCL   PROTO :DWORD,:DWORD,:DWORD
			      C     ucgetline PROTO :DWORD,:DWORD,:DWORD
			      C     ucLen     PROTO :DWORD
			      C     ucLeft    PROTO :DWORD,:DWORD,:DWORD
			      C     ucLtrim   PROTO :DWORD,:DWORD
			      C     ucMid     PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     ucMonoSpace PROTO :DWORD
			      C     ucRemove  PROTO :DWORD,:DWORD,:DWORD
			      C     ucRep     PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     ucRight   PROTO :DWORD,:DWORD,:DWORD
			      C     ucRtrim   PROTO :DWORD,:DWORD
			      C     ucLower   PROTO :DWORD
			      C     ucUpper   PROTO :DWORD
			      C     ucRev     PROTO :DWORD,:DWORD
			      C     ucMultiCat PROTO C :DWORD,:DWORD,:VARARG
			      C     ucWcnt    PROTO :DWORD,:DWORD
			      C 
			      C     ucOpenFileDialog PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     ucSaveFileDialog PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C   ; ------------------
			      C   ; whole word replace
			      C   ; ------------------
			      C     wordreplace PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C   ; ------------------------------
			      C   ; extended performance functions
			      C   ; ------------------------------
			      C     atodw_ex      PROTO :DWORD
			      C     byt2bin_ex    PROTO :BYTE,:DWORD
			      C     wrd2bin_ex    PROTO :WORD,:DWORD
			      C     dw2bin_ex     PROTO :DWORD,:DWORD
			      C     bin2byte_ex   PROTO :DWORD
			      C     dw2hex_ex     PROTO :DWORD,:DWORD
			      C     hexflip32     PROTO :DWORD
			      C 
			      C   ; -----------------------------------
			      C   ; high speed binary / hex conversions
			      C   ; -----------------------------------
			      C     bin2hex       PROTO :DWORD,:DWORD,:DWORD
			      C     hex2bin       PROTO :DWORD,:DWORD
			      C 
			      C   ; --------------------------
			      C   ; additional shell functions
			      C   ; --------------------------
			      C     wshell        PROTO :DWORD
			      C 
			      C   ; -------------------------------------
			      C   ; compare memory blocks of known length
			      C   ; -------------------------------------
			      C     cmpmem PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C   ; ---------------------------------------------------------
			      C   ; structure and prototype for running a synchronous process
			      C   ; ---------------------------------------------------------
 00000014		      C     RUN_SYNCH_PROCESS_EX STRUCT
 00000000  00000000	      C       priority dd ?       ; priority setting
 00000004  00000000	      C       timeout  dd ?       ; timeout interval
 00000008  00000000	      C       rvcreate dd ?       ; CreateProcess() return value
 0000000C  00000000	      C       exitcode dd ?       ; GetExitCodeProcess() exit code
 00000010  00000000	      C       rvwait   dd ?       ; WaitForSingleObjectEx() return value
			      C     RUN_SYNCH_PROCESS_EX ENDS
			      C 
			      C     run_synch_process_ex PROTO :DWORD,:DWORD
			      C 
			      C   ; -----------------------------------------------
			      C   ; return the font handle from a CreateFont() call
			      C   ; -----------------------------------------------
			      C     RetFontHandle PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C     ArgByNumber PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     get_ml      PROTO :DWORD,:DWORD,:DWORD
			      C     decomment   PROTO :DWORD
			      C 
			      C   ; ---------------
			      C   ; text tokenisers
			      C   ; ---------------
			      C     ltok PROTO :DWORD,:DWORD
			      C     wtok PROTO :DWORD,:DWORD
			      C 
			      C   ; --------------------
			      C   ; clipboard text algos
			      C   ; --------------------
			      C     GetClipboardText PROTO
			      C     SetClipboardText PROTO :DWORD
			      C 
			      C   ; *****************************
			      C   ; prototypes for dynamic arrays
			      C   ; *****************************
			      C     arralloc  PROTO :DWORD
			      C     arrealloc PROTO :DWORD,:DWORD
			      C     arrfree   PROTO :DWORD
			      C     arrset    PROTO :DWORD,:DWORD,:DWORD
			      C     arrget    PROTO :DWORD,:DWORD
			      C     arrcnt    PROTO :DWORD
			      C     arrlen    PROTO :DWORD,:DWORD
			      C     arrtrunc  PROTO :DWORD,:DWORD
			      C     arrextnd  PROTO :DWORD,:DWORD
			      C     arrtotal  PROTO :DWORD,:DWORD
			      C     arr2file  PROTO :DWORD,:DWORD
			      C     arr2mem   PROTO :DWORD,:DWORD
			      C     arr2text  PROTO :DWORD,:DWORD
			      C     arrtxt    PROTO :DWORD
			      C     arrfile   PROTO :DWORD
			      C     arrbin    PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C ELSE
			      C ENDIF
			      C 
					  include \masm32\include\user32.inc
			      C ; --------------------------------------------------------------------------------------------------
			      C ;                           user32.inc Copyright The MASM32 SDK 1998-2010
			      C ; --------------------------------------------------------------------------------------------------
			      C 
			      C IFNDEF USER32_INC
 = 1			      C USER32_INC equ <1>
			      C 
			      C ActivateKeyboardLayout PROTO STDCALL :DWORD,:DWORD
			      C AdjustWindowRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C AdjustWindowRectEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C AllowSetForegroundWindow PROTO STDCALL :DWORD
			      C AnimateWindow PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C AnyPopup PROTO STDCALL
			      C 
			      C AppendMenuA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = AppendMenuA		      C   AppendMenu equ <AppendMenuA>
			      C ENDIF
			      C 
			      C AppendMenuW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ArrangeIconicWindows PROTO STDCALL :DWORD
			      C AttachThreadInput PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C BeginDeferWindowPos PROTO STDCALL :DWORD
			      C BeginPaint PROTO STDCALL :DWORD,:DWORD
			      C BlockInput PROTO STDCALL :DWORD
			      C BringWindowToTop PROTO STDCALL :DWORD
			      C 
			      C BroadcastSystemMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = BroadcastSystemMessageA    C   BroadcastSystemMessage equ <BroadcastSystemMessageA>
			      C ENDIF
			      C 
			      C BroadcastSystemMessageExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = BroadcastSystemMessageEx   C   BroadcastSystemMessageEx equ <BroadcastSystemMessageExA>
   A
			      C ENDIF
			      C 
			      C BroadcastSystemMessageExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C BroadcastSystemMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C CallMsgFilterA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CallMsgFilterA	      C   CallMsgFilter equ <CallMsgFilterA>
			      C ENDIF
			      C 
			      C CallMsgFilterW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CallNextHookEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CallWindowProcA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CallWindowProcA	      C   CallWindowProc equ <CallWindowProcA>
			      C ENDIF
			      C 
			      C CallWindowProcW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CascadeChildWindows PROTO STDCALL :DWORD,:DWORD
			      C CascadeWindows PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ChangeClipboardChain PROTO STDCALL :DWORD,:DWORD
			      C 
			      C ChangeDisplaySettingsA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ChangeDisplaySettingsA     C   ChangeDisplaySettings equ <ChangeDisplaySettingsA>
			      C ENDIF
			      C 
			      C ChangeDisplaySettingsExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ChangeDisplaySettingsExA   C   ChangeDisplaySettingsEx equ <ChangeDisplaySettingsExA>
			      C ENDIF
			      C 
			      C ChangeDisplaySettingsExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ChangeDisplaySettingsW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ChangeMenuA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ChangeMenuA		      C   ChangeMenu equ <ChangeMenuA>
			      C ENDIF
			      C 
			      C ChangeMenuW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharLowerA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = CharLowerA		      C   CharLower equ <CharLowerA>
			      C ENDIF
			      C 
			      C CharLowerBuffA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CharLowerBuffA	      C   CharLowerBuff equ <CharLowerBuffA>
			      C ENDIF
			      C 
			      C CharLowerBuffW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharLowerW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharNextA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = CharNextA		      C   CharNext equ <CharNextA>
			      C ENDIF
			      C 
			      C CharNextExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CharNextExA		      C   CharNextEx equ <CharNextExA>
			      C ENDIF
			      C 
			      C CharNextW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharPrevA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CharPrevA		      C   CharPrev equ <CharPrevA>
			      C ENDIF
			      C 
			      C CharPrevExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CharPrevExA		      C   CharPrevEx equ <CharPrevExA>
			      C ENDIF
			      C 
			      C CharPrevW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharToOemA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CharToOemA		      C   CharToOem equ <CharToOemA>
			      C ENDIF
			      C 
			      C CharToOemBuffA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CharToOemBuffA	      C   CharToOemBuff equ <CharToOemBuffA>
			      C ENDIF
			      C 
			      C CharToOemBuffW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharToOemW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharUpperA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = CharUpperA		      C   CharUpper equ <CharUpperA>
			      C ENDIF
			      C 
			      C CharUpperBuffA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CharUpperBuffA	      C   CharUpperBuff equ <CharUpperBuffA>
			      C ENDIF
			      C 
			      C CharUpperBuffW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CharUpperW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CheckDlgButton PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C CheckMenuItem PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C CheckMenuRadioItem PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CheckRadioButton PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C ChildWindowFromPoint PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C ChildWindowFromPointEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C ClientToScreen PROTO STDCALL :DWORD,:DWORD
			      C ClipCursor PROTO STDCALL :DWORD
			      C CloseClipboard PROTO STDCALL
			      C CloseDesktop PROTO STDCALL :DWORD
			      C CloseWindow PROTO STDCALL :DWORD
			      C CloseWindowStation PROTO STDCALL :DWORD
			      C 
			      C CopyAcceleratorTableA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CopyAcceleratorTableA      C   CopyAcceleratorTable equ <CopyAcceleratorTableA>
			      C ENDIF
			      C 
			      C CopyAcceleratorTableW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CopyIcon PROTO STDCALL :DWORD
			      C CopyImage PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CopyRect PROTO STDCALL :DWORD,:DWORD
			      C CountClipboardFormats PROTO STDCALL
			      C 
			      C CreateAcceleratorTableA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateAcceleratorTableA    C   CreateAcceleratorTable equ <CreateAcceleratorTableA>
			      C ENDIF
			      C 
			      C CreateAcceleratorTableW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateCaret PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateCursor PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CreateDesktopA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateDesktopA	      C   CreateDesktop equ <CreateDesktopA>
			      C ENDIF
			      C 
			      C CreateDesktopW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateDialogIndirectParamA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateDialogIndirectPara   C   CreateDialogIndirectParam equ <CreateDialogIndirectParamA>
   mA
			      C ENDIF
			      C 
			      C CreateDialogIndirectParamW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateDialogParamA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateDialogParamA	      C   CreateDialogParam equ <CreateDialogParamA>
			      C ENDIF
			      C 
			      C CreateDialogParamW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateIcon PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateIconFromResource PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateIconFromResourceEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateIconIndirect PROTO STDCALL :DWORD
			      C 
			      C CreateMDIWindowA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateMDIWindowA	      C   CreateMDIWindow equ <CreateMDIWindowA>
			      C ENDIF
			      C 
			      C CreateMDIWindowW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateMenu PROTO STDCALL
			      C CreatePopupMenu PROTO STDCALL
			      C 
			      C CreateWindowExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateWindowExA	      C   CreateWindowEx equ <CreateWindowExA>
			      C ENDIF
			      C 
			      C CreateWindowExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateWindowStationA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateWindowStationA	      C   CreateWindowStation equ <CreateWindowStationA>
			      C ENDIF
			      C 
			      C CreateWindowStationW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DbgWin32HeapFail PROTO STDCALL :DWORD,:DWORD
			      C DbgWin32HeapStat PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DdeAbandonTransaction PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DdeAccessData PROTO STDCALL :DWORD,:DWORD
			      C DdeAddData PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DdeClientTransaction PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DdeCmpStringHandles PROTO STDCALL :DWORD,:DWORD
			      C DdeConnect PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DdeConnectList PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DdeCreateDataHandle PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C DdeCreateStringHandleA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DdeCreateStringHandleA     C   DdeCreateStringHandle equ <DdeCreateStringHandleA>
			      C ENDIF
			      C 
			      C DdeCreateStringHandleW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DdeDisconnect PROTO STDCALL :DWORD
			      C DdeDisconnectList PROTO STDCALL :DWORD
			      C DdeEnableCallback PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DdeFreeDataHandle PROTO STDCALL :DWORD
			      C DdeFreeStringHandle PROTO STDCALL :DWORD,:DWORD
			      C DdeGetData PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DdeGetLastError PROTO STDCALL :DWORD
			      C DdeImpersonateClient PROTO STDCALL :DWORD
			      C 
			      C DdeInitializeA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DdeInitializeA	      C   DdeInitialize equ <DdeInitializeA>
			      C ENDIF
			      C 
			      C DdeInitializeW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DdeKeepStringHandle PROTO STDCALL :DWORD,:DWORD
			      C DdeNameService PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DdePostAdvise PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DdeQueryConvInfo PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DdeQueryNextServer PROTO STDCALL :DWORD,:DWORD
			      C 
			      C DdeQueryStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DdeQueryStringA	      C   DdeQueryString equ <DdeQueryStringA>
			      C ENDIF
			      C 
			      C DdeQueryStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DdeReconnect PROTO STDCALL :DWORD
			      C DdeSetQualityOfService PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DdeSetUserHandle PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DdeUnaccessData PROTO STDCALL :DWORD
			      C DdeUninitialize PROTO STDCALL :DWORD
			      C 
			      C DefDlgProcA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DefDlgProcA		      C   DefDlgProc equ <DefDlgProcA>
			      C ENDIF
			      C 
			      C DefDlgProcW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DefFrameProcA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DefFrameProcA	      C   DefFrameProc equ <DefFrameProcA>
			      C ENDIF
			      C 
			      C DefFrameProcW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DefMDIChildProcA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DefMDIChildProcA	      C   DefMDIChildProc equ <DefMDIChildProcA>
			      C ENDIF
			      C 
			      C DefMDIChildProcW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DefRawInputProc PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C DefWindowProcA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DefWindowProcA	      C   DefWindowProc equ <DefWindowProcA>
			      C ENDIF
			      C 
			      C DefWindowProcW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DeferWindowPos PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DeleteMenu PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DeregisterShellHookWindow PROTO STDCALL :DWORD
			      C DestroyAcceleratorTable PROTO STDCALL :DWORD
			      C DestroyCaret PROTO STDCALL
			      C DestroyCursor PROTO STDCALL :DWORD
			      C DestroyIcon PROTO STDCALL :DWORD
			      C DestroyMenu PROTO STDCALL :DWORD
			      C DestroyWindow PROTO STDCALL :DWORD
			      C 
			      C DialogBoxIndirectParamA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DialogBoxIndirectParamA    C   DialogBoxIndirectParam equ <DialogBoxIndirectParamA>
			      C ENDIF
			      C 
			      C DialogBoxIndirectParamW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DialogBoxParamA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DialogBoxParamA	      C   DialogBoxParam equ <DialogBoxParamA>
			      C ENDIF
			      C 
			      C DialogBoxParamW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DisableProcessWindowsGhosting PROTO STDCALL
			      C 
			      C DispatchMessageA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = DispatchMessageA	      C   DispatchMessage equ <DispatchMessageA>
			      C ENDIF
			      C 
			      C DispatchMessageW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DlgDirListA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DlgDirListA		      C   DlgDirList equ <DlgDirListA>
			      C ENDIF
			      C 
			      C DlgDirListComboBoxA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DlgDirListComboBoxA	      C   DlgDirListComboBox equ <DlgDirListComboBoxA>
			      C ENDIF
			      C 
			      C DlgDirListComboBoxW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DlgDirListW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DlgDirSelectComboBoxExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DlgDirSelectComboBoxExA    C   DlgDirSelectComboBoxEx equ <DlgDirSelectComboBoxExA>
			      C ENDIF
			      C 
			      C DlgDirSelectComboBoxExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DlgDirSelectExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DlgDirSelectExA	      C   DlgDirSelectEx equ <DlgDirSelectExA>
			      C ENDIF
			      C 
			      C DlgDirSelectExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DragDetect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DragObject PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DrawAnimatedRects PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DrawCaption PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DrawEdge PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DrawFocusRect PROTO STDCALL :DWORD,:DWORD
			      C DrawFrame PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DrawFrameControl PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DrawIcon PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C DrawIconEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DrawMenuBar PROTO STDCALL :DWORD
			      C 
			      C DrawStateA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DrawStateA		      C   DrawState equ <DrawStateA>
			      C ENDIF
			      C 
			      C DrawStateW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DrawTextA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DrawTextA		      C   DrawText equ <DrawTextA>
			      C ENDIF
			      C 
			      C DrawTextExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DrawTextExA		      C   DrawTextEx equ <DrawTextExA>
			      C ENDIF
			      C 
			      C DrawTextExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DrawTextW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EditWndProc PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C EmptyClipboard PROTO STDCALL
			      C EnableMenuItem PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C EnableScrollBar PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C EnableWindow PROTO STDCALL :DWORD,:DWORD
			      C EndDeferWindowPos PROTO STDCALL :DWORD
			      C EndDialog PROTO STDCALL :DWORD,:DWORD
			      C EndMenu PROTO STDCALL
			      C EndPaint PROTO STDCALL :DWORD,:DWORD
			      C EndTask PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C EnumChildWindows PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C EnumClipboardFormats PROTO STDCALL :DWORD
			      C EnumDesktopWindows PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C EnumDesktopsA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumDesktopsA	      C   EnumDesktops equ <EnumDesktopsA>
			      C ENDIF
			      C 
			      C EnumDesktopsW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumDisplayDevicesA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumDisplayDevicesA	      C   EnumDisplayDevices equ <EnumDisplayDevicesA>
			      C ENDIF
			      C 
			      C EnumDisplayDevicesW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumDisplayMonitors PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C EnumDisplaySettingsA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumDisplaySettingsA	      C   EnumDisplaySettings equ <EnumDisplaySettingsA>
			      C ENDIF
			      C 
			      C EnumDisplaySettingsExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumDisplaySettingsExA     C   EnumDisplaySettingsEx equ <EnumDisplaySettingsExA>
			      C ENDIF
			      C 
			      C EnumDisplaySettingsExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumDisplaySettingsW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumPropsA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumPropsA		      C   EnumProps equ <EnumPropsA>
			      C ENDIF
			      C 
			      C EnumPropsExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumPropsExA		      C   EnumPropsEx equ <EnumPropsExA>
			      C ENDIF
			      C 
			      C EnumPropsExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumPropsW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumThreadWindows PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C EnumWindowStationsA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumWindowStationsA	      C   EnumWindowStations equ <EnumWindowStationsA>
			      C ENDIF
			      C 
			      C EnumWindowStationsW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumWindows PROTO STDCALL :DWORD,:DWORD
			      C EqualRect PROTO STDCALL :DWORD,:DWORD
			      C ExcludeUpdateRgn PROTO STDCALL :DWORD,:DWORD
			      C ExitWindowsEx PROTO STDCALL :DWORD,:DWORD
			      C FillRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C FindWindowA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindWindowA		      C   FindWindow equ <FindWindowA>
			      C ENDIF
			      C 
			      C FindWindowExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindWindowExA	      C   FindWindowEx equ <FindWindowExA>
			      C ENDIF
			      C 
			      C FindWindowExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindWindowW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FlashWindow PROTO STDCALL :DWORD,:DWORD
			      C FlashWindowEx PROTO STDCALL :DWORD
			      C FrameRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C FreeDDElParam PROTO STDCALL :DWORD,:DWORD
			      C GetActiveWindow PROTO STDCALL
			      C 
			      C GetAltTabInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetAltTabInfoA	      C   GetAltTabInfo equ <GetAltTabInfoA>
			      C ENDIF
			      C 
			      C GetAltTabInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetAncestor PROTO STDCALL :DWORD,:DWORD
			      C GetAsyncKeyState PROTO STDCALL :DWORD
			      C GetCapture PROTO STDCALL
			      C GetCaretBlinkTime PROTO STDCALL
			      C GetCaretPos PROTO STDCALL :DWORD
			      C 
			      C GetClassInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetClassInfoA	      C   GetClassInfo equ <GetClassInfoA>
			      C ENDIF
			      C 
			      C GetClassInfoExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetClassInfoExA	      C   GetClassInfoEx equ <GetClassInfoExA>
			      C ENDIF
			      C 
			      C GetClassInfoExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetClassInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetClassLongA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetClassLongA	      C   GetClassLong equ <GetClassLongA>
			      C ENDIF
			      C 
			      C GetClassLongW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetClassNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetClassNameA	      C   GetClassName equ <GetClassNameA>
			      C ENDIF
			      C 
			      C GetClassNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetClassWord PROTO STDCALL :DWORD,:DWORD
			      C GetClientRect PROTO STDCALL :DWORD,:DWORD
			      C GetClipCursor PROTO STDCALL :DWORD
			      C GetClipboardData PROTO STDCALL :DWORD
			      C 
			      C GetClipboardFormatNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetClipboardFormatNameA    C   GetClipboardFormatName equ <GetClipboardFormatNameA>
			      C ENDIF
			      C 
			      C GetClipboardFormatNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetClipboardOwner PROTO STDCALL
			      C GetClipboardSequenceNumber PROTO STDCALL
			      C GetClipboardViewer PROTO STDCALL
			      C GetComboBoxInfo PROTO STDCALL :DWORD,:DWORD
			      C GetCursor PROTO STDCALL
			      C GetCursorInfo PROTO STDCALL :DWORD
			      C GetCursorPos PROTO STDCALL :DWORD
			      C GetDC PROTO STDCALL :DWORD
			      C GetDCEx PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetDesktopWindow PROTO STDCALL
			      C GetDialogBaseUnits PROTO STDCALL
			      C GetDlgCtrlID PROTO STDCALL :DWORD
			      C GetDlgItem PROTO STDCALL :DWORD,:DWORD
			      C GetDlgItemInt PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C GetDlgItemTextA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetDlgItemTextA	      C   GetDlgItemText equ <GetDlgItemTextA>
			      C ENDIF
			      C 
			      C GetDlgItemTextW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetDoubleClickTime PROTO STDCALL
			      C GetFocus PROTO STDCALL
			      C GetForegroundWindow PROTO STDCALL
			      C GetGUIThreadInfo PROTO STDCALL :DWORD,:DWORD
			      C GetGuiResources PROTO STDCALL :DWORD,:DWORD
			      C GetIconInfo PROTO STDCALL :DWORD,:DWORD
			      C GetInputDesktop PROTO STDCALL
			      C GetInputState PROTO STDCALL
			      C GetKBCodePage PROTO STDCALL
			      C 
			      C GetKeyNameTextA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetKeyNameTextA	      C   GetKeyNameText equ <GetKeyNameTextA>
			      C ENDIF
			      C 
			      C GetKeyNameTextW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetKeyState PROTO STDCALL :DWORD
			      C GetKeyboardLayout PROTO STDCALL :DWORD
			      C GetKeyboardLayoutList PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetKeyboardLayoutNameA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GetKeyboardLayoutNameA     C   GetKeyboardLayoutName equ <GetKeyboardLayoutNameA>
			      C ENDIF
			      C 
			      C GetKeyboardLayoutNameW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetKeyboardState PROTO STDCALL :DWORD
			      C GetKeyboardType PROTO STDCALL :DWORD
			      C GetLastActivePopup PROTO STDCALL :DWORD
			      C GetLastInputInfo PROTO STDCALL :DWORD
			      C GetLayeredWindowAttributes PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C GetListBoxInfo PROTO STDCALL :DWORD
			      C GetMenu PROTO STDCALL :DWORD
			      C GetMenuBarInfo PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C GetMenuCheckMarkDimensions PROTO STDCALL
			      C GetMenuContextHelpId PROTO STDCALL :DWORD
			      C GetMenuDefaultItem PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetMenuInfo PROTO STDCALL :DWORD,:DWORD
			      C GetMenuItemCount PROTO STDCALL :DWORD
			      C GetMenuItemID PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetMenuItemInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetMenuItemInfoA	      C   GetMenuItemInfo equ <GetMenuItemInfoA>
			      C ENDIF
			      C 
			      C GetMenuItemInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetMenuItemRect PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C GetMenuState PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C GetMenuStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetMenuStringA	      C   GetMenuString equ <GetMenuStringA>
			      C ENDIF
			      C 
			      C GetMenuStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetMessageA		      C   GetMessage equ <GetMessageA>
			      C ENDIF
			      C 
			      C GetMessageExtraInfo PROTO STDCALL
			      C GetMessagePos PROTO STDCALL
			      C GetMessageTime PROTO STDCALL
			      C 
			      C GetMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetMonitorInfoA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetMonitorInfoA	      C   GetMonitorInfo equ <GetMonitorInfoA>
			      C ENDIF
			      C 
			      C GetMonitorInfoW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetMouseMovePointsEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetNextDlgGroupItem PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetNextDlgTabItem PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetOpenClipboardWindow PROTO STDCALL
			      C GetParent PROTO STDCALL :DWORD
			      C GetPriorityClipboardFormat PROTO STDCALL :DWORD,:DWORD
			      C GetProcessDefaultLayout PROTO STDCALL :DWORD
			      C GetProcessWindowStation PROTO STDCALL
			      C 
			      C GetPropA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetPropA		      C   GetProp equ <GetPropA>
			      C ENDIF
			      C 
			      C GetPropW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetQueueStatus PROTO STDCALL :DWORD
			      C GetRawInputBuffer PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetRawInputData PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C GetRawInputDeviceInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetRawInputDeviceInfoA     C   GetRawInputDeviceInfo equ <GetRawInputDeviceInfoA>
			      C ENDIF
			      C 
			      C GetRawInputDeviceInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetRawInputDeviceList PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetRegisteredRawInputDevices PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetScrollBarInfo PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetScrollInfo PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetScrollPos PROTO STDCALL :DWORD,:DWORD
			      C GetScrollRange PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C GetShellWindow PROTO STDCALL
			      C GetSubMenu PROTO STDCALL :DWORD,:DWORD
			      C GetSysColor PROTO STDCALL :DWORD
			      C GetSysColorBrush PROTO STDCALL :DWORD
			      C GetSystemMenu PROTO STDCALL :DWORD,:DWORD
			      C GetSystemMetrics PROTO STDCALL :DWORD
			      C 
			      C GetTabbedTextExtentA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetTabbedTextExtentA	      C   GetTabbedTextExtent equ <GetTabbedTextExtentA>
			      C ENDIF
			      C 
			      C GetTabbedTextExtentW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetThreadDesktop PROTO STDCALL :DWORD
			      C GetTitleBarInfo PROTO STDCALL :DWORD,:DWORD
			      C GetTopWindow PROTO STDCALL :DWORD
			      C GetUpdateRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetUpdateRgn PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C GetUserObjectInformationA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetUserObjectInformation   C   GetUserObjectInformation equ <GetUserObjectInformationA>
   A
			      C ENDIF
			      C 
			      C GetUserObjectInformationW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetUserObjectSecurity PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetWindow PROTO STDCALL :DWORD,:DWORD
			      C GetWindowContextHelpId PROTO STDCALL :DWORD
			      C GetWindowDC PROTO STDCALL :DWORD
			      C GetWindowInfo PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetWindowLongA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetWindowLongA	      C   GetWindowLong equ <GetWindowLongA>
			      C ENDIF
			      C 
			      C GetWindowLongW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C GetWindowModuleFileNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetWindowModuleFileNameA   C   GetWindowModuleFileName equ <GetWindowModuleFileNameA>
			      C ENDIF
			      C 
			      C GetWindowModuleFileNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetWindowPlacement PROTO STDCALL :DWORD,:DWORD
			      C GetWindowRect PROTO STDCALL :DWORD,:DWORD
			      C GetWindowRgn PROTO STDCALL :DWORD,:DWORD
			      C GetWindowRgnBox PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetWindowTextA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetWindowTextA	      C   GetWindowText equ <GetWindowTextA>
			      C ENDIF
			      C 
			      C GetWindowTextLengthA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GetWindowTextLengthA	      C   GetWindowTextLength equ <GetWindowTextLengthA>
			      C ENDIF
			      C 
			      C GetWindowTextLengthW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetWindowTextW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetWindowThreadProcessId PROTO STDCALL :DWORD,:DWORD
			      C GetWindowWord PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GrayStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GrayStringA		      C   GrayString equ <GrayStringA>
			      C ENDIF
			      C 
			      C GrayStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C HideCaret PROTO STDCALL :DWORD
			      C HiliteMenuItem PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C IMPGetIMEA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = IMPGetIMEA		      C   IMPGetIME equ <IMPGetIMEA>
			      C ENDIF
			      C 
			      C IMPGetIMEW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IMPQueryIMEA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = IMPQueryIMEA		      C   IMPQueryIME equ <IMPQueryIMEA>
			      C ENDIF
			      C 
			      C IMPQueryIMEW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IMPSetIMEA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = IMPSetIMEA		      C   IMPSetIME equ <IMPSetIMEA>
			      C ENDIF
			      C 
			      C IMPSetIMEW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ImpersonateDdeClientWindow PROTO STDCALL :DWORD,:DWORD
			      C InSendMessage PROTO STDCALL
			      C InSendMessageEx PROTO STDCALL :DWORD
			      C InflateRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C InsertMenuA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = InsertMenuA		      C   InsertMenu equ <InsertMenuA>
			      C ENDIF
			      C 
			      C InsertMenuItemA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = InsertMenuItemA	      C   InsertMenuItem equ <InsertMenuItemA>
			      C ENDIF
			      C 
			      C InsertMenuItemW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C InsertMenuW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C InternalGetWindowText PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IntersectRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C InvalidateRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C InvalidateRgn PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C InvertRect PROTO STDCALL :DWORD,:DWORD
			      C 
			      C IsCharAlphaA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = IsCharAlphaA		      C   IsCharAlpha equ <IsCharAlphaA>
			      C ENDIF
			      C 
			      C IsCharAlphaNumericA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = IsCharAlphaNumericA	      C   IsCharAlphaNumeric equ <IsCharAlphaNumericA>
			      C ENDIF
			      C 
			      C IsCharAlphaNumericW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IsCharAlphaW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IsCharLowerA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = IsCharLowerA		      C   IsCharLower equ <IsCharLowerA>
			      C ENDIF
			      C 
			      C IsCharLowerW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IsCharUpperA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = IsCharUpperA		      C   IsCharUpper equ <IsCharUpperA>
			      C ENDIF
			      C 
			      C IsCharUpperW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IsChild PROTO STDCALL :DWORD,:DWORD
			      C IsClipboardFormatAvailable PROTO STDCALL :DWORD
			      C 
			      C IsDialogMessageA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = IsDialogMessageA	      C   IsDialogMessage equ <IsDialogMessageA>
			      C ENDIF
			      C 
			      C IsDialogMessageW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IsDlgButtonChecked PROTO STDCALL :DWORD,:DWORD
			      C IsGUIThread PROTO STDCALL :DWORD
			      C IsHungAppWindow PROTO STDCALL :DWORD
			      C IsIconic PROTO STDCALL :DWORD
			      C IsMenu PROTO STDCALL :DWORD
			      C IsRectEmpty PROTO STDCALL :DWORD
			      C IsWinEventHookInstalled PROTO STDCALL :DWORD
			      C IsWindow PROTO STDCALL :DWORD
			      C IsWindowEnabled PROTO STDCALL :DWORD
			      C IsWindowUnicode PROTO STDCALL :DWORD
			      C IsWindowVisible PROTO STDCALL :DWORD
			      C IsZoomed PROTO STDCALL :DWORD
			      C KillTimer PROTO STDCALL :DWORD,:DWORD
			      C 
			      C LoadAcceleratorsA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadAcceleratorsA	      C   LoadAccelerators equ <LoadAcceleratorsA>
			      C ENDIF
			      C 
			      C LoadAcceleratorsW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadBitmapA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadBitmapA		      C   LoadBitmap equ <LoadBitmapA>
			      C ENDIF
			      C 
			      C LoadBitmapW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadCursorA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadCursorA		      C   LoadCursor equ <LoadCursorA>
			      C ENDIF
			      C 
			      C LoadCursorFromFileA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = LoadCursorFromFileA	      C   LoadCursorFromFile equ <LoadCursorFromFileA>
			      C ENDIF
			      C 
			      C LoadCursorFromFileW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadCursorW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadIconA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadIconA		      C   LoadIcon equ <LoadIconA>
			      C ENDIF
			      C 
			      C LoadIconW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadImageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadImageA		      C   LoadImage equ <LoadImageA>
			      C ENDIF
			      C 
			      C LoadImageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadKeyboardLayoutA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadKeyboardLayoutA	      C   LoadKeyboardLayout equ <LoadKeyboardLayoutA>
			      C ENDIF
			      C 
			      C LoadKeyboardLayoutW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadMenuA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadMenuA		      C   LoadMenu equ <LoadMenuA>
			      C ENDIF
			      C 
			      C LoadMenuIndirectA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = LoadMenuIndirectA	      C   LoadMenuIndirect equ <LoadMenuIndirectA>
			      C ENDIF
			      C 
			      C LoadMenuIndirectW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadMenuW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadStringA		      C   LoadString equ <LoadStringA>
			      C ENDIF
			      C 
			      C LoadStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LockSetForegroundWindow PROTO STDCALL :DWORD
			      C LockWindowUpdate PROTO STDCALL :DWORD
			      C LockWorkStation PROTO STDCALL
			      C LookupIconIdFromDirectory PROTO STDCALL :DWORD,:DWORD
			      C LookupIconIdFromDirectoryEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C MapDialogRect PROTO STDCALL :DWORD,:DWORD
			      C 
			      C MapVirtualKeyA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MapVirtualKeyA	      C   MapVirtualKey equ <MapVirtualKeyA>
			      C ENDIF
			      C 
			      C MapVirtualKeyExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MapVirtualKeyExA	      C   MapVirtualKeyEx equ <MapVirtualKeyExA>
			      C ENDIF
			      C 
			      C MapVirtualKeyExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MapVirtualKeyW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MapWindowPoints PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C MenuItemFromPoint PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C MessageBeep PROTO STDCALL :DWORD
			      C 
			      C MessageBoxA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MessageBoxA		      C   MessageBox equ <MessageBoxA>
			      C ENDIF
			      C 
			      C MessageBoxExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MessageBoxExA	      C   MessageBoxEx equ <MessageBoxExA>
			      C ENDIF
			      C 
			      C MessageBoxExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MessageBoxIndirectA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = MessageBoxIndirectA	      C   MessageBoxIndirect equ <MessageBoxIndirectA>
			      C ENDIF
			      C 
			      C MessageBoxIndirectW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MessageBoxTimeoutA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MessageBoxTimeoutA	      C   MessageBoxTimeout equ <MessageBoxTimeoutA>
			      C ENDIF
			      C 
			      C MessageBoxTimeoutW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MessageBoxW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ModifyMenuA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ModifyMenuA		      C   ModifyMenu equ <ModifyMenuA>
			      C ENDIF
			      C 
			      C ModifyMenuW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MonitorFromPoint PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C MonitorFromRect PROTO STDCALL :DWORD,:DWORD
			      C MonitorFromWindow PROTO STDCALL :DWORD,:DWORD
			      C MoveWindow PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C MsgWaitForMultipleObjects PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C MsgWaitForMultipleObjectsEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C NotifyWinEvent PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C OemKeyScan PROTO STDCALL :DWORD
			      C 
			      C OemToCharA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OemToCharA		      C   OemToChar equ <OemToCharA>
			      C ENDIF
			      C 
			      C OemToCharBuffA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OemToCharBuffA	      C   OemToCharBuff equ <OemToCharBuffA>
			      C ENDIF
			      C 
			      C OemToCharBuffW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OemToCharW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OffsetRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C OpenClipboard PROTO STDCALL :DWORD
			      C 
			      C OpenDesktopA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenDesktopA		      C   OpenDesktop equ <OpenDesktopA>
			      C ENDIF
			      C 
			      C OpenDesktopW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OpenIcon PROTO STDCALL :DWORD
			      C OpenInputDesktop PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C OpenWindowStationA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenWindowStationA	      C   OpenWindowStation equ <OpenWindowStationA>
			      C ENDIF
			      C 
			      C OpenWindowStationW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C PackDDElParam PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C PaintDesktop PROTO STDCALL :DWORD
			      C 
			      C PeekMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = PeekMessageA		      C   PeekMessage equ <PeekMessageA>
			      C ENDIF
			      C 
			      C PeekMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C PostMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = PostMessageA		      C   PostMessage equ <PostMessageA>
			      C ENDIF
			      C 
			      C PostMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C PostQuitMessage PROTO STDCALL :DWORD
			      C 
			      C PostThreadMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = PostThreadMessageA	      C   PostThreadMessage equ <PostThreadMessageA>
			      C ENDIF
			      C 
			      C PostThreadMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C PrintWindow PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C PrivateExtractIconsA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = PrivateExtractIconsA	      C   PrivateExtractIcons equ <PrivateExtractIconsA>
			      C ENDIF
			      C 
			      C PrivateExtractIconsW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C PtInRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C RealChildWindowFromPoint PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C RealGetWindowClassA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = RealGetWindowClassA	      C   RealGetWindowClass equ <RealGetWindowClassA>
			      C ENDIF
			      C 
			      C RealGetWindowClassW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RedrawWindow PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C RegisterClassA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = RegisterClassA	      C   RegisterClass equ <RegisterClassA>
			      C ENDIF
			      C 
			      C RegisterClassExA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = RegisterClassExA	      C   RegisterClassEx equ <RegisterClassExA>
			      C ENDIF
			      C 
			      C RegisterClassExW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RegisterClassW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RegisterClipboardFormatA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = RegisterClipboardFormatA   C   RegisterClipboardFormat equ <RegisterClipboardFormatA>
			      C ENDIF
			      C 
			      C RegisterClipboardFormatW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RegisterDeviceNotificationA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = RegisterDeviceNotificati   C   RegisterDeviceNotification equ <RegisterDeviceNotificationA>
   onA
			      C ENDIF
			      C 
			      C RegisterDeviceNotificationW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RegisterHotKey PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C RegisterRawInputDevices PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C RegisterShellHookWindow PROTO STDCALL :DWORD
			      C 
			      C RegisterWindowMessageA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = RegisterWindowMessageA     C   RegisterWindowMessage equ <RegisterWindowMessageA>
			      C ENDIF
			      C 
			      C RegisterWindowMessageW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ReleaseCapture PROTO STDCALL
			      C ReleaseDC PROTO STDCALL :DWORD,:DWORD
			      C RemoveMenu PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C RemovePropA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = RemovePropA		      C   RemoveProp equ <RemovePropA>
			      C ENDIF
			      C 
			      C RemovePropW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ReplyMessage PROTO STDCALL :DWORD
			      C ReuseDDElParam PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ScreenToClient PROTO STDCALL :DWORD,:DWORD
			      C ScrollDC PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ScrollWindow PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ScrollWindowEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C SendDlgItemMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SendDlgItemMessageA	      C   SendDlgItemMessage equ <SendDlgItemMessageA>
			      C ENDIF
			      C 
			      C SendDlgItemMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SendIMEMessageExA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SendIMEMessageExA	      C   SendIMEMessageEx equ <SendIMEMessageExA>
			      C ENDIF
			      C 
			      C SendIMEMessageExW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SendInput PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C SendMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SendMessageA		      C   SendMessage equ <SendMessageA>
			      C ENDIF
			      C 
			      C SendMessageCallbackA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SendMessageCallbackA	      C   SendMessageCallback equ <SendMessageCallbackA>
			      C ENDIF
			      C 
			      C SendMessageCallbackW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SendMessageTimeoutA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SendMessageTimeoutA	      C   SendMessageTimeout equ <SendMessageTimeoutA>
			      C ENDIF
			      C 
			      C SendMessageTimeoutW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SendMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SendNotifyMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SendNotifyMessageA	      C   SendNotifyMessage equ <SendNotifyMessageA>
			      C ENDIF
			      C 
			      C SendNotifyMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetActiveWindow PROTO STDCALL :DWORD
			      C SetCapture PROTO STDCALL :DWORD
			      C SetCaretBlinkTime PROTO STDCALL :DWORD
			      C SetCaretPos PROTO STDCALL :DWORD,:DWORD
			      C 
			      C SetClassLongA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetClassLongA	      C   SetClassLong equ <SetClassLongA>
			      C ENDIF
			      C 
			      C SetClassLongW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetClassWord PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetClipboardData PROTO STDCALL :DWORD,:DWORD
			      C SetClipboardViewer PROTO STDCALL :DWORD
			      C SetCursor PROTO STDCALL :DWORD
			      C SetCursorPos PROTO STDCALL :DWORD,:DWORD
			      C SetDebugErrorLevel PROTO STDCALL :DWORD
			      C SetDeskWallpaper PROTO STDCALL :DWORD
			      C SetDlgItemInt PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C SetDlgItemTextA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetDlgItemTextA	      C   SetDlgItemText equ <SetDlgItemTextA>
			      C ENDIF
			      C 
			      C SetDlgItemTextW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetDoubleClickTime PROTO STDCALL :DWORD
			      C SetFocus PROTO STDCALL :DWORD
			      C SetForegroundWindow PROTO STDCALL :DWORD
			      C SetKeyboardState PROTO STDCALL :DWORD
			      C SetLastErrorEx PROTO STDCALL :DWORD,:DWORD
			      C SetLayeredWindowAttributes PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SetMenu PROTO STDCALL :DWORD,:DWORD
			      C SetMenuContextHelpId PROTO STDCALL :DWORD,:DWORD
			      C SetMenuDefaultItem PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetMenuInfo PROTO STDCALL :DWORD,:DWORD
			      C SetMenuItemBitmaps PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C SetMenuItemInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetMenuItemInfoA	      C   SetMenuItemInfo equ <SetMenuItemInfoA>
			      C ENDIF
			      C 
			      C SetMenuItemInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetMessageExtraInfo PROTO STDCALL :DWORD
			      C SetMessageQueue PROTO STDCALL :DWORD
			      C SetParent PROTO STDCALL :DWORD,:DWORD
			      C SetProcessDefaultLayout PROTO STDCALL :DWORD
			      C SetProcessWindowStation PROTO STDCALL :DWORD
			      C 
			      C SetPropA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetPropA		      C   SetProp equ <SetPropA>
			      C ENDIF
			      C 
			      C SetPropW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetRect PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetRectEmpty PROTO STDCALL :DWORD
			      C SetScrollInfo PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SetScrollPos PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SetScrollRange PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetShellWindow PROTO STDCALL :DWORD
			      C SetSysColors PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetSystemCursor PROTO STDCALL :DWORD,:DWORD
			      C SetThreadDesktop PROTO STDCALL :DWORD
			      C SetTimer PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C SetUserObjectInformationA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetUserObjectInformation   C   SetUserObjectInformation equ <SetUserObjectInformationA>
   A
			      C ENDIF
			      C 
			      C SetUserObjectInformationW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetUserObjectSecurity PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetWinEventHook PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetWindowContextHelpId PROTO STDCALL :DWORD,:DWORD
			      C 
			      C SetWindowLongA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetWindowLongA	      C   SetWindowLong equ <SetWindowLongA>
			      C ENDIF
			      C 
			      C SetWindowLongW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetWindowPlacement PROTO STDCALL :DWORD,:DWORD
			      C SetWindowPos PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetWindowRgn PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C SetWindowTextA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetWindowTextA	      C   SetWindowText equ <SetWindowTextA>
			      C ENDIF
			      C 
			      C SetWindowTextW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetWindowWord PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C SetWindowsHookA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetWindowsHookA	      C   SetWindowsHook equ <SetWindowsHookA>
			      C ENDIF
			      C 
			      C SetWindowsHookExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetWindowsHookExA	      C   SetWindowsHookEx equ <SetWindowsHookExA>
			      C ENDIF
			      C 
			      C SetWindowsHookExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetWindowsHookW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ShowCaret PROTO STDCALL :DWORD
			      C ShowCursor PROTO STDCALL :DWORD
			      C ShowOwnedPopups PROTO STDCALL :DWORD,:DWORD
			      C ShowScrollBar PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C ShowWindow PROTO STDCALL :DWORD,:DWORD
			      C ShowWindowAsync PROTO STDCALL :DWORD,:DWORD
			      C SubtractRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SwapMouseButton PROTO STDCALL :DWORD
			      C SwitchDesktop PROTO STDCALL :DWORD
			      C SwitchToThisWindow PROTO STDCALL :DWORD,:DWORD
			      C 
			      C SystemParametersInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SystemParametersInfoA      C   SystemParametersInfo equ <SystemParametersInfoA>
			      C ENDIF
			      C 
			      C SystemParametersInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C TabbedTextOutA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = TabbedTextOutA	      C   TabbedTextOut equ <TabbedTextOutA>
			      C ENDIF
			      C 
			      C TabbedTextOutW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C TileChildWindows PROTO STDCALL :DWORD,:DWORD
			      C TileWindows PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ToAscii PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ToAsciiEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ToUnicode PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ToUnicodeEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C TrackMouseEvent PROTO STDCALL :DWORD
			      C TrackPopupMenu PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C TrackPopupMenuEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C TranslateAcceleratorA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = TranslateAcceleratorA      C   TranslateAccelerator equ <TranslateAcceleratorA>
			      C ENDIF
			      C 
			      C TranslateAcceleratorW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C TranslateMDISysAccel PROTO STDCALL :DWORD,:DWORD
			      C TranslateMessage PROTO STDCALL :DWORD
			      C UnhookWinEvent PROTO STDCALL :DWORD
			      C UnhookWindowsHook PROTO STDCALL :DWORD,:DWORD
			      C UnhookWindowsHookEx PROTO STDCALL :DWORD
			      C UnionRect PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C UnloadKeyboardLayout PROTO STDCALL :DWORD
			      C UnpackDDElParam PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C UnregisterClassA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = UnregisterClassA	      C   UnregisterClass equ <UnregisterClassA>
			      C ENDIF
			      C 
			      C UnregisterClassW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C UnregisterDeviceNotification PROTO STDCALL :DWORD
			      C UnregisterHotKey PROTO STDCALL :DWORD,:DWORD
			      C UpdateLayeredWindow PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C UpdateWindow PROTO STDCALL :DWORD
			      C UserHandleGrantAccess PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C ValidateRect PROTO STDCALL :DWORD,:DWORD
			      C ValidateRgn PROTO STDCALL :DWORD,:DWORD
			      C 
			      C VkKeyScanA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = VkKeyScanA		      C   VkKeyScan equ <VkKeyScanA>
			      C ENDIF
			      C 
			      C VkKeyScanExA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = VkKeyScanExA		      C   VkKeyScanEx equ <VkKeyScanExA>
			      C ENDIF
			      C 
			      C VkKeyScanExW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C VkKeyScanW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WINNLSEnableIME PROTO STDCALL :DWORD,:DWORD
			      C WINNLSGetEnableStatus PROTO STDCALL :DWORD
			      C WINNLSGetIMEHotkey PROTO STDCALL :DWORD
			      C WaitForInputIdle PROTO STDCALL :DWORD,:DWORD
			      C WaitMessage PROTO STDCALL
			      C 
			      C WinHelpA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WinHelpA		      C   WinHelp equ <WinHelpA>
			      C ENDIF
			      C 
			      C WinHelpW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WindowFromDC PROTO STDCALL :DWORD
			      C WindowFromPoint PROTO STDCALL :DWORD,:DWORD
			      C keybd_event PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C mouse_event PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C wsprintfA PROTO C :VARARG
			      C IFNDEF __UNICODE__
 = wsprintfA		      C   wsprintf equ <wsprintfA>
			      C ENDIF
			      C 
			      C wsprintfW PROTO C :VARARG
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C wvsprintfA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = wvsprintfA		      C   wvsprintf equ <wvsprintfA>
			      C ENDIF
			      C 
			      C wvsprintfW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ELSE
			      C ENDIF
			      C 
					  include \masm32\include\kernel32.inc
			      C ; --------------------------------------------------------------------------------------------------
			      C ;                          kernel32.inc Copyright The MASM32 SDK 1998-2010
			      C ; --------------------------------------------------------------------------------------------------
			      C 
			      C IFNDEF KERNEL32_INC
 = 1			      C KERNEL32_INC equ <1>
			      C 
			      C ActivateActCtx PROTO STDCALL :DWORD,:DWORD
			      C 
			      C AddAtomA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = AddAtomA		      C   AddAtom equ <AddAtomA>
			      C ENDIF
			      C 
			      C AddAtomW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C AddLocalAlternateComputerNameA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = AddLocalAlternateCompute   C   AddLocalAlternateComputerName equ <AddLocalAlternateComputerNameA>
   rNameA
			      C ENDIF
			      C 
			      C AddLocalAlternateComputerNameW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C AddRefActCtx PROTO STDCALL :DWORD
			      C AddVectoredExceptionHandler PROTO STDCALL :DWORD,:DWORD
			      C AllocConsole PROTO STDCALL
			      C AllocateUserPhysicalPages PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C AreFileApisANSI PROTO STDCALL
			      C AssignProcessToJobObject PROTO STDCALL :DWORD,:DWORD
			      C AttachConsole PROTO STDCALL :DWORD
			      C BackupRead PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C BackupSeek PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C BackupWrite PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C Beep PROTO STDCALL :DWORD,:DWORD
			      C 
			      C BeginUpdateResourceA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = BeginUpdateResourceA	      C   BeginUpdateResource equ <BeginUpdateResourceA>
			      C ENDIF
			      C 
			      C BeginUpdateResourceW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C BindIoCompletionCallback PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C BuildCommDCBA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = BuildCommDCBA	      C   BuildCommDCB equ <BuildCommDCBA>
			      C ENDIF
			      C 
			      C BuildCommDCBAndTimeoutsA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = BuildCommDCBAndTimeoutsA   C   BuildCommDCBAndTimeouts equ <BuildCommDCBAndTimeoutsA>
			      C ENDIF
			      C 
			      C BuildCommDCBAndTimeoutsW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C BuildCommDCBW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CallNamedPipeA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CallNamedPipeA	      C   CallNamedPipe equ <CallNamedPipeA>
			      C ENDIF
			      C 
			      C CallNamedPipeW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CancelDeviceWakeupRequest PROTO STDCALL :DWORD
			      C CancelIo PROTO STDCALL :DWORD
			      C CancelTimerQueueTimer PROTO STDCALL :DWORD,:DWORD
			      C CancelWaitableTimer PROTO STDCALL :DWORD
			      C ChangeTimerQueueTimer PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CheckNameLegalDOS8Dot3A PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CheckNameLegalDOS8Dot3A    C   CheckNameLegalDOS8Dot3 equ <CheckNameLegalDOS8Dot3A>
			      C ENDIF
			      C 
			      C CheckNameLegalDOS8Dot3W PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CheckRemoteDebuggerPresent PROTO STDCALL :DWORD,:DWORD
			      C ClearCommBreak PROTO STDCALL :DWORD
			      C ClearCommError PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C CloseHandle PROTO STDCALL :DWORD
			      C 
			      C CommConfigDialogA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CommConfigDialogA	      C   CommConfigDialog equ <CommConfigDialogA>
			      C ENDIF
			      C 
			      C CommConfigDialogW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CompareFileTime PROTO STDCALL :DWORD,:DWORD
			      C 
			      C CompareStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CompareStringA	      C   CompareString equ <CompareStringA>
			      C ENDIF
			      C 
			      C CompareStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ConnectNamedPipe PROTO STDCALL :DWORD,:DWORD
			      C ContinueDebugEvent PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C ConvertDefaultLocale PROTO STDCALL :DWORD
			      C ConvertFiberToThread PROTO STDCALL
			      C ConvertThreadToFiber PROTO STDCALL :DWORD
			      C 
			      C CopyFileA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CopyFileA		      C   CopyFile equ <CopyFileA>
			      C ENDIF
			      C 
			      C CopyFileExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CopyFileExA		      C   CopyFileEx equ <CopyFileExA>
			      C ENDIF
			      C 
			      C CopyFileExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CopyFileW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateActCtxA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = CreateActCtxA	      C   CreateActCtx equ <CreateActCtxA>
			      C ENDIF
			      C 
			      C CreateActCtxW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateConsoleScreenBuffer PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CreateDirectoryA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateDirectoryA	      C   CreateDirectory equ <CreateDirectoryA>
			      C ENDIF
			      C 
			      C CreateDirectoryExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateDirectoryExA	      C   CreateDirectoryEx equ <CreateDirectoryExA>
			      C ENDIF
			      C 
			      C CreateDirectoryExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateDirectoryW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateEventA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateEventA		      C   CreateEvent equ <CreateEventA>
			      C ENDIF
			      C 
			      C CreateEventW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateFiber PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C CreateFiberEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CreateFileA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateFileA		      C   CreateFile equ <CreateFileA>
			      C ENDIF
			      C 
			      C CreateFileMappingA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateFileMappingA	      C   CreateFileMapping equ <CreateFileMappingA>
			      C ENDIF
			      C 
			      C CreateFileMappingW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateFileW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateHardLinkA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateHardLinkA	      C   CreateHardLink equ <CreateHardLinkA>
			      C ENDIF
			      C 
			      C CreateHardLinkW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateIoCompletionPort PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CreateJobObjectA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateJobObjectA	      C   CreateJobObject equ <CreateJobObjectA>
			      C ENDIF
			      C 
			      C CreateJobObjectW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateJobSet PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C CreateMailslotA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateMailslotA	      C   CreateMailslot equ <CreateMailslotA>
			      C ENDIF
			      C 
			      C CreateMailslotW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateMemoryResourceNotification PROTO STDCALL :DWORD
			      C 
			      C CreateMutexA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateMutexA		      C   CreateMutex equ <CreateMutexA>
			      C ENDIF
			      C 
			      C CreateMutexW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateNamedPipeA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateNamedPipeA	      C   CreateNamedPipe equ <CreateNamedPipeA>
			      C ENDIF
			      C 
			      C CreateNamedPipeW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreatePipe PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CreateProcessA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateProcessA	      C   CreateProcess equ <CreateProcessA>
			      C ENDIF
			      C 
			      C CreateProcessInternalWSecure PROTO STDCALL
			      C 
			      C CreateProcessW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateRemoteThread PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C CreateSemaphoreA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateSemaphoreA	      C   CreateSemaphore equ <CreateSemaphoreA>
			      C ENDIF
			      C 
			      C CreateSemaphoreW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C CreateTapePartition PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateThread PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateTimerQueue PROTO STDCALL
			      C CreateTimerQueueTimer PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateToolhelp32Snapshot PROTO STDCALL :DWORD,:DWORD
			      C 
			      C CreateWaitableTimerA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = CreateWaitableTimerA	      C   CreateWaitableTimer equ <CreateWaitableTimerA>
			      C ENDIF
			      C 
			      C CreateWaitableTimerW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DeactivateActCtx PROTO STDCALL :DWORD,:DWORD
			      C DebugActiveProcess PROTO STDCALL :DWORD
			      C DebugActiveProcessStop PROTO STDCALL :DWORD
			      C DebugBreak PROTO STDCALL
			      C DebugBreakProcess PROTO STDCALL :DWORD
			      C DebugSetProcessKillOnExit PROTO STDCALL :DWORD
			      C DecodePointer PROTO STDCALL :DWORD
			      C DecodeSystemPointer PROTO STDCALL :DWORD
			      C 
			      C DefineDosDeviceA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DefineDosDeviceA	      C   DefineDosDevice equ <DefineDosDeviceA>
			      C ENDIF
			      C 
			      C DefineDosDeviceW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DeleteAtom PROTO STDCALL :DWORD
			      C DeleteCriticalSection PROTO STDCALL :DWORD
			      C DeleteFiber PROTO STDCALL :DWORD
			      C 
			      C DeleteFileA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = DeleteFileA		      C   DeleteFile equ <DeleteFileA>
			      C ENDIF
			      C 
			      C DeleteFileW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DeleteTimerQueue PROTO STDCALL :DWORD
			      C DeleteTimerQueueEx PROTO STDCALL :DWORD,:DWORD
			      C DeleteTimerQueueTimer PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C DeleteVolumeMountPointA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = DeleteVolumeMountPointA    C   DeleteVolumeMountPoint equ <DeleteVolumeMountPointA>
			      C ENDIF
			      C 
			      C DeleteVolumeMountPointW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DeviceIoControl PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DisableThreadLibraryCalls PROTO STDCALL :DWORD
			      C DisconnectNamedPipe PROTO STDCALL :DWORD
			      C 
			      C DnsHostnameToComputerNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = DnsHostnameToComputerNam   C   DnsHostnameToComputerName equ <DnsHostnameToComputerNameA>
   eA
			      C ENDIF
			      C 
			      C DnsHostnameToComputerNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C DosDateTimeToFileTime PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C DuplicateHandle PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C EncodePointer PROTO STDCALL :DWORD
			      C EncodeSystemPointer PROTO STDCALL :DWORD
			      C 
			      C EndUpdateResourceA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EndUpdateResourceA	      C   EndUpdateResource equ <EndUpdateResourceA>
			      C ENDIF
			      C 
			      C EndUpdateResourceW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnterCriticalSection PROTO STDCALL :DWORD
			      C 
			      C EnumCalendarInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumCalendarInfoA	      C   EnumCalendarInfo equ <EnumCalendarInfoA>
			      C ENDIF
			      C 
			      C EnumCalendarInfoExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumCalendarInfoExA	      C   EnumCalendarInfoEx equ <EnumCalendarInfoExA>
			      C ENDIF
			      C 
			      C EnumCalendarInfoExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumCalendarInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumDateFormatsA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumDateFormatsA	      C   EnumDateFormats equ <EnumDateFormatsA>
			      C ENDIF
			      C 
			      C EnumDateFormatsExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumDateFormatsExA	      C   EnumDateFormatsEx equ <EnumDateFormatsExA>
			      C ENDIF
			      C 
			      C EnumDateFormatsExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumDateFormatsW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumLanguageGroupLocalesA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumLanguageGroupLocales   C   EnumLanguageGroupLocales equ <EnumLanguageGroupLocalesA>
   A
			      C ENDIF
			      C 
			      C EnumLanguageGroupLocalesW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumResourceLanguagesA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumResourceLanguagesA     C   EnumResourceLanguages equ <EnumResourceLanguagesA>
			      C ENDIF
			      C 
			      C EnumResourceLanguagesW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumResourceNamesA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumResourceNamesA	      C   EnumResourceNames equ <EnumResourceNamesA>
			      C ENDIF
			      C 
			      C EnumResourceNamesW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumResourceTypesA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumResourceTypesA	      C   EnumResourceTypes equ <EnumResourceTypesA>
			      C ENDIF
			      C 
			      C EnumResourceTypesW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumSystemCodePagesA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumSystemCodePagesA	      C   EnumSystemCodePages equ <EnumSystemCodePagesA>
			      C ENDIF
			      C 
			      C EnumSystemCodePagesW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumSystemGeoID PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C EnumSystemLanguageGroupsA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumSystemLanguageGroups   C   EnumSystemLanguageGroups equ <EnumSystemLanguageGroupsA>
   A
			      C ENDIF
			      C 
			      C EnumSystemLanguageGroupsW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumSystemLocalesA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumSystemLocalesA	      C   EnumSystemLocales equ <EnumSystemLocalesA>
			      C ENDIF
			      C 
			      C EnumSystemLocalesW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumTimeFormatsA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumTimeFormatsA	      C   EnumTimeFormats equ <EnumTimeFormatsA>
			      C ENDIF
			      C 
			      C EnumTimeFormatsW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumUILanguagesA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumUILanguagesA	      C   EnumUILanguages equ <EnumUILanguagesA>
			      C ENDIF
			      C 
			      C EnumUILanguagesW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EnumerateLocalComputerNamesA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = EnumerateLocalComputerNa   C   EnumerateLocalComputerNames equ <EnumerateLocalComputerNamesA>
   mesA
			      C ENDIF
			      C 
			      C EnumerateLocalComputerNamesW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C EraseTape PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C EscapeCommFunction PROTO STDCALL :DWORD,:DWORD
			      C ExitProcess PROTO STDCALL :DWORD
			      C ExitThread PROTO STDCALL :DWORD
			      C 
			      C ExpandEnvironmentStringsA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ExpandEnvironmentStrings   C   ExpandEnvironmentStrings equ <ExpandEnvironmentStringsA>
   A
			      C ENDIF
			      C 
			      C ExpandEnvironmentStringsW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FatalAppExitA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FatalAppExitA	      C   FatalAppExit equ <FatalAppExitA>
			      C ENDIF
			      C 
			      C FatalAppExitW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FatalExit PROTO STDCALL :DWORD
			      C FileTimeToDosDateTime PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C FileTimeToLocalFileTime PROTO STDCALL :DWORD,:DWORD
			      C FileTimeToSystemTime PROTO STDCALL :DWORD,:DWORD
			      C FillConsoleOutputAttribute PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C FillConsoleOutputCharacterA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FillConsoleOutputCharact   C   FillConsoleOutputCharacter equ <FillConsoleOutputCharacterA>
   erA
			      C ENDIF
			      C 
			      C FillConsoleOutputCharacterW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindActCtxSectionGuid PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C FindActCtxSectionStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindActCtxSectionStringA   C   FindActCtxSectionString equ <FindActCtxSectionStringA>
			      C ENDIF
			      C 
			      C FindActCtxSectionStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindAtomA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = FindAtomA		      C   FindAtom equ <FindAtomA>
			      C ENDIF
			      C 
			      C FindAtomW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindClose PROTO STDCALL :DWORD
			      C FindCloseChangeNotification PROTO STDCALL :DWORD
			      C 
			      C FindFirstChangeNotificationA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindFirstChangeNotificat   C   FindFirstChangeNotification equ <FindFirstChangeNotificationA>
   ionA
			      C ENDIF
			      C 
			      C FindFirstChangeNotificationW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindFirstFileA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindFirstFileA	      C   FindFirstFile equ <FindFirstFileA>
			      C ENDIF
			      C 
			      C FindFirstFileExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindFirstFileExA	      C   FindFirstFileEx equ <FindFirstFileExA>
			      C ENDIF
			      C 
			      C FindFirstFileExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindFirstFileW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindFirstVolumeA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindFirstVolumeA	      C   FindFirstVolume equ <FindFirstVolumeA>
			      C ENDIF
			      C 
			      C FindFirstVolumeMountPointA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindFirstVolumeMountPoin   C   FindFirstVolumeMountPoint equ <FindFirstVolumeMountPointA>
   tA
			      C ENDIF
			      C 
			      C FindFirstVolumeMountPointW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindFirstVolumeW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindNextChangeNotification PROTO STDCALL :DWORD
			      C 
			      C FindNextFileA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindNextFileA	      C   FindNextFile equ <FindNextFileA>
			      C ENDIF
			      C 
			      C FindNextFileW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindNextVolumeA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindNextVolumeA	      C   FindNextVolume equ <FindNextVolumeA>
			      C ENDIF
			      C 
			      C FindNextVolumeMountPointA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindNextVolumeMountPoint   C   FindNextVolumeMountPoint equ <FindNextVolumeMountPointA>
   A
			      C ENDIF
			      C 
			      C FindNextVolumeMountPointW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindNextVolumeW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindResourceA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindResourceA	      C   FindResource equ <FindResourceA>
			      C ENDIF
			      C 
			      C FindResourceExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FindResourceExA	      C   FindResourceEx equ <FindResourceExA>
			      C ENDIF
			      C 
			      C FindResourceExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindResourceW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FindVolumeClose PROTO STDCALL :DWORD
			      C FindVolumeMountPointClose PROTO STDCALL :DWORD
			      C FlushConsoleInputBuffer PROTO STDCALL :DWORD
			      C FlushFileBuffers PROTO STDCALL :DWORD
			      C FlushInstructionCache PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C FlushViewOfFile PROTO STDCALL :DWORD,:DWORD
			      C 
			      C FoldStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FoldStringA		      C   FoldString equ <FoldStringA>
			      C ENDIF
			      C 
			      C FoldStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FormatMessageA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = FormatMessageA	      C   FormatMessage equ <FormatMessageA>
			      C ENDIF
			      C 
			      C FormatMessageW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FreeConsole PROTO STDCALL
			      C 
			      C FreeEnvironmentStringsA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = FreeEnvironmentStringsA    C   FreeEnvironmentStrings equ <FreeEnvironmentStringsA>
			      C ENDIF
			      C 
			      C FreeEnvironmentStringsW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C FreeLibrary PROTO STDCALL :DWORD
			      C FreeLibraryAndExitThread PROTO STDCALL :DWORD,:DWORD
			      C FreeResource PROTO STDCALL :DWORD
			      C FreeUserPhysicalPages PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GenerateConsoleCtrlEvent PROTO STDCALL :DWORD,:DWORD
			      C GetACP PROTO STDCALL
			      C 
			      C GetAtomNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetAtomNameA		      C   GetAtomName equ <GetAtomNameA>
			      C ENDIF
			      C 
			      C GetAtomNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C GetBinaryTypeA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetBinaryTypeA	      C   GetBinaryType equ <GetBinaryTypeA>
			      C ENDIF
			      C 
			      C GetBinaryTypeW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetCPInfo PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetCPInfoExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetCPInfoExA		      C   GetCPInfoEx equ <GetCPInfoExA>
			      C ENDIF
			      C 
			      C GetCPInfoExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetCalendarInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetCalendarInfoA	      C   GetCalendarInfo equ <GetCalendarInfoA>
			      C ENDIF
			      C 
			      C GetCalendarInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetCommConfig PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetCommMask PROTO STDCALL :DWORD,:DWORD
			      C GetCommModemStatus PROTO STDCALL :DWORD,:DWORD
			      C GetCommProperties PROTO STDCALL :DWORD,:DWORD
			      C GetCommState PROTO STDCALL :DWORD,:DWORD
			      C GetCommTimeouts PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetCommandLineA PROTO STDCALL
			      C IFNDEF __UNICODE__
 = GetCommandLineA	      C   GetCommandLine equ <GetCommandLineA>
			      C ENDIF
			      C 
			      C GetCommandLineW PROTO STDCALL
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetCompressedFileSizeA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetCompressedFileSizeA     C   GetCompressedFileSize equ <GetCompressedFileSizeA>
			      C ENDIF
			      C 
			      C GetCompressedFileSizeW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetComputerNameA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetComputerNameA	      C   GetComputerName equ <GetComputerNameA>
			      C ENDIF
			      C 
			      C GetComputerNameExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetComputerNameExA	      C   GetComputerNameEx equ <GetComputerNameExA>
			      C ENDIF
			      C 
			      C GetComputerNameExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetComputerNameW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetConsoleCP PROTO STDCALL
			      C GetConsoleCursorInfo PROTO STDCALL :DWORD,:DWORD
			      C GetConsoleDisplayMode PROTO STDCALL :DWORD
			      C GetConsoleFontSize PROTO STDCALL :DWORD,:DWORD
			      C GetConsoleMode PROTO STDCALL :DWORD,:DWORD
			      C GetConsoleOutputCP PROTO STDCALL
			      C GetConsoleProcessList PROTO STDCALL :DWORD,:DWORD
			      C GetConsoleScreenBufferInfo PROTO STDCALL :DWORD,:DWORD
			      C GetConsoleSelectionInfo PROTO STDCALL :DWORD
			      C 
			      C GetConsoleTitleA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetConsoleTitleA	      C   GetConsoleTitle equ <GetConsoleTitleA>
			      C ENDIF
			      C 
			      C GetConsoleTitleW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetConsoleWindow PROTO STDCALL
			      C 
			      C GetCurrencyFormatA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetCurrencyFormatA	      C   GetCurrencyFormat equ <GetCurrencyFormatA>
			      C ENDIF
			      C 
			      C GetCurrencyFormatW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetCurrentActCtx PROTO STDCALL :DWORD
			      C GetCurrentConsoleFont PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C GetCurrentDirectoryA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetCurrentDirectoryA	      C   GetCurrentDirectory equ <GetCurrentDirectoryA>
			      C ENDIF
			      C 
			      C GetCurrentDirectoryW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetCurrentProcess PROTO STDCALL
			      C GetCurrentProcessId PROTO STDCALL
			      C GetCurrentThread PROTO STDCALL
			      C GetCurrentThreadId PROTO STDCALL
			      C 
			      C GetDateFormatA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetDateFormatA	      C   GetDateFormat equ <GetDateFormatA>
			      C ENDIF
			      C 
			      C GetDateFormatW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetDefaultCommConfigA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetDefaultCommConfigA      C   GetDefaultCommConfig equ <GetDefaultCommConfigA>
			      C ENDIF
			      C 
			      C GetDefaultCommConfigW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetDevicePowerState PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetDiskFreeSpaceA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetDiskFreeSpaceA	      C   GetDiskFreeSpace equ <GetDiskFreeSpaceA>
			      C ENDIF
			      C 
			      C GetDiskFreeSpaceExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetDiskFreeSpaceExA	      C   GetDiskFreeSpaceEx equ <GetDiskFreeSpaceExA>
			      C ENDIF
			      C 
			      C GetDiskFreeSpaceExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetDiskFreeSpaceW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetDllDirectoryA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetDllDirectoryA	      C   GetDllDirectory equ <GetDllDirectoryA>
			      C ENDIF
			      C 
			      C GetDllDirectoryW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetDriveTypeA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GetDriveTypeA	      C   GetDriveType equ <GetDriveTypeA>
			      C ENDIF
			      C 
			      C GetDriveTypeW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C GetEnvironmentStringsA PROTO STDCALL
			      C IFNDEF __UNICODE__
 = GetEnvironmentStringsA     C   GetEnvironmentStrings equ <GetEnvironmentStringsA>
			      C ENDIF
			      C 
			      C GetEnvironmentStringsW PROTO STDCALL
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetEnvironmentVariableA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetEnvironmentVariableA    C   GetEnvironmentVariable equ <GetEnvironmentVariableA>
			      C ENDIF
			      C 
			      C GetEnvironmentVariableW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetExitCodeProcess PROTO STDCALL :DWORD,:DWORD
			      C GetExitCodeThread PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetFileAttributesA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GetFileAttributesA	      C   GetFileAttributes equ <GetFileAttributesA>
			      C ENDIF
			      C 
			      C GetFileAttributesExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetFileAttributesExA	      C   GetFileAttributesEx equ <GetFileAttributesExA>
			      C ENDIF
			      C 
			      C GetFileAttributesExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetFileAttributesW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetFileInformationByHandle PROTO STDCALL :DWORD,:DWORD
			      C GetFileSize PROTO STDCALL :DWORD,:DWORD
			      C GetFileSizeEx PROTO STDCALL :DWORD,:DWORD
			      C GetFileTime PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C GetFileType PROTO STDCALL :DWORD
			      C 
			      C GetFirmwareEnvironmentVariableA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetFirmwareEnvironmentVa   C   GetFirmwareEnvironmentVariable equ <GetFirmwareEnvironmentVariableA>
   riableA
			      C ENDIF
			      C 
			      C GetFirmwareEnvironmentVariableW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetFullPathNameA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetFullPathNameA	      C   GetFullPathName equ <GetFullPathNameA>
			      C ENDIF
			      C 
			      C GetFullPathNameW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetGeoInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetGeoInfoA		      C   GetGeoInfo equ <GetGeoInfoA>
			      C ENDIF
			      C 
			      C GetGeoInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetHandleInformation PROTO STDCALL :DWORD,:DWORD
			      C GetLargestConsoleWindowSize PROTO STDCALL :DWORD
			      C GetLastError PROTO STDCALL
			      C GetLocalTime PROTO STDCALL :DWORD
			      C 
			      C GetLocaleInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetLocaleInfoA	      C   GetLocaleInfo equ <GetLocaleInfoA>
			      C ENDIF
			      C 
			      C GetLocaleInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetLogicalDriveStringsA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetLogicalDriveStringsA    C   GetLogicalDriveStrings equ <GetLogicalDriveStringsA>
			      C ENDIF
			      C 
			      C GetLogicalDriveStringsW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetLogicalDrives PROTO STDCALL
			      C 
			      C GetLongPathNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetLongPathNameA	      C   GetLongPathName equ <GetLongPathNameA>
			      C ENDIF
			      C 
			      C GetLongPathNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetMailslotInfo PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C GetModuleFileNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetModuleFileNameA	      C   GetModuleFileName equ <GetModuleFileNameA>
			      C ENDIF
			      C 
			      C GetModuleFileNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetModuleHandleA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GetModuleHandleA	      C   GetModuleHandle equ <GetModuleHandleA>
			      C ENDIF
			      C 
			      C GetModuleHandleExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetModuleHandleExA	      C   GetModuleHandleEx equ <GetModuleHandleExA>
			      C ENDIF
			      C 
			      C GetModuleHandleExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetModuleHandleW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetNamedPipeHandleStateA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetNamedPipeHandleStateA   C   GetNamedPipeHandleState equ <GetNamedPipeHandleStateA>
			      C ENDIF
			      C 
			      C GetNamedPipeHandleStateW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetNamedPipeInfo PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetNativeSystemInfo PROTO STDCALL :DWORD
			      C GetNumaAvailableMemory PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetNumaAvailableMemoryNode PROTO STDCALL :DWORD,:DWORD
			      C GetNumaHighestNodeNumber PROTO STDCALL :DWORD
			      C GetNumaNodeProcessorMask PROTO STDCALL :DWORD,:DWORD
			      C GetNumaProcessorMap PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetNumaProcessorNode PROTO STDCALL :DWORD,:DWORD
			      C 
			      C GetNumberFormatA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetNumberFormatA	      C   GetNumberFormat equ <GetNumberFormatA>
			      C ENDIF
			      C 
			      C GetNumberFormatW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetNumberOfConsoleInputEvents PROTO STDCALL :DWORD,:DWORD
			      C GetNumberOfConsoleMouseButtons PROTO STDCALL :DWORD
			      C GetOEMCP PROTO STDCALL
			      C GetOverlappedResult PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C GetPriorityClass PROTO STDCALL :DWORD
			      C 
			      C GetPrivateProfileIntA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetPrivateProfileIntA      C   GetPrivateProfileInt equ <GetPrivateProfileIntA>
			      C ENDIF
			      C 
			      C GetPrivateProfileIntW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetPrivateProfileSectionA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetPrivateProfileSection   C   GetPrivateProfileSection equ <GetPrivateProfileSectionA>
   A
			      C ENDIF
			      C 
			      C GetPrivateProfileSectionNamesA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetPrivateProfileSection   C   GetPrivateProfileSectionNames equ <GetPrivateProfileSectionNamesA>
   NamesA
			      C ENDIF
			      C 
			      C GetPrivateProfileSectionNamesW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetPrivateProfileSectionW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetPrivateProfileStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetPrivateProfileStringA   C   GetPrivateProfileString equ <GetPrivateProfileStringA>
			      C ENDIF
			      C 
			      C GetPrivateProfileStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetPrivateProfileStructA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetPrivateProfileStructA   C   GetPrivateProfileStruct equ <GetPrivateProfileStructA>
			      C ENDIF
			      C 
			      C GetPrivateProfileStructW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetProcAddress PROTO STDCALL :DWORD,:DWORD
			      C GetProcessAffinityMask PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetProcessHandleCount PROTO STDCALL :DWORD,:DWORD
			      C GetProcessHeap PROTO STDCALL
			      C GetProcessHeaps PROTO STDCALL :DWORD,:DWORD
			      C GetProcessId PROTO STDCALL :DWORD
			      C GetProcessIoCounters PROTO STDCALL :DWORD,:DWORD
			      C GetProcessPriorityBoost PROTO STDCALL :DWORD,:DWORD
			      C GetProcessShutdownParameters PROTO STDCALL :DWORD,:DWORD
			      C GetProcessTimes PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetProcessVersion PROTO STDCALL :DWORD
			      C GetProcessWorkingSetSize PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C GetProfileIntA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetProfileIntA	      C   GetProfileInt equ <GetProfileIntA>
			      C ENDIF
			      C 
			      C GetProfileIntW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetProfileSectionA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetProfileSectionA	      C   GetProfileSection equ <GetProfileSectionA>
			      C ENDIF
			      C 
			      C GetProfileSectionW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetProfileStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetProfileStringA	      C   GetProfileString equ <GetProfileStringA>
			      C ENDIF
			      C 
			      C GetProfileStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetQueuedCompletionStatus PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C GetShortPathNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetShortPathNameA	      C   GetShortPathName equ <GetShortPathNameA>
			      C ENDIF
			      C 
			      C GetShortPathNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetStartupInfoA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GetStartupInfoA	      C   GetStartupInfo equ <GetStartupInfoA>
			      C ENDIF
			      C 
			      C GetStartupInfoW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetStdHandle PROTO STDCALL :DWORD
			      C 
			      C GetStringTypeA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetStringTypeA	      C   GetStringType equ <GetStringTypeA>
			      C ENDIF
			      C 
			      C GetStringTypeExA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetStringTypeExA	      C   GetStringTypeEx equ <GetStringTypeExA>
			      C ENDIF
			      C 
			      C GetStringTypeExW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetStringTypeW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetSystemDefaultLCID PROTO STDCALL
			      C GetSystemDefaultLangID PROTO STDCALL
			      C GetSystemDefaultUILanguage PROTO STDCALL
			      C 
			      C GetSystemDirectoryA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetSystemDirectoryA	      C   GetSystemDirectory equ <GetSystemDirectoryA>
			      C ENDIF
			      C 
			      C GetSystemDirectoryW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetSystemInfo PROTO STDCALL :DWORD
			      C GetSystemPowerStatus PROTO STDCALL :DWORD
			      C GetSystemRegistryQuota PROTO STDCALL :DWORD,:DWORD
			      C GetSystemTime PROTO STDCALL :DWORD
			      C GetSystemTimeAdjustment PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetSystemTimeAsFileTime PROTO STDCALL :DWORD
			      C GetSystemTimes PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C GetSystemWindowsDirectoryA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetSystemWindowsDirector   C   GetSystemWindowsDirectory equ <GetSystemWindowsDirectoryA>
   yA
			      C ENDIF
			      C 
			      C GetSystemWindowsDirectoryW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetSystemWow64DirectoryA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetSystemWow64DirectoryA   C   GetSystemWow64Directory equ <GetSystemWow64DirectoryA>
			      C ENDIF
			      C 
			      C GetSystemWow64DirectoryW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetTapeParameters PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C GetTapePosition PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetTapeStatus PROTO STDCALL :DWORD
			      C 
			      C GetTempFileNameA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetTempFileNameA	      C   GetTempFileName equ <GetTempFileNameA>
			      C ENDIF
			      C 
			      C GetTempFileNameW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetTempPathA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetTempPathA		      C   GetTempPath equ <GetTempPathA>
			      C ENDIF
			      C 
			      C GetTempPathW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetThreadContext PROTO STDCALL :DWORD,:DWORD
			      C GetThreadIOPendingFlag PROTO STDCALL :DWORD,:DWORD
			      C GetThreadLocale PROTO STDCALL
			      C GetThreadPriority PROTO STDCALL :DWORD
			      C GetThreadPriorityBoost PROTO STDCALL :DWORD,:DWORD
			      C GetThreadSelectorEntry PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GetThreadTimes PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetTickCount PROTO STDCALL
			      C 
			      C GetTimeFormatA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetTimeFormatA	      C   GetTimeFormat equ <GetTimeFormatA>
			      C ENDIF
			      C 
			      C GetTimeFormatW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetTimeZoneInformation PROTO STDCALL :DWORD
			      C GetUserDefaultLCID PROTO STDCALL
			      C GetUserDefaultLangID PROTO STDCALL
			      C GetUserDefaultUILanguage PROTO STDCALL
			      C GetUserGeoID PROTO STDCALL :DWORD
			      C GetVersion PROTO STDCALL
			      C 
			      C GetVersionExA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GetVersionExA	      C   GetVersionEx equ <GetVersionExA>
			      C ENDIF
			      C 
			      C GetVersionExW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetVolumeInformationA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetVolumeInformationA      C   GetVolumeInformation equ <GetVolumeInformationA>
			      C ENDIF
			      C 
			      C GetVolumeInformationW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetVolumeNameForVolumeMountPointA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetVolumeNameForVolumeMo   C   GetVolumeNameForVolumeMountPoint equ <GetVolumeNameForVolumeMountPointA>
   untPointA
			      C ENDIF
			      C 
			      C GetVolumeNameForVolumeMountPointW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetVolumePathNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetVolumePathNameA	      C   GetVolumePathName equ <GetVolumePathNameA>
			      C ENDIF
			      C 
			      C GetVolumePathNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetVolumePathNamesForVolumeNameA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetVolumePathNamesForVol   C   GetVolumePathNamesForVolumeName equ <GetVolumePathNamesForVolumeNameA>
   umeNameA
			      C ENDIF
			      C 
			      C GetVolumePathNamesForVolumeNameW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetWindowsDirectoryA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GetWindowsDirectoryA	      C   GetWindowsDirectory equ <GetWindowsDirectoryA>
			      C ENDIF
			      C 
			      C GetWindowsDirectoryW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GetWriteWatch PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C GlobalAddAtomA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GlobalAddAtomA	      C   GlobalAddAtom equ <GlobalAddAtomA>
			      C ENDIF
			      C 
			      C GlobalAddAtomW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GlobalAlloc PROTO STDCALL :DWORD,:DWORD
			      C GlobalCompact PROTO STDCALL :DWORD
			      C GlobalDeleteAtom PROTO STDCALL :DWORD
			      C 
			      C GlobalFindAtomA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = GlobalFindAtomA	      C   GlobalFindAtom equ <GlobalFindAtomA>
			      C ENDIF
			      C 
			      C GlobalFindAtomW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GlobalFix PROTO STDCALL :DWORD
			      C GlobalFlags PROTO STDCALL :DWORD
			      C GlobalFree PROTO STDCALL :DWORD
			      C 
			      C GlobalGetAtomNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = GlobalGetAtomNameA	      C   GlobalGetAtomName equ <GlobalGetAtomNameA>
			      C ENDIF
			      C 
			      C GlobalGetAtomNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C GlobalHandle PROTO STDCALL :DWORD
			      C GlobalLock PROTO STDCALL :DWORD
			      C GlobalMemoryStatus PROTO STDCALL :DWORD
			      C GlobalMemoryStatusEx PROTO STDCALL :DWORD
			      C GlobalReAlloc PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C GlobalSize PROTO STDCALL :DWORD
			      C GlobalUnWire PROTO STDCALL :DWORD
			      C GlobalUnfix PROTO STDCALL :DWORD
			      C GlobalUnlock PROTO STDCALL :DWORD
			      C GlobalWire PROTO STDCALL :DWORD
			      C Heap32First PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C Heap32ListFirst PROTO STDCALL :DWORD,:DWORD
			      C Heap32ListNext PROTO STDCALL :DWORD,:DWORD
			      C Heap32Next PROTO STDCALL :DWORD
			      C HeapAlloc PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C HeapCompact PROTO STDCALL :DWORD,:DWORD
			      C HeapCreate PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C HeapDestroy PROTO STDCALL :DWORD
			      C HeapFree PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C HeapLock PROTO STDCALL :DWORD
			      C HeapQueryInformation PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C HeapReAlloc PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C HeapSetInformation PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C HeapSize PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C HeapUnlock PROTO STDCALL :DWORD
			      C HeapValidate PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C HeapWalk PROTO STDCALL :DWORD,:DWORD
			      C InitAtomTable PROTO STDCALL :DWORD
			      C InitializeCriticalSection PROTO STDCALL :DWORD
			      C InitializeCriticalSectionAndSpinCount PROTO STDCALL :DWORD,:DWORD
			      C InitializeSListHead PROTO STDCALL :DWORD
			      C InterlockedCompareExchange PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C InterlockedDecrement PROTO STDCALL :DWORD
			      C InterlockedExchange PROTO STDCALL :DWORD,:DWORD
			      C InterlockedExchangeAdd PROTO STDCALL :DWORD,:DWORD
			      C InterlockedFlushSList PROTO STDCALL :DWORD
			      C InterlockedIncrement PROTO STDCALL :DWORD
			      C InterlockedPopEntrySList PROTO STDCALL :DWORD
			      C InterlockedPushEntrySList PROTO STDCALL :DWORD,:DWORD
			      C IsBadCodePtr PROTO STDCALL :DWORD
			      C IsBadHugeReadPtr PROTO STDCALL :DWORD,:DWORD
			      C IsBadHugeWritePtr PROTO STDCALL :DWORD,:DWORD
			      C IsBadReadPtr PROTO STDCALL :DWORD,:DWORD
			      C 
			      C IsBadStringPtrA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = IsBadStringPtrA	      C   IsBadStringPtr equ <IsBadStringPtrA>
			      C ENDIF
			      C 
			      C IsBadStringPtrW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C IsBadWritePtr PROTO STDCALL :DWORD,:DWORD
			      C IsDBCSLeadByte PROTO STDCALL :DWORD
			      C IsDBCSLeadByteEx PROTO STDCALL :DWORD,:DWORD
			      C IsDebuggerPresent PROTO STDCALL
			      C IsProcessInJob PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IsProcessorFeaturePresent PROTO STDCALL :DWORD
			      C IsSystemResumeAutomatic PROTO STDCALL
			      C IsValidCodePage PROTO STDCALL :DWORD
			      C IsValidLanguageGroup PROTO STDCALL :DWORD,:DWORD
			      C IsValidLocale PROTO STDCALL :DWORD,:DWORD
			      C IsWow64Process PROTO STDCALL :DWORD,:DWORD
			      C 
			      C LCMapStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LCMapStringA		      C   LCMapString equ <LCMapStringA>
			      C ENDIF
			      C 
			      C LCMapStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LeaveCriticalSection PROTO STDCALL :DWORD
			      C 
			      C LoadLibraryA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = LoadLibraryA		      C   LoadLibrary equ <LoadLibraryA>
			      C ENDIF
			      C 
			      C LoadLibraryExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = LoadLibraryExA	      C   LoadLibraryEx equ <LoadLibraryExA>
			      C ENDIF
			      C 
			      C LoadLibraryExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadLibraryW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C LoadModule PROTO STDCALL :DWORD,:DWORD
			      C LoadResource PROTO STDCALL :DWORD,:DWORD
			      C LocalAlloc PROTO STDCALL :DWORD,:DWORD
			      C LocalCompact PROTO STDCALL :DWORD
			      C LocalFileTimeToFileTime PROTO STDCALL :DWORD,:DWORD
			      C LocalFlags PROTO STDCALL :DWORD
			      C LocalFree PROTO STDCALL :DWORD
			      C LocalHandle PROTO STDCALL :DWORD
			      C LocalLock PROTO STDCALL :DWORD
			      C LocalReAlloc PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C LocalShrink PROTO STDCALL :DWORD,:DWORD
			      C LocalSize PROTO STDCALL :DWORD
			      C LocalUnlock PROTO STDCALL :DWORD
			      C LockFile PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C LockFileEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C LockResource PROTO STDCALL :DWORD
			      C MapUserPhysicalPages PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C MapUserPhysicalPagesScatter PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C MapViewOfFile PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C MapViewOfFileEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C Module32FirstW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C Module32NextW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MoveFileA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MoveFileA		      C   MoveFile equ <MoveFileA>
			      C ENDIF
			      C 
			      C MoveFileExA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MoveFileExA		      C   MoveFileEx equ <MoveFileExA>
			      C ENDIF
			      C 
			      C MoveFileExW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MoveFileW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MoveFileWithProgressA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = MoveFileWithProgressA      C   MoveFileWithProgress equ <MoveFileWithProgressA>
			      C ENDIF
			      C 
			      C MoveFileWithProgressW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C MulDiv PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C MultiByteToWideChar PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C NumaVirtualQueryNode PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C OpenEventA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenEventA		      C   OpenEvent equ <OpenEventA>
			      C ENDIF
			      C 
			      C OpenEventW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OpenFile PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C OpenFileMappingA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenFileMappingA	      C   OpenFileMapping equ <OpenFileMappingA>
			      C ENDIF
			      C 
			      C OpenFileMappingW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OpenJobObjectA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenJobObjectA	      C   OpenJobObject equ <OpenJobObjectA>
			      C ENDIF
			      C 
			      C OpenJobObjectW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OpenMutexA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenMutexA		      C   OpenMutex equ <OpenMutexA>
			      C ENDIF
			      C 
			      C OpenMutexW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OpenProcess PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C OpenSemaphoreA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenSemaphoreA	      C   OpenSemaphore equ <OpenSemaphoreA>
			      C ENDIF
			      C 
			      C OpenSemaphoreW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OpenThread PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C OpenWaitableTimerA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = OpenWaitableTimerA	      C   OpenWaitableTimer equ <OpenWaitableTimerA>
			      C ENDIF
			      C 
			      C OpenWaitableTimerW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C OutputDebugStringA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = OutputDebugStringA	      C   OutputDebugString equ <OutputDebugStringA>
			      C ENDIF
			      C 
			      C OutputDebugStringW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C PeekConsoleInputA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = PeekConsoleInputA	      C   PeekConsoleInput equ <PeekConsoleInputA>
			      C ENDIF
			      C 
			      C PeekConsoleInputW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C PeekNamedPipe PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C PostQueuedCompletionStatus PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C PrepareTape PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C Process32FirstW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C Process32NextW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ProcessIdToSessionId PROTO STDCALL :DWORD,:DWORD
			      C PulseEvent PROTO STDCALL :DWORD
			      C PurgeComm PROTO STDCALL :DWORD,:DWORD
			      C 
			      C QueryActCtxW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C QueryDepthSList PROTO STDCALL :DWORD
			      C 
			      C QueryDosDeviceA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = QueryDosDeviceA	      C   QueryDosDevice equ <QueryDosDeviceA>
			      C ENDIF
			      C 
			      C QueryDosDeviceW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C QueryInformationJobObject PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C QueryMemoryResourceNotification PROTO STDCALL :DWORD,:DWORD
			      C QueryPerformanceCounter PROTO STDCALL :DWORD
			      C QueryPerformanceFrequency PROTO STDCALL :DWORD
			      C QueueUserAPC PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C QueueUserWorkItem PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C RaiseException PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C ReadConsoleA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ReadConsoleA		      C   ReadConsole equ <ReadConsoleA>
			      C ENDIF
			      C 
			      C ReadConsoleInputA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ReadConsoleInputA	      C   ReadConsoleInput equ <ReadConsoleInputA>
			      C ENDIF
			      C 
			      C ReadConsoleInputW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ReadConsoleOutputA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ReadConsoleOutputA	      C   ReadConsoleOutput equ <ReadConsoleOutputA>
			      C ENDIF
			      C 
			      C ReadConsoleOutputAttribute PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C ReadConsoleOutputCharacterA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ReadConsoleOutputCharact   C   ReadConsoleOutputCharacter equ <ReadConsoleOutputCharacterA>
   erA
			      C ENDIF
			      C 
			      C ReadConsoleOutputCharacterW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ReadConsoleOutputW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ReadConsoleW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ReadDirectoryChangesW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ReadFile PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadFileEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadFileScatter PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadProcessMemory PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C RegisterWaitForSingleObject PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C RegisterWaitForSingleObjectEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReleaseActCtx PROTO STDCALL :DWORD
			      C ReleaseMutex PROTO STDCALL :DWORD
			      C ReleaseSemaphore PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C RemoveDirectoryA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = RemoveDirectoryA	      C   RemoveDirectory equ <RemoveDirectoryA>
			      C ENDIF
			      C 
			      C RemoveDirectoryW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RemoveLocalAlternateComputerNameA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = RemoveLocalAlternateComp   C   RemoveLocalAlternateComputerName equ <RemoveLocalAlternateComputerNameA>
   uterNameA
			      C ENDIF
			      C 
			      C RemoveLocalAlternateComputerNameW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RemoveVectoredExceptionHandler PROTO STDCALL :DWORD
			      C 
			      C ReplaceFileA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ReplaceFileA		      C   ReplaceFile equ <ReplaceFileA>
			      C ENDIF
			      C 
			      C ReplaceFileW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C RequestDeviceWakeup PROTO STDCALL :DWORD
			      C RequestWakeupLatency PROTO STDCALL :DWORD
			      C ResetEvent PROTO STDCALL :DWORD
			      C ResetWriteWatch PROTO STDCALL :DWORD,:DWORD
			      C RestoreLastError PROTO STDCALL :DWORD
			      C ResumeThread PROTO STDCALL :DWORD
			      C RtlCaptureContext PROTO STDCALL :DWORD
			      C RtlCaptureStackBackTrace PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C RtlFillMemory PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C RtlMoveMemory PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C RtlUnwind PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C RtlZeroMemory PROTO STDCALL :DWORD,:DWORD
			      C 
			      C ScrollConsoleScreenBufferA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = ScrollConsoleScreenBuffe   C   ScrollConsoleScreenBuffer equ <ScrollConsoleScreenBufferA>
   rA
			      C ENDIF
			      C 
			      C ScrollConsoleScreenBufferW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SearchPathA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SearchPathA		      C   SearchPath equ <SearchPathA>
			      C ENDIF
			      C 
			      C SearchPathW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetCalendarInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetCalendarInfoA	      C   SetCalendarInfo equ <SetCalendarInfoA>
			      C ENDIF
			      C 
			      C SetCalendarInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetCommBreak PROTO STDCALL :DWORD
			      C SetCommConfig PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetCommMask PROTO STDCALL :DWORD,:DWORD
			      C SetCommState PROTO STDCALL :DWORD,:DWORD
			      C SetCommTimeouts PROTO STDCALL :DWORD,:DWORD
			      C 
			      C SetComputerNameA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = SetComputerNameA	      C   SetComputerName equ <SetComputerNameA>
			      C ENDIF
			      C 
			      C SetComputerNameExA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetComputerNameExA	      C   SetComputerNameEx equ <SetComputerNameExA>
			      C ENDIF
			      C 
			      C SetComputerNameExW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetComputerNameW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetConsoleActiveScreenBuffer PROTO STDCALL :DWORD
			      C SetConsoleCP PROTO STDCALL :DWORD
			      C SetConsoleCtrlHandler PROTO STDCALL :DWORD,:DWORD
			      C SetConsoleCursor PROTO STDCALL :DWORD,:DWORD
			      C SetConsoleCursorInfo PROTO STDCALL :DWORD,:DWORD
			      C SetConsoleCursorPosition PROTO STDCALL :DWORD,:DWORD
			      C SetConsoleMode PROTO STDCALL :DWORD,:DWORD
			      C SetConsoleOutputCP PROTO STDCALL :DWORD
			      C SetConsoleScreenBufferSize PROTO STDCALL :DWORD,:DWORD
			      C SetConsoleTextAttribute PROTO STDCALL :DWORD,:DWORD
			      C 
			      C SetConsoleTitleA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = SetConsoleTitleA	      C   SetConsoleTitle equ <SetConsoleTitleA>
			      C ENDIF
			      C 
			      C SetConsoleTitleW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetConsoleWindowInfo PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetCriticalSectionSpinCount PROTO STDCALL :DWORD,:DWORD
			      C 
			      C SetCurrentDirectoryA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = SetCurrentDirectoryA	      C   SetCurrentDirectory equ <SetCurrentDirectoryA>
			      C ENDIF
			      C 
			      C SetCurrentDirectoryW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetDefaultCommConfigA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetDefaultCommConfigA      C   SetDefaultCommConfig equ <SetDefaultCommConfigA>
			      C ENDIF
			      C 
			      C SetDefaultCommConfigW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetDllDirectoryA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = SetDllDirectoryA	      C   SetDllDirectory equ <SetDllDirectoryA>
			      C ENDIF
			      C 
			      C SetDllDirectoryW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetEndOfFile PROTO STDCALL :DWORD
			      C 
			      C SetEnvironmentVariableA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetEnvironmentVariableA    C   SetEnvironmentVariable equ <SetEnvironmentVariableA>
			      C ENDIF
			      C 
			      C SetEnvironmentVariableW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetErrorMode PROTO STDCALL :DWORD
			      C SetEvent PROTO STDCALL :DWORD
			      C SetFileApisToANSI PROTO STDCALL
			      C SetFileApisToOEM PROTO STDCALL
			      C 
			      C SetFileAttributesA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetFileAttributesA	      C   SetFileAttributes equ <SetFileAttributesA>
			      C ENDIF
			      C 
			      C SetFileAttributesW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetFilePointer PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SetFilePointerEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C SetFileShortNameA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetFileShortNameA	      C   SetFileShortName equ <SetFileShortNameA>
			      C ENDIF
			      C 
			      C SetFileShortNameW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetFileTime PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SetFileValidData PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C SetFirmwareEnvironmentVariableA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetFirmwareEnvironmentVa   C   SetFirmwareEnvironmentVariable equ <SetFirmwareEnvironmentVariableA>
   riableA
			      C ENDIF
			      C 
			      C SetFirmwareEnvironmentVariableW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetHandleCount PROTO STDCALL :DWORD
			      C SetHandleInformation PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetInformationJobObject PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SetLastError PROTO STDCALL :DWORD
			      C 
			      C SetLocalPrimaryComputerNameA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetLocalPrimaryComputerN   C   SetLocalPrimaryComputerName equ <SetLocalPrimaryComputerNameA>
   ameA
			      C ENDIF
			      C 
			      C SetLocalPrimaryComputerNameW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetLocalTime PROTO STDCALL :DWORD
			      C 
			      C SetLocaleInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetLocaleInfoA	      C   SetLocaleInfo equ <SetLocaleInfoA>
			      C ENDIF
			      C 
			      C SetLocaleInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetMailslotInfo PROTO STDCALL :DWORD,:DWORD
			      C SetMessageWaitingIndicator PROTO STDCALL :DWORD,:DWORD
			      C SetNamedPipeHandleState PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SetPriorityClass PROTO STDCALL :DWORD,:DWORD
			      C SetProcessAffinityMask PROTO STDCALL :DWORD,:DWORD
			      C SetProcessPriorityBoost PROTO STDCALL :DWORD,:DWORD
			      C SetProcessShutdownParameters PROTO STDCALL :DWORD,:DWORD
			      C SetProcessWorkingSetSize PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetStdHandle PROTO STDCALL :DWORD,:DWORD
			      C SetSystemPowerState PROTO STDCALL :DWORD,:DWORD
			      C SetSystemTime PROTO STDCALL :DWORD
			      C SetSystemTimeAdjustment PROTO STDCALL :DWORD,:DWORD
			      C SetTapeParameters PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SetTapePosition PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetThreadAffinityMask PROTO STDCALL :DWORD,:DWORD
			      C SetThreadContext PROTO STDCALL :DWORD,:DWORD
			      C SetThreadExecutionState PROTO STDCALL :DWORD
			      C SetThreadIdealProcessor PROTO STDCALL :DWORD,:DWORD
			      C SetThreadLocale PROTO STDCALL :DWORD
			      C SetThreadPriority PROTO STDCALL :DWORD,:DWORD
			      C SetThreadPriorityBoost PROTO STDCALL :DWORD,:DWORD
			      C SetTimeZoneInformation PROTO STDCALL :DWORD
			      C SetTimerQueueTimer PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetUnhandledExceptionFilter PROTO STDCALL :DWORD
			      C SetUserGeoID PROTO STDCALL :DWORD
			      C 
			      C SetVolumeLabelA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetVolumeLabelA	      C   SetVolumeLabel equ <SetVolumeLabelA>
			      C ENDIF
			      C 
			      C SetVolumeLabelW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetVolumeMountPointA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = SetVolumeMountPointA	      C   SetVolumeMountPoint equ <SetVolumeMountPointA>
			      C ENDIF
			      C 
			      C SetVolumeMountPointW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C SetWaitableTimer PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetupComm PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C SignalObjectAndWait PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C SizeofResource PROTO STDCALL :DWORD,:DWORD
			      C Sleep PROTO STDCALL :DWORD
			      C SleepEx PROTO STDCALL :DWORD,:DWORD
			      C SuspendThread PROTO STDCALL :DWORD
			      C SwitchToFiber PROTO STDCALL :DWORD
			      C SwitchToThread PROTO STDCALL
			      C SystemTimeToFileTime PROTO STDCALL :DWORD,:DWORD
			      C SystemTimeToTzSpecificLocalTime PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C TerminateJobObject PROTO STDCALL :DWORD,:DWORD
			      C TerminateProcess PROTO STDCALL :DWORD,:DWORD
			      C TerminateThread PROTO STDCALL :DWORD,:DWORD
			      C Thread32First PROTO STDCALL :DWORD,:DWORD
			      C Thread32Next PROTO STDCALL :DWORD,:DWORD
			      C TlsAlloc PROTO STDCALL
			      C TlsFree PROTO STDCALL :DWORD
			      C TlsGetValue PROTO STDCALL :DWORD
			      C TlsSetValue PROTO STDCALL :DWORD,:DWORD
			      C Toolhelp32ReadProcessMemory PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C TransactNamedPipe PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C TransmitCommChar PROTO STDCALL :DWORD,:DWORD
			      C TryEnterCriticalSection PROTO STDCALL :DWORD
			      C TzSpecificLocalTimeToSystemTime PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C UnhandledExceptionFilter PROTO STDCALL :DWORD
			      C UnlockFile PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C UnlockFileEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C UnmapViewOfFile PROTO STDCALL :DWORD
			      C UnregisterWait PROTO STDCALL :DWORD
			      C UnregisterWaitEx PROTO STDCALL :DWORD,:DWORD
			      C 
			      C UpdateResourceA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = UpdateResourceA	      C   UpdateResource equ <UpdateResourceA>
			      C ENDIF
			      C 
			      C UpdateResourceW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C VerLanguageNameA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = VerLanguageNameA	      C   VerLanguageName equ <VerLanguageNameA>
			      C ENDIF
			      C 
			      C VerLanguageNameW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C VerSetConditionMask PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C VerifyVersionInfoA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = VerifyVersionInfoA	      C   VerifyVersionInfo equ <VerifyVersionInfoA>
			      C ENDIF
			      C 
			      C VerifyVersionInfoW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C VirtualAlloc PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualAllocEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualFree PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C VirtualFreeEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualLock PROTO STDCALL :DWORD,:DWORD
			      C VirtualProtect PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualProtectEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualQuery PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C VirtualQueryEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualUnlock PROTO STDCALL :DWORD,:DWORD
			      C WTSGetActiveConsoleSessionId PROTO STDCALL
			      C WaitCommEvent PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C WaitForDebugEvent PROTO STDCALL :DWORD,:DWORD
			      C WaitForMultipleObjects PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C WaitForMultipleObjectsEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WaitForSingleObject PROTO STDCALL :DWORD,:DWORD
			      C WaitForSingleObjectEx PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C WaitNamedPipeA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WaitNamedPipeA	      C   WaitNamedPipe equ <WaitNamedPipeA>
			      C ENDIF
			      C 
			      C WaitNamedPipeW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WideCharToMultiByte PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WinExec PROTO STDCALL :DWORD,:DWORD
			      C 
			      C WriteConsoleA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WriteConsoleA	      C   WriteConsole equ <WriteConsoleA>
			      C ENDIF
			      C 
			      C WriteConsoleInputA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WriteConsoleInputA	      C   WriteConsoleInput equ <WriteConsoleInputA>
			      C ENDIF
			      C 
			      C WriteConsoleInputW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WriteConsoleOutputA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WriteConsoleOutputA	      C   WriteConsoleOutput equ <WriteConsoleOutputA>
			      C ENDIF
			      C 
			      C WriteConsoleOutputAttribute PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C WriteConsoleOutputCharacterA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WriteConsoleOutputCharac   C   WriteConsoleOutputCharacter equ <WriteConsoleOutputCharacterA>
   terA
			      C ENDIF
			      C 
			      C WriteConsoleOutputCharacterW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WriteConsoleOutputW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WriteConsoleW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WriteFile PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteFileEx PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteFileGather PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C WritePrivateProfileSectionA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WritePrivateProfileSecti   C   WritePrivateProfileSection equ <WritePrivateProfileSectionA>
   onA
			      C ENDIF
			      C 
			      C WritePrivateProfileSectionW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WritePrivateProfileStringA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WritePrivateProfileStrin   C   WritePrivateProfileString equ <WritePrivateProfileStringA>
   gA
			      C ENDIF
			      C 
			      C WritePrivateProfileStringW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WritePrivateProfileStructA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WritePrivateProfileStruc   C   WritePrivateProfileStruct equ <WritePrivateProfileStructA>
   tA
			      C ENDIF
			      C 
			      C WritePrivateProfileStructW PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WriteProcessMemory PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C WriteProfileSectionA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WriteProfileSectionA	      C   WriteProfileSection equ <WriteProfileSectionA>
			      C ENDIF
			      C 
			      C WriteProfileSectionW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WriteProfileStringA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = WriteProfileStringA	      C   WriteProfileString equ <WriteProfileStringA>
			      C ENDIF
			      C 
			      C WriteProfileStringW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C WriteTapemark PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD
			      C ZombifyActCtx PROTO STDCALL :DWORD
			      C _hread PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C _hwrite PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C _lclose PROTO STDCALL :DWORD
			      C _lcreat PROTO STDCALL :DWORD,:DWORD
			      C _llseek PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C _lopen PROTO STDCALL :DWORD,:DWORD
			      C _lread PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C _lwrite PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C 
			      C lstrcatA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = lstrcatA		      C   lstrcat equ <lstrcatA>
			      C ENDIF
			      C 
			      C lstrcatW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C lstrcmpA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = lstrcmpA		      C   lstrcmp equ <lstrcmpA>
			      C ENDIF
			      C 
			      C lstrcmpW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C lstrcmpiA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = lstrcmpiA		      C   lstrcmpi equ <lstrcmpiA>
			      C ENDIF
			      C 
			      C lstrcmpiW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C lstrcpyA PROTO STDCALL :DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = lstrcpyA		      C   lstrcpy equ <lstrcpyA>
			      C ENDIF
			      C 
			      C lstrcpyW PROTO STDCALL :DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C lstrcpynA PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFNDEF __UNICODE__
 = lstrcpynA		      C   lstrcpyn equ <lstrcpynA>
			      C ENDIF
			      C 
			      C lstrcpynW PROTO STDCALL :DWORD,:DWORD,:DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C 
			      C lstrlenA PROTO STDCALL :DWORD
			      C IFNDEF __UNICODE__
 = lstrlenA		      C   lstrlen equ <lstrlenA>
			      C ENDIF
			      C 
			      C lstrlenW PROTO STDCALL :DWORD
			      C IFDEF __UNICODE__
			      C ENDIF
			      C 
			      C ELSE
			      C ENDIF
			      C 
					  
					  includelib \masm32\lib\masm32.lib
					  includelib \masm32\lib\user32.lib
					  includelib \masm32\lib\kernel32.lib

 00000000			.data
 00000000 30 34 30 34 31		birthday db "04041998",0
	   39 39 38 00
 00000009 25 64 00			format db "%d",0
 00000000			.data?
 00000000  00000040 [			buffer db 64 dup(?)
	    00
	   ]
 00000040 00				mainStr db ?
 00000000			.const 
 00000000 04				A db 4
 00000001 FC				A_ db -4
 00000002 0004				A1 dw 4
 00000004 FFFC				A1_ dw -4
 00000006 0194				B1 dw 404
 00000008 FE6C				B1_ dw -404
 0000000A 00000004			A2 dd 4
 0000000E FFFFFFFC			A2_ dd -4
 00000012 00000194			B2 dd 404
 00000016 FFFFFE6C			B2_ dd -404
 0000001A 003DAD0E			C2 dd 4041998
 0000001E FFC252F2			C2_ dd -4041998
 00000022				A3 dq 04
	   0000000000000004
 0000002A				A3_ dq -04
	   FFFFFFFFFFFFFFFC
 00000032				B3 dq 404
	   0000000000000194
 0000003A				B3_ dq -404
	   FFFFFFFFFFFFFE6C
 00000042				C3 dq 4041998
	   00000000003DAD0E
 0000004A				C3_ dq -4041998
	   FFFFFFFFFFC252F2
 00000052 3A378034			D1 dd 0.0007
 00000056 BBE56042			D1_ dd -0.0007
 0000005A				E dq 0.075
	   3FB3333333333333
 00000062				E_ dq -0.075
	   BFB3333333333333
 0000006A				F1 dt 760.059
	   4008BE03C6A7EF9DB22D
 00000074				F1_ dt -760.059
	   C008BE03C6A7EF9DB22D
 0000007E				D dq 0.0007
	   3F46F0068DB8BAC7
 00000086				F dq 760.059
	   4087C078D4FDF3B6
 00000000			.code
 00000000			start:
					invoke wsprintf,addr buffer, addr format, A
					invoke szCatStr, offset mainStr, offset buffer
 0000000C		     1	        .data
 0000000C 0A 00		     1	          ??0000 db 10,0
 0000002E		     1	          .code
					invoke szCatStr, offset mainStr, offset chr$(10)
					invoke wsprintf,addr buffer, addr format, B1
					invoke szCatStr, offset mainStr, offset buffer
 00000010		     1	        .data
 00000010 0A 00		     1	          ??0001 db 10,0
 00000067		     1	          .code
					invoke szCatStr, offset mainStr, offset chr$(10)
					invoke wsprintf,addr buffer, addr format, C2
					invoke szCatStr, offset mainStr, offset buffer
 00000014		     1	        .data
 00000014 0A 00		     1	          ??0002 db 10,0
 0000009D		     1	          .code
					invoke szCatStr, offset mainStr, offset chr$(10)
					invoke FloatToStr2, D, offset buffer
					invoke szCatStr, offset mainStr, offset buffer
 00000018		     1	        .data
 00000018 0A 00		     1	          ??0003 db 10,0
 000000D1		     1	          .code
					invoke szCatStr, offset mainStr, offset chr$(10)
					invoke FloatToStr2, E, offset buffer
					invoke szCatStr, offset mainStr, offset buffer
 0000001C		     1	        .data
 0000001C 0A 00		     1	          ??0004 db 10,0
 00000105		     1	          .code
					invoke szCatStr, offset mainStr, offset chr$(10)
					invoke FloatToStr2, F, offset buffer
					invoke szCatStr, offset mainStr, offset buffer
 00000020		     1	        .data
 00000020 53 75 6C 79 6D     1	          ??0005 db "Sulyma-2  04.04.1998",0
	   61 2D 32 20 20
	   30 34 2E 30 34
	   2E 31 39 39 38
	   00
 00000139		     1	          .code
					invoke MessageBoxA, 0, offset mainStr, offset chr$("Sulyma-2  04.04.1998"), 0
 0000014C  C3				ret
				end start
Microsoft (R) Macro Assembler Version 6.14.8444		    09/20/16 22:28:31
Sulyma-2_2.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

?cstr? . . . . . . . . . . . . .	Proc
A2WDAT . . . . . . . . . . . . .	Proc
ASM  . . . . . . . . . . . . . .	Func
AppModel . . . . . . . . . . . .	Proc
AppStart . . . . . . . . . . . .	Proc
Append . . . . . . . . . . . . .	Proc
BeginMessageLoop . . . . . . . .	Proc
CADD . . . . . . . . . . . . . .	Func
CPROTO . . . . . . . . . . . . .	Func
CTXT . . . . . . . . . . . . . .	Func
CurDir$  . . . . . . . . . . . .	Func
DDPROTO  . . . . . . . . . . . .	Func
DropFileName . . . . . . . . . .	Func
EndMessageLoop . . . . . . . . .	Proc
FLOAT10  . . . . . . . . . . . .	Proc
FLOAT4 . . . . . . . . . . . . .	Proc
FLOAT8 . . . . . . . . . . . . .	Proc
FP10 . . . . . . . . . . . . . .	Func
FP4  . . . . . . . . . . . . . .	Func
FP8  . . . . . . . . . . . . . .	Func
FUNC . . . . . . . . . . . . . .	Func
GLOBALS  . . . . . . . . . . . .	Proc
GLOBAL . . . . . . . . . . . . .	Proc
GetConsoleCaption$ . . . . . . .	Func
GetDllProc . . . . . . . . . . .	Func
GetFontHandle  . . . . . . . . .	Func
InputFileA . . . . . . . . . . .	Func
InputFileW . . . . . . . . . . .	Func
InputFile  . . . . . . . . . . .	Func
LOWORD . . . . . . . . . . . . .	Proc
LastError$ . . . . . . . . . . .	Func
LimitWindowHeight  . . . . . . .	Proc
LimitWindowWidth . . . . . . . .	Proc
LoadProcAddress  . . . . . . . .	Proc
MAKEDWORD  . . . . . . . . . . .	Proc
MakeIP . . . . . . . . . . . . .	Func
Mcopy  . . . . . . . . . . . . .	Proc
MsgBox . . . . . . . . . . . . .	Proc
OpenFileDlg  . . . . . . . . . .	Func
OutputFileA  . . . . . . . . . .	Func
OutputFileW  . . . . . . . . . .	Func
OutputFile . . . . . . . . . . .	Func
Pcall  . . . . . . . . . . . . .	Proc
RGB  . . . . . . . . . . . . . .	Proc
SADD . . . . . . . . . . . . . .	Func
SPROTO . . . . . . . . . . . . .	Func
STRADD . . . . . . . . . . . . .	Proc
STRING . . . . . . . . . . . . .	Proc
SaveFileDlg  . . . . . . . . . .	Func
Scall  . . . . . . . . . . . . .	Proc
SetConsoleCaption  . . . . . . .	Proc
ShellAboutBox  . . . . . . . . .	Proc
SingleInstanceOnly . . . . . . .	Proc
SysDir$  . . . . . . . . . . . .	Func
TB_BEGIND  . . . . . . . . . . .	Proc
TB_BEGIN . . . . . . . . . . . .	Proc
TB_END . . . . . . . . . . . . .	Proc
TxtItem  . . . . . . . . . . . .	Proc
TxtSeperator . . . . . . . . . .	Proc
UCCSTR . . . . . . . . . . . . .	Proc
UCSTR  . . . . . . . . . . . . .	Proc
WSTR . . . . . . . . . . . . . .	Proc
WinDir$  . . . . . . . . . . . .	Func
a2r10  . . . . . . . . . . . . .	Func
a2r4 . . . . . . . . . . . . . .	Func
a2r8 . . . . . . . . . . . . . .	Func
a2sb . . . . . . . . . . . . . .	Func
a2sd . . . . . . . . . . . . . .	Func
a2sq . . . . . . . . . . . . . .	Func
a2sw . . . . . . . . . . . . . .	Func
a2ub . . . . . . . . . . . . . .	Func
a2ud . . . . . . . . . . . . . .	Func
a2uq . . . . . . . . . . . . . .	Func
a2uw . . . . . . . . . . . . . .	Func
acfm$  . . . . . . . . . . . . .	Func
add$ . . . . . . . . . . . . . .	Func
alloc$ . . . . . . . . . . . . .	Func
alloc  . . . . . . . . . . . . .	Func
append$  . . . . . . . . . . . .	Func
argcount . . . . . . . . . . . .	Func
arr2file$  . . . . . . . . . . .	Func
arr2mem$ . . . . . . . . . . . .	Func
arr2text$  . . . . . . . . . . .	Func
arralloc$  . . . . . . . . . . .	Func
arrbin$  . . . . . . . . . . . .	Func
arrcnt$  . . . . . . . . . . . .	Func
arrealloc$ . . . . . . . . . . .	Func
arrextnd$  . . . . . . . . . . .	Func
arrfile$ . . . . . . . . . . . .	Func
arrfree$ . . . . . . . . . . . .	Func
arrget$  . . . . . . . . . . . .	Func
arrlen$  . . . . . . . . . . . .	Func
arrset$  . . . . . . . . . . . .	Func
arrtotal$  . . . . . . . . . . .	Func
arrtrunc$  . . . . . . . . . . .	Func
arrtxt$  . . . . . . . . . . . .	Func
ascii  . . . . . . . . . . . . .	Func
case$  . . . . . . . . . . . . .	Proc
casei$ . . . . . . . . . . . . .	Proc
case . . . . . . . . . . . . . .	Proc
cat$ . . . . . . . . . . . . . .	Func
catargs  . . . . . . . . . . . .	Proc
ccout  . . . . . . . . . . . . .	Proc
cfm$ . . . . . . . . . . . . . .	Func
chdir  . . . . . . . . . . . . .	Proc
chr$ . . . . . . . . . . . . . .	Func
chtype$  . . . . . . . . . . . .	Func
cls  . . . . . . . . . . . . . .	Proc
cmd$ . . . . . . . . . . . . . .	Func
cmp$ . . . . . . . . . . . . . .	Func
cmpi$  . . . . . . . . . . . . .	Func
cprint . . . . . . . . . . . . .	Proc
cst  . . . . . . . . . . . . . .	Proc
date$  . . . . . . . . . . . . .	Func
default  . . . . . . . . . . . .	Proc
dsText . . . . . . . . . . . . .	Proc
else$  . . . . . . . . . . . . .	Proc
elsei$ . . . . . . . . . . . . .	Proc
endsw$ . . . . . . . . . . . . .	Proc
endswi$  . . . . . . . . . . . .	Proc
endsw  . . . . . . . . . . . . .	Proc
env$ . . . . . . . . . . . . . .	Func
envget$  . . . . . . . . . . . .	Func
envset$  . . . . . . . . . . . .	Func
exit . . . . . . . . . . . . . .	Proc
expand_prefix  . . . . . . . . .	Func
fclose . . . . . . . . . . . . .	Proc
fcreateW . . . . . . . . . . . .	Func
fcreate  . . . . . . . . . . . .	Func
fdeleteW . . . . . . . . . . . .	Func
fdelete  . . . . . . . . . . . .	Func
fexist . . . . . . . . . . . . .	Func
fflush . . . . . . . . . . . . .	Proc
find$  . . . . . . . . . . . . .	Func
fld10  . . . . . . . . . . . . .	Proc
fld4 . . . . . . . . . . . . . .	Proc
fld8 . . . . . . . . . . . . . .	Proc
fncx . . . . . . . . . . . . . .	Proc
fnc  . . . . . . . . . . . . . .	Proc
fnx  . . . . . . . . . . . . . .	Proc
fn . . . . . . . . . . . . . . .	Proc
fopenW . . . . . . . . . . . . .	Func
fopen  . . . . . . . . . . . . .	Func
fprintc  . . . . . . . . . . . .	Proc
fprint . . . . . . . . . . . . .	Proc
fread  . . . . . . . . . . . . .	Func
free$  . . . . . . . . . . . . .	Proc
free . . . . . . . . . . . . . .	Proc
fseek  . . . . . . . . . . . . .	Func
fseteof  . . . . . . . . . . . .	Proc
fsize  . . . . . . . . . . . . .	Func
ftext  . . . . . . . . . . . . .	Proc
fwrite . . . . . . . . . . . . .	Func
getarg . . . . . . . . . . . . .	Func
getkey . . . . . . . . . . . . .	Proc
h2ub . . . . . . . . . . . . . .	Func
h2ud . . . . . . . . . . . . . .	Func
h2uq . . . . . . . . . . . . . .	Func
h2uw . . . . . . . . . . . . . .	Func
hDlgItem . . . . . . . . . . . .	Func
halloc . . . . . . . . . . . . .	Func
hex$ . . . . . . . . . . . . . .	Func
hfree  . . . . . . . . . . . . .	Proc
hsize  . . . . . . . . . . . . .	Func
hval . . . . . . . . . . . . . .	Func
inkey  . . . . . . . . . . . . .	Proc
input  . . . . . . . . . . . . .	Func
isregister . . . . . . . . . . .	Func
issize . . . . . . . . . . . . .	Func
jmp_table  . . . . . . . . . . .	Proc
lcase$ . . . . . . . . . . . . .	Func
left$  . . . . . . . . . . . . .	Func
len  . . . . . . . . . . . . . .	Func
linein$  . . . . . . . . . . . .	Func
lineout$ . . . . . . . . . . . .	Func
literal  . . . . . . . . . . . .	Func
lob  . . . . . . . . . . . . . .	Proc
loc  . . . . . . . . . . . . . .	Proc
lstrcat$ . . . . . . . . . . . .	Func
lstrcmp$ . . . . . . . . . . . .	Func
lstrcmpi$  . . . . . . . . . . .	Func
lstrcpy$ . . . . . . . . . . . .	Func
lstrcpyn$  . . . . . . . . . . .	Func
ltrim$ . . . . . . . . . . . . .	Func
m2m  . . . . . . . . . . . . . .	Proc
memalign . . . . . . . . . . . .	Proc
mkdir  . . . . . . . . . . . . .	Proc
mrm  . . . . . . . . . . . . . .	Proc
nops . . . . . . . . . . . . . .	Proc
num2str  . . . . . . . . . . . .	Func
op_type  . . . . . . . . . . . .	Func
popr . . . . . . . . . . . . . .	Proc
poptexti . . . . . . . . . . . .	Proc
poptext  . . . . . . . . . . . .	Proc
poptxt$  . . . . . . . . . . . .	Func
poptxt . . . . . . . . . . . . .	Proc
printc . . . . . . . . . . . . .	Proc
printf . . . . . . . . . . . . .	Func
print  . . . . . . . . . . . . .	Proc
pth$ . . . . . . . . . . . . . .	Func
ptr$ . . . . . . . . . . . . . .	Func
pushr  . . . . . . . . . . . . .	Proc
pushtexti  . . . . . . . . . . .	Proc
pushtext . . . . . . . . . . . .	Proc
pushtxt  . . . . . . . . . . . .	Proc
real10$  . . . . . . . . . . . .	Func
real4$ . . . . . . . . . . . . .	Func
real8$ . . . . . . . . . . . . .	Func
regsize  . . . . . . . . . . . .	Func
remove$  . . . . . . . . . . . .	Func
repargof . . . . . . . . . . . .	Func
repargs  . . . . . . . . . . . .	Func
repargv  . . . . . . . . . . . .	Func
reparg . . . . . . . . . . . . .	Func
return . . . . . . . . . . . . .	Proc
retval . . . . . . . . . . . . .	Proc
rev$ . . . . . . . . . . . . . .	Func
right$ . . . . . . . . . . . . .	Func
rmdir  . . . . . . . . . . . . .	Proc
rndir  . . . . . . . . . . . . .	Proc
rtrim$ . . . . . . . . . . . . .	Func
rvcx . . . . . . . . . . . . . .	Func
rvc  . . . . . . . . . . . . . .	Func
rvx  . . . . . . . . . . . . . .	Func
rv . . . . . . . . . . . . . . .	Func
sas  . . . . . . . . . . . . . .	Proc
sbyte$ . . . . . . . . . . . . .	Func
sdb$ . . . . . . . . . . . . . .	Func
sdd$ . . . . . . . . . . . . . .	Func
sdq$ . . . . . . . . . . . . . .	Func
sdw$ . . . . . . . . . . . . . .	Func
sdword$  . . . . . . . . . . . .	Func
setenv . . . . . . . . . . . . .	Proc
sqword$  . . . . . . . . . . . .	Func
sstr$  . . . . . . . . . . . . .	Func
stackframe . . . . . . . . . . .	Proc
stb  . . . . . . . . . . . . . .	Proc
str$ . . . . . . . . . . . . . .	Func
stralloc . . . . . . . . . . . .	Proc
strcat . . . . . . . . . . . . .	Proc
strfree  . . . . . . . . . . . .	Proc
sval . . . . . . . . . . . . . .	Func
switch$  . . . . . . . . . . . .	Proc
switchi$ . . . . . . . . . . . .	Proc
switch . . . . . . . . . . . . .	Proc
sword$ . . . . . . . . . . . . .	Func
szText . . . . . . . . . . . . .	Proc
time$  . . . . . . . . . . . . .	Func
trim$  . . . . . . . . . . . . .	Func
tstarg . . . . . . . . . . . . .	Func
tstline$ . . . . . . . . . . . .	Func
uadd$  . . . . . . . . . . . . .	Func
ubyte$ . . . . . . . . . . . . .	Func
uc$  . . . . . . . . . . . . . .	Func
ucCmd$ . . . . . . . . . . . . .	Func
ucase$ . . . . . . . . . . . . .	Func
ucc$ . . . . . . . . . . . . . .	Func
ucfm$  . . . . . . . . . . . . .	Func
ucmp$  . . . . . . . . . . . . .	Func
ucopy$ . . . . . . . . . . . . .	Proc
udb$ . . . . . . . . . . . . . .	Func
udd$ . . . . . . . . . . . . . .	Func
udq$ . . . . . . . . . . . . . .	Func
udw$ . . . . . . . . . . . . . .	Func
udword$  . . . . . . . . . . . .	Func
uhex$  . . . . . . . . . . . . .	Func
ulcase$  . . . . . . . . . . . .	Func
uleft$ . . . . . . . . . . . . .	Func
ulen$  . . . . . . . . . . . . .	Func
ultrim$  . . . . . . . . . . . .	Func
umid$  . . . . . . . . . . . . .	Func
uni$ . . . . . . . . . . . . . .	Func
uptr$  . . . . . . . . . . . . .	Func
uqword$  . . . . . . . . . . . .	Func
urev$  . . . . . . . . . . . . .	Func
uright$  . . . . . . . . . . . .	Func
urtrim$  . . . . . . . . . . . .	Func
uselib . . . . . . . . . . . . .	Proc
ustr$  . . . . . . . . . . . . .	Func
uucase$  . . . . . . . . . . . .	Func
uval . . . . . . . . . . . . . .	Func
uword$ . . . . . . . . . . . . .	Func
write  . . . . . . . . . . . . .	Proc
xbyte$ . . . . . . . . . . . . .	Func
xdb$ . . . . . . . . . . . . . .	Func
xdd$ . . . . . . . . . . . . . .	Func
xdq$ . . . . . . . . . . . . . .	Func
xdw$ . . . . . . . . . . . . . .	Func
xdword$  . . . . . . . . . . . .	Func
xqword$  . . . . . . . . . . . .	Func
xword$ . . . . . . . . . . . . .	Func
zero1  . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

RUN_SYNCH_PROCESS_EX . . . . . .	 00000014
  priority . . . . . . . . . . .	 00000000	 DWord
  timeout  . . . . . . . . . . .	 00000004	 DWord
  rvcreate . . . . . . . . . . .	 00000008	 DWord
  exitcode . . . . . . . . . . .	 0000000C	 DWord
  rvwait . . . . . . . . . . . .	 00000010	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

CONST  . . . . . . . . . . . . .	32 Bit	 0000008E Para	  Public  'CONST'	 ReadOnly
FLAT . . . . . . . . . . . . . .	GROUP
_BSS . . . . . . . . . . . . . .	32 Bit	 00000041 Para	  Public  'BSS'  
_DATA  . . . . . . . . . . . . .	32 Bit	 00000038 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 0000014D Para	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

AboutBox . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ActivateActCtx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ActivateKeyboardLayout . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddAtomA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddAtomW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddLocalAlternateComputerNameA .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddLocalAlternateComputerNameW .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddRefActCtx . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddVectoredExceptionHandler  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AdjustWindowRectEx . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AdjustWindowRect . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AllocConsole . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AllocateUserPhysicalPages  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Alloc  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AllowSetForegroundWindow . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AnimateWindow  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AnyPopup . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AppendMenuA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AppendMenuW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AreFileApisANSI  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ArgByNumber  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ArgClC . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ArgCl  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ArrangeIconicWindows . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AsciiDump  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AssignProcessToJobObject . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AttachConsole  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AttachThreadInput  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BMBinSearch  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BMHBinsearch . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BackupRead . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BackupSeek . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BackupWrite  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Beep . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BeginDeferWindowPos  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BeginPaint . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BeginUpdateResourceA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BeginUpdateResourceW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BinSearch  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BindIoCompletionCallback . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BitmapFromFile . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BitmapFromMemory . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BitmapFromPicture  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BitmapFromResource . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BlockInput . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BmpButton  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BringWindowToTop . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BroadcastSystemMessageA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BroadcastSystemMessageExA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BroadcastSystemMessageExW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BroadcastSystemMessageW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BrowseForFolder  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBAndTimeoutsA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBAndTimeoutsW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallMsgFilterA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallMsgFilterW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallNamedPipeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallNamedPipeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallNextHookEx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallWindowProcA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallWindowProcW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelDeviceWakeupRequest  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelIo . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelWaitableTimer  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CascadeChildWindows  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CascadeWindows . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeClipboardChain . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeDisplaySettingsA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeDisplaySettingsExA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeDisplaySettingsExW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeDisplaySettingsW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeMenuA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeMenuW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharLowerA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharLowerBuffA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharLowerBuffW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharLowerW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharNextA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharNextExA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharNextW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharPrevA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharPrevExA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharPrevW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharToOemA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharToOemBuffA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharToOemBuffW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharToOemW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharUpperA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharUpperBuffA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharUpperBuffW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CharUpperW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CheckDlgButton . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CheckMenuItem  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CheckMenuRadioItem . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CheckNameLegalDOS8Dot3A  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CheckNameLegalDOS8Dot3W  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CheckRadioButton . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CheckRemoteDebuggerPresent . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChildWindowFromPointEx . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChildWindowFromPoint . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClearCommBreak . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClearCommError . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClearScreen  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClientToScreen . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClipCursor . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseClipboard . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseDesktop . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseMMF . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseWindowStation . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseWindow  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Cmpi . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ColorDialog  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CombSortA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CombSortD  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CommConfigDialogA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CommConfigDialogW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CompareFileTime  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CompareStringA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CompareStringW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ConnectNamedPipe . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ContinueDebugEvent . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ConvertDefaultLocale . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ConvertFiberToThread . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ConvertThreadToFiber . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyAcceleratorTableA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyAcceleratorTableW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileExA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileExW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyIcon . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyImage  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyRect . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CountClipboardFormats  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateAcceleratorTableA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateAcceleratorTableW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateActCtxA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateActCtxW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateCaret  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateConsoleScreenBuffer  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateCursor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDesktopA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDesktopW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDialogIndirectParamA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDialogIndirectParamW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDialogParamA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDialogParamW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateEventA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateEventW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFiberEx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFiber  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileMappingA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileMappingW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateHardLinkA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateHardLinkW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateIconFromResourceEx . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateIconFromResource . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateIconIndirect . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateIcon . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateIoCompletionPort . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateJobObjectA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateJobObjectW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateJobSet . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMDIWindowA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMDIWindowW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMMF  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMailslotA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMailslotW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMemoryResourceNotification .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMenu . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMutexA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMutexW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateNamedPipeA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateNamedPipeW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreatePipe . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreatePopupMenu  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateProcessA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateProcessInternalWSecure . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateProcessW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateRemoteThread . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateSemaphoreA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateSemaphoreW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateTapePartition  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateThread . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateTimerQueue . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateToolhelp32Snapshot . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWaitableTimerA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWaitableTimerW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWindowExA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWindowExW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWindowStationA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWindowStationW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DbgWin32HeapFail . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DbgWin32HeapStat . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeAbandonTransaction  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeAccessData  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeAddData . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeClientTransaction . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeCmpStringHandles  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeConnectList . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeConnect . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeCreateDataHandle  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeCreateStringHandleA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeCreateStringHandleW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeDisconnectList  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeDisconnect  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeEnableCallback  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeFreeDataHandle  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeFreeStringHandle  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeGetData . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeGetLastError  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeImpersonateClient . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeInitializeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeInitializeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeKeepStringHandle  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeNameService . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdePostAdvise  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeQueryConvInfo . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeQueryNextServer . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeQueryStringA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeQueryStringW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeReconnect . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeSetQualityOfService . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeSetUserHandle . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeUnaccessData  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DdeUninitialize  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeactivateActCtx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DebugActiveProcessStop . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DebugActiveProcess . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DebugBreakProcess  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DebugBreak . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DebugSetProcessKillOnExit  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DecodePointer  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DecodeSystemPointer  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefDlgProcA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefDlgProcW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefFrameProcA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefFrameProcW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefMDIChildProcA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefMDIChildProcW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefRawInputProc  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefWindowProcA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefWindowProcW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeferWindowPos . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefineDosDeviceA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefineDosDeviceW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteAtom . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteCriticalSection  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteFiber  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteFileW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteMenu . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteTimerQueueEx . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteTimerQueue . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteVolumeMountPointA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteVolumeMountPointW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeregisterShellHookWindow  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DestroyAcceleratorTable  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DestroyCaret . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DestroyCursor  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DestroyIcon  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DestroyMenu  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DestroyWindow  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeviceIoControl  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DialogBoxIndirectParamA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DialogBoxIndirectParamW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DialogBoxParamA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DialogBoxParamW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisableProcessWindowsGhosting  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisableThreadLibraryCalls  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisconnectNamedPipe  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DispatchMessageA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DispatchMessageW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisplayBmp . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisplayIcon  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirListA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirListComboBoxA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirListComboBoxW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirListW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirSelectComboBoxExA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirSelectComboBoxExW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirSelectExA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DlgDirSelectExW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DnsHostnameToComputerNameA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DnsHostnameToComputerNameW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DosDateTimeToFileTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DragDetect . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DragObject . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawAnimatedRects  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawCaption  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawEdge . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawFocusRect  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawFrameControl . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawFrame  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawIconEx . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawIcon . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawMenuBar  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawStateA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawStateW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawTextA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawTextExA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawTextExW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawTextW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DuplicateHandle  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EditWndProc  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EmptyClipboard . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnableMenuItem . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnableScrollBar  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnableWindow . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EncodePointer  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EncodeSystemPointer  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndDeferWindowPos  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndDialog  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndMenu  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndPaint . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndTask  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndUpdateResourceA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndUpdateResourceW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnterCriticalSection . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoExA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoExW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumChildWindows . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumClipboardFormats . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDesktopWindows . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDesktopsA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDesktopsW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDisplayDevicesA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDisplayDevicesW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDisplayMonitors  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDisplaySettingsA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDisplaySettingsExA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDisplaySettingsExW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDisplaySettingsW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumLanguageGroupLocalesA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumLanguageGroupLocalesW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumPropsA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumPropsExA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumPropsExW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumPropsW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceLanguagesA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceLanguagesW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceNamesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceNamesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceTypesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceTypesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemCodePagesA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemCodePagesW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemGeoID  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLanguageGroupsA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLanguageGroupsW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLocalesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLocalesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumThreadWindows  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumTimeFormatsA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumTimeFormatsW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumUILanguagesA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumUILanguagesW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumWindowStationsA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumWindowStationsW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumWindows  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumerateLocalComputerNamesA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumerateLocalComputerNamesW . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EqualRect  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EraseTape  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EscapeCommFunction . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExcludeUpdateRgn . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitThread . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitWindowsEx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExpandEnvironmentStringsA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExpandEnvironmentStringsW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FatalAppExitA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FatalAppExitW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FatalExit  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToLocalFileTime  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillConsoleOutputAttribute . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillConsoleOutputCharacterA  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillConsoleOutputCharacterW  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillRect . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindActCtxSectionGuid  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindActCtxSectionStringA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindActCtxSectionStringW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindAtomA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindAtomW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindCloseChangeNotification  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindClose  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstChangeNotificationA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstChangeNotificationW . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileExA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileExW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeMountPointA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeMountPointW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextChangeNotification . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextFileA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextFileW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeMountPointA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeMountPointW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceExA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceExW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindVolumeClose  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindVolumeMountPointClose  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindWindowA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindWindowExA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindWindowExW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindWindowW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlashWindowEx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlashWindow  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatToStr2  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatToStr . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushFileBuffers . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushInstructionCache  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushViewOfFile  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FoldStringA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FoldStringW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FontDialog . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Frame3D  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FrameCtrl  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FrameGrp . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FrameRect  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FrameWindow  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeConsole  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeDDElParam  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeEnvironmentStringsA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeEnvironmentStringsW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeLibraryAndExitThread . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeLibrary  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeResource . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeUserPhysicalPages  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Free . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GenerateConsoleCtrlEvent . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetACP . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetActiveWindow  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAltTabInfoA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAltTabInfoW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAncestor  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAppPathW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAppPath . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAsyncKeyState . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAtomNameA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAtomNameW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetBinaryTypeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetBinaryTypeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCL  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCPInfoExA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCPInfoExW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCPInfo  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCalendarInfoA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCalendarInfoW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCapture . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCaretBlinkTime  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCaretPos  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassInfoA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassInfoExA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassInfoExW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassInfoW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassLongA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassLongW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassNameA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassNameW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClassWord . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClientRect  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipCursor  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipboardData . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipboardFormatNameA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipboardFormatNameW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipboardOwner  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipboardSequenceNumber . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipboardText . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetClipboardViewer . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComboBoxInfo  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommConfig  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommMask  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommModemStatus . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommProperties  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommState . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommTimeouts  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCompressedFileSizeA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCompressedFileSizeW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleDisplayMode  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleFontSize . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleOutputCP . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleProcessList  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleSelectionInfo  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleTitleW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleWindow . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrencyFormatA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrencyFormatW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentActCtx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentConsoleFont  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentDirectoryA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentDirectoryW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentProcessId  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentProcess  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentThreadId . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentThread . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCursorInfo  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCursorPos . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCursor  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDCEx  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDC  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateFormatA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateFormatW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDefaultCommConfigA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDefaultCommConfigW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDesktopWindow . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDevicePowerState  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDialogBaseUnits . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceExA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceExW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDlgCtrlID . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDlgItemInt  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDlgItemTextA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDlgItemTextW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDlgItem . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDllDirectoryA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDllDirectoryW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDoubleClickTime . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDriveTypeA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDriveTypeW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentStringsA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentStringsW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentVariableA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentVariableW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetErrDescription  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetExitCodeProcess . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetExitCodeThread  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesExA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesExW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileInformationByHandle . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileSizeEx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileSize  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileType  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFile  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFirmwareEnvironmentVariableA 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFirmwareEnvironmentVariableW 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFocus . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetForegroundWindow  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFullPathNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFullPathNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetGUIThreadInfo . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetGeoInfoA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetGeoInfoW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetGuiResources  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetHandleInformation . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetIP  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetIconInfo  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetInputDesktop  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetInputState  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKBCodePage  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyNameTextA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyNameTextW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyboardLayoutList  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyboardLayoutNameA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyboardLayoutNameW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyboardLayout  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyboardState . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyboardType  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLargestConsoleWindowSize  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastActivePopup . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastInputInfo . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLayeredWindowAttributes . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetListBoxInfo . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocaleInfoA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocaleInfoW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLogicalDriveStringsA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLogicalDriveStringsW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLogicalDrives . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLongPathNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLongPathNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMailslotInfo  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuBarInfo . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuCheckMarkDimensions . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuContextHelpId . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuDefaultItem . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuInfo  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuItemCount . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuItemID  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuItemInfoA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuItemInfoW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuItemRect  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuState . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuStringA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenuStringW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMenu  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMessageA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMessageExtraInfo  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMessagePos  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMessageTime . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMessageW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleFileNameA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleFileNameW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleHandleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleHandleExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleHandleExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleHandleW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMonitorInfoA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMonitorInfoW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMouseMovePointsEx . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNamedPipeHandleStateA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNamedPipeHandleStateW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNamedPipeInfo . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNativeSystemInfo  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNextDlgGroupItem  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNextDlgTabItem  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumaAvailableMemoryNode . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumaAvailableMemory . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumaHighestNodeNumber . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumaNodeProcessorMask . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumaProcessorMap  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumaProcessorNode . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberFormatA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberFormatW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleMouseButtons .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetOEMCP . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetOpenClipboardWindow . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetOverlappedResult  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetParent  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPathOnlyW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPathOnly  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPercent . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPriorityClass . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPriorityClipboardFormat . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileIntA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileIntW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionNamesA .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionNamesW .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStringA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStringW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStructA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStructW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcAddress . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessAffinityMask . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessDefaultLayout  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHandleCount  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeaps  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessId . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessIoCounters . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessPriorityBoost  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessShutdownParameters . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessTimes  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessVersion  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessWindowStation  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessWorkingSetSize . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileIntA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileIntW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileSectionA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileSectionW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileStringA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileStringW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPropA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPropW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetQueueStatus . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetQueuedCompletionStatus  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetRawInputBuffer  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetRawInputData  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetRawInputDeviceInfoA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetRawInputDeviceInfoW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetRawInputDeviceList  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetRegisteredRawInputDevices . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetScrollBarInfo . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetScrollInfo  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetScrollPos . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetScrollRange . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetShellWindow . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetShortPathNameA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetShortPathNameW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStartupInfoA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStartupInfoW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeExA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeExW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSubMenu . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSysColorBrush . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSysColor  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDefaultLCID . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDefaultLangID . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDefaultUILanguage . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDirectoryA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDirectoryW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemInfo  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemMenu  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemMetrics . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemPowerStatus . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemRegistryQuota . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTimeAdjustment  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTimeAsFileTime  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTimes . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemWindowsDirectoryA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemWindowsDirectoryW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemWow64DirectoryA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemWow64DirectoryW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTabbedTextExtentA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTabbedTextExtentW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTapeParameters  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTapePosition  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTapeStatus  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempFileNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempFileNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempPathA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempPathW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextInput . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadContext . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadDesktop . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadIOPendingFlag . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadLocale  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadPriorityBoost . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadPriority  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadSelectorEntry . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadTimes . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTimeFormatA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTimeFormatW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTimeZoneInformation . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTitleBarInfo  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTopWindow . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUpdateRect  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUpdateRgn . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserDefaultLCID . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserDefaultLangID . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserDefaultUILanguage . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserGeoID . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserObjectInformationA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserObjectInformationW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserObjectSecurity  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersionExA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersionExW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersion . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeInformationA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeInformationW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeNameForVolumeMountPointA 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeNameForVolumeMountPointW 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumePathNameA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumePathNameW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumePathNamesForVolumeNameA .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumePathNamesForVolumeNameW .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowContextHelpId . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowDC  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowInfo  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowLongA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowLongW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowModuleFileNameA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowModuleFileNameW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowPlacement . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowRect  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowRgnBox  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowRgn . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowTextA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowTextLengthA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowTextLengthW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowTextW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowThreadProcessId . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowWord  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowsDirectoryA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowsDirectoryW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindow  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWriteWatch  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalAddAtomA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalAddAtomW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalAlloc  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalCompact  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalDeleteAtom . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFindAtomA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFindAtomW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFix  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFlags  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFree . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalGetAtomNameA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalGetAtomNameW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalLock . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalMemoryStatusEx . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalMemoryStatus . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalReAlloc  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalSize . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalUnWire . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalUnfix  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalUnlock . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalWire . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GrayStringA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GrayStringW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32First  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32ListFirst  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32ListNext . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32Next . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCompact  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapLock . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapQueryInformation . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapReAlloc  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSetInformation . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapUnlock . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapValidate . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapWalk . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HexDump  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HideCaret  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HiliteMenuItem . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IMPGetIMEA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IMPGetIMEW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IMPQueryIMEA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IMPQueryIMEW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IMPSetIMEA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IMPSetIMEW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IPtoString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ImpersonateDdeClientWindow . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InSendMessageEx  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InSendMessage  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InString . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InflateRect  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitAtomTable  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitializeCriticalSectionAndSpinCount 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitializeCriticalSection  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitializeSListHead  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InsertMenuA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InsertMenuItemA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InsertMenuItemW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InsertMenuW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntDiv . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntMul . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntSqrt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedCompareExchange . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedDecrement . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedExchangeAdd . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedExchange  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedFlushSList  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedIncrement . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedPopEntrySList . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedPushEntrySList  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InternalGetWindowText  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntersectRect  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InvalidateRect . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InvalidateRgn  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InvertRect . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadCodePtr . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadHugeReadPtr . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadHugeWritePtr  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadReadPtr . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadStringPtrA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadStringPtrW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadWritePtr  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharAlphaA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharAlphaNumericA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharAlphaNumericW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharAlphaW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharLowerA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharLowerW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharUpperA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsCharUpperW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsChild  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsClipboardFormatAvailable . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDBCSLeadByteEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDBCSLeadByte . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDebuggerPresent  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDialogMessageA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDialogMessageW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDlgButtonChecked . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsGUIThread  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsHungAppWindow  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsIconic . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsMenu . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsProcessInJob . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsProcessorFeaturePresent  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsRectEmpty  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsSystemResumeAutomatic  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsValidCodePage  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsValidLanguageGroup . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsValidLocale  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsWinEventHookInstalled  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsWindowEnabled  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsWindowUnicode  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsWindowVisible  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsWindow . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsWow64Process . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsZoomed . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
KillTimer  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LCMapStringA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LCMapStringW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LeaveCriticalSection . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadAcceleratorsA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadAcceleratorsW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadBitmapA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadBitmapW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadCursorA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadCursorFromFileA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadCursorFromFileW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadCursorW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadIconA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadIconW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadImageA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadImageW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadKeyboardLayoutA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadKeyboardLayoutW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryExA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryExW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadList . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadMenuA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadMenuIndirectA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadMenuIndirectW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadMenuW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadModule . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadResource . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadStringA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadStringW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalAlloc . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalCompact . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFileTimeToFileTime  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFlags . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalLock  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalReAlloc . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalShrink  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalSize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalUnlock  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockFileEx . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockResource . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockSetForegroundWindow  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockWindowUpdate . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockWorkStation  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LookupIconIdFromDirectoryEx  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LookupIconIdFromDirectory  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapDialogRect  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapUserPhysicalPagesScatter  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapUserPhysicalPages . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapViewOfFileEx  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapViewOfFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapVirtualKeyA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapVirtualKeyExA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapVirtualKeyExW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapVirtualKeyW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapWindowPoints  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MemCopy  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MenuItemFromPoint  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBeep  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxExA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxExW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxIndirectA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxIndirectW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxTimeoutA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxTimeoutW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ModifyMenuA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ModifyMenuW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Module32FirstW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Module32NextW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MonitorFromPoint . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MonitorFromRect  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MonitorFromWindow  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileExA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileExW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileWithProgressA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileWithProgressW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveWindow . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgWaitForMultipleObjectsEx  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgWaitForMultipleObjects  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MulDiv . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MultiByteToWideChar  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
NameFromPathW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
NameFromPath . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
NotifyWinEvent . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
NumaVirtualQueryNode . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OemKeyScan . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OemToCharA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OemToCharBuffA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OemToCharBuffW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OemToCharW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OffsetRect . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenClipboard  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenDesktopA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenDesktopW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenEventA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenEventW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFileDialog . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFileMappingA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFileMappingW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenIcon . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputDesktop . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenJobObjectA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenJobObjectW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenMutexA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenMutexW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenSemaphoreA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenSemaphoreW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenThread . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenWaitableTimerA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenWaitableTimerW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenWindowStationA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenWindowStationW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputDebugStringA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputDebugStringW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PackDDElParam  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PageSetupDialog  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PaintDesktop . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekMessageA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekMessageW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekNamedPipe  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PostMessageA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PostMessageW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PostQueuedCompletionStatus . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PostQuitMessage  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PostThreadMessageA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PostThreadMessageW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrepareTape  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrintDialog  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrintWindow  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrivateExtractIconsA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrivateExtractIconsW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Process32FirstW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Process32NextW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ProcessIdToSessionId . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PtInRect . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PulseEvent . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PurgeComm  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryActCtxW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryDepthSList  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryDosDeviceA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryDosDeviceW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryInformationJobObject  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryMemoryResourceNotification 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryPerformanceCounter  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryPerformanceFrequency  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueueUserAPC . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueueUserWorkItem  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RaiseException . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputAttribute . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputCharacterA  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputCharacterW  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDirectoryChangesW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFileEx . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFileScatter  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadProcessMemory  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Read_File_In . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RealChildWindowFromPoint . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RealGetWindowClassA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RealGetWindowClassW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RedrawWindow . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterClassA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterClassExA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterClassExW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterClassW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterClipboardFormatA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterClipboardFormatW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterDeviceNotificationA  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterDeviceNotificationW  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterHotKey . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterRawInputDevices  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterShellHookWindow  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterWaitForSingleObjectEx  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterWaitForSingleObject  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterWindowMessageA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterWindowMessageW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReleaseActCtx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReleaseCapture . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReleaseDC  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReleaseMutex . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReleaseSemaphore . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveDirectoryA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveDirectoryW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveLocalAlternateComputerNameA 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveLocalAlternateComputerNameW 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveMenu . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemovePropA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemovePropW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveVectoredExceptionHandler .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReplaceFileA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReplaceFileW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReplyMessage . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RequestDeviceWakeup  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RequestWakeupLatency . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ResetEvent . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ResetWriteWatch  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RestoreLastError . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ResumeThread . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RetFontHandle  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReuseDDElParam . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RichEd1  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RichEd2  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RolData  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RorData  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlCaptureContext  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlCaptureStackBackTrace . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlFillMemory  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlMoveMemory  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlUnwind  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlZeroMemory  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SBMBinSearch . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SaveFileDialog . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScreenToClient . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScrollConsoleScreenBufferA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScrollConsoleScreenBufferW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScrollDC . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScrollWindowEx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScrollWindow . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SearchPathA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SearchPathW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendDlgItemMessageA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendDlgItemMessageW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendIMEMessageExA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendIMEMessageExW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendInput  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendMessageA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendMessageCallbackA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendMessageCallbackW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendMessageTimeoutA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendMessageTimeoutW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendMessageW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendNotifyMessageA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SendNotifyMessageW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetActiveWindow  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetBMcolor . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCalendarInfoA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCalendarInfoW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCapture . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCaretBlinkTime  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCaretPos  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetClassLongA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetClassLongW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetClassWord . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetClipboardData . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetClipboardText . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetClipboardViewer . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommBreak . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommConfig  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommMask  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommState . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommTimeouts  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleActiveScreenBuffer . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCtrlHandler  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursor . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleOutputCP . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCriticalSectionSpinCount  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCurrentDirectoryA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCurrentDirectoryW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCursorPos . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCursor  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDebugErrorLevel . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDefaultCommConfigA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDefaultCommConfigW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDeskWallpaper . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDlgItemInt  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDlgItemTextA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDlgItemTextW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDllDirectoryA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDllDirectoryW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDoubleClickTime . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEndOfFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEnvironmentVariableA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEnvironmentVariableW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetErrorMode . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEvent . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileApisToANSI  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileApisToOEM . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileAttributesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileAttributesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointerEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileShortNameA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileShortNameW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileValidData . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFirmwareEnvironmentVariableA 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFirmwareEnvironmentVariableW 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFocus . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetForegroundWindow  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetHandleCount . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetHandleInformation . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetInformationJobObject  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetKeyboardState . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLastErrorEx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLayeredWindowAttributes . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalPrimaryComputerNameA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalPrimaryComputerNameW . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocaleInfoA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocaleInfoW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMailslotInfo  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMenuContextHelpId . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMenuDefaultItem . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMenuInfo  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMenuItemBitmaps . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMenuItemInfoA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMenuItemInfoW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMenu  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMessageExtraInfo  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMessageQueue  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMessageWaitingIndicator . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetNamedPipeHandleState  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetParent  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetPriorityClass . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessAffinityMask . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessDefaultLayout  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessPriorityBoost  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessShutdownParameters . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessWindowStation  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessWorkingSetSize . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetPropA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetPropW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetRectEmpty . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetRect  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetScrollInfo  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetScrollPos . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetScrollRange . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetShellWindow . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSysColors . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSystemCursor  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSystemPowerState  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSystemTimeAdjustment  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTapeParameters  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTapePosition  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadAffinityMask  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadContext . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadDesktop . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadExecutionState  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadIdealProcessor  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadLocale  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadPriorityBoost . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadPriority  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTimeZoneInformation . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTimerQueueTimer . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTimer . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetUnhandledExceptionFilter  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetUserGeoID . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetUserObjectInformationA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetUserObjectInformationW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetUserObjectSecurity  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeLabelA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeLabelW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeMountPointA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeMountPointW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWaitableTimer . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWinEventHook  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowContextHelpId . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowLongA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowLongW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowPlacement . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowPos . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowRgn . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowTextA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowTextW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowWord  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowsHookA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowsHookExA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowsHookExW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWindowsHookW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetupComm  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowCaret  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowCursor . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowOwnedPopups  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowScrollBar  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowWindowAsync  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowWindow . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SignalObjectAndWait  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SizeofResource . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SleepEx  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdErrW  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdErr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdInW . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdIn  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdOutW  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdOut . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLen . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrToFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StripLF  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StripRangeI  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StripRangeX  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SubtractRect . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SuspendThread  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SwapMouseButton  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SwitchDesktop  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SwitchToFiber  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SwitchToThisWindow . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SwitchToThread . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemParametersInfoA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemParametersInfoW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToTzSpecificLocalTime 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TabbedTextOutA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TabbedTextOutW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TerminateJobObject . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TerminateProcess . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TerminateThread  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Thread32First  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Thread32Next . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TileChildWindows . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TileWindows  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsAlloc . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsFree  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsGetValue  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsSetValue  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ToAsciiEx  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ToAscii  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ToUnicodeEx  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ToUnicode  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Toolhelp32ReadProcessMemory  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TrackMouseEvent  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TrackPopupMenuEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TrackPopupMenu . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TransactNamedPipe  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TranslateAcceleratorA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TranslateAcceleratorW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TranslateMDISysAccel . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TranslateMessage . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TransmitCommChar . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TryEnterCriticalSection  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TzSpecificLocalTimeToSystemTime 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnhandledExceptionFilter . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnhookWinEvent . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnhookWindowsHookEx  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnhookWindowsHook  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnionRect  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnloadKeyboardLayout . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnlockFileEx . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnlockFile . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnmapViewOfFile  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnpackDDElParam  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterClassA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterClassW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterDeviceNotification . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterHotKey . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterWaitEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterWait . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UpdateLayeredWindow  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UpdateResourceA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UpdateResourceW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UpdateWindow . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UserHandleGrantAccess  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ValidateRect . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ValidateRgn  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerLanguageNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerLanguageNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerSetConditionMask  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerifyVersionInfoA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerifyVersionInfoW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerticalTile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualAllocEx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualAlloc . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualFreeEx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualFree  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualLock  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualProtectEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualProtect . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualQueryEx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualQuery . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualUnlock  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VkKeyScanA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VkKeyScanExA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VkKeyScanExW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VkKeyScanW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WINNLSEnableIME  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WINNLSGetEnableStatus  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WINNLSGetIMEHotkey . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WTSGetActiveConsoleSessionId . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitCommEvent  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForDebugEvent  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForInputIdle . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForMultipleObjectsEx . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForMultipleObjects . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForSingleObjectEx  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForSingleObject  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMessage  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitNamedPipeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitNamedPipeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WideCharToMultiByte  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WinExec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WinHelpA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WinHelpW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WindowFromDC . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WindowFromPoint  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WordCount  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleInputA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleInputW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterW . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFileEx  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFileGather  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileSectionA  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileSectionW  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStringA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStringW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStructA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStructW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProcessMemory . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileSectionA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileSectionW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileStringA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileStringW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteTapemark  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Write_To_Disk  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
XorData  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ZombifyActCtx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_hread . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_hwrite  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lclose  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lcreat  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_llseek  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lopen . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lread . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lwrite  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
a2dw . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
a2wc . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
acisort  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
aissort  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr2file . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr2mem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr2text . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr_add  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr_mul  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr_sub  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arralloc . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrbin . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrcnt . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrealloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrextnd . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrfile  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrfree  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrget . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrlen . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrset . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrtotal . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrtrunc . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arrtxt . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
asqsort  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
assort . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
atodw_ex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
atodw  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
atol . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
bin2byte_ex  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
bin2hex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
bstsorta . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
bstsortd . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
byt2bin_ex . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
byte_count . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ccsorta  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ccsortd  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
circle . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
cmpmem . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
create_array . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
cstsorta . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
cstsortd . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dcisort  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
decomment  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dissort  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dsqsort  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dssort . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dw2a . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dw2bin_ex  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dw2hex_ex  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dw2hex . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dwtoa  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
existW . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
exist  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
filesizeW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
filesize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
get_ml . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
getcl_ex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
hex2bin  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
hexflip32  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
htodw  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
isalphanum . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
isalpha  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
islower  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
isnumber . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
isupper  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
keybd_event  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lfcnt  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
line . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
load_drives  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
locate . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcatA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcatW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpiA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpiW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpyA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpyW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpynA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpynW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrlenA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrlenW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ltoa . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ltok . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
memfill  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
mouse_event  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nrQsortA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nrQsortD . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nrandom  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nseed  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ofCallBack . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
parse_line . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
partial  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
qssorta  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
qssortd  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
read_disk_fileW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
read_disk_file . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
readline . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ret_key  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
run_synch_process_ex . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
sfCallBack . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
shell_ex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
shell  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ssorta . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ssortd . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCatStr . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCmpi . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCmp  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCopy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLeft . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLen  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLower  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLtrim  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szMid  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szMonoSpace  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szMultiCat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
szRemove . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szRep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szRev  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szRight  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szRtrim  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szTrim . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szUpper  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szWcnt . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szappend . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
testreg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
tstline  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucArgByNum . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucCatStr . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucCmdTail  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucCmp  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucCopy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucFind . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucGetCL  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucLeft . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucLen  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucLower  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucLtrim  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucMid  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucMonoSpace  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucMultiCat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
ucOpenFileDialog . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucRemove . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucRep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucRev  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucRight  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucRtrim  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucSaveFileDialog . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucUpper  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucWcnt . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucappend . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ucgetline  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
udw2str  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ustr2dw  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
wait_key . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
wordreplace  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
wrd2bin_ex . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
write_disk_fileW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
write_disk_file  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
writeline  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
wshell . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wtok . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
wvsprintfA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
wvsprintfW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

$casflg  . . . . . . . . . . . .	Text   	 
$casstk  . . . . . . . . . . . .	Text   	 
$casvar  . . . . . . . . . . . .	Text   	 
$end_sw$ . . . . . . . . . . . .	Text   	 
$end_swi$  . . . . . . . . . . .	Text   	 
$sw_state$ . . . . . . . . . . .	Text   	 
$sw_statei$  . . . . . . . . . .	Text   	 
$test_val$ . . . . . . . . . . .	Text   	 
$test_vali$  . . . . . . . . . .	Text   	 
$text_stack$ . . . . . . . . . .	Text   	 #
$text_stacki$  . . . . . . . . .	Text   	 #
??0000 . . . . . . . . . . . . .	Byte	 0000000C _DATA	
??0001 . . . . . . . . . . . . .	Byte	 00000010 _DATA	
??0002 . . . . . . . . . . . . .	Byte	 00000014 _DATA	
??0003 . . . . . . . . . . . . .	Byte	 00000018 _DATA	
??0004 . . . . . . . . . . . . .	Byte	 0000001C _DATA	
??0005 . . . . . . . . . . . . .	Byte	 00000020 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
A1_  . . . . . . . . . . . . . .	Word	 00000004 CONST	
A1 . . . . . . . . . . . . . . .	Word	 00000002 CONST	
A2_  . . . . . . . . . . . . . .	DWord	 0000000E CONST	
A2 . . . . . . . . . . . . . . .	DWord	 0000000A CONST	
A3_  . . . . . . . . . . . . . .	QWord	 0000002A CONST	
A3 . . . . . . . . . . . . . . .	QWord	 00000022 CONST	
A_ . . . . . . . . . . . . . . .	Byte	 00000001 CONST	
AddAtom  . . . . . . . . . . . .	Text   	 AddAtomA
AddLocalAlternateComputerName  .	Text   	 AddLocalAlternateComputerNameA
AppendMenu . . . . . . . . . . .	Text   	 AppendMenuA
A  . . . . . . . . . . . . . . .	Byte	 00000000 CONST	
B1_  . . . . . . . . . . . . . .	Word	 00000008 CONST	
B1 . . . . . . . . . . . . . . .	Word	 00000006 CONST	
B2_  . . . . . . . . . . . . . .	DWord	 00000016 CONST	
B2 . . . . . . . . . . . . . . .	DWord	 00000012 CONST	
B3_  . . . . . . . . . . . . . .	QWord	 0000003A CONST	
B3 . . . . . . . . . . . . . . .	QWord	 00000032 CONST	
BeginUpdateResource  . . . . . .	Text   	 BeginUpdateResourceA
BroadcastSystemMessageEx . . . .	Text   	 BroadcastSystemMessageExA
BroadcastSystemMessage . . . . .	Text   	 BroadcastSystemMessageA
BuildCommDCBAndTimeouts  . . . .	Text   	 BuildCommDCBAndTimeoutsA
BuildCommDCB . . . . . . . . . .	Text   	 BuildCommDCBA
C2_  . . . . . . . . . . . . . .	DWord	 0000001E CONST	
C2 . . . . . . . . . . . . . . .	DWord	 0000001A CONST	
C3_  . . . . . . . . . . . . . .	QWord	 0000004A CONST	
C3 . . . . . . . . . . . . . . .	QWord	 00000042 CONST	
CASEELSE . . . . . . . . . . . .	Text   	 default
CASE . . . . . . . . . . . . . .	Text   	 case
CHDIR  . . . . . . . . . . . . .	Text   	 chdir
CallMsgFilter  . . . . . . . . .	Text   	 CallMsgFilterA
CallNamedPipe  . . . . . . . . .	Text   	 CallNamedPipeA
CallWindowProc . . . . . . . . .	Text   	 CallWindowProcA
CaseElse . . . . . . . . . . . .	Text   	 default
Caseelse . . . . . . . . . . . .	Text   	 default
Case . . . . . . . . . . . . . .	Text   	 case
ChangeDisplaySettingsEx  . . . .	Text   	 ChangeDisplaySettingsExA
ChangeDisplaySettings  . . . . .	Text   	 ChangeDisplaySettingsA
ChangeMenu . . . . . . . . . . .	Text   	 ChangeMenuA
CharLowerBuff  . . . . . . . . .	Text   	 CharLowerBuffA
CharLower  . . . . . . . . . . .	Text   	 CharLowerA
CharNextEx . . . . . . . . . . .	Text   	 CharNextExA
CharNext . . . . . . . . . . . .	Text   	 CharNextA
CharPrevEx . . . . . . . . . . .	Text   	 CharPrevExA
CharPrev . . . . . . . . . . . .	Text   	 CharPrevA
CharToOemBuff  . . . . . . . . .	Text   	 CharToOemBuffA
CharToOem  . . . . . . . . . . .	Text   	 CharToOemA
CharUpperBuff  . . . . . . . . .	Text   	 CharUpperBuffA
CharUpper  . . . . . . . . . . .	Text   	 CharUpperA
CheckNameLegalDOS8Dot3 . . . . .	Text   	 CheckNameLegalDOS8Dot3A
CommConfigDialog . . . . . . . .	Text   	 CommConfigDialogA
CompareString  . . . . . . . . .	Text   	 CompareStringA
CopyAcceleratorTable . . . . . .	Text   	 CopyAcceleratorTableA
CopyFileEx . . . . . . . . . . .	Text   	 CopyFileExA
CopyFile . . . . . . . . . . . .	Text   	 CopyFileA
CreateAcceleratorTable . . . . .	Text   	 CreateAcceleratorTableA
CreateActCtx . . . . . . . . . .	Text   	 CreateActCtxA
CreateDesktop  . . . . . . . . .	Text   	 CreateDesktopA
CreateDialogIndirectParam  . . .	Text   	 CreateDialogIndirectParamA
CreateDialogParam  . . . . . . .	Text   	 CreateDialogParamA
CreateDirectoryEx  . . . . . . .	Text   	 CreateDirectoryExA
CreateDirectory  . . . . . . . .	Text   	 CreateDirectoryA
CreateEvent  . . . . . . . . . .	Text   	 CreateEventA
CreateFileMapping  . . . . . . .	Text   	 CreateFileMappingA
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
CreateHardLink . . . . . . . . .	Text   	 CreateHardLinkA
CreateJobObject  . . . . . . . .	Text   	 CreateJobObjectA
CreateMDIWindow  . . . . . . . .	Text   	 CreateMDIWindowA
CreateMailslot . . . . . . . . .	Text   	 CreateMailslotA
CreateMutex  . . . . . . . . . .	Text   	 CreateMutexA
CreateNamedPipe  . . . . . . . .	Text   	 CreateNamedPipeA
CreateProcess  . . . . . . . . .	Text   	 CreateProcessA
CreateSemaphore  . . . . . . . .	Text   	 CreateSemaphoreA
CreateWaitableTimer  . . . . . .	Text   	 CreateWaitableTimerA
CreateWindowEx . . . . . . . . .	Text   	 CreateWindowExA
CreateWindowStation  . . . . . .	Text   	 CreateWindowStationA
D1_  . . . . . . . . . . . . . .	DWord	 00000056 CONST	
D1 . . . . . . . . . . . . . . .	DWord	 00000052 CONST	
DEFAULT  . . . . . . . . . . . .	Text   	 default
DdeCreateStringHandle  . . . . .	Text   	 DdeCreateStringHandleA
DdeInitialize  . . . . . . . . .	Text   	 DdeInitializeA
DdeQueryString . . . . . . . . .	Text   	 DdeQueryStringA
DefDlgProc . . . . . . . . . . .	Text   	 DefDlgProcA
DefFrameProc . . . . . . . . . .	Text   	 DefFrameProcA
DefMDIChildProc  . . . . . . . .	Text   	 DefMDIChildProcA
DefWindowProc  . . . . . . . . .	Text   	 DefWindowProcA
Default  . . . . . . . . . . . .	Text   	 default
DefineDosDevice  . . . . . . . .	Text   	 DefineDosDeviceA
DeleteFile . . . . . . . . . . .	Text   	 DeleteFileA
DeleteVolumeMountPoint . . . . .	Text   	 DeleteVolumeMountPointA
DialogBoxIndirectParam . . . . .	Text   	 DialogBoxIndirectParamA
DialogBoxParam . . . . . . . . .	Text   	 DialogBoxParamA
DispatchMessage  . . . . . . . .	Text   	 DispatchMessageA
DlgDirListComboBox . . . . . . .	Text   	 DlgDirListComboBoxA
DlgDirList . . . . . . . . . . .	Text   	 DlgDirListA
DlgDirSelectComboBoxEx . . . . .	Text   	 DlgDirSelectComboBoxExA
DlgDirSelectEx . . . . . . . . .	Text   	 DlgDirSelectExA
DnsHostnameToComputerName  . . .	Text   	 DnsHostnameToComputerNameA
DrawState  . . . . . . . . . . .	Text   	 DrawStateA
DrawTextEx . . . . . . . . . . .	Text   	 DrawTextExA
DrawText . . . . . . . . . . . .	Text   	 DrawTextA
D  . . . . . . . . . . . . . . .	QWord	 0000007E CONST	
ENDSEL . . . . . . . . . . . . .	Text   	 endsw
ENDSW  . . . . . . . . . . . . .	Text   	 endsw
E_ . . . . . . . . . . . . . . .	QWord	 00000062 CONST	
EndSw  . . . . . . . . . . . . .	Text   	 endsw
EndUpdateResource  . . . . . . .	Text   	 EndUpdateResourceA
Endsel . . . . . . . . . . . . .	Text   	 endsw
Endsw  . . . . . . . . . . . . .	Text   	 endsw
EnumCalendarInfoEx . . . . . . .	Text   	 EnumCalendarInfoExA
EnumCalendarInfo . . . . . . . .	Text   	 EnumCalendarInfoA
EnumDateFormatsEx  . . . . . . .	Text   	 EnumDateFormatsExA
EnumDateFormats  . . . . . . . .	Text   	 EnumDateFormatsA
EnumDesktops . . . . . . . . . .	Text   	 EnumDesktopsA
EnumDisplayDevices . . . . . . .	Text   	 EnumDisplayDevicesA
EnumDisplaySettingsEx  . . . . .	Text   	 EnumDisplaySettingsExA
EnumDisplaySettings  . . . . . .	Text   	 EnumDisplaySettingsA
EnumLanguageGroupLocales . . . .	Text   	 EnumLanguageGroupLocalesA
EnumPropsEx  . . . . . . . . . .	Text   	 EnumPropsExA
EnumProps  . . . . . . . . . . .	Text   	 EnumPropsA
EnumResourceLanguages  . . . . .	Text   	 EnumResourceLanguagesA
EnumResourceNames  . . . . . . .	Text   	 EnumResourceNamesA
EnumResourceTypes  . . . . . . .	Text   	 EnumResourceTypesA
EnumSystemCodePages  . . . . . .	Text   	 EnumSystemCodePagesA
EnumSystemLanguageGroups . . . .	Text   	 EnumSystemLanguageGroupsA
EnumSystemLocales  . . . . . . .	Text   	 EnumSystemLocalesA
EnumTimeFormats  . . . . . . . .	Text   	 EnumTimeFormatsA
EnumUILanguages  . . . . . . . .	Text   	 EnumUILanguagesA
EnumWindowStations . . . . . . .	Text   	 EnumWindowStationsA
EnumerateLocalComputerNames  . .	Text   	 EnumerateLocalComputerNamesA
ExpandEnvironmentStrings . . . .	Text   	 ExpandEnvironmentStringsA
E  . . . . . . . . . . . . . . .	QWord	 0000005A CONST	
F1_  . . . . . . . . . . . . . .	TWord	 00000074 CONST	
F1 . . . . . . . . . . . . . . .	TWord	 0000006A CONST	
FatalAppExit . . . . . . . . . .	Text   	 FatalAppExitA
FillConsoleOutputCharacter . . .	Text   	 FillConsoleOutputCharacterA
FindActCtxSectionString  . . . .	Text   	 FindActCtxSectionStringA
FindAtom . . . . . . . . . . . .	Text   	 FindAtomA
FindFirstChangeNotification  . .	Text   	 FindFirstChangeNotificationA
FindFirstFileEx  . . . . . . . .	Text   	 FindFirstFileExA
FindFirstFile  . . . . . . . . .	Text   	 FindFirstFileA
FindFirstVolumeMountPoint  . . .	Text   	 FindFirstVolumeMountPointA
FindFirstVolume  . . . . . . . .	Text   	 FindFirstVolumeA
FindNextFile . . . . . . . . . .	Text   	 FindNextFileA
FindNextVolumeMountPoint . . . .	Text   	 FindNextVolumeMountPointA
FindNextVolume . . . . . . . . .	Text   	 FindNextVolumeA
FindResourceEx . . . . . . . . .	Text   	 FindResourceExA
FindResource . . . . . . . . . .	Text   	 FindResourceA
FindWindowEx . . . . . . . . . .	Text   	 FindWindowExA
FindWindow . . . . . . . . . . .	Text   	 FindWindowA
FoldString . . . . . . . . . . .	Text   	 FoldStringA
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
FreeEnvironmentStrings . . . . .	Text   	 FreeEnvironmentStringsA
F  . . . . . . . . . . . . . . .	QWord	 00000086 CONST	
GetAltTabInfo  . . . . . . . . .	Text   	 GetAltTabInfoA
GetAtomName  . . . . . . . . . .	Text   	 GetAtomNameA
GetBinaryType  . . . . . . . . .	Text   	 GetBinaryTypeA
GetCPInfoEx  . . . . . . . . . .	Text   	 GetCPInfoExA
GetCalendarInfo  . . . . . . . .	Text   	 GetCalendarInfoA
GetClassInfoEx . . . . . . . . .	Text   	 GetClassInfoExA
GetClassInfo . . . . . . . . . .	Text   	 GetClassInfoA
GetClassLong . . . . . . . . . .	Text   	 GetClassLongA
GetClassName . . . . . . . . . .	Text   	 GetClassNameA
GetClipboardFormatName . . . . .	Text   	 GetClipboardFormatNameA
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
GetCompressedFileSize  . . . . .	Text   	 GetCompressedFileSizeA
GetComputerNameEx  . . . . . . .	Text   	 GetComputerNameExA
GetComputerName  . . . . . . . .	Text   	 GetComputerNameA
GetConsoleTitle  . . . . . . . .	Text   	 GetConsoleTitleA
GetCurrencyFormat  . . . . . . .	Text   	 GetCurrencyFormatA
GetCurrentDirectory  . . . . . .	Text   	 GetCurrentDirectoryA
GetDateFormat  . . . . . . . . .	Text   	 GetDateFormatA
GetDefaultCommConfig . . . . . .	Text   	 GetDefaultCommConfigA
GetDiskFreeSpaceEx . . . . . . .	Text   	 GetDiskFreeSpaceExA
GetDiskFreeSpace . . . . . . . .	Text   	 GetDiskFreeSpaceA
GetDlgItemText . . . . . . . . .	Text   	 GetDlgItemTextA
GetDllDirectory  . . . . . . . .	Text   	 GetDllDirectoryA
GetDriveType . . . . . . . . . .	Text   	 GetDriveTypeA
GetEnvironmentStrings  . . . . .	Text   	 GetEnvironmentStringsA
GetEnvironmentVariable . . . . .	Text   	 GetEnvironmentVariableA
GetFileAttributesEx  . . . . . .	Text   	 GetFileAttributesExA
GetFileAttributes  . . . . . . .	Text   	 GetFileAttributesA
GetFirmwareEnvironmentVariable .	Text   	 GetFirmwareEnvironmentVariableA
GetFullPathName  . . . . . . . .	Text   	 GetFullPathNameA
GetGeoInfo . . . . . . . . . . .	Text   	 GetGeoInfoA
GetKeyNameText . . . . . . . . .	Text   	 GetKeyNameTextA
GetKeyboardLayoutName  . . . . .	Text   	 GetKeyboardLayoutNameA
GetLocaleInfo  . . . . . . . . .	Text   	 GetLocaleInfoA
GetLogicalDriveStrings . . . . .	Text   	 GetLogicalDriveStringsA
GetLongPathName  . . . . . . . .	Text   	 GetLongPathNameA
GetMenuItemInfo  . . . . . . . .	Text   	 GetMenuItemInfoA
GetMenuString  . . . . . . . . .	Text   	 GetMenuStringA
GetMessage . . . . . . . . . . .	Text   	 GetMessageA
GetModuleFileName  . . . . . . .	Text   	 GetModuleFileNameA
GetModuleHandleEx  . . . . . . .	Text   	 GetModuleHandleExA
GetModuleHandle  . . . . . . . .	Text   	 GetModuleHandleA
GetMonitorInfo . . . . . . . . .	Text   	 GetMonitorInfoA
GetNamedPipeHandleState  . . . .	Text   	 GetNamedPipeHandleStateA
GetNumberFormat  . . . . . . . .	Text   	 GetNumberFormatA
GetPrivateProfileInt . . . . . .	Text   	 GetPrivateProfileIntA
GetPrivateProfileSectionNames  .	Text   	 GetPrivateProfileSectionNamesA
GetPrivateProfileSection . . . .	Text   	 GetPrivateProfileSectionA
GetPrivateProfileString  . . . .	Text   	 GetPrivateProfileStringA
GetPrivateProfileStruct  . . . .	Text   	 GetPrivateProfileStructA
GetProfileInt  . . . . . . . . .	Text   	 GetProfileIntA
GetProfileSection  . . . . . . .	Text   	 GetProfileSectionA
GetProfileString . . . . . . . .	Text   	 GetProfileStringA
GetProp  . . . . . . . . . . . .	Text   	 GetPropA
GetRawInputDeviceInfo  . . . . .	Text   	 GetRawInputDeviceInfoA
GetShortPathName . . . . . . . .	Text   	 GetShortPathNameA
GetStartupInfo . . . . . . . . .	Text   	 GetStartupInfoA
GetStringTypeEx  . . . . . . . .	Text   	 GetStringTypeExA
GetStringType  . . . . . . . . .	Text   	 GetStringTypeA
GetSystemDirectory . . . . . . .	Text   	 GetSystemDirectoryA
GetSystemWindowsDirectory  . . .	Text   	 GetSystemWindowsDirectoryA
GetSystemWow64Directory  . . . .	Text   	 GetSystemWow64DirectoryA
GetTabbedTextExtent  . . . . . .	Text   	 GetTabbedTextExtentA
GetTempFileName  . . . . . . . .	Text   	 GetTempFileNameA
GetTempPath  . . . . . . . . . .	Text   	 GetTempPathA
GetTimeFormat  . . . . . . . . .	Text   	 GetTimeFormatA
GetUserObjectInformation . . . .	Text   	 GetUserObjectInformationA
GetVersionEx . . . . . . . . . .	Text   	 GetVersionExA
GetVolumeInformation . . . . . .	Text   	 GetVolumeInformationA
GetVolumeNameForVolumeMountPoint .	Text   	 GetVolumeNameForVolumeMountPointA
GetVolumePathNamesForVolumeName 	Text   	 GetVolumePathNamesForVolumeNameA
GetVolumePathName  . . . . . . .	Text   	 GetVolumePathNameA
GetWindowLong  . . . . . . . . .	Text   	 GetWindowLongA
GetWindowModuleFileName  . . . .	Text   	 GetWindowModuleFileNameA
GetWindowTextLength  . . . . . .	Text   	 GetWindowTextLengthA
GetWindowText  . . . . . . . . .	Text   	 GetWindowTextA
GetWindowsDirectory  . . . . . .	Text   	 GetWindowsDirectoryA
GlobalAddAtom  . . . . . . . . .	Text   	 GlobalAddAtomA
GlobalFindAtom . . . . . . . . .	Text   	 GlobalFindAtomA
GlobalGetAtomName  . . . . . . .	Text   	 GlobalGetAtomNameA
GrayString . . . . . . . . . . .	Text   	 GrayStringA
IMPGetIME  . . . . . . . . . . .	Text   	 IMPGetIMEA
IMPQueryIME  . . . . . . . . . .	Text   	 IMPQueryIMEA
IMPSetIME  . . . . . . . . . . .	Text   	 IMPSetIMEA
InsertMenuItem . . . . . . . . .	Text   	 InsertMenuItemA
InsertMenu . . . . . . . . . . .	Text   	 InsertMenuA
IsBadStringPtr . . . . . . . . .	Text   	 IsBadStringPtrA
IsCharAlphaNumeric . . . . . . .	Text   	 IsCharAlphaNumericA
IsCharAlpha  . . . . . . . . . .	Text   	 IsCharAlphaA
IsCharLower  . . . . . . . . . .	Text   	 IsCharLowerA
IsCharUpper  . . . . . . . . . .	Text   	 IsCharUpperA
IsDialogMessage  . . . . . . . .	Text   	 IsDialogMessageA
KERNEL32_INC . . . . . . . . . .	Text   	 1
LCMapString  . . . . . . . . . .	Text   	 LCMapStringA
LOCALVAR . . . . . . . . . . . .	Text   	 LOCAL
LoadAccelerators . . . . . . . .	Text   	 LoadAcceleratorsA
LoadBitmap . . . . . . . . . . .	Text   	 LoadBitmapA
LoadCursorFromFile . . . . . . .	Text   	 LoadCursorFromFileA
LoadCursor . . . . . . . . . . .	Text   	 LoadCursorA
LoadIcon . . . . . . . . . . . .	Text   	 LoadIconA
LoadImage  . . . . . . . . . . .	Text   	 LoadImageA
LoadKeyboardLayout . . . . . . .	Text   	 LoadKeyboardLayoutA
LoadLibraryEx  . . . . . . . . .	Text   	 LoadLibraryExA
LoadLibrary  . . . . . . . . . .	Text   	 LoadLibraryA
LoadMenuIndirect . . . . . . . .	Text   	 LoadMenuIndirectA
LoadMenu . . . . . . . . . . . .	Text   	 LoadMenuA
LoadString . . . . . . . . . . .	Text   	 LoadStringA
MASM32_INC . . . . . . . . . . .	Text   	 1
MKDIR  . . . . . . . . . . . . .	Text   	 mkdir
MapVirtualKeyEx  . . . . . . . .	Text   	 MapVirtualKeyExA
MapVirtualKey  . . . . . . . . .	Text   	 MapVirtualKeyA
MessageBoxEx . . . . . . . . . .	Text   	 MessageBoxExA
MessageBoxIndirect . . . . . . .	Text   	 MessageBoxIndirectA
MessageBoxTimeout  . . . . . . .	Text   	 MessageBoxTimeoutA
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
ModifyMenu . . . . . . . . . . .	Text   	 ModifyMenuA
MoveFileEx . . . . . . . . . . .	Text   	 MoveFileExA
MoveFileWithProgress . . . . . .	Text   	 MoveFileWithProgressA
MoveFile . . . . . . . . . . . .	Text   	 MoveFileA
OemToCharBuff  . . . . . . . . .	Text   	 OemToCharBuffA
OemToChar  . . . . . . . . . . .	Text   	 OemToCharA
OpenDesktop  . . . . . . . . . .	Text   	 OpenDesktopA
OpenEvent  . . . . . . . . . . .	Text   	 OpenEventA
OpenFileMapping  . . . . . . . .	Text   	 OpenFileMappingA
OpenJobObject  . . . . . . . . .	Text   	 OpenJobObjectA
OpenMutex  . . . . . . . . . . .	Text   	 OpenMutexA
OpenSemaphore  . . . . . . . . .	Text   	 OpenSemaphoreA
OpenWaitableTimer  . . . . . . .	Text   	 OpenWaitableTimerA
OpenWindowStation  . . . . . . .	Text   	 OpenWindowStationA
OutputDebugString  . . . . . . .	Text   	 OutputDebugStringA
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
PeekMessage  . . . . . . . . . .	Text   	 PeekMessageA
PostMessage  . . . . . . . . . .	Text   	 PostMessageA
PostThreadMessage  . . . . . . .	Text   	 PostThreadMessageA
PrivateExtractIcons  . . . . . .	Text   	 PrivateExtractIconsA
QueryDosDevice . . . . . . . . .	Text   	 QueryDosDeviceA
RMDIR  . . . . . . . . . . . . .	Text   	 rmdir
RNDIR  . . . . . . . . . . . . .	Text   	 rndir
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsoleOutputCharacter . . .	Text   	 ReadConsoleOutputCharacterA
ReadConsoleOutput  . . . . . . .	Text   	 ReadConsoleOutputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
RealGetWindowClass . . . . . . .	Text   	 RealGetWindowClassA
RegisterClassEx  . . . . . . . .	Text   	 RegisterClassExA
RegisterClass  . . . . . . . . .	Text   	 RegisterClassA
RegisterClipboardFormat  . . . .	Text   	 RegisterClipboardFormatA
RegisterDeviceNotification . . .	Text   	 RegisterDeviceNotificationA
RegisterWindowMessage  . . . . .	Text   	 RegisterWindowMessageA
RemoveDirectory  . . . . . . . .	Text   	 RemoveDirectoryA
RemoveLocalAlternateComputerName .	Text   	 RemoveLocalAlternateComputerNameA
RemoveProp . . . . . . . . . . .	Text   	 RemovePropA
ReplaceFile  . . . . . . . . . .	Text   	 ReplaceFileA
SELECT . . . . . . . . . . . . .	Text   	 switch
SWITCH . . . . . . . . . . . . .	Text   	 switch
ScrollConsoleScreenBuffer  . . .	Text   	 ScrollConsoleScreenBufferA
SearchPath . . . . . . . . . . .	Text   	 SearchPathA
Select . . . . . . . . . . . . .	Text   	 switch
SendDlgItemMessage . . . . . . .	Text   	 SendDlgItemMessageA
SendIMEMessageEx . . . . . . . .	Text   	 SendIMEMessageExA
SendMessageCallback  . . . . . .	Text   	 SendMessageCallbackA
SendMessageTimeout . . . . . . .	Text   	 SendMessageTimeoutA
SendMessage  . . . . . . . . . .	Text   	 SendMessageA
SendNotifyMessage  . . . . . . .	Text   	 SendNotifyMessageA
SetCalendarInfo  . . . . . . . .	Text   	 SetCalendarInfoA
SetClassLong . . . . . . . . . .	Text   	 SetClassLongA
SetComputerNameEx  . . . . . . .	Text   	 SetComputerNameExA
SetComputerName  . . . . . . . .	Text   	 SetComputerNameA
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
SetCurrentDirectory  . . . . . .	Text   	 SetCurrentDirectoryA
SetDefaultCommConfig . . . . . .	Text   	 SetDefaultCommConfigA
SetDlgItemText . . . . . . . . .	Text   	 SetDlgItemTextA
SetDllDirectory  . . . . . . . .	Text   	 SetDllDirectoryA
SetEnvironmentVariable . . . . .	Text   	 SetEnvironmentVariableA
SetFileAttributes  . . . . . . .	Text   	 SetFileAttributesA
SetFileShortName . . . . . . . .	Text   	 SetFileShortNameA
SetFirmwareEnvironmentVariable .	Text   	 SetFirmwareEnvironmentVariableA
SetLocalPrimaryComputerName  . .	Text   	 SetLocalPrimaryComputerNameA
SetLocaleInfo  . . . . . . . . .	Text   	 SetLocaleInfoA
SetMenuItemInfo  . . . . . . . .	Text   	 SetMenuItemInfoA
SetProp  . . . . . . . . . . . .	Text   	 SetPropA
SetUserObjectInformation . . . .	Text   	 SetUserObjectInformationA
SetVolumeLabel . . . . . . . . .	Text   	 SetVolumeLabelA
SetVolumeMountPoint  . . . . . .	Text   	 SetVolumeMountPointA
SetWindowLong  . . . . . . . . .	Text   	 SetWindowLongA
SetWindowText  . . . . . . . . .	Text   	 SetWindowTextA
SetWindowsHookEx . . . . . . . .	Text   	 SetWindowsHookExA
SetWindowsHook . . . . . . . . .	Text   	 SetWindowsHookA
Switch . . . . . . . . . . . . .	Text   	 switch
SystemParametersInfo . . . . . .	Text   	 SystemParametersInfoA
TabbedTextOut  . . . . . . . . .	Text   	 TabbedTextOutA
TranslateAccelerator . . . . . .	Text   	 TranslateAcceleratorA
UCC  . . . . . . . . . . . . . .	Text   	 UCCSTR
UC . . . . . . . . . . . . . . .	Text   	 UCCSTR
USER32_INC . . . . . . . . . . .	Text   	 1
UnregisterClass  . . . . . . . .	Text   	 UnregisterClassA
UpdateResource . . . . . . . . .	Text   	 UpdateResourceA
VerLanguageName  . . . . . . . .	Text   	 VerLanguageNameA
VerifyVersionInfo  . . . . . . .	Text   	 VerifyVersionInfoA
VkKeyScanEx  . . . . . . . . . .	Text   	 VkKeyScanExA
VkKeyScan  . . . . . . . . . . .	Text   	 VkKeyScanA
WaitNamedPipe  . . . . . . . . .	Text   	 WaitNamedPipeA
WinHelp  . . . . . . . . . . . .	Text   	 WinHelpA
WriteConsoleInput  . . . . . . .	Text   	 WriteConsoleInputA
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsoleOutput . . . . . . .	Text   	 WriteConsoleOutputA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
WritePrivateProfileSection . . .	Text   	 WritePrivateProfileSectionA
WritePrivateProfileString  . . .	Text   	 WritePrivateProfileStringA
WritePrivateProfileStruct  . . .	Text   	 WritePrivateProfileStructA
WriteProfileSection  . . . . . .	Text   	 WriteProfileSectionA
WriteProfileString . . . . . . .	Text   	 WriteProfileStringA
_sw_cnt_ . . . . . . . . . . . .	Number	 00000000h   
_sw_cnti_  . . . . . . . . . . .	Number	 00000000h   
birthday . . . . . . . . . . . .	Byte	 00000000 _DATA	
buffer . . . . . . . . . . . . .	Byte	 00000000 _BSS	
caseelse . . . . . . . . . . . .	Text   	 default
cmpsi  . . . . . . . . . . . . .	Text   	 szCmpi
cmpstr . . . . . . . . . . . . .	Text   	 szCmp
endsel . . . . . . . . . . . . .	Text   	 endsw
format . . . . . . . . . . . . .	Byte	 00000009 _DATA	
istring  . . . . . . . . . . . .	Text   	 find$
lcase  . . . . . . . . . . . . .	Text   	 szLower
lnstr  . . . . . . . . . . . . .	Text   	 szLen
lstrcat  . . . . . . . . . . . .	Text   	 lstrcatA
lstrcmpi . . . . . . . . . . . .	Text   	 lstrcmpiA
lstrcmp  . . . . . . . . . . . .	Text   	 lstrcmpA
lstrcpyn . . . . . . . . . . . .	Text   	 lstrcpynA
lstrcpy  . . . . . . . . . . . .	Text   	 lstrcpyA
lstrlen  . . . . . . . . . . . .	Text   	 lstrlenA
lstr . . . . . . . . . . . . . .	Text   	 szLeft
ltrim  . . . . . . . . . . . . .	Text   	 szLtrim
mainStr  . . . . . . . . . . . .	Byte	 00000040 _BSS	
midstr . . . . . . . . . . . . .	Text   	 szMid
revstr . . . . . . . . . . . . .	Text   	 szRev
rstr . . . . . . . . . . . . . .	Text   	 szRight
rtrim  . . . . . . . . . . . . .	Text   	 szRtrim
start  . . . . . . . . . . . . .	L Near	 00000000 _TEXT	Public STDCALL
trim . . . . . . . . . . . . . .	Text   	 szTrim
ucase  . . . . . . . . . . . . .	Text   	 szUpper
val  . . . . . . . . . . . . . .	Text   	 uval
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
wvsprintf  . . . . . . . . . . .	Text   	 wvsprintfA

	   0 Warnings
	   0 Errors

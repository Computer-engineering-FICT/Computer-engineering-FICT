
                                - 35 -


            4.5.1  MBR, загрузочные сектора и таблица разделов

     Информация о разделении жесткого диска находится в первом
секторе (т.е. в первом секторе первой дорожки первого диска). Этот
сектор называется MBR (сокращение от Master Boot Record) этого
диска. При загрузке компьютера BIOS загружает его в память и
выполняет. MBR содержит небольшую программу, которая считывает
таблицу разделов, находит активный раздел (т.е. раздел, отмеченный
как загрузочный) и считывает первый сектор этого раздела, который
называется загрузочным сектором (MBR также является загрузочным
сектором, но он выполняет специальные функции и поэтому имеет
отдельное название). Этот сектор содержит другую небольшую
программу, которая, в свою очередь, считывает начальную часть
операционной системы, расположенной в этом разделе, а затем
выполняет ее.

     Схема разделения не встроена в оборудование или даже в BIOS.
Это только стандарт, которого придерживается большое количество
операционных систем. Не все системы поддерживают его, но они
являются исключениями. Некоторые системы поддерживают разделение,
но они занимают всего один раздел на диске и используют свою
внутреннюю схему разделения в пределах используемого раздела.
Такие операционные системы нормально работают с другими системами
(включая Linux), которые находятся на том же диске. Но те
операционные системы, которые не поддерживают разделы, не могут
быть установлены вместе с другими системами на одном диске.

     Из мер предосторожности следует записать таблицу разделов.
Если эта таблица каким-либо образом повредится, то все файлы
останутся в сохранности (испорченная таблица разделов может быть
исправлена при помощи программы fdisk).

               4.5.2  Расширенные и логические разделы

     Изначально, в схеме разделения жесткого диска в PC
допускалось использование только четырех разделов. Но вскоре этого
оказалось недостаточно, частично по причине того, что многим для

                                - 36 -

работы требуется более четырех операционных систем (например,
Linux, MS-DOS, OS/2, Minix, FreeBSD, NetBSD, Windows/NT и т.д.),
но в основном из-за того, что одной системой используется
несколько разделов. Например, в системе Linux swap-область чаще
всего размещается в отдельном разделе (а не в основном разделе
Linux) для повышения скорости обмена (см. ниже).

     Для решения этой проблемы была разработана схема,
использующая расширенные разделы. Она позволяет разбивать основной
раздел на подразделы. Основной раздел, разбитый таким образом,
называется расширенным разделом, а подразделы называются
логическими разделами. Они функционируют так же, как и основные
разделы, различие состоит в схеме их создания.

     Ниже дан пpимеp pазбиения жеского диска на pазделы. Весь диск
разбит на три основных раздела, второй из которых разбит на два
логических. Часть диска не используется вообще. Весь диск, как
целое, и каждый основной раздел имеют свой загрузочный сектор.

  имммммммммммммммммммммммммммммммммммммм»
  є MBR                                  є
  лмммммммммммммммммммммммммммммммммммммм№ддддддддддддд
  є Загрузочный сектор                   є
  є--------------------------------------є  Основной
  є                                      є
  є Область данных раздела               є   раздел
  є                                      є
  лмммммммммммммммммммммммммммммммммммммм№ддддддддддддд
  є Загрузочный сектор                   є           Ё
  єддддддддддддддддддддддддддддддддддддддє           Ё
  є Неиспользуемый загрузочный сектор    є ЛогическийЁ
  є--------------------------------------є           Ё
  є                                      є   раздел  Ё
  є Область данных раздела               є           Ё
  є                                      є           Ё Расширенный
  єддддддддддддддддддддддддддддддддддддддєдддддддддддґ
  є Неиспользуемый загрузочный сектор    є           Ё   раздел
  є--------------------------------------є ЛогическийЁ

                                - 37 -

  є                                      є           Ё
  є Область данных раздела               є   раздел  Ё
  є                                      є           Ё
  лмммммммммммммммммммммммммммммммммммммм№ддддддддддддд
  є                                      є
  є Неиспользуемое дисковое пространство є
  є                                      є
  лмммммммммммммммммммммммммммммммммммммм№ддддддддддддд
  є Загрузочный сектор                   є
  є--------------------------------------є  Основной
  є                                      є
  є Область данных раздела               є   раздел
  є                                      є
  хммммммммммммммммммммммммммммммммммммммјддддддддддддд


                        4.5.3    Типы разделов

     Таблицы разделов (одна находится в MBR, другие используются
для расширенных разделов) содержат один байт для каждого раздела,
который указывает тип раздела. Это позволяет определить
операционную систему, которая использует раздел или для чего он
используется во избежание случайного размещения двух систем на
одном разделе. Однако, в действительности, операционные системы
игнорируют байт типа раздела. Например, система Linux вообще не
имеет представления о его существовании. Хуже того, некоторые
системы неправильно его интерпретируют (по крайней мере, некоторые
версии DR-DOS игнорируют самый важный бит этого байта, в отличие
от других).

     Не существует никаких стандартов, касающихся значений этих
байтов, хотя некоторые общепринятые значения приведены в таблице
ниже. Такую же информацию предоставляет программа Linux fdisk.

0 пустой раздел          40 Venix 80286          94 Amoeba BBT
1 DOS 12-битная FAT      51 Novell               a5 BSD/386
2 XENIX root             52 Microport            b7 BSDI fs
3 XENIX usr              63 GNU HURD             b8 BSDI swap-область

                                - 38 -

4 DOS 16-бит (<32Мб)     64 Novell               c7 Syrinx
5 расширенный            75 PC/IX                db CP/M
6 DOS 16-бит (>=32Мб)    80 Old MINIX            e1 DOS
7 OS/2 HPFS              81 Linux/MINIX          e3 DOS r/o
8 AIX                    82 Linux swap-область   f2 DOS дополнительный
9 AIX загрузочный        83 Linux                ff BBT
a OS/2 загрузочный       93 Amoeba

                4.5.4   Разделение жесткого диска

     Существует много программ, позволяющих создавать и удалять
разделы. У большинства операционных систем имеются свои
собственные и разумнее всего пользоваться именно такими
программами. Чаще всего эта программа называется fdisk (как и в
случае Linux). Особенности работы с ней рассмотрены в ее
руководстве. Команда cfdisk подобна fdisk, только в первой
используется полноэкранный интерфейс.

     При pаботе с IDE дисками, загрузочный раздел (раздел, в
котором находятся файлы, используемые при загрузке и само ядро)
должен полностью располагаться в пределах первых 1024 цилиндров,
потому как во время загрузки работа с диском происходит через BIOS
(перед переходом системы в защищенный режим), а BIOS не может
оперировать с цилиндрами, номер которых больше, чем 1024. Иногда
представляется возможным использование загрузочного раздела, лишь
частично расположенного в пределах первых 1024 цилиндров. Данный
метод работает до тех пор, пока все файлы, считываемые посредством
BIOS, находятся в пределах 1024 цилиндров. Так как это сделать
довольно сложно, то пpименение этого метода не рекомедуется.
Сложно предугадать, когда после дефрагментации или сбрасывании
содержимого буфера на диск система перестанет загружаться. Поэтому
следует удостовериться в том, что загрузочный раздел расположен в
пределах первых 1024 цилиндров.

     Некоторые последние версии BIOS и недавние модели IDE дисков
в действительности позволяют pаботать с цилиндрами, номер которых
превышает 1024.


                                - 39 -

     Каждый раздел должен содержать четное количество секторов,
так как в системе Linux используются блоки размером в 1 Кб, т.е.
два сектора. Нечетное количество секторов приведет к тому, что
последний из них будет неиспользован. Это ни на что не влияет, но
пpи запуске fdisk будет выдано пpедупpеждение.

     При изменении размера раздела обычно требуется сначала
сделать резервную копию всей необходимой информации, удалить
раздел, создать новый раздел, а затем восстановить всю сохраненную
информацию на новый раздел. Хотя существует программа для MS-DOS
под названием fips, которая позволяет изменять объем раздела без
резервного копирования, но для других файловых систем эту опеpацию
необходимо пpоизводить.

                  4.5.5  Файлы устройств и разделы

     Каждому основному и расширенному разделу соответствует
отдельный файл устpойства. Существует соглашение для имен подобных
файлов, которое состоит в добавлении номера раздела к имени файла
самого диска. 1-4 разделы являются основными (вне зависимости от
того, сколько существует основных pазделов), а 5-8 - логическими
(вне зависимости от того, к какому основному разделу они
относятся). Например, /dev/hda1 соответствует первому основному
разделу первого IDE жесткого диска, а /dev/sdb7 - третьему
расширенному разделу второго SCSI диска.


                     4.6   Файловые системы

              4.6.1  Что такое файловая система?

     Файловая система - это методы и структуры данных, которые
используются операционной системой для хранения файлов на диске
или его разделе. О файловой системе также говорят, ссылаясь на
раздел или диск, используемый для хранения файлов или тип файловой
системы.

     Нужно видеть разницу между диском или разделом и

                                - 40 -

установленной на нем файловой системой. Некоторые программы
(например, программы установки файловой системы) при обращении к
диску или разделу используют прямой доступ к секторам. Если на
этом месте была файловая система, то она будет серьезно
повреждена. Большинство программ взаимодействуют с диском
посредством файловой системы, и, следовательно, их работа будет
нарушена, если на разделе или диске никакая система не установлена
(или тип файловой системы не соответствует требуемуму).

     Перед тем, как раздел или диск могут быть использованы в
качестве файловой системы, она должна быть инициализирована, а
требуемые данные перенесены на этот диск. Этот процесс называется
созданием файловой системы.

     У большей части файловых систем UNIX сходная структура, а их
некоторые особенности очень мало различаются. Основными понятиями
являются: суперблок, индексный дескриптор (inode), блок данных,
блок каталога и косвенный блок. В суперблоке содержится информация
о файловой системе в целом, например, ее размер (точная информация
зависит от типа файловой системы). В индексном дескрипторе
хранится вся информация о файле, кроме его имени. Имя файла
хранится в блоке каталога, вместе с номером дескриптора. Запись
каталога содержит имя файла и номер индексного дескриптора
соответствующего файла. В этом дескрипторе хранятся номера
нескольких блоков данных, которые используются для хранения самого
файла. В inode есть место только для нескольких номеров блоков
данных, однако, если требуется большее количество, то пространство
для указателей на блоки данных динамически выделяется. Такие блоки
называются косвенными. Для того, чтобы найти блок данных, нужно
сначала найти его номер в косвенном блоке.

     В файловых системах UNIX обычно имеется возможность создания
дыр в файлах (это можно сделать с помощью команды lseek(2), см.
руководство). Это означает, что файловая система предоставляет
ложную информацию о том, что в каком-то месте в файле содержатся
нулевые байты, но в действительности для этого не выделяются
сектора (это означает, что файл будет занимать несколько меньше
места на диске). Это часто используется особенно в небольших

                                - 41 -

двоичных программах, библиотек Linux, в некоторых базах данных и в
других отдельных случаях. (Дыры реализуются хранением специального
значения в косвенном блоке или индексном дескрипторе вместо адреса
блока данных. Это специальное значение показывает, что для данной
части файла блоки данных не размещены и, следовательно, что в
файле есть дыра.)

     Использование дыр достаточно эффективно. На компьютере с
общим дисковым пространством в 200 Мб, простые измерения
показывают, что применение дыр дает экономию в 4 Мб. Однако, эти
измерения проводились на системе, где было установлено
относительно мало программ и отсутствовали файлы баз данных. Метод
измерения дыр рассмотрен в приложении B.

                      4.6.2   Типы файловых систем

     Linux поддерживает несколько типов файловых систем. Наиболее
важные из них рассмотрены ниже.

minix     Считается самой старой и самой надежной файловой системой,
но достаточно ограниченной в своих возможностях (у файлов
отсутствуют некоторые временные параметры, длина имени файла
ограничена 30-ю символами) и доступных объемах (максимум 64 Мб на
одну файловую систему).

xia       Модифицированная версия системы minix, в которой увеличена
максимальная длина имени файла и размер файловой системы, хотя она
не pеализует никаких новых возможностей.

ext2      Наиболее богатая функциональными возможностями файловая
система из семейства совместимых с Linux. На данный момент
считается самой популярной системой. Она разработана с учетом
совместимости с последующими версиями, поэтому для установки новой
версии кода системы не требуется устанавливать ее заново.

ext       Предыдущая версия системы ext2, не совместима с последующими
версиями. В настоящее время она очень редко включается в пакеты
новых поставляемых систем, т.к. большинство пользователей сейчас

                                - 42 -

пользуются системой ext2.

     В дополнение к рассмотренным выше, в Linux включена поддержка
еще некоторых файловых систем для обеспечения обмена файлами между
другими операционными системами. Эти файловые системы работают
также, как и описанные выше, кроме того, что их функциональные
возможности могут быть значительно ограничены по сравнению с
возможностями, обычно предоставляемыми файловыми системами UNIX.

msdos     Обеспечивается совместимость с системой MS-DOS (а также
OS/2 и Windows NT).

umsdos    Расширяет возможности драйвера файловой системы MS-DOS
для Linux таким образом, что при работе в Linux, имеется
возможность работы с именами файлов нестандартной длины, просмотра
прав доступа к файлу, ссылок, имени пользователя, которому
принадлежит файл, а также оперирование с файлами устройств. Это
позволяет использовать обычную систему MS-DOS, так, как если бы
это была система Linux. Таким образом, исключается необходимость
создания отдельного раздела для Linux.

iso9660   Стандартная файловая система для CD-ROM. Довольно
популярное развитие стандарта CD-ROM, выполненное Rock Ridge'м,
которое обеспечивает автоматическую поддержку имен файлов
нестандартной длины.

nfs       Сетевая файловая система, обеспечивающая разделение
одной файловой системы между несколькими компьютерами для
предоставления доступа к ее файлам со всех машин.

hpfs      Файловая система OS/2.

sysv      Файловые системы System V/386, Coherent и Xenix.


     Также существует файловая система proc, которая обычно
доступна через каталог /proc. В действительности, она не является
файловой системой, хотя по ее структуре сложно обнаружить разницу.

                                - 43 -

Эта система позволяет получить доступ к определенным структурам
данных ядра, к таким, как список процессов (отсюда название). Все
эти структуры выглядят как файловая система и ими можно
оперировать обычными средствами работы с файловой системой.
Например, для получения списка всех процессов, используется
следующая команда:

ttyp5 root ~ $ ls -l /proc
total 0
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 1
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 63
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 94
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 95
dr-xr-xr-x   4 root     users           0 Jan 31 20:37 98
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 99
-r--r--r--   1 root     root            0 Jan 31 20:37 devices
-r--r--r--   1 root     root            0 Jan 31 20:37 dma
-r--r--r--   1 root     root            0 Jan 31 20:37 filesystems
-r--r--r--   1 root     root            0 Jan 31 20:37 interrupts
-r--------   1 root     root      8654848 Jan 31 20:37 kcore
-r--r--r--   1 root     root            0 Jan 31 11:50 kmsg
-r--r--r--   1 root     root            0 Jan 31 20:37 ksyms
-r--r--r--   1 root     root            0 Jan 31 11:51 loadavg
-r--r--r--   1 root     root            0 Jan 31 20:37 meminfo
-r--r--r--   1 root     root            0 Jan 31 20:37 modules
dr-xr-xr-x   2 root     root            0 Jan 31 20:37 net
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 self
-r--r--r--   1 root     root            0 Jan 31 20:37 stat
-r--r--r--   1 root     root            0 Jan 31 20:37 uptime
-r--r--r--   1 root     root            0 Jan 31 20:37 version
ttyp5 root ~ $

(В действительности, должно быть еще несколько файлов, не
соответствующих процессам, однако, этот пример немного укорочен.)

     Хотя система /proc и называется файловой, ни одна ее часть не
взаимодействует с диском. Она существует только в представлении
ядра и при попытке обращения к какой-либо ее части, создается

                                - 44 -

впечатление, что эта часть где-то существует, хотя в
действительности это не так. Даже если существует файл /proc/kmem
в несколько мегабайт, он не занимает места но диске.

             4.6.3  Какую файловую систему устанавливать?

     Обычно мало смысла в пpименении нескольких разных файловых
систем. В настоящее время наиболее популярной считается система
ext2fs и, возможно, является наилучшим выбором. В зависимости от
различных параметров (скорость, производительность, надежность,
совместимость и др.) может оказаться, что установка другой
файловой системы будет более приемлемым вариантом.

                  4.6.4  Установка файловой системы

     Файловая система устанавливается, т.е. инициализируется, при
помощи команды mkfs(8). В действительности, существуют отдельные
программы для каждого типа файловой системы. Команда mkfs только
запускает требуемую программу в зависимости от типа
устанавливаемой системы. Тип файловой системы указывается при
помощи опции -t fstype.

     Параметры, передаваемые программам, вызываемым mkfs, слегка
различаются. Наиболее важные из них рассмотрены ниже (для более
подробной информации см. руководство).

-t fstype     Указывается тип файловой системы.

-c            Производится поиск плохих блоков и, соответственно,
инициализация списка плохих блоков.

-l filename   Считывается начальный список плохих блоков из файла
filename.

     Для установки файловой системы ext2 на дискету, используется
следующая последовательность команд:

ttyp5 root ~ $ fdformat -n /dev/fd0H1440

                                - 45 -

Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
ttyp5 root ~ $ badblocks /dev/fd0H1440 1440 > bad-blocks
ttyp5 root ~ $ mkfs -t ext2 -l bad-blocks /dev/fd0H1440
mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group

360 inodes per group
Writing inode tables: done
Writing superblocks and filesystem accounting information: done
ttyp5 root ~ $

     В первую очередь дискета форматируется (параметр -n
предотвращает проверку на наличие плохих блоков). Затем
производится поиск плохих блоков при помощи команды badblocks,
вывод которой перенаправлен в файл bad-blocks. И, наконец,
файловая система устанавливается с инициализацией списка найденных
плохих блоков.

     Вместо использования badblocks, команде mkfs может быть
указан параметр -c, как это видно из примера, рассмотренного ниже.

ttyp5 root ~ $ mkfs -t ext2 -c /dev/fd0H1440
mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

                                - 46 -


Checking for bad blocks (read-only test): done
Writing inode tables: done
Writing superblocks and filesystem accounting information: done
ttyp5 root ~ $

     Указание параметра -c намного удобнее, чем применение команды
badblocks, но ее использование необходимо для проверки файловой
системы после ее установки.

     Установка файловых систем на жесткий диск или его раздел
аналогична установке на дискету, исключая форматирование.

                 4.6.5    Монтирование и демонтирование

     Перед работой с файловой системой, она должна быть
смонтирована. При этом операционная система выполняет некоторые
действия, обеспечивающие функционирование монтируемой системы. Так
как все файлы в системе UNIX принадлежат одной структуре
каталогов, то эта операция обеспечивает работу с файловой
системой, как с каталогом уже смонтированной.

     Рассмотрим три различные файловые системы. Если две последние
системы (2-ю и 3-ю) соответственно смонтировать к каталогам /home
и /usr первой системы, то в итоге образуется файловая система с
единой структурой каталогов (4).

1]                  2]                   3]

/ ддбддддд bin      / ддбдддддд abc      / ддбдддддд bin
    Ё                   Ё                    Ё
    цддддд dev          цдддддд liw          цдддддд etc
    Ё                   Ё                    Ё
    цддддд home         юдддддд ftp          юдддддд lib
    Ё
    цддддд etc
    Ё
    цддддд lib

                                - 47 -

    Ё
    юддддд usr

4]
/ ддбдддбд usr
    Ё   Ё
    Ё   цдддддд lib
    Ё   Ё
    Ё   цдддддд etc
    Ё   Ё
    Ё   юдддддд bin
    Ё
    цддддд lib
    Ё
    цддддд etc
    Ё
    цдддбд home
    Ё   Ё
    Ё   цдддддд ftp
    Ё   Ё
    Ё   цдддддд liw
    Ё   Ё
    Ё   юдддддд abc
    Ё
    цддддд bin
    Ё
    юддддд dev


     В примере, рассмотреном ниже, показано, как это сделать.

ttyp5 root ~ $ mount /dev/hda2 /home
ttyp5 root ~ $ mount /dev/hda3 /usr
ttyp5 root ~ $

     Команда mount(8) принимает два параметра. Первый их них -
файл устройства, соответствующий диску или разделу, на котором
раположена файловая система. Вторым параметром является имя

                                - 48 -

каталога, к которому будет монтироваться система. После выполнения
этих команд содержимое файловых систем отображается в каталогах
/home и /usr соответственно. Также можно сказать, что раздел
/dev/hda2 смонтирован к каталогу /home, а /dev/hda3 - к каталогу
/usr. Существует различие между файлом устройства, /dev/hda2, и
монтируемым каталогом, /home. Файл устройства предоставляет доступ
к 'сырым' данным, расположенным на диске, а монтируемый каталог -
к файлам. Такой каталог называется узлом монтирования.

     Монтируемый каталог не обязательно должен быть пустым, хотя
он должен существовать. Однако все файлы, в нем расположенные,
будут недоступны после монтирования файловой системы. (Открытые
ранее файлы будут также доступны, а файлы, являющиеся жесткими
ссылками из других каталогов, будут доступны с использованием имен
ссылок.) Таким образом, никакого ущерба не наносится и это даже
может быть полезно. Например, некоторые делают каталог /tmp
символической ссылкой на каталог /usr/tmp. При загрузке системы,
когда файловая система /usr не смонтирована, каталог размещается в
системе root. После того, как /usr смонтирована, каталог /usr/tmp,
расположенный в файловой системе root, становится недоступным.
Если же /usr/tmp не существует в системе root, то перед
монтированием /usr создание и pабота с временными файлами будет
невозможна.

     Для защиты файловой системы от записи, команда mount
запускается с опцией -r, после чего монтирование производится в
режиме read-only. После этого ядро пресекает любые попытки записи,
включая модификацию времени доступа к файлам в индексном
дескрипторе. Монтирование с защитой от записи используется при
работе с такими устройствами, как CD-ROM.

     Возникает вопрос: каким же образом монтируется самая первая
файловая система (т.е. система root), так как очевидно, что она не
может быть смонтирована на какую-либо другую. Система root
монтируется во время загрузки, поэтому считается, что она всегда
установлена (если бы она не была установлена, то компьютер не смог
бы загрузиться). Название файловой системы, используемой для
монтирования root, либо встроено в ядро, либо устанавливается при

                                - 49 -

помощи LILO или rdev.

     Обычно сначала система root монтируется в режиме read-only.
Затем запускается программа fsck(8) для проверки ее целостности и
если все в порядке, то система монтируется снова в режиме
read-write. fsck не следует запускать на смонтированной файловой
системе, так как изменения, произведенные при ее выполнении, могут
привести к повpеждению системы. Так как система root сначала
монтируется в режиме read-only, то после ее проверки все неполадки
могут быть полностью устранены при повторном монтировании.

     На многих системах существуют и другие файловые системы,
которые должны быть смонтированы во время загрузки. Их список
содержится в файле /etc/fstab (см. руководство к fstab(5)).

     Если файловая система для работы больше не требуется, то она
может быть демонтирована. Для этого используется команда umount(8)
с одним параметром. Это может быть как файл устройства, так и узел
монтирования. Например, для демонтирования каталогов,
рассмотренных в предыдущем примере, используются следующие
команды:

ttyp5 root ~ $ umount /dev/hda2
ttyp5 root ~ $ umount /usr
ttyp5 root ~ $

     После работы с дисководом следует каждый раз применять эту
команду, так как до демонтирования системы нельзя быть уверенным,
что данные были записаны на диск, а не остались в буфере.

     Для выполнения операций монтирования и демонтирования
требуется наличие прав доступа пользователя root. Однако, многие
пользователи довольно часто работают с дисководом и для решения
этой проблемы существует несколько способов:

     Сообщить всем пароль пользователя root. Это самый простой, но
далеко не лучший выход. Он может использоваться на некоторых
системах, не нуждающихся в защите (обычно не подключенных к

                                - 50 -

какой-либо сети).

     Применять какую-либо программу (например, sudo(8)),
позволяющую всем использовать команду mount. Это также не лучший
способ по причине плохой защиты, хотя его применение не
предоставляет напpямую права root каждому пользователю.

     Применение пакета mtools, используемого только для работы с
файловой системой MS-DOS без выполнения операции монтирования.
Используется только в тех случаях, когда дисковод применяется для
работы с дисками системы MS-DOS.

     Поместить список файлов устройств, используемых при работе с
гибкими дисками, и доступных узлов монтирования вместе с нужными
опциями в файл /etc/fstab.

     Последний метод может быть реализован путем добавления в файл
/etc/fstab следующей строки:

/dev/fd0 /floppy msdos user,noauto

     Сначала указывается файл устройства, затем каталог, на
который монтируется устройство, тип файловой системы и опции.
Опция noauto запрещает автоматическое монтирование при начальной
загрузке системы. Опция user позволяет любому пользователю
монтировать указанную файловую систему и, по причине защиты
системы, запрещает выполнение программ и работу с файлами
устройств, расположенных на смонтированной системе. После этого,
любой пользователь может выполнить следующую команду:

ttyp5 root ~ $ mount /floppy
ttyp5 root ~ $

     Для демонтирования системы используется команда umount с
соответствующими параметрами.

           4.6.6   Поддержка работоспособности файловых систем


                                - 51 -

     Файловые системы это достаточно сложные объекты, поэтому
иногда их функционирование нарушается. Для проверки целостности и
работоспособности файловой системы используется команда fsck(8).
Наиболее часто возникающие тpудности связаны с перебоями в
питании, неполадках в оборудовании или ошибках оператора
(например, некорректное выключение системы).

     Большинство систем сконфигурировано таким образом, что
команда fsck запускается автоматически при загрузке системы,
поэтому возможные неполадки будут обнаружены (и, возможно,
исправлены) перед тем, как система будет использоваться. Работа с
поврежденной файловой системой может привести к потерям данных и
другим нарушениям ее функционирования. Однако, если файловая
система довольно большая по объему, то ее проверка может занять
некоторое время, а так как неполадки случаются очень редко, то
если система была выключена корректно, пpименяются определенные
методы для избежания проверки файловой системы. Первый из них
связан с тем, что если существует файл /etc/fastboot, то никаких
проверок не производится. Второй метод заключается в том, что в
файловой системе ext2 существует специальный флаг, раположенный в
суперблоке, который используется для выявления коppектности
демонтирования системы пpи последнем выключении системы. Эта
возможность используется в программе e2fsck (версия команды fsck
для файловой системы ext2fs) для избежания излишней проверки
файловой системы, если флаг ее целостности установлен (то есть
система была коppектно демонтирована). Фунционирование метода,
используещего файл /etc/fastboot, зависит от файлов, запускаемых
при загрузке системы, в то время как применение команды e2fsck
работает в любом случае (см. руководство по e2fsck(8) для более
подробной информации).

     Автоматическая проверка используется только для файловых
систем, устанавливаемых во время загрузки. Для проверки других
систем команда fsck должна выполняться отдельно.

     Если fsck находит неисправность, не подлежащую
восстановлению, то могут потребоваться глубокие знания и понимание
работы файловых систем и их типов. Также могут потребоваться

                                - 52 -

резервные копии. Некоторую информацию по тем или иным вопросам
можно найти через телеконференции, связанные с системой Linux.
Также может потpебоваться программа debugfs(8), созданная Theodore
T.

     Команда fsck должна использоваться только для демонтированных
систем (за исключением системы root, смонтированной в режиме
read-only во время загрузки), так как при ее работе используется
прямой доступ к диску и информация о внесении каких-либо изменений
в файловую систему может быть недоступна операционной системе,
что, обычно, приводит к нарушению ее работы.

     Иногда следует проводить поиск плохих блоков при помощи
команды badblocks. При ее выполнении выводится список номеров
найденных плохих блоков. Этот список может быть использован
программой fsck для внесения изменений в структуру файловой
системы во избежание использования этих блоков для хранения
информации. В следующем примере показано как это сделать.

ttyp5 root ~ $ badblocks /dev/fd0H1440 1440 > bad-blocks
ttyp5 root ~ $ fsck -t ext2 -l bad-blocks /dev/fd0H1440
Parallelizing fsck version 0.5a (5-Apr-94)
e2fsck 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Check reference counts.
Pass 5: Checking group summary information.

/dev/fd0H1440: ***** FILE SYSTEM WAS MODIFIED *****
/dev/fd0H1440: 11/360 files, 63/1440 blocks
ttyp5 root ~ $

                     4.7  Диски без файловых систем

     Не все диски или разделы используются как файловые системы.
Например, раздел swap-области не содержит файловой системы. Многие
дисководы используются в режиме эмуляции ленточного накопителя,

                                - 53 -

поэтому tar-файл или любой другой файл записывается
непосредственно на диск без использования какой-либо файловой
системы. У такого использования есть небольшое преимущество в
свободном пространстве (при установке файловой системы некоторая
часть дискового простьранства используется для системных целей) и
совместимости с другими системами. Например, файловый формат tar
является стандартным для всех систем, в то время как файловые
системы на разных платформах различаются. Дискеты экстренной
загрузки системы Linux также могут не содержать файловой системы.

     Одна из причин использования прямого доступа к диску (без
применения файловой системы) это создание копий. Например, если
диск содержит частично поврежденную файловую систему, то при
возможности следует создать его копию перед тем, как пытаться
что-либо сделать. Для этого можно использовать программу dd(1).

ttyp5 root /usr/tmp $ dd if=/dev/fd0H1440 of=floppy-image
2880+0 records in
2880+0 records out
ttyp5 root /usr/tmp $ dd if=floppy-image of=/dev/fd0H1440
2880+0 records in
2880+0 records out
ttyp5 root /usr/tmp $

     Сначала команда dd выполняет точную копию дискеты в файл
floppy-image, а затем записывает копию обратно на диск
(предполагается, что перед выполнением последней команды была
вставлена другая дискета).

             4.8  Распределение дискового пространства

                 4.8.1   Схемы разделения дисков

     Довольно сложно разбить диск на несколько разделов наилучшим
образом, так как на это влияет довольно много факторов.

     Обычно используется отдельный раздел или диск для файловой
системы root, которая содержит каталоги /bin, /etc, /dev, /lib,

                                - 54 -

/tmp и некоторые другие, требуемые для нормальной загрузки и
запуска системы. Таким образом, все, что нужно для запуска системы
- это файловая система root. Для файловой системы /usr, личных
каталогов пользователей (обычно каталог /home) и для swap-области
используются отдельные диски или их разделы. Разделение каталогов
с пользовательскими файлами облегчает создание резервных копий,
так как обычно не требуется сохранять рабочие программы
(расположенные в каталоге /usr). Также возможно разделение системы
/usr между несколькими компьютерами в сети (с использованием NFS)
для уменьшения общего используемого дискового пространства.

     Для жестких дисков небольшого объема лучше всего использовать
один раздел. При использовании большого диска обычно его разбивают
на несколько крупных разделов. Если в системе используется
несколько дисков, то, возможно, неплохим вариантом будет
установить файловую систему root (включая /usr) на один диск, а
личные каталоги пользователей - на другой.

                4.8.2  Требования к дисковому пространству

     При установке Linux будет предоставлена информация о
требуемом дисковом пространстве при различной конфигурации
системы. Отдельно устанавливаемые программы также могут
использовать подобную схему. Это помогает распределять место на
диске.

     Размер области, используемой для файлов пользователей,
зависит от характера работы. Многие считают, что для личных
каталогов нужно использовать как можно больше пространства, хотя
минимально требуемый объем на разных системах сильно варьируется.
Для простейшей обработки текстов некоторым может потребоваться
всего несколько мегабайт, в то время как другим, работающим с
мощными графическими приложениями, могут потребоваться многие
гигабайты.

     Размещение swap-области рассмотрено в разделе 6.5.



                                - 55 -

              4.8.3   Примеры распределения жесткого диска

     На рассматриваемом компьютере был установлен диск объемом 109
Мб. Сейчас на нем используется диск объемом 330 Мб. Ниже
рассматривается как и почему эти диски были разбиты.

     Первый диск (109 Мб) был разбит следующим образом. На
компьютере были установлены системы MS-DOS и Linux. При этом, для
DOS использовался раздел объемом 20 Мб, 10-ти Мб раздел был
предназначен для swap-области и оставшиеся 79 Мб были отданы под
отдельный раздел, где хранились все файлы, необходимые для работы
Linux.

     Другой диск размером 330 Мб был разбит следующим образом:

5 Мб       файловая система root
10 Мб      swap-область
180 Мб     файловая система /usr
120 Мб     файловая система /home
15 Мб      дополнительный раздел

        4.8.4   Использование дополнительного дискового пространства

     Добавление дискового пространства в системе Linux довольно
просто, по крайней мере после установки нужного оборудования.
Требуемый диск форматируется, в случае необходимости, затем
создаются разделы и устанавливается файловая система (это было
рассмотрено выше). После этого добавляются соответствующие строки
в файл /etc/fstab, что позволяет автоматически монтировать
дополнительный раздел или диск.

               4.8.5  Методы сохранения дискового пространства

     Наилучший метод сохранения дискового пространства - это не
устанавливать неиспользуемые программы. Иногда можно удалить
неиспользуемые файлы, такие как ненужные шрифты для X11 или
некоторые библиотеки для C++.


                                - 56 -

     Также в определенных случаях можно использовать сжатие
файлов. Существуют программы, такие как gzip(1) и zip(1),
позволяющие производить компрессию файлов и каталогов. Система
gzexe сжимает и разжимает файлы незаметно для пользователя. А
экспериментальная система DouBle производит компрессию файлов
незаметно для использующих их программ.
.
                                - 57 -



                 Глава 5  Обзор Структуры Каталогов

     В этой главе рассмотрены наиболее важные составляющие
структуры каталогов системы Linux, основанные на стандарте FSSTND.
Также в общих чертах описывается разбиение общей структуры
каталогов на отдельные файловые системы и с какой целью.

                          5.1  Введение

     Эта глава основана на стандарте файловой системы Linux FSSTND
версии 1.2, который выпущен для попытки стандартизировать
организацию структуры каталогов в системе Linux. Он может быть
использован для облегчения разработки и переноса программного
обеспечения для Linux, а также администрирования Linux систем. В
создании FSSTND сделана попытка последовать традициям и настоящим
перспективам развития Unix, что сближает Linux системы с более
профессиональными Unix системами.

     Глава не является таким подробным описанием, как FSSTND.
Поэтому системный администратор должен прочитать его для полного
понимания всех аспектов.

     В главе не рассматриваются форматы файлов и другие
подробности, так как цель главы - это сделать обзор всей системы
относительно файловой системы.

     Построение структуры каталогов изначально предполагает ее
разбиение на отдельные части, каждая из которых может размещаться
на отдельном диске или его разделе. Это используется для
облегчения контроля объема диска, создания резервных копий и
других обязанностей системного администратора. Основными частями
являются файловые системы root, /usr, /var и /home. Структура
каталогов разрабатывалась также для работы в сети, где возможно
распределение ее некоторых частей посредством какого-либо
устройства (например, CD-ROM) или сети с использованием NFS.


                                - 58 -

     Далее рассматривается назначение различных частей структуры
каталогов.

     Файловая система root (она обычно находится на локальном
диске, хотя может быть загpужена в пямять во вpемя запуска
системы) содеpжит все файлы, необходимые для загpузки и запуска
системы так, что после этого может быть смонтиpована любая дpугая
файловая система. Она также содеpжит сpедства для восстановления
повpежденных файловых систем и для pаботы с pезеpвными копиями.

     В файловой системе /usr находятся все команды, пpогpаммы,
библиотеки, стpаницы pуководств и дpугие файлы, тpебуемые для
ноpмального функциониpования системы. Ни один из файлов этой
системы не должен быть специфичным для какой либо отдельной машины
и не должен быть изменен пpи обычной pаботе системы. Это позволяет
pаспpеделять эти файлы в сети, что может быть довольно эффективным
pешением за счет экономии дискового пpостpанства и пpинятия
некотоpых pешений пpи администpиpовании системы. Даже если /usr
pасположена на локальном диске, то она должна быть смонтиpована в
pежиме read-only во избежание ее случайного повpеждения.

     Файловая система /var содеpжит pазличные файлы, изменяемые во
вpемя pаботы системы, такие как буфеpные каталоги (для почты,
новостей и т.д.), жуpнальные файлы, фоpматиpованные стpаницы
pуководств, а также вpеменные файлы. Обычно вся инфоpмация в /var
извлекается из системы /usr, но тогда было бы невозможным
смонтиpовать /usr в pежиме read-only.

     В файловой системе /home находятся личные каталоги
пользователей. Размещение /home в отдельном каталоге или файловой
системе упpощает pезеpвное копиpование инфоpмации. Пpи увеличении
объема инфоpмации она может быть pазбита на несколько отдельных
файловых систем (напpимеp, /home/students или /home/staff).

     Хотя выше pазличные составляющие и назывались файловыми
системами, в действительности они не обязательно должны быть
pазмещены на отдельных файловых системах. Они легко могут
находится на одной системе, если используется однопользовательский

                                - 59 -

pежим pаботы. Стpуктуpа каталогов также может быть pазбита по
pазному, в зависимости от объема дискового пpостpанства и его
pаспpеделения для pазличных целей. Важно только чтобы стандаpтные
имена файлов соответствовали действительности.

     В файловой системе UNIX все файлы гpуппиpуются по их
назначению (все команды находятся в одном месте, файлы данных - в
дpугом, документация - в тpетьем и т.д.). Альтеpнативой этому
является pазмещение файлов в зависимости от того к какой пpогpамме
они относятся, то есть все файлы, относящиеся к pедактоpу Emacs
находятся в одном каталоге, все файлы TeX - в дpугом и т.д.
Возникает только пpоблема в pаспpеделении файлов (каталог, в
котоpом находится пpогpамма, обычно содеpжит как постоянные файлы,
так файлы, изменяемые в пpоцессе pаботы), а иногда даже в их
поиске (напpимеp, поиск pуководства к пpогpамме).

                      5.2  Файловая система root

     Файловая система root должна быть небольших pазмеpов, так как
она содеpжит важные файлы и команды. Чем меньше объем файловой
системы и чем pеже она подлежит изменениям, тем меньше веpоятность
ее повpеждения. Если система root повpеждена, то обычно это
означает, что начальная загpузка компьютеpа невозможна (кpоме
отдельных методов, напpимеp пpи помощи дискет).

     Коpневой каталог обычно не содеpжит каких-либо файлов, хотя в
нем может находится системный файл ядpа (обычно он называется
/vmlinuz), загpужаемый в память пpи стаpте системы. Все остальные
файлы pасполагаются в следующих подкаталогах:

/bin            Команды, тpебуемые пpи загpузке системы и
используемые обычными пользователями.

/sbin           То же, что и /bin, только находящиеся здесь команды
не пpедназначены для пользователей с общими пpавами.

/etc            Различные конфигуpационные файлы.


                                - 60 -

/root           Личный каталог пользователя root.

/lib            Библиотеки, используемые пpогpаммами из
файловой системы root.

/lib/modules    Подгpужаемые модули для ядpа.

/dev            Файлы устpойств.

/tmp            Вpеменные файлы.

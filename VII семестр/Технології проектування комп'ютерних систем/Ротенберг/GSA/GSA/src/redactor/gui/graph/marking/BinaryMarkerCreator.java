package redactor.gui.graph.marking;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Creates binary marking, using information about connection between vertexes.
 * This information is taken from automateTable (generated by MealyContentCreator).
 * Represents automat table as TreeVertex List, sorted by number of children.
 *
 *
 */
public class BinaryMarkerCreator {
    private List<String[]> automateTable;
    private int zCounter;
    private  List<TreeVertex> treeVertexList;
    private  int sizeOfMarking;


    public BinaryMarkerCreator(List<String[]> automateTable, int zCounter) {
        this.automateTable = automateTable;
        this.zCounter = zCounter;

        treeVertexList = new ArrayList<TreeVertex>();
    }

    public void useCreateMarking() {

        //     int tableSize = zCounter - 1;               //TODO
        int tableSize = zCounter;

        int[][] tableOfGraphConnections = new int[tableSize][tableSize];

        for (int i = 0; i < tableSize; i++) {
            for (int j = 0; j < tableSize; j++)
                tableOfGraphConnections[i][j] = 0;
        }

        for (int i = 0; i < automateTable.size(); i++) {

            int indexFrom = Integer.valueOf(automateTable.get(i)[0].substring(1));
            int indexTo = Integer.valueOf(automateTable.get(i)[3].substring(1));
            if (indexFrom != indexTo) {
                tableOfGraphConnections[indexFrom - 1][indexTo - 1] = 1;
                tableOfGraphConnections[indexTo - 1][indexFrom - 1] = 1;
            }
        }



        int temp = 0;

        sizeOfMarking = (int) (Math.ceil(Math.log(tableSize) / Math.log(2)));

        for (int i = 0; i < tableSize; i++) {
            for (int j = 0; j < tableSize; j++)
                if (tableOfGraphConnections[i][j] == 1)
                    temp++;
            if (temp > sizeOfMarking)
                sizeOfMarking = temp;
            temp = 0;

        }

        HashMap<Integer, Boolean> poolOfAvailableMarkers = new HashMap<Integer, Boolean>();
        for (int i = 0; i < Math.pow(2, sizeOfMarking); i++)
            poolOfAvailableMarkers.put(i, true);

        HashMap<Integer, Integer> markedVertexTable = new HashMap<Integer, Integer>();
        for (int i = 0; i < tableSize; i++)
            markedVertexTable.put(i + 1, -1);

        fillTreeVertex(tableOfGraphConnections);

        createMarking(poolOfAvailableMarkers, 0);

        for (int i = 0; i < treeVertexList.size(); i++)
            System.out.println(treeVertexList.get(i).toString());

        generateTransitionTable();
    }

    public void fillTreeVertex(int[][] tableOfGraphConnections) {

        int tableSize = zCounter;

        for (int i = 1; i <= tableSize; i++) {
            TreeVertex vertex = new TreeVertex(i);
            treeVertexList.add(vertex);
        }

        for (int i = 0; i < tableSize; i++) {
            for (int j = 0; j < tableSize; j++) {
                if ((tableOfGraphConnections[i][j] != 0) && (!thisConnectionAlreadyExist(j + 1, i + 1))) {
                    findVertex(i + 1).getChildrenList().add(j + 1);

                }
            }
        }


        for (int i = 0; i < treeVertexList.size() - 1; i++) {
            if (treeVertexList.get(i + 1).getChildrenList().size() > treeVertexList.get(i).getChildrenList().size()) {
                TreeVertex temp = treeVertexList.get(i);
                treeVertexList.set(i, treeVertexList.get(i + 1));
                treeVertexList.set(i + 1, temp);
                i = 0;
            }
        }
    }

    public void createMarking(HashMap<Integer, Boolean> pool, int startMarker) {

        TreeVertex currentVertex = treeVertexList.get(0);
        currentVertex.setBinaryMarker(startMarker);
        pool.put(startMarker, false);

        for (int i = 0; i < currentVertex.getChildrenList().size(); i++) {
            int marker = differenceInOneBit(startMarker, pool);
            TreeVertex connectedVertex = findVertex(currentVertex.getChildrenList().get(i));
            connectedVertex.setBinaryMarker(marker);
            pool.put(marker, false);
      //      System.out.println("child = " + connectedVertex.getMyNumberOfVertex() + "; marker = " + Integer.toBinaryString(marker));
        }

        for (int i = 1; i < treeVertexList.size(); i++) {
            currentVertex = treeVertexList.get(i);
       //     System.out.println("processing " + currentVertex.toString());
            if ((currentVertex.getBinaryMarker() == -1) && (currentVertex.getChildrenList().size() != 0)) {
                ArrayList<Integer> fluentExistingMarkers = new ArrayList<Integer>();
                for (int j = 0; j < currentVertex.getChildrenList().size(); j++) {
                    TreeVertex child = findVertex(currentVertex.getChildrenList().get(j));
                    if (child.getBinaryMarker() != -1)
                        fluentExistingMarkers.add(child.getBinaryMarker());
                }

                switch (fluentExistingMarkers.size()) {
                    case 0:
                        currentVertex.setBinaryMarker(findSmallestFree(pool));
                        pool.put(currentVertex.getBinaryMarker(), false);
                        break;
                    case 1:
                        int marker = differenceInOneBit(fluentExistingMarkers.get(0), pool);
                        if (marker != 0)
                            currentVertex.setBinaryMarker(marker);
                        else System.out.println("no available marker for Z" + currentVertex.getMyNumberOfVertex());
                        break;


                    case 2:
                        marker = fluentExistingMarkers.get(0) | fluentExistingMarkers.get(1);

                        if (pool.get(marker)) {
                            currentVertex.setBinaryMarker(marker);
                            pool.put(marker, false);
                        } else System.out.println("no available marker for Z" + currentVertex.getMyNumberOfVertex());
                        break;
                    default:
                        System.out.println("need to extend graph");
                        break;
                }


            } else if ((currentVertex.getBinaryMarker() == -1) && (currentVertex.getChildrenList().size() == 0)) {
                currentVertex.setBinaryMarker(findSmallestFree(pool));
                pool.put(currentVertex.getBinaryMarker(), false);
            } else if ((currentVertex.getBinaryMarker() != -1) && (currentVertex.getChildrenList().size()) != 0) {
                for (int j = 0; j < currentVertex.getChildrenList().size(); j++) {
                    TreeVertex currentChild = findVertex(currentVertex.getChildrenList().get(j));
                    if (currentChild.getBinaryMarker() == -1) {
                        int marker = differenceInOneBit(currentVertex.getBinaryMarker(), pool);
                        if (marker != -1)
                            currentChild.setBinaryMarker(marker);
                        else
                            System.out.println("trouble with child marking");
                    }
                }
            }
        }
    }

    /**
     * @return transition[0] - from;
     *         transition[1] - to;
     *         transition[2] - marker from;
     *         transition[3] - marker to;
     *         transition[4] - conditions
     *         transition[5] - operations
     */

    public ArrayList<String[]> generateTransitionTable() {
        ArrayList<String[]> transitions = new ArrayList<String[]>();
        for (int i = 0; i < automateTable.size(); i++) {
            String[] trans = new String[6];
            trans[0] = automateTable.get(i)[0].substring(1);
            trans[1] = automateTable.get(i)[3].substring(1);
            trans[2] = String.valueOf(findVertex(Integer.valueOf(trans[0])).getBinaryMarker());
            trans[3] = String.valueOf(findVertex(Integer.valueOf(trans[1])).getBinaryMarker());
            trans[4] = automateTable.get(i)[1];
            trans[5] = automateTable.get(i)[2];
            //       if ((transitions.size()>0) && (trans != transitions.get(transitions.size() - 1)))
            transitions.add(trans);
        }

        int i = 1;

        while (i < transitions.size()) {
            String[] previous = transitions.get(i - 1);
            String[] current = transitions.get(i);

            if ((Integer.valueOf(previous[0]) > Integer.valueOf(current[0]))
                    || ((Integer.valueOf(previous[0]).equals(Integer.valueOf(current[0])))
                    && (Integer.valueOf(previous[1]) > Integer.valueOf(current[1])))) {
                String[] temp = previous;
                transitions.set(i - 1, current);
                transitions.set(i, temp);
                //    current = temp;
                i = 0;
            } else if ((previous[0].equals(current[0])) && (previous[1].equals(current[1]))) {
                transitions.remove(i);
                i = 0;
            }
            i++;
        }

//        System.out.println(" sorted transitions");
//
//        for (i = 0; i < transitions.size(); i++) {
//            System.out.println(transitions.get(i)[0] + " --> " + transitions.get(i)[1] + "; "
//                    + Integer.toBinaryString(Integer.valueOf(transitions.get(i)[2]))
//                    + " --> " + Integer.toBinaryString(Integer.valueOf(transitions.get(i)[3])));
//        }


        return transitions;
    }

    public TreeVertex findVertex(int number) {
        for (int i = 0; i < treeVertexList.size(); i++)
            if (treeVertexList.get(i).getMyNumberOfVertex() == number)
                return treeVertexList.get(i);

        return null;
    }

    public boolean thisConnectionAlreadyExist(int from, int to) {
        for (int i = 0; i < treeVertexList.size(); i++) {
            boolean exist = treeVertexList.get(i).hasSuchConnection(from, to);
            if (exist)
                return exist;
        }

        return false;

    }


    public List<Integer> selectDefinedConnections(int currentVertex) {
        List<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < treeVertexList.size(); i++) {
            if (treeVertexList.get(i).isChild(currentVertex)) {
                list.add(treeVertexList.get(i).getMyNumberOfVertex());
            }
        }

        for (int i = 0; i < list.size() - 1; i++) {
            for (int j = i + 1; j < list.size(); j++) {

            }

        }

        return list;

    }

    private int findSmallestFree(HashMap<Integer, Boolean> pool) {
        for (int i = 0; i < pool.size(); i++) {
            if (pool.get(i))
                return i;
        }
        return -1;
    }

    public int differenceInOneBit(int connectedMarker, HashMap<Integer, Boolean> pool) {
        int temp;

        for (int i = 0; i < pool.size(); i++) {
            if (pool.get(i)) {
                temp = i ^ connectedMarker;
                while (temp % 2 == 0)
                    temp /= 2;
                if (temp == 1) {
                    pool.put(i, false);
                    return i;
                }

            }
        }

        return -1;

    }

    public List<TreeVertex> getTreeVertexList() {
        return treeVertexList;
    }

    public int getSizeOfMarking() {
        return sizeOfMarking;
    }
}

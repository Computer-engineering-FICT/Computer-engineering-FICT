описание алгоритмов и разбор задач		Автор:	Петров Александр
Сайт создан:	23 Сентябрь 2005
Последнее обновление:	13 Ноябрь 2005
Адрес сайта:	p-analiz.jino-net.ru
	

.:: Разделы ::.
 Главная
 Учебник
 Задачник
 Литература
 Программы
 Ссылки
.:: Содержание ::.
 Сортировка и поиск
 Структуры данных
 Графы
 Математика
 Геометрия
 Анализ алгоритмов
.:: Техинформация ::.
 Обратная связь
 О сайте
.:: Новости ::.
25 Ноябрь 2007

Оказывается, мой сайт еще жив. Блин, точно знаю, что должны возникнуть какие-то чувства по этому поводу: "..чувствуй, падла, чувствуй, ну..." - как говорил Гришковец. Но, увы... 

Я сморю, джино тут и рекламу повесил. Ай-ай-ай

А я, кстати, в МГУ учусь. Так, информация ни для кого :)

Юрий Иваныч, привет, если ты читаешь :) 

		Квадратичные сортировки
Квадратичные сортировки

Сортировка посредством выбора

Это, пожалуй, самый простой способ сортировки. Его идея заключается в следующем: ищется минимальный элемент массива и ставиться на первое место. Затем ищется наименьший элемент среди элементов a[2]..a[N] и ложится в a[2]. Обобщая: на i-м шаге в a[i] помещается наименьший из элементов с индексами i..N.

Я приведу две вариации описанного метода. Первая - прямой выбор - сначала ищется наименьший элемент и лишь потом меняется местами. Во второй же реализации нет необходимости заводить дополнительную переменную: роль наименьшего элемента играет сам a[i].
procedure selectsort;{straight selection}
begin
    for i := 1 to n do
    begin
      min := i;
      for j := i+1 to n do
        if a[j] < a[min] then min := j;
      swap(a[i], a[min])
    end
end;

procedure selectsort;
begin
    for i := 1 to n-1 do
      for j := i+1 to n do
        if a[i] > a[j] then swap(a[i], a[j])
end;начальное состояние	5 2 4 1 3
рез-т 1-й итерации	1 5 2 4 3
рез-т 2-й итерации	1 2 5 4 3
рез-т 3-й итерации	1 2 3 5 4
рез-т 4-й итерации	1 2 3 4 5


Сортировка "пузырьком"

Суть этого алгоритма настолько же проста, как предыдущий способ. Представим себе вертикальный массив, пронумерованный сверху вниз. Наиболее легкие элементы, т.е. элементы с меньшими значениями, поднимаются вверх (как бы "всплывают" наподобие пузырька). Делается это так.

Предположим, что наименьшим элементом, т.е. пузырьком является последний элемент массива. Он сравнивается с вышестоящим. Если значение нижнего меньше верхнего, то они меняются местами (пузырек всплывает на единицу). Если же он не всплывает, значит, верхний элемент "легче" нижнего и тот становится пузырьком. Проверка повторяется на уровне выше. Как только пузырек всплывает (достигает верх массива), начинается поиск второго по величине элемента аналогичным образом.


Вот код этого алгоритма. Надеюсь, разобраться в нем не составит труда.
for i := 1 to n do
  for j := n downto i+1 do
    if a[j] < a[j-1] then swap(a[j], a[j-1])
1-ая итерация (жирным шрифтом указан "пузырек")
5
2
1
4
3	5
2
1
3
4	5
2
1
3
4	5
1
2
3
4	1
5
2
3
4

начальное состояние	5 2 1 4 3
рез-т 1-й итерации	1 5 2 3 4
рез-т 2-й итерации	1 2 5 3 4
рез-т 3-й итерации	1 2 3 5 4
рез-т 4-й итерации	1 2 3 4 5


Оценим эти два способа сортировки. Их объединяет то, что после выполнения i-го шага в a[i] - минимальный из оставшихся элементов. Так как всего объектов N, а поиск наименьшего занимает O(N-i+1), то время выполнения сортировок посредством выбора и "пузырьком" составляет N*(N-1)/2 , что равно O(N2).

Сортировка вставками

Основная идея сортировки вставками такова: на i-м шаге мы имеем отсортированными первые i элементов исходного массива. Именно исходными. В отличие от двух предыдущих методов, где мы пробегаем весь массив в поиске наименьшего элемента, сортировка вставками работает только с первыми i-ми. Допустим, у нас они уже отсортированы, тогда за время O(i) мы можем добавить в этот список еще один элемент ( (i+1)-й ):
for i := 2 to n do
    * Вставить i-ый элемент в отсортированный список от 1 до (i-1)

При вставке элемента k, надо найти такое j, что a[j-1] ? k < a[j], j ? [1..i]. Есть разные способы вставки. Один из них такой: будем менять элемент k с левым соседом до тех пор, пока он не встанет на свое место:
for i := 2 to n do
begin
  while a[j] < a[j-1] do
  begin
    swap(a[j], a[j-1]);
    j := j-1
  end
end;

Можно чуть его изменить:
for i := 2 to n do
begin
    k := a[i]; j := i; a[0] := k;
    while a[j-1] > k do
    begin
      a[j] := a[j-1];
      dec(j)
    end;
    a[j] := k
end;

Эта модификация предпочтительнее, так как она не использует процедуру swap, а запоминает элемент k, затем сдвигает все элементы, большие k, вправо и вставляет его в освободившееся место. Описанный метод называется прямой вставкой. 

Есть еще алгоритм, называемый двоичной вставкой. В этом случае j (j: a[j-1] ? k < a[j], j ? [1..i]) ищется методом двоичного поиска. Как только он найден (максимум за O(log n)), все элементы, большие k (от j до i), сдвигаются и в a[j] ложится k: 
for i := 2 to N do
begin
    k := a[i]; L := 1; R := i;
    while L < R do
    begin
       m := (L+R) div 2;
       if a[m] <= k then L := m+1
                    else R := m
    end;
    for j := i downto R+1 do
       a[j] := a[j-1];
    a[R] := k
end

Преимущество этого способа - отсутствие условия a[j-1] > k, недостаток - время, необходимое на бинарный поиск. Но в целом он работает быстрее. 

Несмотря на различные способы вставки, их асимптотика равна, т.е. O(N). Учитывая внешний цикл, общее время работы алгоритмов составляет O(N2). 



Заключение

Хоть эти способы сортировки просты и набираются вслепую за несколько секунд, их главный недостаток - время выполнения. Если они эффективно сортируют 2000 элементов, то на десяти тысячах висят довольно долго. Для большого числа объектов существуют эффективные методы, выполняющиеся за O(N log N).
.:: наверх ::. 

Copyright © 2005 Александр Петров aka sahek - сайт p-analiz.jino-net.ru
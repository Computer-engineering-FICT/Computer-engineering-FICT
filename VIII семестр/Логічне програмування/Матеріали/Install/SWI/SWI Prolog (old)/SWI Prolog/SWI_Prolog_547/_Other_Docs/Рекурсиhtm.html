<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0072)http://www.ctc.msiu.ru/materials/Book2/ch_10_prolog/07_recurs/index.html -->
<HTML><HEAD><TITLE>Рекурсия</TITLE>
<META http-equiv=Content-Type content="text/html; charset=koi8-r"><LINK 
href="Рекурсия.files/list.css" type=text/css rel=stylesheet>
<SCRIPT language=javascript1.2 src="Рекурсия.files/cookie.js">
</SCRIPT>

<SCRIPT language=javascript1.2>
function onLoad () {
  parent.nav.set_cookie ("Source", "./ch_10_prolog/07_recurs/index.html", 1000);
}
</SCRIPT>

<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY><A 
href="http://www.ctc.msiu.ru/materials/Book2/ch_10_prolog/06_rules/index.html"><IMG 
alt="Предыдущий раздел" src="Рекурсия.files/prev.gif" border=0></A> <A 
href="http://www.ctc.msiu.ru/materials/Book2/ch_10_prolog/index.html"><IMG 
alt="Уровень выше" src="Рекурсия.files/up.gif" border=0></A> <A 
href="http://www.ctc.msiu.ru/materials/Book2/ch_10_prolog/08_programm/index.html"><IMG 
alt="Следующий раздел" src="Рекурсия.files/next.gif" border=0></A> <A 
onmousedown="document.images['cont'].src='../../Images/ContentsDown.gif'" 
onmouseout="document.images['cont'].src='../../Images/Contents.gif'" 
href="http://www.ctc.msiu.ru/materials/Book2/contents.html"><IMG 
src="Рекурсия.files/Contents.gif" border=0 name=cont></A> 
<H2>Рекурсивные процедуры</H2><IMG src="Рекурсия.files/blank.gif"> 
<P><B>Рекурсия</B> в большинстве языков программирования - это такой способ 
организации обработки данных, при котором программа (процедура) вызывает сама 
себя непосредственно, либо с помощью другой программы (процедуры). </P>
<TABLE>
  <TBODY>
  <TR>
    <TD><IMG hspace=4 src="Рекурсия.files/DrawingHandsLg.jpg"> </TD>
    <TD>
      <P align=justify>Гравюра голландского художника Мориса Эшера "Рисующие 
      руки" - одна из лучших иллюстраций понятия рекурсии. Всем известный стишок 
      о попе и его собаке демонстрирует нам бесконечность рекурсивных вызовов. 
      Используя рекурсию как прием программирования мы должны быть уверены, что 
      рекурсивная процедура будет завершена. </P></TD></TR></TBODY></TABLE>
<P>В Прологе рекурсия встречается, когда предикат содержит цель, которая 
ссылается на саму себя. В рекурсивном правиле более сложные входные аргументы 
должны выражаться через менее сложные. 
<P>На примере уже имеющейся у нас базы данных объясним преимущества 
использования рекурсии и особенности рекурсивных правил. Пусть имеются следующие 
факты: <PRE>больше(слон, лошадь).
больше(лошадь, осел).
больше(осел, собака).
больше(осел, обезьяна).
</PRE>Выполним запрос к базе данных <PRE>?- больше(осел, собака).
Yes
</PRE>Цель <TT>больше(осел, собака)</TT> была достигнута потому, что этот факт 
был сообщен Прологу при загрузке базы. Теперь проверим, больше ли обезьяна 
слона? <PRE>?- больше(обезьяна, слон).
No
</PRE>Нет, не больше. Мы получили такой ответ, какой и ожидали: соответствующий 
запрос, а именно <TT>больше(обезьяна, слон)</TT> не подтвердился. Но, что 
случится, если мы зададим вопрос по-другому? <PRE>?- больше(слон, обезьяна).
No
</PRE>Таким образом, слоны не больше, чем обезьяны. Полученный результат 
совершенно не согласуется с нашими представлениями о мире, но если посмотреть на 
базу данных, то легко заметить, что в ней действительно ничего не сказано об 
отношениях между слонами и обезьянами. Однако, мы знаем, что слоны больше, чем 
лошади, которые в свою очередь больше, чем ослы, которые больше обезьян, поэтому 
слоны также должны быть больше, чем обезьяны. 
<P>Правильная интерпретация отрицательного ответа, данного Прологом, такова: 
<EM>информации, сообщенной системе, недостаточно для доказательства того, что 
слон больше обезьяны.</EM> Если мы захотим получить положительный ответ на 
запрос вида <TT>больше(слон, обезьяна)</TT>, то мы должны обеспечить более 
точное описание мира. Одним из возможных способов решения этой проблемы является 
добавление отсутствующих фактов, например, <PRE>больше(слон, обезьяна).
</PRE>Для нашего маленького примера это означает добавление еще 5 фактов. Однако 
гораздо лучшим решением будет добавление в программу нового отношения, которое 
мы назовем <TT>больше_2</TT>. Животное <TT>X</TT> больше, чем животное 
<TT>Y</TT>, если это определено как факт (первое правило) или существует 
животное <TT>Z</TT>, для которого определен факт, что животное <TT>X</TT> 
больше, чем животное <TT>Z</TT> и может быть показано, что животное <TT>Z</TT> 
больше, чем животное <TT>Y</TT> (второе правило). На Прологе это запишется так: <PRE>больше_2(X, Y) :- больше(X, Y).
больше_2(X, Y) :- больше(X, Z), больше(Z, Y).
</PRE>Если в цепочке участвуют не три, а большее число объектов, то придется 
добавить новые правила: <PRE>больше_2(X, Y) :- больше(X, Z1), больше(Z1, Z2), 
                  больше(Z2, Y).
больше_2(X, Y) :- больше(X, Z1), больше(Z1, Z2),
                  больше(Z2, Z3), больше(Z3, Y).
...
</PRE>Эта программа длинна и работать будет далеко не всегда. Она сможет 
просматривать базу данных только до определенной глубины, задаваемой 
максимальным количеством подцелей в правилах. 
<P>Поэтому воспользуемся более корректной и элегантной формулировкой. Ключевая 
идея здесь - <EM>определить отношение</EM> <TT>больше_2</TT> <EM>с помощью его 
самого</EM>. Теперь второе (и последнее!) правило выглядит так: <PRE>больше_2(X, Y) :- больше(X, Z), больше_2(Z, Y).
</PRE>Таким образом, итоговая программа будет иметь вид <PRE>больше_2(X, Y) :- больше(X, Y). 
больше_2(X, Y) :- больше(X, Z), больше_2(Z, Y).
</PRE>
<P>Обратите внимание на порядок подцелей во втором правиле: если их поменять 
местами, то в большинстве реализаций языка Пролог выполнение запроса к такой 
базе знаний приведет к сообщению об ошибке, аналогичному следующему: <PRE>ERROR: Out of local stack
</PRE>
<P>Если теперь в запросе использовать предикат <TT>больше_2</TT> вместо 
<TT>больше</TT>, то программа будет работать так, как и предполагалось: <PRE>?- больше_2(слон, обезьяна).
Yes
</PRE>
<P>Интерпретатор всегда просматривает базу данных <EM>сверху вниз.</EM> Поэтому 
он анализирует сначала первую фразу процедуры <TT>больше_2</TT> и пытается 
унифицировать каждый аргумент запроса с соответствующим аргументом этой фразы. 
Это происходит при помощи <EM>сравнения</EM> запроса с началом правила 
<TT>больше_2(X, Y)</TT> (т.&nbsp;е. с его головой). После этого двум переменным 
присваиваются значения: <TT>X = слон</TT> и <TT>Y = обезьяна</TT>. 
<P>После конкретизации переменной некоторым термом это значение "закрепляется" 
<B>за всеми случаями</B> использования этой переменной в правиле. После 
унификации запроса с заголовком фразы интерпретатор переходит к обработке целей, 
содержащихся в теле этой фразы. 
<P>В данном случае Пролог не может найти в базе данных факта <TT>больше(слон, 
обезьяна)</TT> и переходит к рассмотрению второго правила. Оно гласит, что для 
того, чтобы получить ответ на вопрос <TT>больше_2(X,Y)</TT> (с фиксированными 
значениями переменных, то есть <TT>больше_2(слон, обезьяна)</TT>), Пролог должен 
ответить на два <EM>подвопроса</EM> <TT>больше(X, Z)</TT> и <TT>больше_2(Z, 
Y)</TT>, опять же с соответствующими значениями переменных. Процесс просмотра 
базы знаний с самого начала повторяется до тех пор, пока факты, составляющие 
цепочку между <TT>слон</TT> и <TT>обезьяна</TT>, не будут найдены, а запрос 
успешно обработан. 
<P>Любая рекурсивная процедура должна включать по крайней мере по одной из ниже 
перечисленных компонент. 
<OL>
  <LI><EM>Нерекурсивную фразу,</EM> определяющую правило, применяемое в момент 
  прекращения рекурсии. 
  <LI><EM>Рекурсивное правило,</EM> первая подцель которого вырабатывает новые 
  значения аргументов, а вторая - рекурсивная подцель- использует эти значения. 
  </LI></OL>
<P><BR><B>Задание</B><BR>Дана база данных "Родители", в которой предикат 
<TT>родитель(коля, андрей)</TT> означает, что Коля является родителем Андрея: <PRE>родитель(коля, андрей). 
родитель(андрей, саша).
родитель(виктор, федор).
родитель(виктор, петр).
родитель(петр, елена).
</PRE>Используя рекурсию, определите отношение <TT>предок/2</TT> через отношение 
<TT>родитель/2</TT>. Будем говорить, что некоторый <TT>X</TT> является 
отдаленным предком некоторого <TT>Y</TT>, если между <TT>X</TT> и <TT>Y</TT> 
существует цепочка людей, связанных между собой отношением родитель&nbsp;- 
ребенок. <BR clear=all><A 
href="http://www.ctc.msiu.ru/materials/Book2/ch_10_prolog/06_rules/index.html"><IMG 
alt="Предыдущий раздел" src="Рекурсия.files/prev.gif" border=0></A> <A 
href="http://www.ctc.msiu.ru/materials/Book2/ch_10_prolog/index.html"><IMG 
alt="Уровень выше" src="Рекурсия.files/up.gif" border=0></A> <A 
href="http://www.ctc.msiu.ru/materials/Book2/ch_10_prolog/08_programm/index.html"><IMG 
alt="Следующий раздел" src="Рекурсия.files/next.gif" border=0></A> 
</BODY></HTML>

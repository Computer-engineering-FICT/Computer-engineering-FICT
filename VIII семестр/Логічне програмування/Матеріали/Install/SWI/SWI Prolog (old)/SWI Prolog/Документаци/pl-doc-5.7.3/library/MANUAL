
                                              University of Amsterdam

                                              Human-Computer Studies
                                                (HCS, formerly SWI)

                                                Kruislaan 419, 1098
                                                   VA  Amsterdam
                                                  The Netherlands
                                              Tel.  (+31) 20 5256121

                         SSWWII--PPrroolloogg 55..77

                        RReeffeerreennccee MMaannuuaall
            _U_p_d_a_t_e_d _f_o_r _v_e_r_s_i_o_n _5_._7_._3_, _D_e_c_e_m_b_e_r _2_0_0_8

                         _J_a_n _W_i_e_l_e_m_a_k_e_r
                    wielemak@science.uva.nl
                   http://www.swi-prolog.org

SWI-Prolog  is  a Prolog  implementation based  on a  subset of
the  WAM (Warren Abstract  Machine).   SWI-Prolog was developed
as  an _o_p_e_n  Prolog environment,  providing a powerful  and bi-
directional  interface to C in an era this was unknown to other
Prolog  implementations.  This environment  is required to deal
with  XPCE,  an object-oriented  GUI system  developed  at SWI.
XPCE  is used at SWI for the development of knowledge-intensive
graphical  applications.   As  SWI-Prolog became  more popular,
a   large  user-community  provided  requirements  that  guided
its  development.    Compatibility,  portability,  scalability,
stability  and  providing  a  powerful development  environment
have   been  the  most  important  requirements.     Edinburgh,
Quintus,  SICStus and the ISO-standard guide the development of
the  SWI-Prolog primitives.  This document gives an overview of
the features, system limits and built-in predicates.

Copyright Oc 1990--2008, University of Amsterdam


CChhaapptteerr 11..  IINNTTRROODDUUCCTTIIOONN


11..11 SSWWII--PPrroolloogg

SWI-Prolog started back in  1986 with the requirement for a  Prolog that
could handle recursive interaction with the C-language:   Prolog calling
C and  C calling  Prolog recursively.   Those  days Prolog systems  were
very aware  of its environment  and we needed such  a system to  support
interactive  applications.   Since  then,  SWI-Prolog's development  has
been guided  by requests from the  user community, especially  focussing
on (in arbitrary  order) interaction with the environment,  scalability,
(I/O)  performance,  standard  compliance,   teaching  and  the  program
development environment.

SWI-Prolog  is   based  on   a  very  simple   Prolog  virtual   machine
called ZIP  [Bowen _e_t _a_l_., 1983, Neumerkel, 1993]  which defines only  7
instructions.  Prolog can easily be compiled into  this language and the
abstract machine code is  easily decompiled back into Prolog.  As  it is
also possible to wire a standard 4-port debugger in  the virtual machine
there is  no need  for a  distinction between  compiled and  interpreted
code.    Besides simplifying  the  design of  the Prolog  system  itself
this  approach has  advantages for  program development:   the  compiler
is  simple and  fast,  the  user does  not  have  to decide  in  advance
whether debugging is  required and the system only runs  slightly slower
when in  debug mode.    The price  we have  to pay  is some  performance
degradation (taking  out the debugger from  the VM interpreter  improves
performance by about  20%) and somewhat additional memory usage  to help
the decompiler and debugger.

SWI-Prolog  extends  the  minimal  set  of   instructions  described  in
[Bowen _e_t _a_l_., 1983]  to improve  performance.    While  extending  this
set care  has been  taken to  maintain the  advantages of  decompilation
and  tracing of  compiled  code.    The extensions  include  specialised
instructions  for unification,  predicate  invocation,  some  frequently
used built-in  predicates, arithmetic, and  control (;/2, |/2),  if-then
(->/2) and negation-by-failure (\+/1).


11..11..11 BBooookkss aabboouutt PPrroolloogg

This manual does not  describe the full syntax and semantics  of Prolog,
nor how  one should  write a  program in Prolog.    These subjects  have
been  described extensively  in  the literature.    See  [Bratko, 1986],
[Sterling & Shapiro, 1986],   and   [Clocksin & Melish, 1987].       For
more  advanced  Prolog  material  see  [O'Keefe, 1990].      Syntax  and
standard  operator declarations  confirm  to the  `Edinburgh  standard'.
Most  built  in  predicates  are  compatible  with  those  described  in
[Clocksin & Melish, 1987].      SWI-Prolog  also  offers  a  number   of
primitive  predicates compatible  with  Quintus Prolog  [Qui, 1997]  and
BIM_Prolog [BIM, 1989].

ISO  compliant  predicates  are based  on  ``Prolog:    The  Standard'',
[Deransart _e_t _a_l_., 1996], validated using [Hodgson, 1998].


11..22 SSttaattuuss

This manual describes  version 5.7 of SWI-Prolog.   SWI-Prolog has  been
used now for many  years.  The application range includes  Prolog course
material,  meta-interpreters, simulation  of parallel  Prolog,  learning
systems,  natural  language  processing,  complex  interactive  systems,
web-server  and web-server  components.    Although  in  our  experience
rather obvious and  critical bugs can remain unnoticed for  a remarkable
long period, we assume  the basic Prolog system is fairly stable.   Bugs
can be expected in infrequently used built-in predicates.

Some bugs are known to  the author.  They are described as  footnotes in
this manual.


11..33 CCoommpplliiaannccee ttoo tthhee IISSOO ssttaannddaarrdd

SWI-Prolog 3.3.0 implements  all predicates described in ``Prolog:   The
Standard'' [Deransart _e_t _a_l_., 1996].

Exceptions  and warning  are still  weak.    Some SWI-Prolog  predicates
silently  fail on  conditions where  the ISO  specification requires  an
exception  (functor/3 for  example).    Some predicates  print  warnings
rather than raising an  exception.  All predicates where  exceptions may
be  caused due  to a  correct program  operating in  an imperfect  world
(I/O, arithmetic,  resource overflows)  should behave  according to  the
ISO standard.   In other  words:  SWI-Prolog  should be able to  execute
any program  conforming to [Deransart _e_t _a_l_., 1996]  that does not  rely
on exceptions generated by errors in the program.


11..44 SShhoouulldd yyoouu bbee uussiinngg SSWWII--PPrroolloogg??

There are a number of reasons why you better  choose a commercial Prolog
system, or another academic product:

  o _S_W_I_-_P_r_o_l_o_g _i_s _n_o_t _s_u_p_p_o_r_t_e_d
    Although  I usually fix bugs shortly  after a bug report arrives,  I
    cannot  promise anything.   Now that the  sources are provided,  you
    can always dig into them yourself.

  o _M_e_m_o_r_y _r_e_q_u_i_r_e_m_e_n_t_s _a_n_d _p_e_r_f_o_r_m_a_n_c_e _a_r_e _y_o_u_r _f_i_r_s_t _c_o_n_c_e_r_n_s
    A  number  of  commercial compilers  are  more  keen on  memory  and
    performance  than SWI-Prolog.   I do not  wish to sacrifice some  of
    the  nice features of the system, nor its portability to  compete on
    raw performance.

  o _Y_o_u _n_e_e_d _f_e_a_t_u_r_e_s _n_o_t _o_f_f_e_r_e_d _b_y _S_W_I_-_P_r_o_l_o_g
    In  this case you  may wish to  give me suggestions for  extensions.
    If  you  have great  plans, please  contact me  (you  might have  to
    implement them yourself however).

On the other hand, SWI-Prolog offers some nice facilities:

  o _N_i_c_e _e_n_v_i_r_o_n_m_e_n_t
    This includes `Do  What I Mean', automatic completion of atom names,
    history mechanism and  a tracer that operates on single key-strokes.
    Interfaces  to  some  standard  editors are  provided  (and  can  be
    extended), as well as a facility to maintain programs (see make/0).

  o _V_e_r_y _f_a_s_t _c_o_m_p_i_l_e_r
    Even  very  large applications  can  be loaded  in seconds  on  most
    machines.  If  this is not enough, there is a Quick Load Format that
    is slightly more compact and loading is almost always I/O bound.

  o _T_r_a_n_s_p_a_r_e_n_t _c_o_m_p_i_l_e_d _c_o_d_e
    SWI-Prolog  compiled code can be  treated just as interpreted  code:
    you  can list it, trace  it, etc.  This  implies you do not have  to
    decide  beforehand whether a module  should be loaded for  debugging
    or  not.  Also, performance  is much better than the  performance of
    most interpreters.

  o _P_r_o_f_i_l_i_n_g
    SWI-Prolog offers tools  for performance analysis, which can be very
    useful  to optimise  programs.   Unless you  are very familiar  with
    Prolog  and Prolog  performance  considerations this  might be  more
    helpful than a better compiler without these facilities.

  o _F_l_e_x_i_b_i_l_i_t_y
    SWI-Prolog  can  easily   be  integrated  with  C,  supporting  non-
    determinism  in Prolog calling  C as well  as C calling Prolog  (see
    section  9).  It can also be _e_m_b_e_d_d_e_d embedded in  external programs
    (see  section 9.7).  System  predicates can be redefined locally  to
    provide compatibility with other Prolog systems.

  o _I_n_t_e_g_r_a_t_i_o_n _w_i_t_h _X_P_C_E
    SWI-Prolog   offers  a   tight  integration  to   the  Object   Ori-
    ented   Package  for   User  Interface   Development,  called   XPCE
    [Anjewierden & Wielemaker, 1989].    XPCE  allows you  to  implement
    graphical  user  interfaces  that are  source-code  compatible  over
    Unix/X11,  Win32  (Windows  95/98/ME  and NT/2000/XP)  and  MacOS  X
    (darwin).


11..55 TThhee XXPPCCEE GGUUII ssyysstteemm ffoorr PPrroolloogg

The  XPCE GUI  system  for dynamically  typed  languages has  been  with
SWI-Prolog for  a long time.   It is  developed by Anjo Anjewierden  and
Jan  Wielemaker from  the department  of SWI,  University of  Amsterdam.
It  aims at  a  high-productive  development environment  for  graphical
applications based on Prolog.

Object  oriented  technology has  proven  to  be a  suitable  model  for
implementing GUIs, which  typically deal with things Prolog is  not very
good  at:   event-driven  control  and global  state.    With  XPCE,  we
designed  a system  that has  similar characteristics  that make  Prolog
such  a powerful  tool:   dynamic typing,  meta-programming and  dynamic
modification of the running system.

XPCE is  an object-system written  in the C-language.   It provides  for
the implementation of methods  in multiple languages.  New  XPCE classes
may be defined from Prolog using a simple, natural syntax.   The body of
the method is executed  by Prolog itself, providing a  natural interface
between the two systems.  Below is a very simple class definition.

:- pce_begin_class(prolog_lister, frame,
                   "List Prolog predicates").

initialise(Self) :->
        "As the C++ constructor"::
        send_super(Self, initialise, 'Prolog Lister'),
        send(Self, append, new(D, dialog)),
        send(D, append,
             text_item(predicate, message(Self, list, @arg1))),
        send(new(view), below, D).

list(Self, From:name) :->
        "List predicates from specification"::
        (   catch(term_to_atom(Term, From), _, fail)
        ->  get(Self, member, view, V),
            current_output(Old),
            pce_open(V, write, Fd),
            set_output(Fd),
            listing(Term),
            close(Fd),
            set_output(Old)
        ;   send(Self, report, error, 'Syntax error')
        ).

:- pce_end_class.

test :- send(new(prolog_lister), open).

Its  165  built-in   classes  deal  with  the  meta-environment,   data-
representation  and---of  course---graphics.     The   graphics  classes
concentrate on direct-manipulation of diagrammatic representations.

AAvvaaiillaabbiilliittyy.. XPCE  runs on  most  Unixtm platforms,  Windows  95/98/ME,
Windows NT/2000/XP and MacOS  X (using X11).  In the past,  versions for
Quintus- and SICStus Prolog as well as some Lisp  dialects have existed.
After discontinuing  active Lisp  development at SWI  the Lisp  versions
have died.   Active development on the Quintus and SICStus  versions has
been stopped  due to lack  of standardisation  in the Prolog  community.
If adequate  standards emerge  we are  happy to  actively support  other
Prolog implementations.

IInnffoo.. further    information   is    available   from    http://www.swi-
prolog.org/packages/xpce/ or by E-mail to info@www.swi-prolog.org.


11..66 RReelleeaassee NNootteess

Collected release-notes.   This section  only contains some  highlights.
Smaller changes to especially  older releases have been removed.   For a
complete log, see the file ChangeLog from the distribution.


11..66..11 VVeerrssiioonn 11..88 RReelleeaassee NNootteess

Version  1.8 offers  a stack-shifter  to  provide dynamically  expanding
stacks  on machines  that  do  not offer  operating-system  support  for
implementing dynamic stacks.


11..66..22 VVeerrssiioonn 11..99 RReelleeaassee NNootteess

Version  1.9  offers  better portability  including  an  MS-Windows  3.1
version.  Changes to the Prolog system include:

  o _R_e_d_e_f_i_n_i_t_i_o_n _o_f _s_y_s_t_e_m _p_r_e_d_i_c_a_t_e_s
    Redefinition  of system  predicates  was allowed  silently in  older
    versions.    Version 1.9  only allows it  if the  new definition  is
    headed by a :- redefine_system_predicate/1 directive.top-level

  o _`_A_n_s_w_e_r_' _r_e_u_s_e
    The  top-level maintains a table  of bindings returned by  top-level
    goals  and  allows for  reuse  of these  bindings by  prefixing  the
    variables with the $ sign.  See section 2.8.

  o _B_e_t_t_e_r _s_o_u_r_c_e _c_o_d_e _a_d_m_i_n_i_s_t_r_a_t_i_o_n
    Allows  for proper updating of multifile predicates and  finding the
    sources of individual clauses.


11..66..33 VVeerrssiioonn 22..00 RReelleeaassee NNootteess

New features offered:

  o _3_2_-_b_i_t _V_i_r_t_u_a_l _M_a_c_h_i_n_e
    Removes various limits and improves performance.

  o _I_n_l_i_n_e _f_o_r_e_i_g_n _f_u_n_c_t_i_o_n_s
    `Simple'  foreign predicates no  longer build a Prolog  stack-frame,
    but are directly  called from the VM. Notably provides a speedup for
    the test predicates such as var/1, etc.

  o _V_a_r_i_o_u_s _c_o_m_p_a_t_i_b_i_l_i_t_y _i_m_p_r_o_v_e_m_e_n_t_s

  o _S_t_r_e_a_m _b_a_s_e_d _I_/_O _l_i_b_r_a_r_y
    All  SWI-Prolog's I/O is now  handled by the stream-package  defined
    in  the foreign include file SWI-Stream.h.   Physical I/O of  Prolog
    streams  may be  redefined through the  foreign language  interface,
    facilitating much simpler integration in window environments.


11..66..44 VVeerrssiioonn 22..55 RReelleeaassee NNootteess

Version  2.5  is  an  intermediate release  on  the  path  from  2.1  to
3.0.    All  changes are  to  the foreign-language  interface,  both  to
user- and system-predicates implemented  in the C-language.  The  aim is
twofold.   First of all  to make garbage-collection and  stack-expansion
(stack-shifts)  possible  while  foreign  code  is  active  without  the
C-programmer having  to worry  about locking  and unlocking  C-variables
pointing  to Prolog  terms.    The new  approach is  closely  compatible
with the  Quintus and SICStus Prolog  foreign interface using the  +term
argument specification (see their respective manuals).   This allows for
writing foreign  interfaces that  are easily portable  over these  three
Prolog platforms.

Apart from  various bug fixes  listed in the  ChangeLog file, these  are
the main changes since 2.1.0:

  o _I_S_O _c_o_m_p_a_t_i_b_i_l_i_t_y
    Many   ISO  compatibility  features   have  been  added:     open/4,
    arithmetic functions, syntax, etc.

  o _W_i_n_3_2
    Many  fixes for the Win32 (NT,  '95 and win32s) platforms.   Notably
    many  problems related  to pathnames  and a problem  in the  garbage
    collector.

  o _P_e_r_f_o_r_m_a_n_c_e
    Many  changes to  the clause  indexing system:   added  hash-tables,
    lazy computation of the index information, etc.

  o _P_o_r_t_a_b_l_e _s_a_v_e_d_-_s_t_a_t_e_s
    The   predicate  qsave_program/[1,2] allows  for   the  creating  of
    machine independent saved-states that load very quickly.


11..66..55 VVeerrssiioonn 22..66 RReelleeaassee NNootteess

Version 2.6  provides a stable implementation  of the features added  in
the 2.5.x  releases, but  at the same  time implements  a number of  new
features that may have impact on the system stability.

  o _3_2_-_b_i_t _i_n_t_e_g_e_r _a_n_d _d_o_u_b_l_e _f_l_o_a_t _a_r_i_t_h_m_e_t_i_c
    The  biggest change is the  support for full 32-bit signed  integers
    and  raw  machine-format  double precision  floats.    The  internal
    data  representation as well as  the arithmetic instruction set  and
    interface to the arithmetic functions has been changed for this.

  o _E_m_b_e_d_d_i_n_g _f_o_r _W_i_n_3_2 _a_p_p_l_i_c_a_t_i_o_n_s
    The  Win32 version has been reorganised.   The Prolog kernel is  now
    implemented  as Win32  DLL that may  be embedded in  C-applications.
    Two front ends  are provided, one for window-based operation and one
    to run as a Win32 console application.

  o _C_r_e_a_t_i_n_g _s_t_a_n_d_-_a_l_o_n_e _e_x_e_c_u_t_a_b_l_e_s
    Version  2.6.0 can create  stand-alone executables by attaching  the
    saved-state to the emulator.  See qsave_program/2.


11..66..66 VVeerrssiioonn 22..77 RReelleeaassee NNootteess

Version 2.7  reorganises the  entire data-representation  of the  Prolog
data  itself.   The  aim is  to remove  most of  the  assumption on  the
machine's memory  layout to  improve portability in  general and  enable
embedding on  systems where the memory  layout may depend on  invocation
or on how the executable is linked.  The latter  is notably a problem on
the Win32 platforms.  Porting to 64-bit architectures is feasible now.

Furthermore, 2.7 lifts the  limits on arity of predicates and  number of
variables in  a clause considerably and  allow for further expansion  at
minimal cost.


11..66..77 VVeerrssiioonn 22..88 RReelleeaassee NNootteess

With version  2.8, we declare  the data-representation changes of  2.7.x
stable.   Version  2.8 exploits  the changes  of 2.7  to support  64-bit
processors like the DEC Alpha.  As of  version 2.8.5, the representation
of  recorded  terms  has  changed,  and  terms   on  the  heap  are  now
represented  in a  compiled format.    SWI-Prolog no  longer limits  the
use of malloc()  or uses assumptions on  the addresses returned by  this
function.


11..66..88 VVeerrssiioonn 22..99 RReelleeaassee NNootteess

Version  2.9  is  the next  step  towards  version  3.0,  improving  ISO
compliance  and introducing  ISO  compliant  exception handling.     New
are catch/3, throw/1, abolish/1, write_term/[2,3], write_canonical/[1,2]
and  the  C-functions PL_exception() and  PL_throw().    The  predicates
display/[1,2] and  displayq/[1,2] have  been moved to  backcomp, so  old
code referring to them will autoload them.

The interface  to PL_open_query()  has changed.   The  _d_e_b_u_g argument  is
replaced  by a  bitwise or'ed  _f_l_a_g_s argument.    The  values FALSE  and
TRUE have their familiar meaning, making old code  using these constants
compatible.   Non-zero values  other than TRUE  (1) will be  interpreted
different.


11..66..99 VVeerrssiioonn 33..00 RReelleeaassee NNootteess

Complete  redesign   of  the   saved-state  mechanism,   providing   the
possibility of  `program resources'.   See  resource/3, open_resource/3,
and qsave_program/[1,2].


11..66..1100 VVeerrssiioonn 33..11 RReelleeaassee NNootteess

Improvements   on  exception-handling.       Allows  relating   software
interrupts (signals)  to exceptions,  handling signals in  Prolog and  C
(see on_signal/3  and PL_signal()).    Prolog stack  overflows now  raise
the resource_error  exception and thus  can be handled  in Prolog  using
catch/3.


11..66..1111 VVeerrssiioonn 33..33 RReelleeaassee NNootteess

Version 3.3  is a  major release,  changing many  things internally  and
externally.   The highlights are a  complete redesign of the  high-level
I/O system, which is  now based on explicit streams rather  then current
input/output.  The  old Edinburgh predicates (see/1, tell/1, etc.)   are
now defined on top of this layer instead of the other  way around.  This
fixes various internal problems and removes Prolog limits  on the number
of streams.

Much  progress  has been  made  to  improve ISO  compliance:    handling
strings  as  lists  of  one-character  atoms  is   now  supported  (next
to  character   codes  as  integers).      Many  more  exceptions   have
been  added and  printing  of exceptions  and messages  is  rationalised
using   Quintus   and   SICStus   Prolog   compatible   print_message/2,
message_hook/3 and print_message_lines/3.   All predicates described  in
[Deransart _e_t _a_l_., 1996] are now implemented.

As of version  3.3, SWI-Prolog adheres the  ISO _l_o_g_i_c_a_l _u_p_d_a_t_e _v_i_e_w  for
dynamic predicates.  See section 4.13.1 for details.

SWI-Prolog  3.3  includes garbage  collection  on  atoms,  removing  the
last serious memory  leak especially in text-manipulation  applications.
See  section 9.6.2.1.    In addition,  both the  user-level and  foreign
interface supports atoms holding _0_-_b_y_t_e_s.

Finally, an  alpha version of a  multi-threaded SWI-Prolog for Linux  is
added.    This version  is still  much slower  than the  single-threaded
version due  to frequent access to  `thread-local-data' as well as  some
too detailed  mutex locks.   The basic thread  API is ready for  serious
use and testing however.  See section 8.


11..66..1111..11 IInnccoommppaattiibbllee cchhaannggeess

A number  of incompatible changes  result from this upgrade.   They  are
all easily fixed however.

  o !/0_, call/1
    The  cut now behaves  according to the ISO  standard.  This  implies
    it  works in compound  goals passed  to call/1 and  is local to  the
    _c_o_n_d_i_t_i_o_n part of if-then-else as well as the argument of \+/1.

  o _a_t_o_m___c_h_a_r_s_/_2
    This  predicate  is now  ISO  compliant and  thus generates  a  list
    of  one-character atoms.    The behaviour  of the  old predicate  is
    available  in the  ---also ISO compliant---  atom_codes/2 predicate.
    Safest  repair is a  replacement of all  atom_chars  into atom_codes.
    If you do not want to change any source-code, you might want to use

    user:goal_expansion(atom_chars(A,B), atom_codes(A,B)).

  o _n_u_m_b_e_r___c_h_a_r_s_/_2
    Same applies for number_chars/2 and number_codes/2.

  o feature/2_, set_feature/2
    These  are replaced by  the ISO  compliant current_prolog_flag/2 and
    set_prolog_flag/2.   The library  backcomp provides definitions  for
    these predicates, so no source mmuusstt be updated.

  o _A_c_c_e_s_s_i_n_g _c_o_m_m_a_n_d_-_l_i_n_e _a_r_g_u_m_e_n_t_s
    This  used  to   be  provided  by  the  undocumented  '$argv'/1  and
    Quintus  compatible library unix/1.   Now  there is also  documented
    current_prolog_flag(_a_r_g_v_, _A_r_g_v).

  o _d_u_p___s_t_r_e_a_m_/_2
    Has  been deleted.   New  stream-aliases can deal  with most of  the
    problems  for which  dup_stream/2 was  designed and  dup/2 from  the
    _c_l_i_b package can with most others.

  o _o_p_/_3
    Operators  are now llooccaall ttoo mmoodduulleess.  This implies  any modification
    of  the operator-table does  not influence other  modules.  This  is
    consistent  with the proposed ISO behaviour and a necessity  to have
    any usable handling of operators in a multi-threaded environment.

  o _s_e_t___p_r_o_l_o_g___f_l_a_g_(_c_h_a_r_a_c_t_e_r___e_s_c_a_p_e_s_, _B_o_o_l_)
    This  Prolog flag is now an interface to changing attributes  on the
    current source-module,  effectively making this flag module-local as
    well.   This is required for consistent handling of  sources written
    with  ISO (obligatory) character-escape sequences together  with old
    Edinburgh code.

  o _c_u_r_r_e_n_t___s_t_r_e_a_m_/_3 _a_n_d _s_t_r_e_a_m___p_o_s_i_t_i_o_n
    These predicates have been moved to quintus.


11..66..1122 VVeerrssiioonn 33..44 RReelleeaassee NNootteess

The  3.4 release  is  a consolidation  release.    It  consolidates  the
improvements  and  standard conformance  of  the  3.3 releases.     This
version  is closely  compatible  with the  3.3  version except  for  one
important change:

  o _A_r_g_u_m_e_n_t _o_r_d_e_r _i_n select/3
    The  list-processing  predicate select/3  somehow  got into  a  very
    early  version of SWI-Prolog  with the wrong  argument order.   This
    has been fixed in  3.4.0.  The correct order is select(?Elem, ?List,
    ?Rest).

    As  select/3 has  no error  conditions, runtime  checking cannot  be
    done.   To simplify  debugging, the library module checkselect  will
    print  references to  select/3  in your  source code  and install  a
    version  of select that enters the debugger if select is  called and
    the second argument is not a list.

    This   library   can    be   loaded   explicitly   or   by   calling
    check_old_select/0.


11..66..1133 VVeerrssiioonn 44..00 RReelleeaassee NNootteess

As of  version 4.0 the  standard distribution  of SWI-Prolog is  bundled
with a  number of its  popular extension packages,  among which the  now
open source XPCE GUI toolkit (see section 1.5).   No significant changes
have been made to the basic SWI-Prolog engine.

Some useful tricks in the integrated environment:

  o _R_e_g_i_s_t_e_r _t_h_e _G_U_I _t_r_a_c_e_r
    Using  a call to guitracer/0,  hooks are installed that replace  the
    normal command-line driven tracer with a graphical front-end.

  o _R_e_g_i_s_t_e_r _P_c_e_E_m_a_c_s _f_o_r _e_d_i_t_i_n_g _f_i_l_e_s
    From  your initialisation file.  you  can load emacs/swi_prolog that
    cause edit/1 to use the built-in PceEmacs editor.


11..66..1144 VVeerrssiioonn 55..00 RReelleeaassee NNootteess

Version  5.0 marks  a breakpoint  in  the philosophy,  where  SWI-Prolog
moves  from  a  dual GPL/proprietary  to  a  uniform  LGPL  (Lesser  GNU
Public Licence)  schema, providing  a widely usable  Free Source  Prolog
implementation.

On  the  technical  site  the  development  environment,  consisting  of
source-level  debugger,  integrated  editor  and  various  analysis  and
navigation tools progress steadily towards a mature set of tools.

Many portability issues have been improved, including a  port to MacOS X
(Darwin).

For details, please visit the new website at http://www.swi-prolog.org


11..66..1155 VVeerrssiioonn 55..11 RReelleeaassee NNootteess

Version 5.1 is  a beta-serie introducing portable multi-threading.   See
chapter 8.   In  addition it introduces many  new facilities to  support
server applications,  such as  the new  rlimit library  to limit  system
resources and the possibility to set timeouts on input streams.


11..66..1166 VVeerrssiioonn 55..22 RReelleeaassee NNootteess

Version  5.2  consolidates   the  5.1.x  beta  series  that   introduced
threading and many related modifications to the kernel.


11..66..1177 VVeerrssiioonn 55..33 RReelleeaassee NNootteess

Version  5.3.x   is  a  development   series  for  adding   coroutining,
constraints, global variables,  cyclic terms (infinite trees) and  other
goodies  to the  kernel.   The  package JPL,  providing a  bidirectional
Java/Prolog  interface is  added to  the common  source-tree and  common
binary packages.


11..66..1188 VVeerrssiioonn 55..44 RReelleeaassee NNootteess

Version 5.4 consolidates the 5.3.x beta series.


11..66..1199 VVeerrssiioonn 55..55 RReelleeaassee NNootteess

Version  5.5.x provides  support  for  _w_i_d_e _c_h_a_r_a_c_t_e_r_s  with  UTF-8  and
UNICODE I/O  (section 2.17.1).   On both 32  and 64-bit hardware  Prolog
integers are now at  minimum 64-bit integers.  If available,  SWI-Prolog
arithmetic  uses the  GNU  GMP  library to  provided  _u_n_b_o_u_n_d_e_d  integer
arithmetic  as well  as rational  arithmetic.    Adding GMP  support  is
sponsored  by Scientific  Software and  Systems Limited,  www.sss.co.nz.
This version also incorporates clp(r) by Christian  Holzbaur, brought to
SWI-Prolog by Tom Schrijvers and Leslie De Koninck (section 11.8).


11..66..2200 VVeerrssiioonn 55..66 RReelleeaassee NNootteess

Version 5.6 consolidates the 5.5.x beta series.


11..77 DDoonnaattee ttoo tthhee SSWWII--PPrroolloogg pprroojjeecctt

If you  are happy with  SWI-Prolog, you  care it to  be around for  much
longer while it becomes  faster, more stable and with more  features you
should consider to  donate to the SWI-Prolog  foundation.  Please  visit
the page below.

    http://www.swi-prolog.org/donate.html


11..88 AAcckknnoowwlleeddggeemmeennttss

Some small parts of the Prolog code of SWI-Prolog  are modified versions
of the corresponding Edinburgh C-Prolog code:   grammar rule compilation
and  writef/2.    Also some  of  the  C-code originates  from  C-Prolog:
finding the  path of the  currently running executable  and some of  the
code underlying  absolute_file_name/2.   Ideas  on programming style  and
techniques originate from  C-Prolog and Richard O'Keefe's _t_h_i_e_f  editor.
An  important  source  of inspiration  are  the  programming  techniques
introduced by Anjo Anjewierden in PCE version 1 and 2.

I also  would like to thank  those who had the  fade of using the  early
versions of this system,  suggested extensions or reported bugs.   Among
them are Anjo Anjewierden, Huub Knops, Bob  Wielinga, Wouter Jansweijer,
Luc Peerdeman, Eric Nombden, Frank van Harmelen, Bert Rengel.

Martin Jansche  (jansche@novell1.gs.uni-heidelberg.de) has been so  kind
to reorganise the sources for version 2.1.3 of this manual.

Horst  von Brand  has been  so  kind to  fix many  typos  in the  2.7.14
manual.  Thanks!

Bart  Demoen and  Tom  Schrijvers  have helped  me  adding  coroutining,
constraints,  global  variables and  support  for  cyclic terms  to  the
kernel.   Tom has provided the  integer interval constraint solver,  the
CHR compiler and some of the coroutining predicates.

Paul Singleton has integrated Fred Dushin's  Java-calls-Prolog side with
his Prolog-calls-Java side into the current  bidirectional JPL interface
package.

Richard O'Keefe  is gratefully acknowledged for  his efforts to  educate
beginners as well as valuable comments on proposed new developments.

Scientific  Software and  Systems Limited,  www.sss.co.nz has  sponsored
the development  if the  SSL library  as well as  unbounded integer  and
rational number arithmetic.

Leslie de Koninck has made clp(QR) available to SWI-Prolog.

Markus Triska has contributed to various libraries.

Paulo  Moura's  great   experience  in  maintaining  Logtalk  for   many
Prolog systems  including SWI-Prolog  has helped in  many places  fixing
compatibility issues.   He also worked on the MacOS port and  fixed many
typos in the 5.6.9 release of the documentation.


CChhaapptteerr 22..  OOVVEERRVVIIEEWW


22..11 GGeettttiinngg ssttaarrtteedd qquuiicckkllyy


22..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg


22..11..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg oonn UUnniixx

By default, SWI-Prolog is installed as `pl',  though some administrators
call  it  `swipl'  or `swi-prolog'.     The  command-line  arguments  of
SWI-Prolog  itself  and  its  utility  programs   are  documented  using
standard  Unix  man pages.     SWI-Prolog  is normally  operated  as  an
interactive application simply by starting the program:

machine% pl
Welcome to SWI-Prolog (Version 5.6.42)
Copyright (c) 1990-2007 University of Amsterdam.
SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software,
and you are welcome to redistribute it under certain conditions.
Please visit http://www.swi-prolog.org for details.

For help, use ?- help(Topic). or ?- apropos(Word).

1 ?-

After  starting Prolog,  one  normally loads  a  program into  it  using
consult/1, which  --- for historical reasons  --- may be abbreviated  by
putting the  name of  the program  file between  square brackets.    The
following  goal loads  the  file  likes.pl containing  clauses  for  the
predicates likes/2:

?- [likes].
% likes compiled, 0.00 sec, 596 bytes.

Yes
?-

After this  point, Unix  and Windows users  unite, so  if you are  using
Unix please continue at section 2.1.2.


22..11..11..22 SSttaarrttiinngg SSWWII--PPrroolloogg oonn WWiinnddoowwss

After SWI-Prolog has been  installed on a Windows system,  the following
important new things are available to the user:

  o A  folder  (called  _d_i_r_e_c_t_o_r_y in  the  remainder of  this  document)
    called  pl  containing the  executables,  libraries, etc.    of  the
    system.  No files are installed outside this directory.

  o A  program  plwin.exe,  providing  a  window  for  interaction  with
    Prolog.  The  program plcon.exe is a version of SWI-Prolog that runs
    in a DOS-box.

  o The  file-extension .pl  is associated with  the program  plwin.exe.
    Opening  a .pl file will cause plwin.exe to start,  change directory
    to  the directory in  which the file-to-open  resides and load  this
    file.

The  normal   way  to  start  with   the  likes.pl  file  mentioned   in
section 2.1.1.1  is by simply double-clicking  this file in the  Windows
explorer.


22..11..22 EExxeeccuuttiinngg aa qquueerryy

After loading a program,  one can ask Prolog queries about  the program.
The query below asks Prolog what food `sam' likes.   The system responds
with X = <_v_a_l_u_e> if it can prove the goal for a certain _X. The  user can
type the semi-colon  (;) if (s)he wants  another solution, or return  if
(s)he is satisfied, after which Prolog will say YYeess.   If Prolog answers
NNoo,  it  indicates it  cannot  find any  (more)  answers to  the  query.
Finally, Prolog can answer using an error message  to indicate the query
or program contains an error.

?- likes(sam, X).

X = dahl ;

X = tandoori ;

...

X = chips ;

No
?-


22..22 TThhee uusseerr''ss iinniittiiaalliissaattiioonn ffiillee

After  the necessary  system  initialisation  the system  consults  (see
consult/1) the user's startup file.  The base-name  of this file follows
conventions of  the operating  system.   On MS-Windows,  it is the  file
pl.ini  and on  Unix systems  .plrc.   The  file is  searched using  the
file_search_path/2 clauses for user_profile.  The table below  shows the
default value for this search-path.   The phrase <_a_p_p_d_a_t_a> refers to the
Windows CSIDL  name for  the folder.   The  actual name  depends on  the
Windows language.  English versions typically use ApplicationData.   See
also win_folder/2

                   ___________________________________
                   |______________|UUnniixx__||WWiinnddoowwss__________________________||
                   || llooccaall ||.    |.                   |
                   |_hhoommee__||~____|<_a_p_p_d_a_t_a>/SWI-Prolog_|

After the  first startup  file is found  it is  loaded and Prolog  stops
looking for further startup files.  The name of the  startup file can be
changed with the  `-f file' option.   If _F_i_l_e denotes an absolute  path,
this file is loaded,  otherwise the file is searched for using  the same
conventions as for the default startup file.  Finally,  if _f_i_l_e is none,
no file is loaded.

See  also  the  -s  (script)  and  -F  (system-wide  initialisation)  in
section 2.4 and section 2.3.


22..33 IInniittiiaalliissaattiioonn ffiilleess aanndd ggooaallss

Using  command-line  arguments (see  section  2.4),  SWI-Prolog  can  be
forced to  load files  and execute queries  for initialisation  purposes
or  non-interactive operation.    The  most  commonly used  options  are
-f file or  -s file to  make Prolog load  a file,  -g goal to define  an
initialisation  goal and  -t goal to  define the  _t_o_p_-_l_e_v_e_l _g_o_a_l.    The
following  is a  typical example  for starting  an application  directly
from the command-line.

machine% pl -s load.pl -g go -t halt

It  tells  SWI-Prolog to  load  load.pl,  start  the  application  using
the  _e_n_t_r_y_-_p_o_i_n_t  go/0  and  ---instead  of   entering  the  interactive
top-level---  exit after  completing  go/0.    The  -q  may be  used  to
suppress all informational messages.

In  MS-Windows,  the  same  can  be  achieved  using  a  short-cut  with
appropriately  defined  command-line  arguments.      A  typically  seen
alternative  is to  write  a file  run.pl  with content  as  illustrated
below.  Double-clicking run.pl will start the application.

:- [load].                      % load program
:- go.                          % run it
:- halt.                        % and exit

Section  2.10.2.1 discusses  further scripting  options  and chapter  10
discusses the  generation of runtime executables.   Runtime  executables
are  a mean  to  deliver executables  that  do  not require  the  Prolog
system.


22..44 CCoommmmaanndd--lliinnee ooppttiioonnss

The full set of command-line options is given below:

----hheellpp
    When  given as  the only  option, it summarises  the most  important
    options.  Also available as -h and -help.

----vveerrssiioonn
    When  given as the  only option, it  summarises the version and  the
    architecture identifier.  Also available as -v.

----aarrcchh
    When   given  as  the  only  option,  it  prints   the  architecture
    identifier   (see  Prolog  flag   arch)  and  exits.      See   also
    -dump-runtime-variables.  Also available as -arch.

----dduummpp--rruunnttiimmee--vvaarriiaabblleess
    When  given as  the only option,  it prints  a sequence of  variable
    settings  that can  be  used in  shell-scripts to  deal with  Prolog
    parameters.   This feature is  also used by plld (see section  9.7).
    Below  is a typical example of  using this feature.  Also  available
    as -dump-runtime-variables.

    eval `pl --dump-runtime-variables`
    cc -I$PLBASE/include -L$PLBASE/runtime/$PLARCH ...

    The  option can be  followed by  =sh to dump  in POSIX shell  format
    (default) or cmd to dump in MS-Windows cmd.exe compatible format.

----wwiinn__aapppp
    This  option  is  available  only  in  plwin.exe  and  is  used  for
    the   start-menu  item.      If  causes   plwin  to  start  in   the
    folder  ...\My Documents\Prolog  or  local equivalent  thereof  (see
    win_folder/2).   The Prolog subdirectory  is created if it does  not
    exist.

----qquuiieett
    Set  the Prolog  flag verbose to  silent, suppressing  informational
    and banner messages.  Also available as -q.

--LL_s_i_z_e_[_k_m_g_]
    Give  local stack limit (default 16Mb  on 32-bit and 32Mb on  64-bit
    hardware).   Note  that there  is no space  between the size  option
    and  its  argument.   By  default, the  argument  is interpreted  in
    Kbytes.   Postfix the  argument with m for  Mbytes or g for  Gbytes.
    The following example specifies 64 Mbytes local stack.

    % pl -L64m

    A maximum is  useful to stop buggy programs from claiming all memory
    resources.   -L0 sets the limit to the highest possible value.   See
    section 2.18.

--GG_s_i_z_e_[_k_m_g_]
    Give  global  stack limit  (4 Mbytes  default).    See -L  for  more
    details.

--TT_s_i_z_e_[_k_m_g_]
    Give  trail  stack  limit  (4  Mbytes  default).     This  limit  is
    relatively  high because trail-stack overflows are not  often caused
    by program bugs.  See -L for more details.

--AA_s_i_z_e_[_k_m_g_]
    Give  argument stack limit (1 Mbytes  default).  The argument  stack
    limits  the  maximum  nesting of  terms  that  can be  compiled  and
    executed.    SWI-Prolog does `last-argument  optimisation' to  avoid
    many  deeply nested  structure  using this  stack.   Enlarging  this
    limit is only necessary in extreme cases.  See -L for more details.

--cc _f_i_l_e _._._.
    Compile files into an `intermediate code file'.  See section 2.10.

--oo _o_u_t_p_u_t
    Used  in combination  with -c  or -b  to determine  output file  for
    compilation.

--OO
    Optimised  compilation.  See current_prolog_flag/2flag  optimise for
    details.

----nnooddeebbuugg
    Disable   debugging.        See   the   current_prolog_flag/2   flag
    generate_debug_info for details.

--ss _f_i_l_e
    Use  _f_i_l_e as a  script-file.   The script file  is loaded after  the
    initialisation  file  specified with  the -f file  option.    Unlike
    -f file,  using -s does  not stop Prolog  from loading the  personal
    initialisation file.

--ff _f_i_l_e
    Use _f_i_l_e as  initialisation file instead of the default .plrc (Unix)
    or pl.ini (Windows).   `-f none' stops SWI-Prolog from searching for
    a  startup file.    This option  can be  used as  an alternative  to
    -s file  that stops Prolog from loading the  personal initialisation
    file.  See also section 2.2.

--FF _s_c_r_i_p_t
    Selects  a startup-script from the  SWI-Prolog home directory.   The
    script-file  is  named <_s_c_r_i_p_t>.rc.    The  default _s_c_r_i_p_t  name  is
    deduced  from  the  executable,  taking the  leading  alphanumerical
    characters  (letters, digits and underscore) from  the program-name.
    -F none stops looking  for a script.  Intended for simple management
    of  slightly  different  versions.    One  could for  example  write
    a  script  iso.rc  and  then select  ISO  compatibility  mode  using
    pl -F iso or make a link from iso-pl to pl.

--gg _g_o_a_l
    _G_o_a_l  is executed just before entering the top level.  Default  is a
    predicate  which prints the  welcome message.   The welcome  message
    can  thus be suppressed by  giving -g true.   _g_o_a_l can be a  complex
    term.    In  this case  quotes  are normally  needed to  protect  it
    from  being  expanded by  the shell.    A  save way  to  run a  goal
    non-interactively is here:

    % pl <options> -g go,halt -t 'halt(1)'

--tt _g_o_a_l
    Use  _g_o_a_l  as  interactive top-level  instead  of the  default  goal
    prolog/0.    _g_o_a_l can  be a  complex term.   If  the top-level  goal
    succeeds  SWI-Prolog exits  with status  0.   If it  fails the  exit
    status  is 1.  If the toplevel raises an exception, this  is printed
    as an uncaught error  and the toplevel is restarted.  This flag also
    determines the goal started  by break/0 and abort/0.  If you want to
    stop  the user from entering interactive mode start  the application
    with `-g goal' and give `halt' as top-level.

--ttttyy
    Unix  only.      Switches  controlling  the  terminal  for  allowing
    single-character  commands to the tracer and  get_single_char/1.   By
    default  manipulating  the terminal  is  enabled unless  the  system
    detects  it is not  connected to a  terminal or it  is running as  a
    GNU-Emacs  inferior process.   This flag  is sometimes required  for
    smooth interaction with other applications.

----nnoossiiggnnaallss
    Inhibit any signal  handling by Prolog, a property that is sometimes
    desirable  for embedded  applications.   This option  sets the  flag
    signals to false.  See section 9.6.20.1 for details.

----hhoommee==DDIIRR
    Use DIR as home directory.  See section 9.8 for details.

--xx _b_o_o_t_f_i_l_e
    Boot  from _b_o_o_t_f_i_l_e instead  of the system's default  boot file.   A
    bootfile is a  file resulting from a Prolog compilation using the -b
    or -c option or a program saved using qsave_program/[1,2].

--pp _a_l_i_a_s_=_p_a_t_h_1_[_:_p_a_t_h_2 _._._._]
    Define  a path alias for file_search_path.  _a_l_i_a_s is the name  of the
    alias,  _p_a_t_h_1 _._._.  is  a list of values for  the alias.  On  Windows
    the  list-separator is ;.   On other  systems it is :.   A value  is
    either  a term of the form  alias(value) or pathname.  The  computed
    aliases  are added  to file_search_path/2 using  asserta/1, so  they
    precede  predefined values  for the  alias.   See file_search_path/2
    for details on using this file-location mechanism.

--
    Stops  scanning for more  arguments, so you  can pass arguments  for
    your  application after this  one.   See current_prolog_flag/2 using
    the flag argv for obtaining the command-line arguments.

The following options  are for system maintenance.   They are given  for
reference only.

--bb _i_n_i_t_f_i_l_e _._._.-c _f_i_l_e _._._.
    Boot  compilation.   _i_n_i_t_f_i_l_e  _._._.   are compiled  by the  C-written
    bootstrap  compiler,  _f_i_l_e  _._._.    by  the normal  Prolog  compiler.
    System maintenance only.

--dd _l_e_v_e_l
    Set  debug  level to  _l_e_v_e_l.    Only  has effect  if the  system  is
    compiled with the -DO_DEBUG flag.  System maintenance only.


22..55 GGNNUU EEmmaaccss IInntteerrffaaccee

The default  Prolog mode for  GNU-Emacs can be  activated by adding  the
following rules to your Emacs initialisation file:

(setq auto-mode-alist
      (append
       '(("\\.pl" . prolog-mode))
       auto-mode-alist))
(setq prolog-program-name "pl")
(setq prolog-consult-string "[user].\n")
;If you want this.  Indentation is either poor or I don't use
;it as intended.
;(setq prolog-indent-width 8)

Unfortunately the  default Prolog mode  of GNU-Emacs  is not very  good.
An  alternative  prolog.el  file for  GNU-Emacs  20  is  available  from
http://www.freesoft.cz/ pdm/software/emacs/prolog-mode/  and  for   GNU-
Emacs 19 from http://w1.858.telia.com/ u85810764/Prolog-mode/index.html


22..66 OOnnlliinnee HHeellpp

Online  help  provides a  fast  lookup  and browsing  facility  to  this
manual.   The online  manual can show predicate  definitions as well  as
entire sections of the manual.

The online help  is displayed from the  file 'MANUAL'. The file  helpidx
provides  an index  into  this  file.    'MANUAL'  is created  from  the
LaTeX sources  with a modified version  of dvitty, using overstrike  for
printing bold  text and  underlining for  rendering italic text.    XPCE
is shipped  with swi_help,  presenting the information  from the  online
help in a hypertext  window.  The Prolog flag  write_help_with_overstrike
controls whether  or not help/1  writes its  output using overstrike  to
realise bold  and underlined  output or  not.   If this  Prolog flag  is
not  set it  is initialised  by the  help library  to true  if the  TERM
variable equals  xterm and false  otherwise.  If  this default does  not
satisfy you, add the  following line to your personal startup  file (see
section 2.2):

:- set_prolog_flag(write_help_with_overstrike, true).


hheellpp
    Equivalent to help(help/1).


hheellpp((_+_W_h_a_t))
    Show specified part of the manual.  _W_h_a_t is one of:

          <Name>/<_A_r_i_t_y> Give help on specified predicate
          <Name>         Give  help  on named  predicate  with any
                         arity  or C interface  function with that
                         name
          <Section>      Display  specified   section.     Section
                         numbers are  dash-separated numbers:  2-3
                         refers  to  section  2.3  of the  manual.

                         Section   numbers   are  obtained   using
                         apropos/1.

    Examples:

       ?- help(assert).     Give help on predicate assert
       ?- help(3-4).        Display section 3.4 of the manual
       ?- help('PL_retry'). Give    help   on    interface   function
                            PL_retry()

    See also apropos/1,  and the SWI-Prolog home page at http://www.swi-
    prolog.org,  which provides  a FAQ,  an HTML version  of manual  for
    online browsing and HTML and PDF versions for downloading.


aapprrooppooss((_+_P_a_t_t_e_r_n))
    Display all predicates,  functions and sections that have _P_a_t_t_e_r_n in
    their  name or summary  description.   Lowercase letters in  _P_a_t_t_e_r_n
    also match a corresponding uppercase letter.  Example:

        ?- apropos(file).  Display  predicates,  functions and  sec-
                           tions that have  `file' (or `File', etc.)
                           in their summary description.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n))
    Give an explanation on  the given `object'.  The argument may be any
    Prolog  data object.   If  the argument is  an atom,  a term of  the
    form  _N_a_m_e_/_A_r_i_t_y or a term of the form  _M_o_d_u_l_e_:_N_a_m_e_/_A_r_i_t_y, explain/1
    describes  the predicate as well as possible references to it.   See
    also gxref/0.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n_, _-_E_x_p_l_a_n_a_t_i_o_n))
    Unify  _E_x_p_l_a_n_a_t_i_o_n with an explanation for _T_o_E_x_p_l_a_i_n.   Backtracking
    yields further explanations.


22..77 CCoommmmaanndd--lliinnee hhiissttoorryy

SWI-Prolog offers a query substitution mechanism called `history'.   The
availability of  this feature is controlled  by set_prolog_flag/2,  using
the  history Prolog  flag.   By  default,  history is  available if  the
Prolog flag  readline is  false.   To enable  this feature,  remembering
the last  50 commands,  put the  following into your  startup file  (see
section 2.2):

:- set_prolog_flag(history, 50).

The history  system allows the  user to compose  new queries from  those
typed  before and  remembered by  the  system.   The  available  history
commands are  shown in  table 2.1.   History  expansion is  not done  if
these sequences appear in quoted atoms or strings.
             ______________________________________________
             | !!.   |Repeat last query                     |

             | !nr.  |Repeat query numbered <_n_r>            |
             | !str. |Repeat last query starting with <_s_t_r> |
             | h.    |Show history of commands              |
             |_!h.___|Show_this_list_______________________ |

                      Table 2.1:  History commands


22..88 RReeuussee ooff ttoopp--lleevveell bbiinnddiinnggss

Bindings resulting  from the  successful execution of  a top-level  goal
are asserted  in a  database.   These values  may be  reused in  further
top-level  queries as  $Var.    Only the  latest binding  is  available.
Example:
1 ?- maplist(plus(1), "hello", X).

X = [105,102,109,109,112]

Yes
2 ?- format('~s~n', [$X]).
ifmmp

Yes

3 ?-

                Figure 2.1:  Reusing top-level bindings

Note that variables may be set by executing =/2:

6 ?- X = statistics.

X = statistics

Yes
7 ?- $X.
28.00 seconds cpu time for 183,128 inferences
4,016 atoms, 1,904 functors, 2,042 predicates, 52 modules
55,915 byte codes; 11,239 external references

                      Limit    Allocated       In use
Heap         :                                624,820 Bytes
Local  stack :    2,048,000        8,192          404 Bytes
Global stack :    4,096,000       16,384          968 Bytes
Trail  stack :    4,096,000        8,192          432 Bytes

Yes
8 ?-


22..99 OOvveerrvviieeww ooff tthhee DDeebbuuggggeerr

SWI-Prolog has a 6-port  tracer, extending the standard 4-port  Byrd box
model tracer  [Byrd, 1980, Clocksin & Melish, 1987] with two  additional
ports.   The optional _u_n_i_f_y port allows  the user to inspect the  result
after unification  of the  head.   The _e_x_c_e_p_t_i_o_n  port shows  exceptions
raised by throw/1 or one of the built-in predicates.  See section 4.9.

The standard  ports are called call,  exit, redo, fail  and unify.   The
tracer is started  by the trace/0 command,  when a spy point is  reached
and the system is  in debugging mode (see spy/1 and debug/0) or  when an
exception is raised.

The interactive top-level  goal trace/0 means ``trace the next  query''.
The tracer shows the  port, displaying the port name, the  current depth
of the  recursion and the goal.   The goal  is printed using the  Prolog
predicate  write_term/2.     The style  is  defined  by the  Prolog  flag
debugger_print_options and can be modified using this flag or  using the
w, p and d commands of the tracer.
1 ?- visible(+all), leash(-exit).

Yes
2 ?- trace, min([3, 2], X).
  Call:  ( 3) min([3, 2], G235) ? creep
  Unify: ( 3) min([3, 2], G235)
  Call:  ( 4) min([2], G244) ? creep
  Unify: ( 4) min([2], 2)
  Exit:  ( 4) min([2], 2)

  Call:  ( 4) min(3, 2, G235) ? creep
  Unify: ( 4) min(3, 2, G235)
  Call:  ( 5) 3 < 2 ? creep
  Fail:  ( 5) 3 < 2 ? creep
  Redo:  ( 4) min(3, 2, G235) ? creep
  Exit:  ( 4) min(3, 2, 2)
  Exit:  ( 3) min([3, 2], 2)

Yes
[trace] 3 ?-

                       Figure 2.2:  Example trace

On _l_e_a_s_h_e_d  _p_o_r_t_s (set  with the  predicate leash/1,  default are  call,
exit, redo and  fail) the user is prompted  for an action.  All  actions
are single character  commands which are executed wwiitthhoouutt waiting  for a
return, unless the command-line option -tty is active.  Tracer options:

+ ((SSppyy))
    Set a spy point (see spy/1) on the current predicate.

- ((NNoo ssppyy))
    Remove the spy point (see nospy/1) from the current predicate.

/ ((FFiinndd))
    Search  for a port.   After the  `/', the user  can enter a line  to
    specify  the port to  search for.   This line consists  of a set  of
    letters  indicating the  port type,  followed by  an optional  term,
    that  should unify with  the goal run by  the port.   If no term  is
    specified  it is taken as a variable, searching for any port  of the
    specified  type.  If an atom is given, any goal whose  functor has a
    name equal to that atom matches.  Examples:

            /f               Search for any fail port

            /fe solve        Search for a  fail or exit  port of
                             any goal with name solve
            /c solve(a, _)   Search for a call to  solve/2 whose
                             first argument is a variable or the
                             atom a
            /a member(_, _)  Search for  any  port on  member/2.
                             This is equivalent to setting a spy
                             point on member/2.

. ((RReeppeeaatt ffiinndd))
    Repeat the last find command (see `/').

A ((AAlltteerrnnaattiivveess))
    Show all goals that have alternatives.

C ((CCoonntteexxtt))
    Toggle  `Show Context'.   If on, the context  module of the goal  is
    displayed between square brackets (see section 5).  Default is off.

L ((LLiissttiinngg))
    List the current predicate with listing/1.

a ((AAbboorrtt))
    Abort Prolog execution (see abort/0).

b ((BBrreeaakk))
    Enter a Prolog break environment (see break/0).

c ((CCrreeeepp))
    Continue execution, stop at next port.  (Also return, space).

d ((DDiissppllaayy))
    Set  the max_depth(_D_e_p_t_h) option of debugger_print_options,  limiting
    the  depth  to which  terms are  printed.    See also  the  w and  p
    options.

e ((EExxiitt))
    Terminate Prolog (see halt/0).

f ((FFaaiill))
    Force failure of the current goal.

g ((GGooaallss))
    Show the list of  parent goals (the execution stack).  Note that due
    to  tail recursion optimization a  number of parent goals might  not
    exist any more.

h ((HHeellpp))
    Show available options (also `?').

i ((IIggnnoorree))
    Ignore the current goal, pretending it succeeded.

l ((LLeeaapp))
    Continue execution, stop at next spy point.

n ((NNoo ddeebbuugg))
    Continue execution in `no debug' mode.

p ((PPrriinntt))
    Set  the Prolog  flag debugger_print_options to  [quoted(true), por-
    tray(true), max_depth(10), priority(699)].  This is the default.

r ((RReettrryy))
    Undo  all actions (except for database and i/o actions) back  to the
    call  port of  the current  goal and  resume execution  at the  call
    port.

s ((SSkkiipp))
    Continue  execution,  stop  at the  next  port  of tthhiiss  goal  (thus
    skipping all calls to children of this goal).

u ((UUpp))
    Continue  execution, stop at the next port of tthhee ppaarreenntt  goal (thus
    skipping  this goal and all calls to  children of this goal).   This
    option is useful to stop tracing a failure driven loop.

w ((WWrriittee))
    Set      the      Prolog     flag      debugger_print_options     to
    [quoted(true), attributes(write), priority(699)],          bypassing
    portray/1, etc.

The  ideal 4  port Byrd  box  model [Byrd, 1980]  as described  in  many
Prolog books  [Clocksin & Melish, 1987] is  not visible  in many  Prolog
implementations because  code optimisation removes  part of the  choice-
and exit-points.    Backtrack points are  not shown  if either the  goal
succeeded  deterministically  or its  alternatives  were  removed  using
the  cut.    When running  in debug  mode  (debug/0) choice  points  are
only  destroyed when  removed by  the cut.    In debug  mode, last  call
optimisation is switched off.

Reference information to  all predicates available for manipulating  the
debugger is in section 4.38.


22..1100 CCoommppiillaattiioonn


22..1100..11 DDuurriinngg pprrooggrraamm ddeevveellooppmmeenntt

During  program   development,  programs   are  normally  loaded   using
consult/1, or the list abbreviation.  It is  common practice to organise
a project  as a  collection of source  files and a  _l_o_a_d_-_f_i_l_e, a  Prolog
file  containing only  use_module/[1,2]  or ensure_loaded/1  directives,
possibly  with a  definition  of the  _e_n_t_r_y_-_p_o_i_n_t  of the  program,  the
predicate that  is normally used  to start  the program.   This file  is
often  called load.pl.    If the  entry-point is  called _g_o,  a  typical
session starts as:

% pl
<banner>

1 ?- [load].
<compilation messages>

Yes
2 ?- go.
<program interaction>

When  using  Windows,  the  user  may  open  load.pl  from  the  Windows
explorer,  which will cause  plwin.exe to  be started  in the  directory
holding load.pl.  Prolog loads load.pl before entering the top-level.


22..1100..22 FFoorr rruunnnniinngg tthhee rreessuulltt

There are  various options if  you want to make  your program ready  for
real usage.   The best  choice depends on whether  the program is to  be
used only  on machines  holding the SWI-Prolog  development system,  the
size of the program and the operating system (Unix vs. Windows).


22..1100..22..11 UUssiinngg PPrroollooggSSccrriipptt

New in  version 4.0.5  is the possibility  to use  a Prolog source  file
directly  as a  Unix  script-file.   The  same  mechanism is  useful  to
specify additional parameters for running a Prolog file on Windows.

If the  first letter of a  Prolog file is #,  the first line is  treated
as comment.  To  create a Prolog script, make the first line  start like
this:

    #!/path/to/pl <_o_p_t_i_o_n_s> -s

Prolog recognises this  starting sequence and causes the interpreter  to
receive the following argument-list:

    /path/to/pl <_o_p_t_i_o_n_s> -s <_s_c_r_i_p_t> -- <_S_c_r_i_p_t_A_r_g_u_m_e_n_t_s>

Instead of  -s, the user may  use -f to stop  Prolog from looking for  a
personal initialisation file.

Here is a simple script doing expression evaluation:

#!/usr/bin/pl -q -t main -f

eval :-
        current_prolog_flag(argv, Argv),
        append(_, [--|Args], Argv),
        concat_atom(Args, ' ', SingleArg),
        term_to_atom(Term, SingleArg),
        Val is Term,
        format('~w~n', [Val]).

main :-
        catch(eval, E, (print_message(error, E), fail)),
        halt.
main :-
        halt(1).

And here are two example runs:

% eval 1+2
3
% eval foo
ERROR: Arithmetic: `foo/0' is not a function
%

TThhee  WWiinnddoowwss  vveerrssiioonn supports  the  #!  construct  too,   but  here  it
serves  a rather  different role.    The  Windows shell  already  allows
the  user to  start Prolog  source files  directly  through the  Windows
file-type  association.   Windows  however makes  it rather  complicated
to provide  additional parameters, such  as the required stack-size  for
an individual  Prolog file.   The #! line  provides for this,  providing
a  more flexible  approach  than changing  the  global  defaults.    The
following starts  Prolog with unlimited stack-size  on the given  source
file:

#!/usr/bin/pl -L0 -T0 -G0 -s

....

Note the  use of  /usr/bin/pl, which  specifies the interpreter.    This
argument is ignored in the Windows version, but  required to ensure best
cross-platform compatibility.


22..1100..22..22 CCrreeaattiinngg aa sshheellll--ssccrriipptt

With  the introduction  of _P_r_o_l_o_g_S_c_r_i_p_t  (see section  2.10.2.1),  using
shell-scripts  as explained  in this  section has  become redundant  for
most applications.

Especially  on  Unix systems  and  not-too-large  applications,  writing
a  shell-script  that  simply  loads  your  application  and  calls  the
entry-point is often a good choice.  A skeleton for  the script is given
below, followed by the Prolog code to obtain the program arguments.

#!/bin/sh

base=<absolute-path-to-source>
PL=pl

exec $PL -f none -g "load_files(['$base/load'],[silent(true)])" \
         -t go -- $*

go :-
        current_prolog_flag(argv, Arguments),
        append(_SytemArgs, [--|Args], Arguments), !,
        go(Args).

go(Args) :-
        ...

On Windows  systems, similar  behaviour can  be achieved  by creating  a
shortcut to Prolog, passing the proper options or writing a .bat file.


22..1100..22..33 CCrreeaattiinngg aa ssaavveedd--ssttaattee

For  larger programs,  as  well as  for programs  that are  required  to
run  on systems  that  do not  have  the SWI-Prolog  development  system
installed,  creating a  saved  state is  the  best solution.    A  saved
state is created using qsave_program/[1,2] or using the  linker plld(1).
A  saved state  is a  file  containing machine-independent  intermediate
code  in  a  format  dedicated  for  fast  loading.    Optionally,   the
emulator may be integrated  in the saved state, creating  a single-file,
but  machine-dependent,  executable.    This  process  is  described  in
chapter 10.


22..1100..22..44 CCoommppiillaattiioonn uussiinngg tthhee --cc ccoommmmaanndd--lliinnee ooppttiioonn

This mechanism loads a series of Prolog source files  and then creates a
saved-state as qsave_program/2 does.  The command syntax is:

% pl [option ...] [-o output] -c file ...

The  _o_p_t_i_o_n_s argument  are  options to  qsave_program/2 written  in  the
format below.    The option-names  and their values  are described  with
qsave_program/2.

    --_o_p_t_i_o_n_-_n_a_m_e=_o_p_t_i_o_n_-_v_a_l_u_e

For  example,  to  create  a  stand-alone   executable  that  starts  by
executing main/0  and for which  the source  is loaded through  load.pl,
use the command

% pl --goal=main --stand_alone=true -o myprog -c load.pl

This performs exactly the same as executing

% pl
<banner>
?- [load].
?- qsave_program(myprog,
                 [ goal(main),
                   stand_alone(true)
                 ]).
?- halt.


22..1111 EEnnvviirroonnmmeenntt CCoonnttrrooll ((PPrroolloogg ffllaaggss))

The  predicates  current_prolog_flag/2 and  set_prolog_flag/2 allow  the
user  to examine  and modify  the execution  environment.   It  provides
access  to whether  optional  features are  available on  this  version,
operating  system,  foreign-code  environment,  command-line  arguments,
version,  as well  as runtime  flags to  control  the runtime  behaviour
of  certain  predicates  to  achieve  compatibility  with  other  Prolog
environments.


ccuurrrreenntt__pprroolloogg__ffllaagg((_?_K_e_y_, _-_V_a_l_u_e))                                  _[_I_S_O_]
    The  predicate current_prolog_flag/2defines an interface  to instal-
    lation  features:  options  compiled in, version,  home, etc.   With
    both  arguments unbound, it will generate all defined  Prolog flags.
    With  the `Key'  instantiated  it unifies  the value  of the  Prolog
    flag.   Flag values  are typed.  Flags  marked as bool can have  the
    values  true and false.   Some Prolog flags  are not defined in  all
    versions, which is  normally indicated in the documentation below as
    _`_`_i_f  _p_r_e_s_e_n_t _a_n_d _t_r_u_e_'_'.   A  Boolean Prolog flag  is true iff  the
    Prolog  flag is present aanndd the _V_a_l_u_e  is the atom true.   Tests for
    such flags should be written as below.

            (   current_prolog_flag(windows, true)
            ->  <Do MS-Windows things>
            ;   <Do normal things>
            )

    aabboorrtt__wwiitthh__eexxcceeppttiioonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines how  abort/0 is realised.    See the description  of
         abort/0 for details.

    aaddddrreessss__bbiittss _(_i_n_t_e_g_e_r_)
         Address-size of  the  hosting machine.    Typically  32 or  64.
         Except for the maximum  stack limit, this has few  implications
         to the user.  See also the Prolog flag arch.

    aaggcc__mmaarrggiinn _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If  this amount  of  atoms  has  been created  since  the  last
         atom-garbage collection,  perform  atom garbage  collection  at
         the  first  opportunity.    Initial  value  is  10,000.     May
         be  changed.    A  value  of 0  (zero)  disables  atom  garbage
         collection.  See also PL_register_atom().

    aallllooww__vvaarriiaabbllee__nnaammee__aass__ffuunnccttoorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default  is false),  Functor(arg) is  read  as if  it
         was written 'Functor'(arg).   Some applications use the  Prolog
         read/1  predicate for  reading  an application  defined  script
         language.   In these  cases, it is  often difficult to  explain
         to  non-Prolog users  of  the  application that  constants  and
         functions can only  start with a  lowercase letter.   Variables
         can be  turned into atoms  starting with  an uppercase atom  by
         calling read_term/2 using the option variable_names and binding
         the variables to their name.   Using this feature, F(x)  can be
         turned into valid syntax for such script languages.   Suggested
         by Robert van Engelen.  SWI-Prolog specific.

    aarrggvv _(_l_i_s_t_)
         List  is a  list of  atoms  representing the  command-line  ar-
         guments  used to  invoke  SWI-Prolog.    Please note  that  aallll
         arguments are included in the list returned.

    aarrcchh _(_a_t_o_m_)
         Identifier for  the  hardware and  operating system  SWI-Prolog
         is running  on.   Used to  select foreign files  for the  right
         architecture.  See also section 9.4 and file_search_path/2.

    aassssoocciiaattee _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         On Windows  systems,  this  is set  to the  filename  extension
         (pl  (default) or  pro  (can  be selected  in  the  installer))
         associated with plwin.exe.

    aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default) autoloading of library functions  is enabled.
         Note that  autoloading only works  if the  flag unknown is  _n_o_t
         set to fail.  See section 2.13.

    bbaacckkqquuootteedd__ssttrriinngg _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default false),  read translates  text between  back-
         quotes into a string object  (see section 4.23).  This  flag is
         mainly for compatibility with LPA Prolog.

    bboouunnddeedd _(_b_o_o_l_)
         ISO Prolog  flag.   If  true, integer  representation is  bound
         by  min_integer and max_integer.    If  false integers  can  be
         arbitrarily large and  the min_integer and max_integer are  not
         present.  See section 4.26.2.1.

    cc__cccc _(_a_t_o_m_)
         Name of the  C-compiler used to  compile SWI-Prolog.   Normally
         either gcc or cc.  See section 9.7.

    cc__llddffllaaggss _(_a_t_o_m_)
         Special linker  flags  passed to  link SWI-Prolog.    See  sec-
         tion 9.7.

    cc__lliibbss _(_a_t_o_m_)
         Libraries passed  to the C-linker  when SWI-Prolog was  linked.
         May  be  used to  determine  the  libraries  needed  to  create
         statically linked extensions for SWI-Prolog.  See section 9.7.

    cchhaarr__ccoonnvveerrssiioonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  whether  character-conversion  takes   place  while
         reading terms.  See also char_conversion/2.

    cchhaarraacctteerr__eessccaappeess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default),  read/1 interprets  \  escape sequences  in
         quoted atoms and strings.  May be changed.   This flag is local
         to the module in which it is changed.

    ccoommppiilleedd__aatt _(_a_t_o_m_)
         Describes when the  system has been  compiled.  Only  available
         if  the C-compiler  used  to  compile SWI-Prolog  provides  the
         __DATE__and __TIME__macros.

    ccoonnssoollee__mmeennuu _(_b_o_o_l_)
         Set  to true  in plwin.exe  to  indicate the  console  supports
         menus.  See also section 4.34.2.

    ccppuu__ccoouunntt _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         Number of  physical CPUs in  the system.   Unfortunately  there
         is  no standard  to  get  this number,  so  on  most  operating
         systems this flag  is not available.   It is marked  read-write
         both  to  allow  obtaining  this  value  later   and  to  allow
         pretending the system  has more or less  processors.  See  also
         thread_setconcurrency/2 and the library thread.  Currently this
         flag is  supported in Windows  and Linux  if /proc is  enabled.
         If  you can  provide  us with  a  C-code fragment  getting  the
         number for a specific  OS, please submit an enhancement  report
         at http://gollem.science.uva.nl/bugzilla/

    ddddee _(_b_o_o_l_)
         Set  to  true  if this  instance  of  Prolog  supports  DDE  as
         described in section 4.42.

    ddeebbuugg _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Switch debugging  mode  on/off.   If  debug  mode is  activated
         the  system  traps  encountered  spy-points  (see   spy/1)  and
         trace-points  (see   trace/1).       In   addition,   last-call
         optimisation is  disabled and the  system is more  conservative
         in destroying choice points to simplify debugging.

         Disabling these optimisations can  cause the system to run  out
         of memory on  programs that behave  correctly if debug mode  is
         off.

    ddeebbuugg__oonn__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  start  the  tracer  after   an  error  is  detected.
         Otherwise just continue  execution.   The goal that raised  the
         error  will normally  fail.    See  also fileerrors/2  and  the
         Prolog flag report_error.   May be changed.   Default is  true,
         except for the runtime version.

    ddeebbuuggggeerr__pprriinntt__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument is  given  as  option-list to  write_term/2  for
         printing  goals  by  the  debugger.     Modified  by  the  `w',
         `p'  and  `<_N>  d'  commands  of  the  debugger.    Default  is
         [quoted(true), portray(true), max_depth(10), attributes(portray)].

    ddeebbuuggggeerr__sshhooww__ccoonntteexxtt _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, show  the context module while printing a  stack-frame
         in the  tracer.   Normally controlled using  the `C' option  of
         the tracer.

    ddiiaalleecctt _(_a_t_o_m_)
         Fixed to swi.   The code below  is a reliable and portable  way
         to detect SWI-Prolog.

         is_dialect(swi) :-
                 catch(current_prolog_flag(dialect, swi), _, fail).

    ddoouubbllee__qquuootteess _(_c_o_d_e_s_,_c_h_a_r_s_,_a_t_o_m_,_s_t_r_i_n_g_, _c_h_a_n_g_e_a_b_l_e_)
         This flag  determines how  double  quoted strings  are read  by
         Prolog and is ---like character_escapes--- maintained  for each
         module.    If codes  (default), a  list  of character-codes  is
         returned,  if chars  a list  of  one-character atoms,  if  atom
         double  quotes  are the  same  as  single-quotes  and  finally,
         string reads the text into a Prolog string  (see section 4.23).
         See also atom_chars/2 and atom_codes/2.

    ddyynnaammiicc__ssttaacckkss _(_b_o_o_l_)
         If true,  the system uses some  form of `sparse-memory  manage-
         ment' to realise the stacks.  If  false, malloc()/realloc() are
         used for  the stacks.   In earlier  days this had  consequences
         for foreign code.   As  of version 2.5,  this is no longer  the
         case.

         Systems  using  `sparse-memory management'  are  a  bit  faster
         as  there  is  no  stack-shifter.     On   most  systems  using
         sparse-memory management  memory  is actually  returned to  the
         system  after a  garbage collection  or  call to  trim_stacks/0
         (called by prolog/0 after finishing a user-query).

    eeddiittoorr _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines the  editor used  by edit/1.   See  section 4.4  for
         details on selecting the editor used.

    eemmaaccss__iinnffeerriioorr__pprroocceessss _(_b_o_o_l_)
         If  true,  SWI-Prolog is  running  as an  _i_n_f_e_r_i_o_r  _p_r_o_c_e_s_s  of
         (GNU/X-)Emacs.   SWI-Prolog  assumes this  is the  case if  the
         environment variable EMACS is t and INFERIOR is yes.

    eennccooddiinngg _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Default encoding  used for  opening files in  text mode.    The
         initial  value  is   deduced  from  the   environment.      See
         section 2.17.1 for details.

    eexxeeccuuttaabbllee _(_a_t_o_m_)
         Path-name of the  running executable.  Used  by qsave_program/2
         as default emulator.

    ffiillee__nnaammee__vvaarriiaabblleess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (default  false),  expand  $_v_a_r_n_a_m_e   and  ~  in  ar-
         guments  of  built-in  predicates  that  accept  a   file  name
         (open/3, exists_file/1,  access_file/2,  etc.).   The  predicate
         expand_file_name/2 can be used to expand environment  variables
         and  wildcard patterns.    This  Prolog  flag is  intended  for
         backward compatibility with older versions of SWI-Prolog.

    ffllooaatt__ffoorrmmaatt _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         C-library printf()  format  specification used  by write/1  and
         friends to  determine how floating  point numbers are  printed.
         The default is %g.   The specified value is passed  to printf()
         without  further checking.    For  example,  if you  want  more
         digits printed,  %.12g will  print all floats  using 12  digits
         instead of the default 6.

         When using  quoted-write, the output  is guaranteed to  contain
         a decimal  dot or exponent,  so read/1  reads a floating  point
         number.  See also format/[1,2], write_term/[2,3].

    ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default), the garbage collector is active.   If false,
         neither garbage-collection,  nor stack-shifts will take  place,
         even not on explicit request.  May be changed.

    ggeenneerraattee__ddeebbuugg__iinnffoo _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default) generate  code  that can  be debugged  using
         trace/0,  spy/1,  etc.      Can  be  set  to  false  using  the
         -nodebug.   The  predicate load_files/2 restores  the value  of
         this  flag  after loading  a  file,  causing  modifications  to
         be  local to  a  source  file.    Many of  the  libraries  have
         :- set_prolog_flag(generate_debug_info, false)  to  hide  their
         details from a normal trace.

    ggmmpp__vveerrssiioonn _(_i_n_t_e_g_e_r_)
         If  Prolog is  linked  with  GMP,  this flag  gives  the  major
         version of the GMP library used.  See also section 9.6.7.

    gguuii _(_b_o_o_l_)
         Set to true if XPCE is around and can be used for graphics.

    hhiissttoorryy _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If _i_n_t_e_g_e_r >0,  support Unix csh(1)  like history as described
         in section  2.7.    Otherwise,  only support  reusing  commands
         through the command-line  editor.  The  default is to set  this
         Prolog flag  to 0  if a  command-line editor  is provided  (see
         Prolog flag readline) and 15 otherwise.

    hhoommee _(_a_t_o_m_)
         SWI-Prolog's notion  of the  home-directory.   SWI-Prolog  uses
         its   home   directory   to   find   its   startup    file   as
         <_h_o_m_e>/boot32.prc(32-bit machines) or <_h_o_m_e>/boot64.prc (64-bit
         machines) and to find its library as <_h_o_m_e>/library.

    hhwwnndd _(_i_n_t_e_g_e_r_)
         In plwin.exe,  this refers to  the MS-Windows window-handle  of
         the console window.

    iinntteeggeerr__rroouunnddiinngg__ffuunnccttiioonn _(_d_o_w_n_,_t_o_w_a_r_d___z_e_r_o_)
         ISO Prolog flag  describing rounding by  // and rem  arithmetic
         functions.  Value depends on the C-compiler used.

    iissoo _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Include some weird ISO compatibility that is  incompatible with
         normal SWI-Prolog behaviour.   Currently  it has the  following
         effect:

           o The  //2 (float division)  _a_l_w_a_y_s return a  float, even  if
             applied to integers that can be divided.

           o In  the standard order  of terms (see  section 4.6.1),  all
             floats are before all integers.

           o atom_length/2 yields  an instantiation  error if the  first
             argument is a number.

           o clause/[2,3]  raises  a  permission  error  when  accessing
             static predicates.

           o abolish/[1,2]  raises  a permission  error  when  accessing
             static predicates.

    llaarrggee__ffiilleess _(_b_o_o_l_)
         If present and  true, SWI-Prolog has  been compiled with  _l_a_r_g_e
         _f_i_l_e _s_u_p_p_o_r_t (LFS) and  is capable to access files  larger than
         2GB on  32-bit  hardware.   Large  file-support  is default  on
         installations built using configure that support it  and may be
         switched off using the configure option --disable-largefile.

    mmaaxx__aarriittyy _(_u_n_b_o_u_n_d_e_d_)
         ISO  Prolog  flag describing  there  is  no  maximum  arity  to
         compound terms.

    mmaaxx__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum integer value  if integers are _b_o_u_n_d_e_d.   See also  the
         flag bounded and section 4.26.2.1.

    mmaaxx__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum integer value represented as a `tagged' value.   Tagged
         integers  require  1  word  storage.      Larger  integers  are
         represented as `indirect  data' and require significantly  more
         space.

    mmaaxx__tthhrreeaaddss _(_i_n_t_e_g_e_r_)
         Provided on  multi-threaded  versions to  indicate the  maximum
         number  of  Prolog  threads  supported.     Currently  (version
         5.6.27) the limit is 100.

    mmiinn__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Minimum integer value  if integers are _b_o_u_n_d_e_d.   See also  the
         flag bounded and section 4.26.2.1.

    mmiinn__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Start of the tagged-integer value range.

    ooccccuurrss__cchheecckk _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  flag  controls  unification  that  creates   an  infinite
         tree  (also called  _c_y_c_l_i_c _t_e_r_m)  and  can have  three  values.
         Using  false  (default),  unification  succeeds,   creating  an
         infinite  tree.       Using   true,   unification  behaves   as
         unify_with_occurs_check/2, failing  silently.   Using error,  an
         attempt to  create  a cyclic  term results  in an  occurs_check
         exception.  The latter is intended  for debugging unintentional
         creations of  cyclic terms.   Note that this  flag is a  global
         flag modifying fundamental behaviour  of Prolog.  Changing  the
         flag from its default  may cause libraries to stop  functioning
         properly.

    ooppeenn__sshhaarreedd__oobbjjeecctt _(_b_o_o_l_)
         If  true,  open_shared_object/2 and  friends  are  implemented,
         providing access  to shared  libraries (.so  files) or  dynamic
         link libraries (.DLL files).

    ooppttiimmiissee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, compile in optimised mode.  The initial  value is true
         if Prolog was started with the -O command-line option.

         Currently   optimise   compilation   implies   compilation   of
         arithmetic, and  deletion of redundant  true/0 that may  result
         from expand_goal/2.

         Later versions might imply various other optimisations  such as
         integrating small  predicates into  their callers,  eliminating
         constant expressions and other predictable constructs.   Source
         code  optimisation is  never  applied  to predicates  that  are
         declared dynamic (see dynamic/1).

    ppiidd _(_i_n_t_)
         Process identifier of  the running Prolog  process.   Existence
         of this flag is implementation defined.

    ppiippee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  open(pipe(command), mode, Stream),   etc.  are  sup-
         ported.    Can  be  changed to  disable  the use  of  pipes  in
         applications testing this feature.  Not recommended.

    pprroommpptt__aalltteerrnnaattiivveess__oonn _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines prompting for  alternatives in the Prolog  toplevel.
         Default is  determinism, which implies  the system prompts  for
         alternatives if the goal succeeded while  leaving choicepoints.
         Many  classical Prolog  systems  behave  as groundness:    they
         prompt  for alternatives  if and  only  if the  query  contains
         variables.

    rreeaaddlliinnee _(_b_o_o_l_)
         If  true,  SWI-Prolog  is linked  with  the  readline  library.
         This is  done by  default if  you have  this library  installed
         on your  system.    It is  also true  for  the Win32  plwin.exe
         version of SWI-Prolog, which realises a subset  of the readline
         functionality.

    rreessoouurrccee__ddaattaabbaassee _(_a_t_o_m_)
         Set to the absolute-filename of the attached state.   Typically
         this is the file boot32.prc, the file specified with  -x or the
         running executable.  See also resource/3.

    rreeppoorrtt__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, print  error messages, otherwise  suppress them.   May
         be changed.  See also  the debug_on_errorProlog flag.   Default
         is true, except for the runtime version.

    rruunnttiimmee _(_b_o_o_l_)
         If present and  true, SWI-Prolog is  compiled with -DO_RUNTIME,
         disabling various  useful development  features (currently  the
         tracer and profiler).

    ssaavveedd__pprrooggrraamm _(_b_o_o_l_)
         If present  and  true, Prolog  has been  started  from a  state
         saved with qsave_program/[1,2].

    sshhaarreedd__oobbjjeecctt__eexxtteennssiioonn _(_a_t_o_m_)
         Extension used  by  the operating  system for  shared  objects.
         .so for  most Unix  systems and  .dll for  Windows.   Used  for
         locating  files using  the  file_type  executable.    See  also
         absolute_file_name/3.

    sshhaarreedd__oobbjjeecctt__sseeaarrcchh__ppaatthh _(_a_t_o_m_)
         Name of the environment  variable used by the system  to search
         for shared objects.

    ssiiggnnaallss _(_b_o_o_l_)
         Determine  whether Prolog  is  handling signals  (software  in-
         terrupts).   This  flag is  false if  the hosting  OS does  not
         support signal handling  or the command-line option  -nosignals
         is active.  See section 9.6.20.1 for details.

    ssyysstteemm__tthhrreeaadd__iidd _(_i_n_t_)
         Available  in  multi-threaded version  (see  section  8)  where
         the  operating  system  provides  system-wide   integer  thread
         identifiers.   The  integer  is the  thread-identifier used  by
         the  operating  system  for the  calling  thread.     See  also
         thread_self/1.

    llaasstt__ccaallll__ooppttiimmiissaattiioonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines whether  or not last-call  optimisation is  enabled.
         Normally the  value of this  flag is equal  to the debug  flag.
         As programs  may run  out  of stack  if last-call  optimisation
         is omitted,  it  is  sometimes necessary  to enable  it  during
         debugging.

    ttiimmeezzoonnee _(_i_n_t_e_g_e_r_)
         Offset in seconds  west of GMT of  the current time-zone.   Set
         at initialization  time from the  timezone variable  associated
         with the POSIX tzset() function.  See also convert_time/2.

    ttoopplleevveell__pprriinntt__aannoonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true,  top-level variables starting  with an  underscore (_)
         are printed normally.   If false they are hidden.  This  may be
         used to hide bindings in complex queries from the top-level.

    ttoopplleevveell__pprriinntt__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument   is  given   as  option-list   to  write_term/2
         for   printing    results   of   queries.         Default    is
         [quoted(true), portray(true), max_depth(10), attributes(portray)].

    ttoopplleevveell__vvaarr__ssiizzee _(_i_n_t_, _c_h_a_n_g_e_a_b_l_e_)
         Maximum  size counted  in  literals of  a  term returned  as  a
         binding for a variable  in a top-level query that is  saved for
         re-use using the $ variable reference.  See section 2.8.

    ttrraaccee__ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (false  is  the  default),  garbage  collections  and
         stack-shifts  will  be  reported on  the  terminal.     May  be
         changed.  Values are reported in bytes as G+T, where  G is the
         global stack  value and  T  the trail  stack value.    `Gained'
         describes the  number of bytes  reclaimed.   `used' the  number
         of bytes on the stack  after GC and `free' the number  of bytes
         allocated, but not in use.  Below is an example output.

         % GC: gained 236,416+163,424 in 0.00 sec; used 13,448+5,808; free 72,568+47,440

    ttttyy__ccoonnttrrooll _(_b_o_o_l_)
         Determines whether  the terminal  is switched to  raw mode  for
         get_single_char/1,  which also  reads the  user-actions for  the
         trace.  May be set.  See also the +/-tty command-line option.

    uunniixx _(_b_o_o_l_)
         If present and  true, the operating  system is some version  of
         Unix.  Defined  if the C-compiler used to compile  this version
         of  SWI-Prolog either  defines  __unix__ or  unix.    On  other
         systems this flag is not available.

    uunnkknnoowwnn _(_f_a_i_l_,_w_a_r_n_i_n_g_,_e_r_r_o_r_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  the behaviour  if  an  undefined procedure  is  en-
         countered.    If  fail,  the predicates  fails  silently.    If
         warn,  a warning  is printed,  and  execution continues  as  if
         the  predicate was  not  defined  and if  error  (default),  an
         existence_error exception is  raised.   This flag  is local  to
         each module.  Switching this flag to  fail disables autoloading
         and thus forces complete and consistent use of use_module/[1,2]
         to load the required libraries.

    vveerrbboossee _(_A_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This flags is used by print_message/2.  If its value is silent,
         messages of type informational and banner are suppressed.   The
         -q switches the value from the initial normal to silent.

    vveerrbboossee__aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true the  normal  consult  message  will be  printed  if  a
         library is autoloaded.  By default this  message is suppressed.
         Intended to be used for debugging purposes.

    vveerrbboossee__llooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If false normal consult  messages will be suppressed.   Default
         is true.  The value of this flag is normally  controlled by the
         option silent(_B_o_o_l) provided by load_files/2.

    vveerrbboossee__ffiillee__sseeaarrcchh _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (default   false),  print  messages  indicating   the
         progress   of  absolute_file_name/[2,3]  in   locating   files.
         Intended for  debugging  complicated file-search  paths.    See
         also file_search_path/2.

    vveerrssiioonn _(_i_n_t_e_g_e_r_)
         The version identifier is an integer with value:

                          10000_*Major+ 100_*Minor+_P_a_t_c_h

         Note  that  in   releases  up  to   2.7.10  this  Prolog   flag
         yielded an atom  holding the three  numbers separated by  dots.
         The  current representation  is  much easier  for  implementing
         version-conditional statements.

    vveerrssiioonn__ddaattaa _(_s_w_i_(_M_a_j_o_r_, _M_i_n_o_r_, _P_a_t_c_h_, _E_x_t_r_a_)_)
         Part of the  dialect compatibility layer,  See also the  Prolog
         flag dialect and section 13.  _E_x_t_r_a  provides platform specific
         version information.  Currently it is simply unified to [].

    vveerrssiioonn__ggiitt _(_a_t_o_m_)
         Available if created from  a git repository.   See git-describe
         for details.

    wwiinnddoowwss _(_b_o_o_l_)
         If present and true, the operating system  is an implementation
         of Microsoft  Windows (NT/2000/XP, etc.).    This flag is  only
         available on MS-Windows based versions.

    wwrriittee__aattttrriibbuutteess _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Defines how  write/1  and friends  write attributed  variables.
         The option values are  described with the attributes option  of
         write_term/3.  Default is ignore.

    wwrriittee__hheellpp__wwiitthh__oovveerrssttrriikkee _(_b_o_o_l_)
         Internal flag used  by help/1 when writing  to a terminal.   If
         present  and true  it prints  bold  and underlined  text  using
         _o_v_e_r_s_t_r_i_k_e.

    xxppccee _(_b_o_o_l_)
         Available  and set  to  true if  the  XPCE graphics  system  is
         loaded.

    xxppccee__vveerrssiioonn _(_a_t_o_m_)
         Available and set to the version of the loaded XPCE system.


sseett__pprroolloogg__ffllaagg((_+_K_e_y_, _+_V_a_l_u_e))                                      _[_I_S_O_]
    Define  a new  Prolog flag or  change its value.    _K_e_y is an  atom.
    If  the flag is a system-defined flag that is not  marked _c_h_a_n_g_e_a_b_l_e
    above,  an  attempt to  modify the flag  yields a  permission_error.
    If  the  provided _V_a_l_u_e  does not  match  the type  of the  flag,  a
    type_error is raised.

    In  addition  to  ISO,  SWI-Prolog allows  for  user-defined  Prolog
    flags.   The type of the  flag is determined from the  initial value
    and  cannot be changed  afterwards.   Defined types are boolean  (if
    the  initial value is one  of false, true, on  or off), atom if  the
    initial value is any  other atom, integer if the value is an integer
    that  can be expressed as a 64-bit signed value.  Any  other initial
    value  results  in an  untyped  flag that  can represent  any  valid
    Prolog term.


22..1122 AAnn oovveerrvviieeww ooff hhooookk pprreeddiiccaatteess

SWI-Prolog provides a large number of hooks, mainly  to control handling
messages, debugging,  startup, shut-down, macro-expansion,  etc.   Below
is  a  summary  of  all  defined  hooks  with  an  indication  of  their
portability.

  o _p_o_r_t_r_a_y_/_1
    Hook into write_term/3 to alter the way terms are printed (ISO).

  o _m_e_s_s_a_g_e___h_o_o_k_/_3
    Hook  into  print_message/2 to  alter the  way system  messages  are
    printed (Quintus/SICStus).

  o _l_i_b_r_a_r_y___d_i_r_e_c_t_o_r_y_/_1
    Hook  into absolute_file_name/3 to define  new library  directories.
    (most Prolog system).

  o _f_i_l_e___s_e_a_r_c_h___p_a_t_h_/_2
    Hook   into   absolute_file_name/3  to   define   new   search-paths
    (Quintus/SICStus).

  o _t_e_r_m___e_x_p_a_n_s_i_o_n_/_2
    Hook  into  load_files/2  to  modify  read  terms  before  they  are
    compiled (macro-processing) (most Prolog system).

  o _g_o_a_l___e_x_p_a_n_s_i_o_n_/_2
    Same as term_expansion/2 for individual goals (SICStus).

  o _p_r_o_l_o_g___l_o_a_d___f_i_l_e_/_2
    Hook  into  load_files/2  to  load  other  data-formats  for  Prolog
    sources  from `non-file' resources.   The load_files/2 predicate  is
    the ancestor of consult/1, use_module/1, etc.

  o _p_r_o_l_o_g___e_d_i_t_:_l_o_c_a_t_e_/_3
    Hook into edit/1 to locate objects (SWI).

  o _p_r_o_l_o_g___e_d_i_t_:_e_d_i_t___s_o_u_r_c_e_/_1
    Hook into edit/1 to call some internal editor (SWI).

  o _p_r_o_l_o_g___e_d_i_t_:_e_d_i_t___c_o_m_m_a_n_d_/_2
    Hook into edit/1 to define the external editor to use (SWI).

  o _p_r_o_l_o_g___l_i_s_t___g_o_a_l_/_1
    Hook  into the tracer  to list the  code associated to a  particular
    goal (SWI).

  o _p_r_o_l_o_g___t_r_a_c_e___i_n_t_e_r_c_e_p_t_i_o_n_/_4
    Hook into the tracer to handle trace-events (SWI).

  o _p_r_o_l_o_g_:_d_e_b_u_g___c_o_n_t_r_o_l___h_o_o_k_/_1
    Hook  in spy/1, nospy/1, nospyall/0 and debugging/0 to  extend these
    control-predicates to higher-level libraries.

  o _p_r_o_l_o_g_:_h_e_l_p___h_o_o_k_/_1
    Hook in help/0, help/1 and apropos/1 to extend the help-system.

  o _r_e_s_o_u_r_c_e_/_3
    Defines a new resource (not really a hook, but similar) (SWI).

  o _e_x_c_e_p_t_i_o_n_/_3
    Old  attempt  to  a  generic  hook mechanism.     Handles  undefined
    predicates (SWI).

  o _a_t_t_r___u_n_i_f_y___h_o_o_k_/_2
    Unification  hook for attributed variables.   Can be defined in  any
    module.  See section 6.1 for details.


22..1133 AAuuttoommaattiicc llooaaddiinngg ooff lliibbrraarriieess

If ---at  runtime--- an undefined predicate  is trapped the system  will
first try  to import  the predicate  from the  module's default  module.
If this  fails the _a_u_t_o  _l_o_a_d_e_r is  activated.   On first activation  an
index  to all  library files  in all  library directories  is loaded  in
core (see library_directory/1 and file_search_path/2).   If the undefined
predicate  can be  located in  one of  the libraries  that library  file
is  automatically loaded  and  the call  to the  (previously  undefined)
predicate  is restarted.    By  default this  mechanism loads  the  file
silently.    The current_prolog_flag/2 verbose_autoload  is provided  to
get  verbose  loading.    The  Prolog  flag  autoload  can  be  used  to
enable/disable the entire auto load system.

The auto-loader only  works if the unknown  flag (see unknown/2) is  set
to  trace (default).    A more  appropriate interaction  with this  flag
should be considered.

Autoloading  only handles  (library) source  files that  use the  module
mechanism  described  in  chapter  5.     The  files   are  loaded  with
use_module/2 and only the  trapped undefined predicate will be  imported
to the module  where the undefined predicate  was called.  Each  library
directory  must hold  a file  INDEX.pl  that contains  an index  to  all
library files  in the directory.    This file consists  of lines of  the
following format:

index(Name, Arity, Module, File).

The  predicate make/0  updates the  autoload  index.   It  searches  for
all library directories (see library_directory/1 and file_search_path/2)
holding the file MKINDEX.pl or INDEX.pl.  If the  current user can write
or create  the file  INDEX.pl and  it does not  exist or  is older  than
the directory  or one  of its  files, the  index for  this directory  is
updated.  If the file MKINDEX.pl exists updating  is achieved by loading
this file, normally containing a directive calling make_library_index/2.
Otherwise make_library_index/1is  called, creating an index for all *.pl
files containing a module.

Below is an example creating a completely indexed library directory.

% mkdir ~/lib/prolog
% cd !$
% pl -g true -t 'make_library_index(.)'

If  there  are  more than  one  library  files  containing  the  desired
predicate the following search schema is followed:

 1. If  there is a  library file  that defines the  module in which  the
    undefined predicate is trapped, this file is used.

 2. Otherwise  library files  are considered  in the  order they  appear
    in  the  library_directory/1  predicate  and  within  the  directory
    alphabetically.


mmaakkee__lliibbrraarryy__iinnddeexx((_+_D_i_r_e_c_t_o_r_y))
    Create  an index for this  directory.  The  index is written to  the
    file  'INDEX.pl' in the specified directory.   Fails with a  warning
    if the directory does not exist or is write protected.


mmaakkee__lliibbrraarryy__iinnddeexx((_+_D_i_r_e_c_t_o_r_y_, _+_L_i_s_t_O_f_P_a_t_t_e_r_n_s))
    Normally  used in  MKINDEX.pl, this  predicate creates INDEX.pl  for
    _D_i_r_e_c_t_o_r_y,  indexing all files that  match one of the  file-patterns
    in _L_i_s_t_O_f_P_a_t_t_e_r_n_s.

    Sometimes  library packages consist  of one public  load file and  a
    number  of files used by  this load-file, exporting predicates  that
    should not be used  directly by the end-user.  Such a library can be
    placed  in a sub-directory of  the library and the files  containing
    public  functionality can  be  added to  the index  of the  library.
    As  an  example we  give the  XPCE library's  MKINDEX.pl,  including
    the  public  functionality of  trace/browse.pl to  the  autoloadable
    predicates for the XPCE package.

    :- make_library_index('.',
                          [ '*.pl',
                            'trace/browse.pl'
                          ]).


rreellooaadd__lliibbrraarryy__iinnddeexx
    Force  reloading  the  index  after modifying  the  set  of  library
    directories   by   changing  the   rules  for   library_directory/1,
    file_search_path/2,  adding  or  deleting  INDEX.pl  files.     This
    predicate   does   _n_o_t   update  the   INDEX.pl   files.       Check
    make_library_index/[1,2] and make/0 for updating the index files.

    Normally, the index  is reloaded automatically if a predicate cannot
    be  found  in the  index  and the  set  of library  directories  has
    changed.   Using reload_library_index/0 is necessary if  directories
    are removed or the order of the library directories is changed.


22..1144 GGaarrbbaaggee CCoolllleeccttiioonn

SWI-Prolog provides garbage-collection, last-call optimization  and atom
garbage collection.   These features  are controlled using Prolog  flags
(see current_prolog_flag/2).


22..1155 SSyynnttaaxx NNootteess

SWI-Prolog uses ISO-Prolog standard syntax, which  is closely compatible
with Edinburgh  Prolog syntax.    A description  of this  syntax can  be
found  in the  Prolog  books referenced  in  the  introduction.    Below
are  some non-standard  or non-common  constructs that  are accepted  by
SWI-Prolog:

  o /* .../* ...*/ ...*/
    The  /* ...*/  comment statement  can be  nested.    This is  useful
    if  some  code with  /* ...*/  comment statements  in it  should  be
    commented out.


22..1155..11 IISSOO SSyynnttaaxx SSuuppppoorrtt

SWI-Prolog offers ISO compatible extensions to the Edinburgh syntax.


22..1155..11..11 PPrroocceessssoorr CChhaarraacctteerr SSeett

The processor character  set specifies the class of each  character used
for parsing Prolog  source text.   Character classification is fixed  to
use UCS/Unicode as  provided by the C-library  wchar_t based  primitives.
See also section 2.17.


22..1155..11..22 CChhaarraacctteerr EEssccaappee SSyynnttaaxx

Within quoted atoms  (using single quotes:  '<atom>' special  characters
are represented  using escape-sequences.    An escape  sequence is  lead
in  by the  backslash  (\) character.    The  list of  escape  sequences
is compatible  with the  ISO standard,  but contains  one extension  and
the interpretation of numerically specified characters  is slightly more
flexible to improve compatibility.

\a
    Alert character.  Normally the ASCII character 7 (beep).

\b
    Backspace character.

\c
    No  output.    All input  characters  up to  but not  including  the
    first  non-layout  character  are skipped.     This allows  for  the
    specification of pretty-looking  long lines.  For compatibility with
    Quintus Prolog.  Not supported by ISO. Example:

    format('This is a long line that would look better if it was \c
           split across multiple physical lines in the input')

\<RETURN>
    No  output.   Skips input till the  next non-layout character or  to
    the end of the next line.  Same intention as \c but ISO compatible.

\f
    Form-feed character.

\n
    Next-line character.

\r
    Carriage-return only (i.e. go back to the start of the line).

\t
    Horizontal tab-character.

\v
    Vertical tab-character (ASCII 11).

\xXX..\
    Hexadecimal  specification  of  a  character.    The  closing  \  is
    obligatory   according  to  the  ISO   standard,  but  optional   in
    SWI-Prolog  to   enhance  compatibility  with  the  older  Edinburgh
    standard.   The code \xa\3 emits the character 10  (hexadecimal `a')
    followed  by `3'.  Characters specified this way are  interpreted as
    Unicode characters.  See also \u.

\uXXXX
    Unicode  character specification  where the  character is  specified
    using  _e_x_a_c_t_l_y 4 hexadecimal  digits.  This  is an extension to  the
    ISO  standard fixing two problems.   First of all, where  \x defines
    a  numeric character code, it  doesn't specify the character set  in
    which  the  character should  be interpreted.    Second,  it is  not
    needed to use the idiosyncratic closing \ ISO Prolog syntax.

\UXXXXXXXX
    Same as \uXXXX, but using 8 digits to cover the whole Unicode set.

\40
    Octal   character  specification.     The  rules  and   remarks  for
    hexadecimal specifications apply to octal specifications as well.

\<_c_h_a_r_a_c_t_e_r>
    Any  character immediately preceded  by a \  and not covered by  the
    above  escape sequences is copied verbatim.   Thus, '\\' is  an atom
    consisting  of a single \ and  '\'' and '''' both describe the  atom
    with a single '.

Character      escaping      is     only      available      if      the
current_prolog_flag(character_escapes, true) is active (default).    See
current_prolog_flag/2.   Character escapes conflict with writef/2  in two
ways:   \40  is interpreted  as decimal  40 by  writef/2, but  character
escapes  handling by  read has  already interpreted  as  32 (40  octal).
Also, \l is translated to  a single `l'.  It is advised to use  the more
widely supported  format/[2,3] predicate instead.    If you insist  upon
using writef/2, either switch character_escapes to false, or  use double
\\, as in writef('\\l').


22..1155..11..33 SSyynnttaaxx ffoorr nnoonn--ddeecciimmaall nnuummbbeerrss

SWI-Prolog  implements  both  Edinburgh  and  ISO   representations  for
non-decimal numbers.   According to  Edinburgh syntax, such numbers  are
written as <_r_a_d_i_x>'<number>, where <_r_a_d_i_x> is a number between 2 and 36.
ISO defines binary,  octal and hexadecimal numbers using 0[bxo]<_n_u_m_b_e_r>.
For example:  A is 0b100 \/ 0xf00  is a valid expression.   Such numbers
are always unsigned.


22..1155..11..44 UUnniiccooddee PPrroolloogg ssoouurrccee

The ISO standard  specifies the Prolog syntax  in ASCII characters.   As
SWI-Prolog supports Unicode  in source files we must extend  the syntax.
This  section describes  the implication  for  the source  files,  while
writing international source files is described in section 3.1.3.

The  SWI-Prolog Unicode  character classification  is  based on  version
4.1.0  of the  Unicode  standard.    Please  note  that char_type/2  and
friends, intended to be used with all text except  Prolog source code is
based on the C-library locale-based classification routines.

  o _Q_u_o_t_e_d _a_t_o_m_s _a_n_d _s_t_r_i_n_g_s
    Any  character  of  any script  can  be  used in  quoted  atoms  and
    strings.      The  escape  sequences  \uXXXX  and   \UXXXXXXXX  (see
    section 2.15.1.2) were  introduced to specify Unicode code points in
    ASCII files.

  o _A_t_o_m_s _a_n_d _V_a_r_i_a_b_l_e_s
    We  handle  them in  one item  as they  are closely  related.    The
    Unicode  standard  defines  a  syntax for  identifiers  in  computer
    languages.   In this syntax identifiers start with ID_Start followed
    by  a sequence of ID_Continue codes.  Such sequences are  handled as
    a  single token  in SWI-Prolog.    The token  is a  _v_a_r_i_a_b_l_e iff  it
    starts with  an uppercase character or an underscore (_).  Otherwise
    it  is an atom.   Note  that many languages do  not have the  notion
    of  character-case.  In such languages variables _m_u_s_t be  written as
    _name.

  o _W_h_i_t_e _s_p_a_c_e
    All  characters  marked  as separators  in  the Unicode  tables  are
    handled as layout characters.

  o _O_t_h_e_r _c_h_a_r_a_c_t_e_r_s
    The first 128 characters  follow the ISO Prolog standard.  All other
    characters  not covered  by the  rules above  are considered  `solo'
    characters:   they form  single-character atoms.   We would like  to
    have a more  appropriate distinction between what is known to Prolog
    as `solo' characters and `symbol' characters.


22..1155..11..55 SSiinngglleettoonn vvaarriiaabbllee cchheecckkiinngg

A _s_i_n_g_l_e_t_o_n  _v_a_r_i_a_b_l_e is  a variable  that appears  only one  time in  a
clause.   It can always be  replaced by _, the  _a_n_o_n_y_m_o_u_s variable.   In
some  cases however  people prefer  to give  the variable  a name.    As
mistyping a variable is a common mistake, Prolog  systems generally give
a  warning (controlled  by style_check/1)  if a  variable is  used  only
once.   The system can  be informed a variable  is known to appear  once
by _s_t_a_r_t_i_n_g  it with  an underscore.    E.g. _Name.    Please note  that
any variable,  except plain _  shares with variables  of the same  name.
The term  t(_X, _X) is equivalent  to t(X, X),  which is _d_i_f_f_e_r_e_n_t  from
t(_, _).

As  Unicode requires  variables  to start  with  an underscore  in  many
languages this  schema needs to be  extended.   First we define the  two
classes of named variables.

  o _N_a_m_e_d _s_i_n_g_l_e_t_o_n _v_a_r_i_a_b_l_e_s
    Named  singletons start with  a double underscore  (__) or a  single
    underscore followed by an uppercase letter.  E.g. __var or _Var.

  o _N_o_r_m_a_l _v_a_r_i_a_b_l_e_s
    All other variables are  `normal' variables.  Note this makes _var a
    normal variable.

Any normal variable appearing  exactly ones in the clause _a_n_d  any named
singleton variables appearing  more than once are  reported.  Below  are
some examples  with warnings in  the right column.   Singleton  messages
can be suppressed using the style_check/1 directive.

___________________________________________________________________________
| test(_).      |                                                         |

| test(_a).     |Singleton variables:  [_a]                                 |
| test(A).     |Singleton variables:  [A]                                 |
| test(_A).     |                                                         |
| test(__a).    |                                                         |
| test(_, _).   |                                                         |
| test(_a, _a). |                                                         |
| test(__a, __a).S|ingleton-marked variables appearing more than once:  [__a] |

| test(_A, _A). |Singleton-marked variables appearing more than once:  [_A] |
|_test(A,_A).__|__________________________________________________________|_


22..1166 IInnffiinniittee ttrreeeess ((ccyycclliicc tteerrmmss))

SWI-Prolog  has  limited support  for  infinite  trees,  also  known  as
cyclic  terms.   Full  support  requires special  code in  all  built-in
predicates that require  recursive exploration of a  term.  The  current
version  supports cycles  terms  in  the pure  Prolog  kernel  including
the  garbage  collector  and  in  the  following   predicates:    =../2,
==/2,  =@=/2,  =/2, @</2 , @=</2,  @>=/2,  @>/2,  \==/2,  \=@=/2,  \=/2,
acyclic_term/1, bagof/3,  compare/3, copy_term/2, cyclic_term/1,  dif/2,
duplicate_term/2,  findall/3, ground/1,  term_hash/2,  numbervars/[3,4],
recorda/3,  recordz/3,   setof/3,  term_variables/2,  throw/1,   when/2,
write/1 (incomplete) .


22..1177 WWiiddee cchhaarraacctteerr ssuuppppoorrtt

SWI-Prolog  supports _w_i_d_e  _c_h_a_r_a_c_t_e_r_s, characters  with character  codes
above  255 that  cannot be  represented in  a single  _b_y_t_e.    _U_n_i_v_e_r_s_a_l
_C_h_a_r_a_c_t_e_r  _S_e_t (UCS)  is the  ISO/IEC 10646  standard  that specifies  a
unique  31-bits unsigned  integer  for any  character in  any  language.
It  is a  superset  of  16-bit Unicode,  which  in  turn is  a  superset
of ISO  8859-1 (ISO  Latin-1), a  superset of US-ASCII.  UCS can  handle
strings  holding  characters  from  multiple  languages   and  character
classification (uppercase, lowercase, digit, etc.)   and operations such
as case-conversion are unambiguously defined.

For this reason SWI-Prolog has two representations for  atoms and string
objects (see  section 4.23).   If the  text fits in  ISO Latin-1, it  is
represented as  an array  of 8-bit characters.    Otherwise the text  is
represented as an array of 32-bit numbers.   This representational issue
is completely  transparent to  the Prolog user.    Users of the  foreign
language interface as described in section 9 sometimes need  to be aware
of these issues though.

Character coding comes into  view when characters of strings need  to be
read from  or written to file  or when they  have to be communicated  to
other software  components using  the foreign  language interface.    In
this section we only deal with I/O through streams,  which includes file
I/O as well as I/O through network sockets.


22..1177..11 WWiiddee cchhaarraacctteerr eennccooddiinnggss oonn ssttrreeaammss

Although  characters   are  uniquely  coded   using  the  UCS   standard
internally, streams  and files are byte  (8-bit) oriented and there  are
a variety of  ways to represent the larger  UCS codes in an 8-bit  octet
stream.   The most popular  one, especially in  the context of the  web,
is UTF-8.   Bytes 0 ... 127 represent simply the  corresponding US-ASCII
character, while bytes 128  ... 255 are used for multi-byte  encoding of
characters placed  higher in the  UCS space.   Especially on  MS-Windows
the  16-bit Unicode  standard, represented  by pairs  of  bytes is  also
popular.

Prolog I/O streams  have a property called _e_n_c_o_d_i_n_g which  specifies the
used encoding  that influence get_code/2 and  put_code/2 as well as  all
the other text I/O predicates.

The  default  encoding  for  files  is  derived  from  the  Prolog  flag
encoding,  which   is  initialised  from  the  environment.      If  the
environment variable  LANG ends  in "UTF-8", this  encoding is  assumed.
Otherwise  the default  is  text and  the  translation  is left  to  the
wide-character  functions  of the  C-library.         The  encoding  can
be  specified  explicitly  in load_files/2  for  loading  Prolog  source
with  an  alternative encoding,   open/4 when  opening  files  or  using
set_stream/2 on  any open  stream.    For Prolog  source  files we  also
provide the  encoding/1 directive  that can  be used  to switch  between
encodings that  are compatible  with US-ASCII (ascii,  iso_latin_1,  utf8
and  many  locales).     See  also  section  3.1.3  for  writing  Prolog
files  with non-US-ASCII  characters  and  section 2.15.1.4  for  syntax
issues.  For additional information and Unicode  resources, please visit
http://www.unicode.org/.

SWI-Prolog currently defines and supports the following encodings:

oocctteett
    Default  encoding for binary streams.  This causes the stream  to be
    read and written fully untranslated.

aasscciiii
    7-bit  encoding  in 8-bit  bytes.   Equivalent  to  iso_latin_1,  but
    generates errors and warnings on encountering values above 127.

iissoo__llaattiinn__11
    8-bit  encoding supporting many western languages.  This  causes the
    stream to be read and written fully untranslated.

tteexxtt
    C-library  default locale encoding for text  files.  Files are  read
    and  written using the C-library functions mbrtowc()  and wcrtomb().
    This may be the  same as one of the other locales, notably it may be
    the  same as iso_latin_1 for western languages  and utf8 in a  UTF-8
    context.

uuttff88
    Multi-byte encoding of full UCS, compatible with ascii.  See above.

uunniiccooddee__bbee
    Unicode  _B_i_g  _E_n_d_i_a_n.     Reads  input  in  pairs  of  bytes,   most
    significant byte first.  Can only represent 16-bit characters.

uunniiccooddee__llee
    Unicode  _L_i_t_t_l_e  _E_n_d_i_a_n.    Reads input  in  pairs of  bytes,  least
    significant byte first.  Can only represent 16-bit characters.

Note that not all encodings can represent all characters.   This implies
that  writing text  to a  stream  may cause  errors because  the  stream
cannot represent these characters.   The behaviour of a stream  on these
errors can  be controlled  using set_stream/2.   Initially the  terminal
stream write  the characters using Prolog  escape sequences while  other
streams generate an I/O exception.


22..1177..11..11 BBOOMM:: BByyttee OOrrddeerr MMaarrkk

From  section  2.17.1,  you  may  have  got  the  impression  text-files
are  complicated.   This  section  deals with  a related  topic,  making
live  often easier  for the  user, but  providing another  worry to  the
programmer.   BBOOMM or  _B_y_t_e _O_r_d_e_r _M_a_r_k_e_r is  a technique for  identifying
Unicode text-files as well  as the encoding they use.  Such  files start
with  the Unicode  character 0xFEFF,  a non-breaking,  zero-width  space
character.   This is a pretty unique  sequence that is not likely to  be
the start of  a non-Unicode file and uniquely distinguishes  the various
Unicode file  formats.   As it is  a zero-width  blank, it even  doesn't
produce any output.  This solves all problems, or ...

Some formats start of as US-ASCII and may contain  some encoding mark to
switch to UTF-8,  such as the encoding="UTF-8" in  an XML header.   Such
formats often explicitly forbid  the use of a UTF-8 BOM. In  other cases
there is additional  information telling the encoding making the  use of
a BOM redundant or even illegal.

The  BOM  is handled  by  SWI-Prolog  open/4  predicate.    By  default,
text-files are  probed for the BOM  when opened for reading.   If a  BOM
is found, the encoding is set accordingly and  the property bom(_t_r_u_e) is
available through stream_property/2.   When opening a file for  writing,
writing a BOM can be requested using the option bom(_t_r_u_e) with open/4.


22..1188 SSyysstteemm lliimmiittss


22..1188..11 LLiimmiittss oonn mmeemmoorryy aarreeaass

SWI-Prolog has  a number of  memory areas which are  only enlarged to  a
certain limit.   The  default sizes for these  areas should suffice  for
most applications, but big  applications may require larger ones.   They
are  modified by  command-line options.    The table  below shows  these
areas.   The first column  gives the option name  to modify the size  of
the area.  The option character is immediately followed  by a number and
optionally by  a k or  m.   With k or  no unit  indicator, the value  is
interpreted in Kbytes (1024 bytes), with m, the  value is interpreted in
Mbytes (10241* 024 bytes).

The local-,  global- and  trail-stack are  limited to 128  Mbytes on  32
bit processors,  or more  generally to  2 to the power bits-per-long - 5
bytes.

The  PrologScript facility  described  in  section 2.10.2.1  provides  a
mechanism for  specifying options with  the load-file.   On Windows  the
default stack-sizes  are controlled  using the Windows  registry on  the
key  HKEY_CURRENT_USER\Software\SWI\Prolog using  the  names  localSize,
globalSize and trailSize.   The value is a DWORD expressing  the default
stack size  in Kbytes.   A  GUI for modifying  these values is  provided
using the XPCE package.  To use this, start the  XPCE manual tools using
manpce/0, after which you find _P_r_e_f_e_r_e_n_c_e_s in the _F_i_l_e menu.
       ___________________________________________________________
       |_Option_|Default_|Area_name______|Description____________|_||-L||16Mlloocc||aallTssttaacckkhe|l||||ocal|stack is used

       |        |                        to  store   the  execu- |             |             ||
       |        |                        tion  environments   of |             |             ||
       |        |                        procedure  invocations. |             |             ||
       |        |                        The  space for  an  en- |             |             ||
       |        |                        vironment is  reclaimed |             |             ||
       |        |                        when  it  fails,  exits |             |             ||
       |        |                        without leaving  choice |             |             ||
       |        |                        points,   the  alterna- |             |             ||
       |        |                        tives are cut  off with |             |             ||
       |        |                                                |             |             ||

       |        |                        the  !/0  predicate  or |             |             ||
       |        |                        no  choice points  have |             |             ||
       |        |                        been created  since the |             |             ||
       |        |                        invocation and the last |             |             ||
       |        |                        subclause  is   started |             |             ||
       |        |                        (last  call   optimisa- |             |             ||
       ||       ||      |               ||tion).                  ||            |             ||

       |   -G   | 32M   |gglloobbaall ssttaacckk   ||Theusglobaled stacktois store| terms
       |        |       |               ||created during Prolog's |
       |        |       |               ||execution.    Terms  on |
       |        |       |               ||                        |
       |        |       |               ||this stack will  be re- |
       |        |       |               ||claimed by backtracking |
       |        |       |               ||to a  point before  the |
       |        |       |               ||term  was   created  or |
       |        |       |               ||by  garbage  collection |

       |        |       |               ||(provided  the term  is |
       ||       ||      ||              ||no||longer referenced).  ||
       |   -T   | 32M   |ttrraaiill ssttaacckk    ||Theusetraild stackto isstore|  as-
       |        |       |               ||signments during execu- |
       |        |       |               ||                        |
       |        |       |               ||tion.   Entries on this |
       |        |       |               ||stack remain  alive un- |

       |        |       |               ||til backtracking before |
       |        |       |               ||the  point of  creation |
       |        |       |               ||or the  garbage collec- |
       ||       ||      ||              ||tor determines||they are ||
       ||| -A   |||1M   |||aarrgguummeenntt ssttaacc||norkkneeded||any||longer.Th|e||argument stack  is

       |        |        |               used || to   store   one |
       |        |        |               of   ||the   intermediate|
       |        |        |               code ||interpreter's reg-|
       |        |        |               ister||s.     The  amount|
       |        |        |               of sp||ace needed on this|
       |        |        |               stack||is determined en- |
       |        |        |               tirel||y by the  depth in|

       |        |        |               which||terms  are nested |
       |        |        |               in  t||he   clauses  that|
       |        |        |               const||itute the program.|
       |        |        |               Overf||low is most likely|
       |        |        |               when ||using long strings|
       |        |        |               in a ||clause.           |
       |        |        |               In ad||dition, this stack|
       |        |        |               is us||ed by  some built-|
       |        |        |                    ||                  |
       |        |        |               in pr||edicates to handle|

       |        |        |               cycli||c terms.   Its de-|
       |        |        |               fault|| size   limit  is |
       |        |        |               propo||rtional   to   the|
       |        |        |               globa||l stack limit such|
       |        |        |               that || it  will   never |
       |________|________|_______________overf||low.______________|_

                        Table 2.2:  Memory areas


22..1188..11..11 TThhee hheeaapp

With  the heap,  we  refer  to the  memory  area  used by  malloc()  and
friends.  SWI-Prolog uses the area to store  atoms, functors, predicates
and their  clauses, records and  other dynamic data.   As of  SWI-Prolog
2.8.5, no limits are  imposed on the addresses returned by  malloc() and
friends.

On  some machines,  the  runtime stacks  described above  are  allocated
using `sparse  allocation'.   Virtual space up to  the limit is  claimed
at startup and committed and released while the area  grows and shrinks.
On Win32  platform this  is realised using  VirtualAlloc() and  friends.
On Unix systems this is realised using mmap().


22..1188..22 OOtthheerr LLiimmiittss

CCllaauusseess  The only  limit  on  clauses  is their  arity  (the  number  of
    arguments  to the head),  which is  limited to 1024.   Raising  this
    limit is easy and relatively cheap, removing it is harder.

AAttoommss aanndd SSttrriinnggss  SWI-Prolog  has no  limits  on  the  sizes  of  atoms
    and  strings.   read/1  and its derivatives  however normally  limit
    the  number  of newlines  in  an  atom or  string  to 5  to  improve
    error  detection  and recovery.    This  can  be switched  off  with
    style_check/1.

    The  number  of  atoms  is  limited  to  16777216  (16M)  on  32-bit
    machines.   On  64-bit machines  this is virtually  unlimited.   See
    also section 9.6.2.1.

MMeemmoorryy aarreeaass  On 32-bit hardware, SWI-Prolog data is packed in  a 32-bit
    word,  which contains  both type and  value information.   The  size
    of  the various memory areas  is limited to 128  Mb for each of  the
    areas,  except  for the  program heap,  which is  not limited.    On
    64-bit hardware there are no meaningful limits.

NNeessttiinngg ooff tteerrmmss  Many build-in  predicates process  nested terms  using
    recursive  C functions.  Too  deeply nested terms generally cause  a
    fatal crash.   All these functions avoid recursion on the right-most
    argument  and therefore terms are  not limited on the nesting  level
    of  the  last argument.    This notably  covers long  lists.    Most
    functions  use  a  stack  for correct  handling  of  rational  trees
    (cyclic  terms).  This stack is segmented, where  different segments
    are allocated using malloc().  Overflow causes a non-graceful exit.

IInntteeggeerrss  On  most systems  SWI-Prolog  is  compiled  with  support  for
    unbounded  integers by means  of the GNU GMP  library.  In  practice
    this  means that integers are bound by  the global stack size.   Too
    large  integers cause a resource_error.   On systems that lack  GMP,
    integers are 64-bit on 32 as well as 64-bit machines.

    Integers  up to the value of  the max_tagged_integerProlog  flag are
    represented more efficiently  on the stack.  For clauses and records
    the difference is much smaller.

FFllooaattiinngg ppooiinntt nnuummbbeerrss  Floating  point  numbers   are  represented   as
    C-native double precision floats, 64 bit IEEE on most machines.


22..1188..33 RReesseerrvveedd NNaammeess

The boot compiler  (see -b option) does  not support the module  system.
As large parts of  the system are written in Prolog itself we  need some
way to  avoid name clashes  with the  user's predicates, database  keys,
etc.   Like Edinburgh C-Prolog [Pereira, 1986] all predicates,  database
keys, etc. that should  be hidden from the user start with a  dollar ($)
sign (see style_check/1).


22..1199 SSWWII--PPrroolloogg aanndd 6644--bbiitt mmaacchhiinneess

SWI-Prolog support for  64-bit machines started with version 2.8  on DEC
Alpha  CPUs running  Linux.   Initially  64-bit  hardware was  developed
to  deal  with  the  addressing  demands  of  large  databases,  running
primarily on  expensive server hardware.   Recently  (2007) we see  CPUs
that support  64-bit addressing become  commonplace, even in  low-budget
desktop hardware.   Most todays 64-bit platforms are capable  of running
both 32-bit and 64-bit applications.  This asks  for some clarifications
on the advantages and drawbacks of 64-bit addressing for (SWI-)Prolog.


22..1199..11 SSuuppppoorrtteedd ppllaattffoorrmmss

On  Unix  systems,  64-bit addressing  is  configured  using  configure.
Traditionally,  both  long and  void*  are  64-bits on  these  machines.
Version  5.6.26 introduces  support for  64-bit  MS-Windows (Windows  XP
and Vista  64-bit editions) on  amd64 (x64) hardware.   Win64 uses  long
integers of only  32-bits.  Version  5.6.26 introduces support for  such
platforms.


22..1199..22 CCoommppaarriinngg 3322-- aanndd 6644--bbiittss PPrroolloogg

Most of Prolog's memory-usage consists of pointers.   This indicates the
primary drawback:   Prolog memory  usage almost  doubles when using  the
64 bit  addressing model.   Using  more memory  means copying more  data
between CPU and main memory, slowing down the system.

What than  are the advantages?   First  of all, SWI-Prolog's  addressing
of the  Prolog stacks  does not  cover the  whole address  space due  to
the  use of  _t_y_p_e _t_a_g  _b_i_t_s and  _g_a_r_b_a_g_e _c_o_l_l_e_c_t_i_o_n  _f_l_a_g_s.   On  32-bit
hardware the  stacks are limited to  128MB each.   This tends to be  too
low for demanding applications  on modern hardware.  On  64-bit hardware
the limit is 232 times higher, exceeding the  addressing capabilities of
todays CPUs and operating  systems.  This implies Prolog can  be started
with stacks sizes that use the full capabilities of your hardware.

Multi-threaded applications profit much more.   SWI-Prolog threads claim
the full stacksize limit in _v_i_r_t_u_a_l _a_d_d_r_e_s_s _s_p_a_c_e and  each thread comes
with its  own set  of stacks.    This approach  quickly exhaust  virtual
memory  on  32-bit systems  but  poses  no problems  when  using  64-bit
addresses.

The implications  theoretical performance loss  due to increased  memory
bandwidth implied by  exchanging wider pointers depend on the  design of
the  hardware.   We  only have  data for  the popular  IA32 vs.    AMD64
architectures.   Here is appears that the  loss is compensated for by  a
an instruction set that  has been optimized for modern programming.   In
particular, the  AMD64 has  more registers and  the relative  addressing
capabilities  have been  improved.    Where  we  see a  10%  performance
degradation when placing the SWI-Prolog kernel in a  Unix shared object,
we cannot  find a measurable  difference on AMD64.   Current  SWI-Prolog
(5.6.26) runs at practically the same speed on IA32 and AMD64.


22..1199..33 CChhoooossiinngg bbeettwweeeenn 3322-- aanndd 6644--bbiittss PPrroolloogg

For those  cases where  we can choose  between 32-  and 64-bits,  either
because the hardware and OS support both or because  we can still choose
the hardware and OS, we give guidelines for this decision.

First of  all, if SWI-Prolog  needs to be linked  against 32- or  64-bit
native libraries,  there  is no choice  as it  is not  possible to  link
32- and  64-bit code into  a single  executable.   Only if all  required
libraries are available  in both sizes and  there is no clear reason  to
use either the different characteristics of Prolog become important.

Prolog  applications  that  require more  than  the  128MB  stack  limit
provided in 32-bit  addressing mode must use  the 64-bit edition.   Note
however that the limits  must be doubled to accommodate the  same Prolog
application.

If the system is  tight on physical memory, 32-bit Prolog has  the clear
advantage to use  only slightly more than  half of the memory of  64-bit
Prolog.    This argument  applies as  long as  the  application fits  in
the _v_i_r_t_u_a_l  _a_d_d_r_e_s_s _s_p_a_c_e of  the machine.   The virtual address  space
of  32-bit hardware  is 4GB,  but  in many  cases the  operating  system
provides less to user applications.  Virtual memory  usage of SWI-Prolog
is roughly  the program size  (_h_e_a_p) plus the  sum of the  stack-limits.
If there are  multiple threads, each thread  has its own stacks and  the
stack-limits must be summed over the running threads.

The  only  standard  SWI-Prolog library  adding  significantly  to  this
calculation is  the RDF  database provided by  the _s_e_m_w_e_b  package.   It
uses approximately 80 bytes per triple on 32-bit hardware  and 150 bytes
on 64-bit hardware.  Details depend on how  many different resources and
literals appear  in the dataset  as well  as desired additional  literal
indexes.

Summarizing,  if applications  are small  enough to  fit comfortably  in
virtual  and physical  memory simply  take  the model  used by  most  of
the applications  on the  OS. If  applications require  more than  128MB
per  stack,  use the  64-bit  edition.    If applications  approach  the
size  of physical  memory,  fit in  the  128MB stack  limit and  fit  in
virtual memory, the 32-bit version has clear advantages.   For demanding
applications  on 64-bit  hardware  with  more than  about  6GB  physical
memory the 64-bit model is the model of choice.


CChhaapptteerr 33..  IINNIITTIIAALLIISSIINNGG AANNDD MMAANNAAGGIINNGG AA PPRROOLLOOGG PPRROOJJEECCTT

Prolog text-books  give you  an overview of  the Prolog  language.   The
manual tells  you what predicates  are provided in  the system and  what
they do.  This chapter wants to explain how to run a  project.  There is
no ultimate `right'  way to do this.   Over the years we developed  some
practice in  this area and  SWI-Prolog's commands  are there to  support
this practice.   This chapter  describes the conventions and  supporting
commands.

The first two sections  (section 3.1 and section 3.2 only  require plain
Prolog.    The remainder  discusses the  use of  the built-in  graphical
tools that require the XPCE graphical library installed on your system.


33..11 TThhee pprroojjeecctt ssoouurrccee--ffiilleess

Organisation  of  source-files  depends largely  on  the  size  of  your
project.    If  you  are doing  exercises  for  a Prolog  course  you'll
normally use one  file for each exercise.   If you have a small  project
you'll work work with  one directory holding a couple of files  and some
files to link it  all together.  Even bigger projects will  be organised
in sub-projects each using their own directory.


33..11..11 FFiillee NNaammeess aanndd LLooccaattiioonnss


33..11..11..11 FFiillee NNaammee EExxtteennssiioonnss

The first consideration  is what extension to use for  the source-files.
Tradition  calls for  .pl,  but conflicts  with Perl  force the  use  of
another extension on systems where extensions have  global meaning, such
as MS-Windows.  On such systems .pro is the common alternative.

All versions of SWI-Prolog load files with the extension  .pl as well as
with the registered alternative extension without  explicitly specifying
the  extension.    For  portability  reasons we  propose  the  following
convention:

IIff tthheerree iiss nnoo ccoonnfflliicctt  because  you   do   not   use   a   conflicting
    application  or the system does not force a unique  relation between
    extension and application, use .pl.

WWiitthh aa ccoonnfflliicctt  choose .pro and  use this extension  for the files  you
    want  to load  through your  file-manager.   Use .pl  for all  other
    files for maximal portability.


33..11..11..22 PPrroojjeecctt DDiirreeccttoorriieess

Large projects are generally composed of sub-projects,  each using their
own directory or  directory-structure.  If  nobody else will ever  touch
your  files and  you use  only one  computer there  is  little to  worry
about, but this is rarely the case with a large project.

To  improve  portability,   SWI-Prolog  uses  the  POSIX   notation  for
filenames, which  uses the  forward slash (/)  to separate  directories.
Just before  hitting the file-system  it uses prolog_to_os_filename/2 to
convert the  filename to the conventions  used by the hosting  operating
system.  It  is _s_t_r_o_n_g_l_y advised to write paths using the  /, especially
on systems using the \ for this purpose (MS-Windows).   Using \ violates
the  portability rules  and requires  you to  _d_o_u_b_l_e the  \  due to  the
Prolog quoted-atom escape rules.

Portable  code should  use  prolog_to_os_filename/2to  convert  computed
paths  into system-paths  when  constructing  commands for  shell/1  and
friends.


33..11..11..33 SSuubb--pprroojjeeccttss uussiinngg sseeaarrcchh--ppaatthhss

Thanks to Quintus, Prolog adapted an extensible  mechanism for searching
files using file_search_path/2.   This mechanism allows for  comfortable
and readable specifications.

Suppose  you  have  extensive  library  packages   on  graph-algorithms,
set-operations  and  GUI-primitives.    These  sub-projects  are  likely
candidates for re-use in future projects.  A good choice  is to create a
directory with sub-directories for each of these sub-projects.

Next,  there are  three options.    One is  to add  the sub-projects  to
the  directory-hierarchy of  the current  project.   Another  is to  use
a completely  dislocated directory  and finally the  sub-project can  be
added to the SWI-Prolog hierarchy.  Using local  installation, a typical
file_search_path/2is:

:- prolog_load_context(directory, Dir),
   asserta(user:file_search_path(myapp, Dir)).

user:file_search_path(graph, myapp(graph)).
user:file_search_path(ui,    myapp(ui)).

For  using sub-projects  in  the  SWI-Prolog hierarchy  one  should  use
the path-alias  swi as  basis.   For a  system-wide installation use  an
absolute-path.

Extensive  sub-projects with  a  small  well-defined API  should  define
a   load-file  using   use_module/1   calls  to   import   the   various
library-components and export the API.


33..11..22 PPrroojjeecctt SSppeecciiaall FFiilleess

There are  a number of  tasks you typically carry  out on your  project,
such as  loading it, creating  a saved-state, debugging it,  etc.   Good
practice  on large  projects is  to  define small  files that  hold  the
commands to execute such a task, name this file after  the task and give
it  a file-extension  that makes  starting easy  (see section  3.1.1.1).
The task _l_o_a_d is generally central to these tasks.   Here is a tentative
list.

  o load.pl
    Use  this file  to set  up the  environment (Prolog  flags and  file
    search  paths) and load the sources.  Quite commonly this  file also
    provides  convenient predicates  to parse  command-line options  and
    start the application.

  o run.pl
    Use  this file to start the application.  Normally it  loads load.pl
    in  silent-mode,  and  calls one  of  the starting  predicates  from
    load.pl.

  o save.pl
    Use this file  to create a saved-state of the application by loading
    load.pl and  call qsave_program/2to generate  a saved-state with the
    proper options.

  o debug.pl
    Loads  the program for  debugging.   In addition to loading  load.pl
    this  file defines rules for portray/1 to modify printing  rules for
    complex  terms and customisation rules for the debugger  and editing
    environment.  It may start some of these tools.


33..11..33 IInntteerrnnaattiioonnaall ssoouurrccee ffiilleess

As  discussed  in   section  2.17,  SWI-Prolog  supports   international
character  handling.   Its  internal encoding  is  UNICODE. I/O  streams
convert  to/from this  internal format.    This  sections discusses  the
options for source-files not in US-ASCII.

SWI-Prolog  can  read  files  in  any  of  the  encodings  described  in
section 2.17.    Two encodings  are of particular  interest.   The  text
encoding  deals with  the  current  _l_o_c_a_l_e,  the default  used  by  this
computer for  representing text files.   The encodings  utf8, unicode_le
and unicode_be are _U_N_I_C_O_D_E encodings:  they can represent---in  the same
file---characters of  virtually any known language.   In addition,  they
do so unambiguously.

If  one wants  to  represent non  US-ASCII text  as  Prolog terms  in  a
source-file there are several options:

  o _U_s_e _e_s_c_a_p_e _s_e_q_u_e_n_c_e_s
    This approach describes  NON-ASCII as sequences of the form \_o_c_t_a_l\.
    The  numerical argument is interpreted as a UNICODE character.   The
    resulting  Prolog file is  strict 7-bit US-ASCII,  but if there  are
    many NON-ASCII characters it becomes very unreadable.

  o _U_s_e _l_o_c_a_l _c_o_n_v_e_n_t_i_o_n_s
    Alternatively  the file  may be specified  using local  conventions,
    such  as the EUC  encoding for Japanese text.   The disadvantage  is
    portability.   If the file is moved to another machine  this machine
    must  be using the  same _l_o_c_a_l_e or  the file is  unreadable.   There
    is  no elegant if files from multiple locales must be united  in one
    application  using this technique.   In other words, it is  fine for
    local projects in countries with uniform locale conventions.

  o _U_s_i_n_g _U_T_F_-_8 _f_i_l_e_s
    The best way  to specify source files with many NON-ASCII characters
    is  definitely the use  of UTF-8 encoding.   Prolog can be  notified
    two ways of  this encoding, using a UTF-8 _B_O_M (see section 2.17.1.1)
    or  using  the  directive  :- encoding(utf8)..    Many  todays  text
    editors,  including PceEmacs,  are capable  of editing UTF-8  files.
    Projects  that started  using local conventions  can be be  re-coded
    using  the Unix iconv tool or often using a commands offered  by the
    editor.


33..22 UUssiinngg mmoodduulleess

Modules have  been debated fiercely  in the Prolog world.   Despite  all
counter-arguments we feel they are extremely useful because

  o _T_h_e_y _h_i_d_e _l_o_c_a_l _p_r_e_d_i_c_a_t_e_s
    This  is the  reason they  have been  invented in  the first  place.
    Hiding  provides  two features.    They  allow for  short  predicate
    names  without worrying about conflicts.  Given the  flat name-space
    introduced  by modules, they  still require meaningful module  names
    as well as meaningful names for exported predicates.

  o _T_h_e_y _d_o_c_u_m_e_n_t _t_h_e _i_n_t_e_r_f_a_c_e
    Possibly  more important then avoiding name-conflicts is  their role
    in  documenting  which part  of the  file is  for  public usage  and
    which  is private.   When editing  a module you  may assume you  can
    reorganise  anything  but the  name and  semantics  of the  exported
    predicates without worrying.

  o _T_h_e_y _h_e_l_p _t_h_e _e_d_i_t_o_r
    The  PceEmacs built-in editor  does on-the-fly cross-referencing  of
    the  current module, colouring predicates based on their  origin and
    usage.    Using modules,  the editor  can quickly find  out what  is
    provided  by the imported  modules by reading  just the first  term.
    This  allows it to indicate real-time which predicates are  not used
    or not defined.

Using modules  is generally  easy.   Only if  you write  meta-predicates
(predicates reasoning about  other predicates) that are exported from  a
module good understanding of resolution of terms to  predicates inside a
module is required.  Here is a typical example from readutil.

:- module(read_util,
          [ read_line_to_codes/2,       % +Fd, -Codes
            read_line_to_codes/3,       % +Fd, -Codes, ?Tail
            read_stream_to_codes/2,     % +Fd, -Codes
            read_stream_to_codes/3,     % +Fd, -Codes, ?Tail
            read_file_to_codes/3,       % +File, -Codes, +Options
            read_file_to_terms/3        % +File, -Terms, +Options
          ]).


33..33 TThhee tteesstt--eeddiitt--rreellooaadd ccyyccllee

SWI-Prolog does not enforce  the use of a particular editor  for writing
down  Prolog  source  code.    Editors  are  complicated  programs  that
must  be mastered  in  detail for  real  productive programming  and  if
you  are familiar  with  a specific  editor  you  should not  be  forced
to change.    You may  specify your  favourite editor  using the  Prolog
flag editor,  the environment variable EDITOR  or by defining rules  for
prolog_edit:edit_source/1 (see section 4.4).

The use of  a built-in editor, which  is selected by setting the  Prolog
flag  editor to  pce_emacs, has  advantages.    The XPCE  _e_d_i_t_o_r  object
around which the  built-in PceEmacs is built  can be opened as a  Prolog
stream allowing analysis of your source by the real Prolog system.


33..33..11 LLooccaattiinngg tthhiinnggss ttoo eeddiitt

The central  predicate for  editing something is  edit/1, an  extensible
front-end that searches for objects (files, predicates,  modules as well
as  XPCE classes  and methods)  in the  Prolog database.    If  multiple
matches are  found it  provides a choice.    Together with the  built-in
completion on atoms  bound to the TAB key  this provides a quick way  to
edit objects:

?- edit(country).
Please select item to edit:

  1 chat:country/10      '/staff/jan/lib/prolog/chat/countr.pl':16
  2 chat:country/1       '/staff/jan/lib/prolog/chat/world0.pl':72

Your choice?


33..33..22 EEddiittiinngg aanndd iinnccrreemmeennttaall ccoommppiillaattiioonn

One of  the nice features  of Prolog  is that the  code can be  modified
while  the program  is running.    Using  pure Prolog  you  can trace  a
program,  find it  is misbehaving,  enter  a _b_r_e_a_k  _e_n_v_i_r_o_n_m_e_n_t,  modify
the  source code,  reload it  and finally  do _r_e_t_r_y  on the  misbehaving
predicate  and  try  again.      This  sequence  is  not   uncommon  for
long-running programs.   For faster  programs one normally aborts  after
understanding  the misbehaviour,  edit  the source,  reload it  and  try
again.

One of the nice features of SWI-Prolog is the  availability of make/0, a
simple predicate that checks  all loaded source files to see  which ones
you have modified.  It then reloads these  files, considering the module
from which the file was loaded originally.   This greatly simplifies the
trace-edit-verify development cycle.  After the tracer  reveals there is
something wrong with prove/3, you do:

?- edit(prove).

Now  edit the  source,  possibly switching  to  other files  and  making
multiple changes.   After  finishing invoke  make/0, either through  the
editor UI (Compile/Make  (Control-C Control-M)) or on the top-level  and
watch the files being reloaded.

?- make.
% show compiled into photo_gallery 0.03 sec, 3,360 bytes


33..44 UUssiinngg tthhee PPcceeEEmmaaccss bbuuiilltt--iinn eeddiittoorr


33..44..11 AAccttiivvaattiinngg PPcceeEEmmaaccss

Initially edit/1  uses the  editor specified in  the EDITOR  environment
variable.   There are two ways to  force it to use the built-in  editor.
One is to  set the Prolog flag editor  to pce_emacs and the other is  by
starting the editor explicitly using the emacs/[0,1] predicates.


33..44..22 BBlluuffffiinngg tthhrroouugghh PPcceeEEmmaaccss

PceEmacs closely  mimics Richard Stallman's  GNU-Emacs commands,  adding
features from  modern window-based  editors to make  it more  acceptable
for beginners.

At the  basis, PceEmacs  maps keyboard sequences  to methods defined  on
the extended  _e_d_i_t_o_r object.   Some frequently  used commands are,  with
their key-binding, presented  in the menu-bar above each  editor window.
A complete  overview of the  bindings for the  current _m_o_d_e is  provided
through Help/Show key bindings (Control-h Control-b).


33..44..22..11 EEddiitt mmooddeess

Modes  are the  heart of  (Pce)Emacs.   Modes  define dedicated  editing
support for  a particular  kind of (source-)text.    For our purpose  we
want _P_r_o_l_o_g _m_o_d_e.   Their are various  ways to make PceEmacs use  Prolog
mode for a file.

  o _U_s_i_n_g _t_h_e _p_r_o_p_e_r _e_x_t_e_n_s_i_o_n
    If  the file  ends in .pl  or the  selected alternative (e.g.  .pro)
    extension, Prolog mode is selected.

  o _U_s_i_n_g #!/path/to/pl
    If  the  file  is a  _P_r_o_l_o_g  _S_c_r_i_p_t  file, starting  with  the  line
    #!/path/to/pl options -s, Prolog  mode is selected regardless of the
    extension

  o _U_s_i_n_g -*- Prolog -*-
    If the above sequence  appears in the first line of the file (inside
    a Prolog comment) Prolog mode is selected.

  o _E_x_p_l_i_c_i_t _s_e_l_e_c_t_i_o_n
    Finally,  using  File/Mode/Prolog (y)ou  can switch  to Prolog  mode
    explicitly.


33..44..22..22 FFrreeqquueennttllyy uusseedd eeddiittoorr ccoommmmaannddss

Below we list a few important commands and how to activate them.

  o _C_u_t_/_C_o_p_y_/_P_a_s_t_e
    These  commands  follow Unix/X11  traditions.    You're best  suited
    with  a three-button mouse.   After  selecting using the  left-mouse
    (double-click  uses word-mode  and triple  line-mode), the  selected
    text   is  _a_u_t_o_m_a_t_i_c_a_l_l_y  copied  to  the  clipboard   (X11  primary
    selection  on  Unix).   _C_u_t  is achieved  using the  DEL  key or  by
    typing  something else  at the location.    _P_a_s_t_e is achieved  using
    the  middle-mouse (or wheel)  button.   If you  don't have a  middle
    mouse-button,  pressing the left- and right-button at the  same time
    is interpreted as a  middle-button click.  If nothing helps there is
    the Edit/Paste menu-entry.  Text is pasted at the caret-location.

  o _U_n_d_o
    Undo  is bound to the GNU-Emacs Control-_ as well as  the MS-Windows
    Control-Z sequence.

  o _A_b_o_r_t
    Multi-key sequences can be aborted at any stage using Control-G.

  o _F_i_n_d
    Find  (Search) is  started  using Control-S  (forward) or  Control-R
    (backward).      PceEmacs  implements  _i_n_c_r_e_m_e_n_t_a_l  _s_e_a_r_c_h.     This
    is  difficult  to  use  for novices,  but  very  powerful  once  you
    get  the  clue.    After  one of  the  above start-keys  the  system
    indicates  search mode in the  status line.   As you are typing  the
    search-string,  the  system searches  for it,  extending the  search
    with  every character you  type.   It illustrates the current  match
    using a green background.

    If  the target  cannot be found,  PceEmacs warns  you and no  longer
    extends  the  search-string.   During  search  some characters  have
    special  meaning.  Typing anything but these characters  commits the
    search, re-starting normal edit mode.  Special commands are:

    Control-S
         Search for next forwards.

    Control-R
         Search for next backwards.

    Control-W
         Extend search to next word-boundary.

    Control-G
         Cancel search, go back to where it started.

    ESC
         Commit search, leaving caret at found location.

    Backspace
         Remove a character from the search string.

  o _D_y_n_a_m_i_c _A_b_b_r_e_v_i_a_t_i_o_n
    Also  called _d_a_b_b_r_e_v  is  an important  feature of  Emacs clones  to
    support  programming.   After  typing the  first few  letters of  an
    identifier  you may hit Alt-/, causing PceEmacs to  search backwards
    for  identifiers that start  the same and  using it to complete  the
    text  you typed.   A second  Alt-/ searches further  backwards.   If
    there  are no hits  before the caret  it starts searching  forwards.
    With  some practice, this system allows for very fast  entering code
    with nice and readable identifiers (or other difficult long words).

  o _O_p_e_n _(_a _f_i_l_e_)
    Is  called File/Find  file (Control-x Control-f).    By default  the
    file  is loaded into the current window.   If you want to  keep this
    window,  Hit Alt-s or  click the little  icon at the bottom-left  to
    make the window _s_t_i_c_k_y.

  o _S_p_l_i_t _v_i_e_w
    Sometimes  you want to look at two places  of the same file.   To do
    this,  use Control-x 2 to create  a new window pointing to  the same
    file.   Do not worry, you  can edit as well as move around  in both.
    Control-x 1 kills all other windows running on the same file.

These were the  most commonly used commands.   In section section  3.4.3
we discuss specific support for dealing with Prolog source code.


33..44..33 PPrroolloogg MMooddee

In  the previous  section (section  3.4.2) we  explained  the basics  of
PceEmacs.     Here  we  continue  with  Prolog  specific  functionality.
Possibly  the most  interesting is  _S_y_n_t_a_x _h_i_g_h_l_i_g_h_t_i_n_g.    Unlike  most
editors  where  this  is  based  on  simple  patterns,  PceEmacs  syntax
highlighting  is  achieved   by  Prolog  itself  actually  reading   and
interpreting the  source as you  type it.   There  are three moments  at
which PceEmacs checks (part of) the syntax.

  o _A_f_t_e_r _t_y_p_i_n_g _a .
    After  typing a .  that is  not preceded by  a _s_y_m_b_o_l character  the
    system  assumes you completed a clause,  tries to find the start  of
    this  clause and verifies the syntax.   If this process succeeds  it
    colours  the elements  of the  clause according to  the rules  given
    below.    Colouring is  done using  information from  the last  full
    check  on this file.  If it fails, the syntax error  is displayed in
    the status line and the clause is not coloured.

  o _A_f_t_e_r _t_h_e _c_o_m_m_a_n_d Control-c Control-s
    Acronym  for CCcheck SSyntax it performs the same checks as  above for
    the  clause surrounding the caret.   On a syntax error however,  the
    caret is moved to the expected location of the error.

  o _A_f_t_e_r _p_a_u_s_i_n_g _f_o_r _t_w_o _s_e_c_o_n_d_s
    After  a short  pause (2  seconds), PceEmacs  opens the  edit-buffer
    and  reads it  as a  whole, creating  an index  of defined,  called,
    dynamic,  imported and exported predicates.  After  completing this,
    it  re-reads the file and colours  all clauses and calls with  valid
    syntax.

  o _A_f_t_e_r _t_y_p_i_n_g Control-l Control-l
    The Control-l commands  re-centers the window (scrolls the window to
    make  the caret the  center of  the window).   Hitting this  command
    twice starts the same process as above.

TThhee ccoolloouurr sscchheemmaa

itself  is  defined  in  emacs/prolog_colour.     The  colouring  can  be
extended and  modified using multifile  predicates.   Please check  this
source-file for details.   In general,  underlined objects have a  popup
(right-mouse button) associated for common commands such  as viewing the
documentation or source.   BBoolldd text is used to indicate  the definition
of  objects (typically  predicates  when using  plain  Prolog).    Other
colours follow intuitive conventions.  See table 3.4.3.
          _____________________________________________________
          |______________________Clauses_______________________|
          | Blue bold  |Head of an exported predicate          |
          | Red bold   |Head of a predicate that is not called |

          |_Black_Bold_|Head_of_remaining_predicates___________|
          |______________Calls_in_the_clause-body______________|
          | Blue       |Call to built-in or imported predicate |
          | Red        |Call to not-defined predicate          |
          |_Purple_____|Call_to_dynamic_predicate______________|
          |___________________Other_entities___________________|

          | Dark green |Comment                                |
          | Dark blue  |Quoted atom or string                  |
          |_Brown______|Variable_______________________________|

                     Table 3.1:  Colour conventions

LLaayyoouutt ssuuppppoorrtt Layout  is not `just nice',  it is _e_s_s_e_n_t_i_a_l for  writing
readable code.   There is  much debate on  the proper layout of  Prolog.
PceEmacs,  being a  rather small  project supports  only one  particular
style for layout.  Below are examples of typical constructs.

head(arg1, arg2).

head(arg1, arg2) :- !.

head(Arg1, arg2) :- !,
        call1(Arg1).

head(Arg1, arg2) :-
        (   if(Arg1)
        ->  then
        ;   else
        ).

head(Arg1) :-
        (   a
        ;   b
        ).

head :-
        a(many,
          long,
          arguments(with,
                    many,
                    more),
          and([ a,
                long,
                list,
                with,
                a,
              | tail
              ])).

PceEmacs uses the  same conventions as GNU-Emacs.   The TAB key  indents
the current  line according  to the  syntax rules.    Alt-q indents  all
lines  of the  current clause.    It provides  support for  head,  calls
(indented 1  tab), if-then-else,  disjunction and argument-lists  broken
across multiple lines as illustrated above.


33..44..33..11 FFiinnddiinngg yyoouurr wwaayy aarroouunndd

The command Alt-.   extracts name and arity from the caret  location and
jumps (after conformation  or edit) to the definition of  the predicate.
It does  so based on the  source-location database of loaded  predicates
also used  by edit/1.   This makes locating  predicates reliable if  all
sources are loaded and up-to-date (see make/0).

In addition,  references to files  in use_module/[1,2], consult/1,  etc.
are red if the file cannot be found and underlined blue  if the file can
be loaded.  A popup allows for opening the referenced file.


33..55 TThhee GGrraapphhiiccaall DDeebbuuggggeerr

SWI-Prolog offers  two debuggers.   One is the traditional  text-console
based 4-port Prolog tracer and the other is  a window-based source-level
debugger.    The window-based  debugger  requires XPCE  installed.    It
operates  based  on   the  prolog_trace_interception/4 hook   and  other
low-level functionality described in chapter 12.

Window-based tracing  provides much better overview  due to the  eminent
relation to your source-code, a clear list of  named variables and their
bindings as well  as a graphical overview  of the call and  choice-point
stack.  There are  some drawbacks though.  Using a textual trace  on the
console one can  scroll back and examine  the past, while the  graphical
debugger just presents a (much better) overview of the current state.


33..55..11 IInnvvookkiinngg tthhee wwiinnddooww--bbaasseedd ddeebbuuggggeerr

Whether the  text-based or window-based debugger  is used is  controlled
using  the predicates  guitracer/0 and  noguitracer/0.   Entering  debug
mode  is controlled  using  the normal  predicates  for this:    trace/0
and  spy/1.   In  addition, PceEmacs  prolog mode  provides the  command
Prolog/Break  at (Control-c b)  to insert  a break-point  at a  specific
location in the source-code.

The graphical tracer is  particulary useful for debugging threads.   The
tracer must be loaded from the main thread before it can  be used from a
background thread.


gguuiittrraacceerr
    This  predicate  installs the  above-mentioned hooks  that  redirect
    tracing  to  the  window-based  environment.    No  window  appears.
    The  debugger window  appears as actual  tracing is started  through
    trace/0,  by hitting a spy-point  defined by spy/1 or a  break-point
    defined using PceEmacs command Prolog/Break at (Control-c b).


nnoogguuiittrraacceerr
    Disable  the hooks  installed by  guitracer/0,  reverting to  normal
    text-console based tracing.


ggttrraaccee
    Utility defined as guitracer,trace.


ggddeebbuugg
    Utility defined as guitracer,debug.


ggssppyy((_+_P_r_e_d_i_c_a_t_e))
    Utility defined as guitracer,spy(Predicate).


33..66 TThhee PPrroolloogg NNaavviiggaattoorr

Another  tool is  the  _P_r_o_l_o_g  _N_a_v_i_g_a_t_o_r.    This  tool can  be  started
from  PceEmacs  using the  command  Browse/Prolog  navigator,  from  the
GUI  debugger or  using  the  programmatic IDE  interface  described  in
section 3.8.


33..77 CCrroossss rreeffeerreenncceerr

A  cross-referencers is  a  tool  examining the  caller-callee  relation
between predicates  and using this  information to explicate  dependency
relations between  source files, find  calls to non-existing  predicates
and predicates  for which no  callers can be  found.   Cross-referencing
is useful during  program development, reorganisation, cleanup,  porting
and  other program  maintenance tasks.    The dynamic  nature of  Prolog
makes the  task non-trivial.   Goals can  be created dynamically  call/1
after construction  of a  goal term.   Abtract  interpretation can  find
some  of such  calls, but  the ultimately  they can  come from  external
communication, making  it completely impossible  to predict the  callee.
In other words,  the cross-referencer has only partial  understanding of
the  program and  its results  are necessarily  incomplete.   Still,  it
provides valuable information to the developer.

SWI-Prolog's cross-referencer  is split into  two parts.   The  standard
Prolog  library prolog_xref  is an  extensible library  for  information
gathering described in section 11.18 and the XPCE

library pce_xref provides a graphical frontend for  the cross-referencer
described here.   We demonstrate the tool on CHAT80, a  natural language
question  and answer  system by  Fernando C.N.  Pereira  and David  H.D.
Warren.


ggxxrreeff
    Run  cross-referencer on  all currently loaded  files and present  a
    graphical  overview of  the result.   As  the predicate operates  on
    the  currently loaded application it  must be run after loading  the
    application.

The lleefftt wwiinnddooww  (see figure ???? provides  browsers for loaded files  and
predicates.  To avoid long file paths the file  hierarchy has three main
branches.  The first is the current directory holding the  sources.  The
second is  marked alias and  below it  are the file-search-path  aliases
(see file_search_path/2 and absolute_file_name/3).   Here you find  files
loaded from  the system as  well as modules of  the program loaded  from
other locations  using file  search path.   All  loaded files that  fall
outside these  categories are  below the  last branch  called /.    File
where  the system  found  suspicious  dependencies are  marked  with  an
exclamation mark.   This also holds for directories holding  such files.
Clicking on a file opens a _F_i_l_e _i_n_f_o window in the right pane.

The FFiillee iinnffoo  window shows a file,  its main properties, its  undefined
and not-called predicates and its import- and export  relations to other
files  in the  project.   Both  predicates and  files can  be opened  by
clicking  on them.    The number  of callers  in a  file  for a  certain
predicate is  indicated with  a blue  underlined number.   A  left-click
will open a list and allows to edit the calling predicate.

The DDeeppeennddeenncciieess  (see figure ????) window  displays a graphical  overview
of dependencies  between files.   Using the  background menu a  complete
graph of the project can be created.  It is  also possible to drag files
onto the  graph window and  use the menu on  the nodes to  incrementally
expand the  graph.   The underlined  blue text  indicates the number  of
predicates used in the destination file.  Left-clicking  opens a menu to
open the definition or select one of the callers.

MMoodduullee  aanndd nnoonn--mmoodduullee  ffiilleess The  cross-referencer threads  module  and
non-module  project files  differently.    Module  files  have  explicit
import  and  export   relations  and  the  tool  shows  the   usage  and
consistency of the  relations.  Using  the menu-command Header the  tool
creates a  consistent import list  for the module  that can be  included
in the  file.   The tool computes the  dependency relations between  the
non-module  files.   If  the user  wishes to  convert  the project  into
a module-based  one the Header command  generates an appropriate  module
header and import list.  Note that the  cross-referencer may have missed
dependencies  and does  not  deal with  meta-predicates defined  in  one
module and called in another.  Such problems must be resolved manually.

SSeettttiinnggss The  following settings  can be  controlled  from the  settings
menu:

WWaarrnn aauuttoollooaadd
    By  default disabled.   If enabled, modules that require  predicates
    to  be  autoloaded are  flagged with  a warning  and  the file  info
    window of a module shows the required autoload predicates.

WWaarrnn nnoott ccaalllleedd
    If  enabled (default),  the file-overview  shows an  alert icon  for
    files that have predicates that are not called.


33..88 AAcccceessssiinngg tthhee IIDDEE ffrroomm yyoouurr pprrooggrraamm

Over  the years  a collection  of IDE  components  have been  developed,
each with their  own interface.   In addition, some of these  components
require  each other  and loading  IDE components  must be  on demand  to
avoid the IDE  being part of a  saved-state (see qsave_program/2).   For
this  reason,  access  to the  IDE  will  be concentrated  on  a  single
interface called prolog_ide/1:


pprroolloogg__iiddee((_+_A_c_t_i_o_n))
    This  predicate ensures the IDE  enabling XPCE component is  loaded,
    creates  the XPCE class _p_r_o_l_o_g___i_d_e and sends  _A_c_t_i_o_n to its one  and
    only  instance \index{@prolog_ide}\objectname{prolog_ide}.    _A_c_t_i_o_n
    is one of the following:

    ooppeenn__nnaavviiggaattoorr((_+_D_i_r_e_c_t_o_r_y))
         Open  the Prolog  Navigator  (see  section 3.6)  in  the  given
         _D_i_r_e_c_t_o_r_y.

    ooppeenn__ddeebbuugg__ssttaattuuss
         Open a window to edit spy- and trace-points.

    ooppeenn__qquueerryy__wwiinnddooww
         Opens  a  little  window to  run  Prolog  queries  from  a  GUI
         component.

    tthhrreeaadd__mmoonniittoorr
         Open a graphical  window indicating existing threads and  their
         status.

    ddeebbuugg__mmoonniittoorr
         Open a graphical front-end for the debug  library that provides
         an overview of the topics and catches messages.

    xxrreeff
         Open  a  graphical  front-end  for  the  cross-referencer  that
         provides an overview of predicates and their callers.


33..99 SSuummmmaarryy ooff tthhee iiDDEE

The  SWI-Prolog  development   environment  consists  of  a  number   of
interrelated but  not (yet) integrated  tools.   Here is  a list of  the
most important features and tips.

  o _A_t_o_m _c_o_m_p_l_e_t_i_o_n
    The  console  completes a  partial atom  on the  TAB  key and  shows
    alternatives on the command Alt-?.

  o _U_s_e edit/1 _t_o _f_i_n_d_i_n_g _l_o_c_a_t_i_o_n_s
    The  command edit/1 takes the name  of a file, module, predicate  or
    other  entity registered  through  extensions and  starts the  users
    preferred editor at the right location.

  o _S_e_l_e_c_t _e_d_i_t_o_r
    External   editors  are  selected   using  the  EDITOR   environment
    variable, by setting  the Prolog flag editor or by defining the hook
    prolog_edit:edit_source/1.

  o _U_p_d_a_t_e _P_r_o_l_o_g _a_f_t_e_r _e_d_i_t_i_n_g
    Using make/0, all files you have edited are re-loaded.

  o _P_c_e_E_m_a_c_s
    Offers  syntax-highlighting and checking based on  real-time parsing
    of the editor's buffer, layout-support and navigation support.

  o _U_s_i_n_g _t_h_e _g_r_a_p_h_i_c_a_l _d_e_b_u_g_g_e_r
    The   predicates  guitracer/0   and  noguitracer/0  switch   between
    traditional  text-based and window-based debugging.   The tracer  is
    activated  using the trace/0, spy/1  or menu-items from PceEmacs  or
    the PrologNavigator.

  o _T_h_e _P_r_o_l_o_g _N_a_v_i_g_a_t_o_r
    Shows  the file-structure and structure inside the file.   It allows
    for loading files, editing, setting spy-points, etc.


CChhaapptteerr 44..  BBUUIILLTT--IINN PPRREEDDIICCAATTEESS


44..11 NNoottaattiioonn ooff PPrreeddiiccaattee DDeessccrriippttiioonnss

We have  tried to  keep the  predicate descriptions  clear and  concise.
First  the predicate  name is  printed  in bold  face, followed  by  the
arguments in italics.  Arguments are preceded by  a mode indicator There
is no  complete agreement on  mode indicators  in the Prolog  community.
We use the following definitions:

        ________________________________________________________+Argument must be fully instantiated to a term that

            satisfies  the required argument  type.   Think of
            the argument as _i_n_p_u_t.
         -  Argument must  be unbound.   Think of the argument
            as _o_u_t_p_u_t.

         ?  Argument  must be bound  to a _p_a_r_t_i_a_l  _t_e_r_m of the
            indicated type.  Note that a variable is a partial
            term  for any  type.    Think  of the  argument as
            either  _i_n_p_u_t or _o_u_t_p_u_t or  _b_o_t_h input and output.
            E.g.  In stream_property(S, reposition(Bool)), the
            reposition  part  of  the term  is  input  and the
            uninstantiated _B_o_o_l is output.
         :  Argument  is a  meta-argument.   Implies  +.   See

            section 5 for more information on module-handing.
         @  Argument  is not further instantiated.   Typically
            used for type-tests.
         !  Argument contains  a mutable structure that may be
        ____modified_using_setarg/3_or_nb_setarg/3._____________

Referring  to a  predicate in  running text  is done  using a  _p_r_e_d_i_c_a_t_e
_i_n_d_i_c_a_t_o_r.     The  canonical and  most  generic  form  of  a  predicate
indicator is a term <_m_o_d_u_l_e>:<_n_a_m_e>/<_a_r_i_t_y>.  If the module is  irrelevant
(built-in  predicate)  or  can  be  inferred  from  the  context  it  is
often  omitted.    Compliant  to the  ISO  standard  draft on  DCG  (see
section 4.12),  SWI-Prolog also allows  for [<_m_o_d_u_l_e>]:<_n_a_m_e>//<_a_r_i_t_y>  to
refer to  a grammar rule.   For  all non-negative arity,  <_n_a_m_e>//<_a_r_i_t_y>
is  the same  as  <_n_a_m_e>/<arity+2>,  regardless on  whether  or  not the
referenced predicate is defined or  can be used as a grammar rule.   The
//-notation can  be used in  all places that  traditionally allow for  a
predicate indicator, e.g. the module declaration, spy/1, and dynamic/1.


44..22 CChhaarraacctteerr rreepprreesseennttaattiioonn

In  traditional (Edinburgh-)  Prolog, characters  are represented  using
_c_h_a_r_a_c_t_e_r_-_c_o_d_e_s.   Character codes are  integer indices into a  specific
character set.   Traditionally  the character  set was 7-bits  US-ASCII.
8-bit  character sets  have  been allowed  for  a long  time,  providing
support for national  character sets, of which iso-latin-1  (ISO 8859-1)
is applicable  to many western  languages.   Text-files are supposed  to
represent a sequence of character-codes.

ISO Prolog introduces three types, two of which  are used for characters
and one for accessing binary streams (see open/4).  These types are:

  o _c_o_d_e
    A  _c_h_a_r_a_c_t_e_r_-_c_o_d_e is  an  integer representing  a single  character.
    As  files  may  use  multi-byte encoding  for  supporting  different
    character  sets (utf-8 encoding for example), reading a code  from a
    text-file is in general not the same as reading a byte.

  o _c_h_a_r
    Alternatively,  characters  may  be  represented  as  _o_n_e_-_c_h_a_r_a_c_t_e_r_-
    _a_t_o_m_s.    This is  a  very natural  representation, hiding  encoding
    problems  from  the  programmer as  well  as providing  much  easier
    debugging.

  o _b_y_t_e
    Bytes are used for accessing binary-streams.

The  current  version  of  SWI-Prolog  does  not   provide  support  for
multi-byte character encoding.  This implies for example  that it is not
capable of  breaking a  multi-byte encoded  atom into characters.    For
SWI-Prolog, bytes  and codes  are the same  and one-character-atoms  are
simple atoms containing one byte.

To  ease  the  pain  of  these  multiple  representations,  SWI-Prolog's
built-in  predicates dealing  with character-data  work  as flexible  as
possible:   they accept  data in  any of these  formats as  long as  the
interpretation  is unambiguous.     In addition,  for  output  arguments
that are  instantiated, the character  is extracted before  unification.
This implies  that the following two  calls are identical, both  testing
whether the next input characters is an a.

peek_code(Stream, a).
peek_code(Stream, 97).

These  multiple-representations  are  handled  by  a   large  number  of
built-in predicates,  all of which are  ISO-compatible.  For  converting
between  code  and  character  there  is  char_code/2.     For  breaking
atoms and  numbers into  characters are are  atom_chars/2,  atom_codes/2,
number_codes/2 and number_chars/2.   For character I/O on streams  there
is  get_char/[1,2],  get_code/[1,2],   get_byte/[1,2],   peek_char/[1,2],
peek_code/[1,2],  peek_byte/[1,2],  put_code/[1,2],  put_char/[1,2]  and
put_byte/[1,2].  The Prolog flag double_quotes controls how text between
double-quotes is interpreted.


44..33 LLooaaddiinngg PPrroolloogg ssoouurrccee ffiilleess

This section deals  with loading Prolog source-files.   A Prolog  source
file is a plain  text file containing a Prolog program or  part thereof.
Prolog source files come in three flavours:

 AA ttrraaddiittiioonnaall   Prolog  source   file  contains   Prolog  clauses   and
    directives,  but no  _m_o_d_u_l_e_-_d_e_c_l_a_r_a_t_i_o_n.   They are normally  loaded
    using consult/1 or ensure_loaded/1.

 AA mmoodduullee   Prolog source file  starts with a module  declaration.   The
    subsequent Prolog code  is loaded into the specified module and only
    the _p_u_b_l_i_c predicates  are made available to the context loading the
    module.   Module  files are normally loaded  using use_module/[1,2].
    See chapter 5 for details.

 AAnn iinncclluuddee   Prolog source file is loaded using the include/1 directive
    and normally contains only directives.

Prolog  source-files are  located  using  absolute_file_name/3 with  the
following options:

locate_prolog_file(Spec, Path) :-
        absolute_file_name(Spec,
                           [ file_type(prolog),
                             access(read)
                           ],
                           Path).

The file_type(_p_r_o_l_o_g) option is  used to determine the extension of  the
file using  prolog_file_type/2.    The default extension  is .pl.    _S_p_e_c
allows  for the  _p_a_t_h_-_a_l_i_a_s construct  defined  by absolute_file_name/3.
The most commonly used path-alias is library(_L_i_b_r_a_r_y_F_i_l_e).   The example
below  loads the  library  file  ordsets.pl (containing  predicates  for
manipulating ordered sets).

:- use_module(library(ordsets)).

SWI-Prolog   recognises    grammar   rules    (DCG)   as   defined    in
[Clocksin & Melish, 1987].   The user may define additional  compilation
of the source  file by defining the  dynamic predicates term_expansion/2
and  goal_expansion/2.     Transformations by  term_expansion/2  overrule
the systems  grammar rule  transformations.   It is  not allowed to  use
assert/1, retract/1 or any other  database predicate in term_expansion/2
other than for local computational purposes.

Directives  may be  placed  anywhere  in a  source  file,  invoking  any
predicate.    They are  executed when  encountered.    If the  directive
fails, a warning is printed.  Directives are specified  by :-/1 or ?-/1.
There is no difference between the two.

SWI-Prolog   does   not   have   a   separate   reconsult/1   predicate.
Reconsulting  is  implied automatically  by  the  fact that  a  file  is
consulted which is already loaded.


llooaadd__ffiilleess((_+_F_i_l_e_s_, _+_O_p_t_i_o_n_s))
    The  predicate load_files/2 is the parent  of all the other  loading
    predicates  except for include/1.   It  currently supports a  subset
    of  the options of Quintus load_files/2.   _F_i_l_e_s is either a  single
    source-file,  or a list  of source-files.   The specification for  a
    source-file  is handed to absolute_file_name/2.  See this  predicate
    for  the supported expansions.   _O_p_t_i_o_n_s is a list of options  using
    the format

         _O_p_t_i_o_n_N_a_m_e(_O_p_t_i_o_n_V_a_l_u_e)

    The following options are currently supported:

    aauuttoollooaadd((_B_o_o_l))
         If  true  (default false),  indicate  this  load  is  a  _d_e_m_a_n_d
         load.   This  implies that,  depending  on the  setting of  the
         Prolog  flag verbose_autoload  the load-action  is  printed  at
         level informational  or silent.   See also  print_message/2 and
         current_prolog_flag/2.

    ddeerriivveedd__ffrroomm((_F_i_l_e))
         Indicate that the  loaded file is derived  from _F_i_l_e.  Used  by
         make/0 to  time-check and  load the original  file rather  than
         the derived file.

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Specify the way  characters are encoded in  the file.   Default
         is taken  from the Prolog  flag encoding.   See section  2.17.1
         for details.

    eexxppaanndd((_B_o_o_l))
         If true, run the  filenames through expand_file_name/2 and load
         the returned  files.   Default is false,  except for  consult/1
         which is intended  for interactive use.   Flexible location  of
         files is defined by file_search_path/2.

    ffoorrmmaatt((_+_F_o_r_m_a_t))
         Used to  specify  the file  format  if data  is loaded  from  a
         stream using  the stream(_S_t_r_e_a_m)  option.   Default is  source,
         loading  Prolog source  text.    If  qlf,  load QLF  data  (see
         qcompile/1).

    iiff((_C_o_n_d_i_t_i_o_n))
         Load the  file only  if the specified  condition is  satisfied.
         The value  true loads the  file unconditionally, changed  loads
         the file  if it  was not loaded  before, or  has been  modified
         since it was loaded the last time, not_loaded loads the file if
         it was not loaded before.

    iimmppoorrttss((_I_m_p_o_r_t))
         Specify what  to import from  the loaded module.   The  default
         for use_module/1  is all.   _I_m_p_o_r_t  is passed  from the  second
         argument  of use_module/2.    Traditionally  it  is a  list  of
         predicate indicators to import.  As part  of the SWI-Prolog/YAP
         integration,  we  also  support  _P_r_e_d  as   _N_a_m_e  to  import  a
         predicate under another  name.  Finally,  _I_m_p_o_r_t can be a  term
         except(_E_x_c_e_p_t_i_o_n_s),  where _E_x_c_e_p_t_i_o_n_s  is a  list of  predicate
         indicators that  specify predicates  that are  _n_o_t imported  or
         _P_r_e_d as  _N_a_m_e terms  to denote renamed  predicates.   See  also
         reexport/2 and use_module/2.

    mmuusstt__bbee__mmoodduullee((_B_o_o_l))
         If true,  raise an  error if  the file  is not  a module  file.
         Used by use_module/[1,2].

    qqccoommppiillee((_B_o_o_l))
         If this call appears in a directive of a file  that is compiled
         into Quick Load Format using qcompile/1 and this  flag is true,
         the contents  of the argument  files are  included in the  .qlf
         file instead of the loading directive.

    rreeeexxppoorrtt((_B_o_o_l))
         If true re-export the  imported predicate.  Used  by reexport/1
         and reexport/2.

    ssiilleenntt((_B_o_o_l))
         If  true, load  the  file  without printing  a  message.    The
         specified  value is  the  default for  all  files loaded  as  a
         result of loading the specified files.  This  option writes the
         Prolog flag verbose_load with the negation of _B_o_o_l.

    ssttrreeaamm((_I_n_p_u_t))
         This SWI-Prolog  extension compiles  the data  from the  stream
         _I_n_p_u_t.    If  this option  is  used,  _F_i_l_e_s  must be  a  single
         atom  which is  used to  identify  the source-location  of  the
         loaded clauses  as well as  remove all clauses  if the data  is
         re-consulted.

         This  option  is   added  to  allow  compiling  from   non-file
         locations such as databases, the web, the  _u_s_e_r (see consult/1)
         or other servers.  It can be combined with  format(_q_l_f) to load
         QLF data from a stream.

    The  load_files/2 predicate  can be  hooked to  load  other data  or
    data  from other objects than  files.  See  prolog_load_file/2for  a
    description and http_load for an example.


ccoonnssuulltt((_+_F_i_l_e))
    Read _F_i_l_e as a Prolog  source file.  _F_i_l_e may be a list of files, in
    which  case all members are consulted in turn.  _F_i_l_e may  start with
    the  Unix shell special  sequences ~,  <_u_s_e_r> and $<_v_a_r>.  _F_i_l_e  may
    also be library(Name),  in which case the libraries are searched for
    a  file with the specified  name.  See  also library_directory/1 and
    file_search_path/2.  consult/1  may be abbreviated by just  typing a
    number of file names in a list.  Examples:

        ?- consult(load).       % consult load or load.pl
        ?- [library(quintus)].  % load Quintus compatibility library
        ?- [user].

    The  predicate  consult/1 is  equivalent  to load_files(Files,  []),
    except for handling  the special file user, which reads clauses from
    the terminal.  See also the stream(_I_n_p_u_t) option of load_files/2.


eennssuurree__llooaaddeedd((_+_F_i_l_e))
    If the file  is not already loaded, this is equivalent to consult/1.
    Otherwise,   if  the  file  defines  a  module,  import  all  public
    predicates.    Finally,  if the  file is  already loaded,  is not  a
    module  file and the context module  is not the global user  module,
    ensure_loaded/1 will call consult/1.

    With the semantics, we  hope to get as closely possible to the clear
    semantics  without the presence  of a module  system.   Applications
    using modules should consider using use_module/[1,2].

    Equivalent to load_files(Files, [if(not_loaded)]).


iinncclluuddee((_+_F_i_l_e))
    Pretend  the  terms   in  _F_i_l_e  are  in  the  source-file  in  which
    :- include(File)  appears.  The  include construct is only  honoured
    if  it appears  as  a directive  in a  source-file.   Normally  _F_i_l_e
    contains a sequence of directives.


rreeqquuiirree((_+_L_i_s_t_O_f_N_a_m_e_A_n_d_A_r_i_t_y))
    Declare  that  this file/module  requires the  specified  predicates
    to  be defined ``with  their commonly accepted  definition''.   This
    predicate  originates from  the Prolog portability  layer for  XPCE.
    It  is intended to provide a portable mechanism for  specifying that
    this module requires the specified predicates.

    The implementation normally  first verifies whether the predicate is
    already defined.   If not, it will search the libraries and load the
    required library.

    SWI-Prolog, having autoloading,  does nnoott load the library.  Instead
    it  creates a  procedure header  for the  predicate if  it does  not
    exist.    This will flag  the predicate  as `undefined'.   See  also
    check/0 and autoload/0.


eennccooddiinngg((_+_E_n_c_o_d_i_n_g))
    This  directive can appear anywhere in  a source file to define  how
    characters  are  encoded in  the remainder  of  the file.    It  can
    be  used in  files that  are encoded  with a  superset of  US-ASCII,
    currently UTF-8 and ISO Latin-1.  See also section 2.17.1.


mmaakkee
    Consult  all source  files that  have been changed  since they  were
    consulted.    It  checks  _a_l_l loaded  source  files:   files  loaded
    into  a  compiled  state  using pl -c ...  and  files  loaded  using
    consult  or one of its derivatives.  The predicate make/0  is called
    after  edit/1, automatically reloading all  modified files.  If  the
    user  uses an  external editor  (in  a separate  window), make/0  is
    normally  used to update  the program after  editing.  In  addition,
    make/0  updates the  autoload indices  (see section  2.13) and  runs
    list_undefined/0  from  the check  library  to report  on  undefined
    predicates.


lliibbrraarryy__ddiirreeccttoorryy((_?_A_t_o_m))
    Dynamic  predicate used  to specify  library directories.    Default
    ./lib,  ~/lib/prolog and  the system's library  (in this order)  are
    defined.    The  user may  add library  directories using  assert/1,
    asserta/1 or remove system defaults using retract/1.


ffiillee__sseeaarrcchh__ppaatthh((_+_A_l_i_a_s_, _?_P_a_t_h))
    Dynamic  predicate used to specify `path-aliases'.  This  feature is
    best described using an example.  Given the definition

    file_search_path(demo, '/usr/lib/prolog/demo').

    the  file specification demo(myfile)  will be expanded to  /usr/lib/
    prolog/demo/myfile.   The second  argument of file_search_path/2 may
    be another alias.

    Below  is the  initial definition  of the file  search path.    This
    path  implies  swi(<_P_a_t_h>)  refers  to  a  file  in  the  SWI-Prolog
    home   directory.     The  alias  foreign(<_P_a_t_h>) is   intended  for
    storing   shared  libraries  (.so  or   .DLL  files).     See   also
    load_foreign_library/[1,2].

    user:file_search_path(library, X) :-
            library_directory(X).
    user:file_search_path(swi, Home) :-
            current_prolog_flag(home, Home).
    user:file_search_path(foreign, swi(ArchLib)) :-
            current_prolog_flag(arch, Arch),
            atom_concat('lib/', Arch, ArchLib).
    user:file_search_path(foreign, swi(lib)).

    The  file_search_path/2expansion  is used by all loading  predicates
    as well as by absolute_file_name/[2,3].

    The  Prolog  flag verbose_file_search can  be set  to  true to  help
    debugging Prolog's search for files.


eexxppaanndd__ffiillee__sseeaarrcchh__ppaatthh((_+_S_p_e_c_, _-_P_a_t_h))
    Unifies  _P_a_t_h  with   all  possible  expansions  of  the  file  name
    specification _S_p_e_c.  See also absolute_file_name/3.


pprroolloogg__ffiillee__ttyyppee((_?_E_x_t_e_n_s_i_o_n_, _?_T_y_p_e))
    This  dynamic multifile predicate defined in module  user determines
    the  extensions considered by file_search_path/2.  _E_x_t_e_n_s_i_o_n is  the
    filename  extension without the leading  dot, _T_y_p_e denotes the  type
    as  used by the file_type(_T_y_p_e) option of  file_search_path/2.   Here
    is the initial definition of prolog_file_type/2:

    user:prolog_file_type(pl,       prolog).
    user:prolog_file_type(Ext,      prolog) :-
            current_prolog_flag(associate, Ext),
            Ext \== pl.
    user:prolog_file_type(qlf,      qlf).
    user:prolog_file_type(Ext,      executable) :-
            current_prolog_flag(shared_object_extension, Ext).

    Users  may  wish to  change  the extension  used for  Prolog  source
    files  to avoid  conflicts (for  example with  perl) as  well as  to
    be  compatible with  some specific  implementation.   The  preferred
    alternative extension is .pro.


ssoouurrccee__ffiillee((_?_F_i_l_e))
    True  if _F_i_l_e is a loaded Prolog source file.  _F_i_l_e  is the absolute
    and canonical path to the source-file.


ssoouurrccee__ffiillee((_?_P_r_e_d_, _?_F_i_l_e))
    Is  true  if  the  predicate  specified  by  _P_r_e_d  was  loaded  from
    file   _F_i_l_e,   where   _F_i_l_e   is   an  absolute   path   name   (see
    absolute_file_name/2).  Can be used with  any instantiation pattern,
    but the database  only maintains the source file for each predicate.
    See also clause_property/2.


pprroolloogg__llooaadd__ccoonntteexxtt((_?_K_e_y_, _?_V_a_l_u_e))
    Obtain  context  information during  compilation.    This  predicate
    can  be  used   from  directives  appearing  in  a  source  file  to
    get   information  about  the   file  being  loaded.      See   also
    source_location/2.  The following keys are defined:

      ________________________________________________________________
      |__KKeeyy______________________||DDeessccrriippttiioonn________________________________________________________________________||
      || module        |Module into which file is loaded               |

      | source        |File loaded.  Returns  the original Prolog file|
      |               |when  loading a  .qlf file.    Compatible  with|
      |               |SICStus Prolog.                                |
      | file          |Currently  equivalent to  source.    In  future|
      |               |versions it  may report a different  values for|
      |               |files being loaded using include/1.            |
      | stream        |Stream identifier (see current_input/1)        |
      | directory     |Directory in which source lives.               |

      | dialect       |Compatibility mode.  See expects_dialect/1.    |
      | term_position |Position of last  term read.  Term of  the form|
      |               |'$stream_position'(0,<_L_i_n_e>,0,0,0).    See  also|
      |_______________|stream_position_data/3.________________________|


ssoouurrccee__llooccaattiioonn((_-_F_i_l_e_, _-_L_i_n_e))
    If the last term  has been read from a physical file (i.e., not from
    the file user or  a string), unify _F_i_l_e with an absolute path to the
    file  and _L_i_n_e with the  line-number in the file.   New code  should
    use prolog_load_context/2.


aatt__iinniittiiaalliizzaattiioonn((_+_G_o_a_l))
    Register  _G_o_a_l to  be run when  the system  initialises.   Initiali-
    sation  takes place after reloading  a .qlf (formerly .wic) file  as
    well  as after reloading a  saved-state.  The  hooks are run in  the
    order  they were registered.   A warning  message is issued if  _G_o_a_l
    fails, but execution continues.  See also at_halt/1


aatt__hhaalltt((_+_G_o_a_l))
    Register  _G_o_a_l to  be run  from PL_cleanup(), which  is called  when
    the  system halts.   The  hooks are  run in the  reverse order  they
    were  registered  (FIFO). Success  or failure  executing  a hook  is
    ignored.   If  the hook  raises an exception  this is printed  using
    print_message/2.    An attempt  to call  halt/[0,1] from  a hook  is
    ignored.


iinniittiiaalliizzaattiioonn((_+_G_o_a_l))
    Call  _G_o_a_l and  register it using  at_initialization/1.   Directives
    that  do  other things  than  creating clauses,  records,  flags  or
    setting  predicate attributes should normally be written  using this
    tag  to ensure the  initialisation is executed  when a saved  system
    starts.  See also qsave_program/[1,2].


ccoommppiilliinngg
    True  if the system is compiling source files with the -c  option or
    qcompile/1  into an intermediate code file.  Can be used  to perform
    conditional code  optimisations in term_expansion/2(see  also the -O
    option) or to omit execution of directives during compilation.


44..33..11 CCoonnddiittiioonnaall ccoommppiillaattiioonn aanndd pprrooggrraamm ttrraannssffoorrmmaattiioonn

ISO  Prolog  defines   no  way  for  program  transformations  such   as
macro  expansion  or   conditional  compilation.     Expansion   through
term_expansion/2 and expand_term/2 can be  seen as part of the  de-facto
standard.   This mechanism  can do  arbitrary translation between  valid
Prolog terms  read from the  source file to Prolog  terms handed to  the
compiler.   As  term_expansion/2 can return a  list, the  transformation
does not need to be term-to-term.

Various  Prolog  dialects  provide the  analogous  goal_expansion/2  and
expand_goal/2, that  allow  for translation  of individual  body  terms,
freeing the user of the task to disassemble each clause.


tteerrmm__eexxppaannssiioonn((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    Dynamic  and  multifile  predicate,  normally  not defined.     When
    defined  by the user all terms  read during consulting are given  to
    this predicate.   If the predicate succeeds Prolog will assert _T_e_r_m_2
    in  the database rather then the read term (_T_e_r_m_1).  _T_e_r_m_2  may be a
    term of the form `?-  _G_o_a_l' or `:- _G_o_a_l'.  _G_o_a_l is then treated as a
    directive.   If  _T_e_r_m_2 is a  list all terms of  the list are  stored
    in  the database or  called (for directives).   If  _T_e_r_m_2 is of  the
    form  below, the system will assert _C_l_a_u_s_e and record  the indicated
    source-location with it.

         '$source_location'(<_F_i_l_e>, <_L_i_n_e>):<_C_l_a_u_s_e>

    When compiling a  module (see chapter 5 and the directive module/2),
    expand_term/2  will first try  term_expansion/2 in the module  being
    compiled  to  allow  for  term-expansion rules  that  are  local  to
    a  module.     If  there  is  no  local  definition,  or  the  local
    definition  fails  to translate  the  term,  expand_term/2 will  try
    term_expansion/2  in module user.    For compatibility with  SICStus
    and  Quintus Prolog,  this feature  should not  be used.   See  also
    expand_term/2, goal_expansion/2 and expand_goal/2.


eexxppaanndd__tteerrmm((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    This  predicate  is  normally  called by  the  compiler  to  perform
    preprocessing.   First it calls term_expansion/2.   If this predicate
    fails  it performs  a grammar-rule translation.    If this fails  it
    returns the first argument.


ggooaall__eexxppaannssiioonn((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    Like   term_expansion/2,   goal_expansion/2  provides   for   macro-
    expansion  of Prolog  source-code.   Between  expand_term/2 and  the
    actual  compilation, the body of clauses analysed and the  goals are
    handed  to expand_goal/2, which  uses the goal_expansion/2 hook to do
    user-defined expansion.

    The  predicate goal_expansion/2 is first  called in the module  that
    is  being compiled, and then on the user module.  If _G_o_a_l  is of the
    form  _M_o_d_u_l_e:_G_o_a_l where _M_o_d_u_l_e is instantiated,  goal_expansion/2 is
    called on _G_o_a_l using rules from module _M_o_d_u_l_e followed by user.

    Only  goals  appearing  in  the  body  of  clauses  when  reading  a
    source-file   are  expanded  using  this  mechanism,  and   only  if
    they  appear  literally  in  the  clause,   or  as  an  argument  to
    the  meta-predicates  not/1, call/1,  once/1,  ignore/1,  findall/3,
    bagof/3,  setof/3  or forall/2.    A  real predicate  definition  is
    required to deal with dynamically constructed calls.


eexxppaanndd__ggooaall((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    This  predicate  is  normally  called by  the  compiler  to  perform
    preprocessing.   First it calls goal_expansion/2.  If this  fails it
    returns the first argument.


ccoommppiillee__aauuxx__ccllaauusseess((_+_C_l_a_u_s_e_s))
    Compile  clauses  on behalf  of  goal_expansion/2.    This  predicate
    compiled  the argument clauses  into static predicates,  associating
    the  predicates with the current file but avoid changing  the notion
    of current predicate and therefore discontiguous warnings.


pprreepprroocceessssoorr((_-_O_l_d_, _+_N_e_w))
    Read   the  input  file  via  an  external  process  that   acts  as
    preprocessor.   A preprocessor is specified  as an atom.   The first
    occurrence  of the string `%f' is  replaced by the name of the  file
    to  be loaded.  The standard output of resulting command  is loaded.
    To use the Unix C preprocessor one should define:

    ?- preprocessor(Old, '/lib/cpp -C -P %f'), consult(...).

    Old = none

    Using cpp for  Prolog preprocessing is not ideal as the tokenization
    rules  for comment and quoted  strings differ between C and  Prolog.
    Another  problem is  availability and compatibility  with regard  to
    option processing of cpp.


44..33..11..11 CCoonnddiittiioonnaall ccoommppiillaattiioonn

Conditional   compilation    builds   on    the   same   principle    as
term_expansion/2,   goal_expansion/2  and  the   expansion  of   grammar
rules to compile sections of the source-code conditionally.   One of the
reasons for introducing  conditional compilation is to simplify  writing
portable code.  See  section 13 for more information.  Here is  a simple
example:

:- if(\+source_exports(library(lists), suffix/2)).

suffix(Suffix, List) :-
        append(_, Suffix, List).

:- endif.

Note that  these directives  can only  appear as separate  terms in  the
input.  Typical usage scenarios include:

  o Load different libraries on different dialects

  o Define a predicate if it is missing as a system predicate

  o Realise  totally different implementations for a particular  part of
    the code due to different capabilities.

  o Realise different configuration options for your software.


::-- iiff((_:_G_o_a_l))
    Compile  subsequent  code  only if  _G_o_a_l  succeeds.    For  enhanced
    portability,  _G_o_a_l is  processed by expand_goal/2 before  execution.
    If an error  occurs, the error is printed and processing proceeds as
    if _G_o_a_l has failed.


::-- eelliiff((_:_G_o_a_l))
    Equivalent to :- else.   :-if(Goal) ...  :- endif.  In a sequence as
    below,  the section below the  first matching elif is processed,  If
    no test succeeds the else branch is processed.

    :- if(test1).
    section_1.
    :- elif(test2).
    section_2.
    :- elif(test3).
    section_3.
    :- else.
    section_else.
    :- endif.


::-- eellssee
    Start `else' branch.


::-- eennddiiff
    End of conditional compilation.


44..33..22 LLooaaddiinngg ffiilleess,, aaccttiivvee ccooddee aanndd tthhrreeaaddss

Traditionally,  Prolog environments  allow for  reloading files  holding
currently active code.   In particular, the following sequence  is valid
use of the development environment:

  o Trace a goal

  o Find unexpected behaviour of a predicate

  o Enter a _b_r_e_a_k using the bb command

  o Fix the sources and reload them using make/0

  o Exit the break, _r_e_t_r_y using the rr command

Goals running  during the  reload keep  running on  the old  definition,
while new  goals use  the reloaded definition,  which is  why the  _r_e_t_r_y
must be used _a_f_t_e_r the reload.  This implies  that clauses of predicates
that are  active during  the reload  cannot be  reclaimed.   Normally  a
small amount of dead clauses should not be an  issue during development.
Such clauses can be reclaimed with garbage_collect_clauses/0.


ggaarrbbaaggee__ccoolllleecctt__ccllaauusseess
    Cleanup  all _d_i_r_t_y  predicates, where  dirty predicates are  defined
    to  be predicates  that have  both old  and new  definitions due  to
    reloading  a  source  file while  the  predicate  was active.     Of
    course,  predicates that are  active using garbage_collect_clauses/0
    cannot  be reclaimed and remain _d_i_r_t_y.   Predicate are -like  atoms-
    shared resources and  therefore all threads are suspended during the
    execution of this predicate.


44..33..22..11 TThhrreeaaddss aanndd rreellooaaddiinngg rruunnnniinngg ccooddee

As of version 5.5.30, there is basic thread-safety  for reloading source
files while  other threads are  executing code  defined in these  source
files.   Reloading a file freezes  all threads after marking the  active
predicates originating from  the file being reloaded.   The threads  are
resumed after the file  has been loaded.  In addition,  after completing
loading the outermost file, the system runs garbage_collect_clauses/0.

What does that mean?   Unfortunately it does _n_o_t mean we  can `hot-swap'
modules.   Consider the case where thread  A is executing the recursive
predicate P.   We `fix'  P and reload.   The already  running goals for
P  continue to  run the  old definition,  but new  recursive calls  will
use the  new definition!   Many  similar cases  can be constructed  with
dependent predicates.

It provides  some basic security for  reloading files in  multi-threaded
applications during  development.   In  the above  scenarios the  system
does not crash  uncontrolled, but behaves like  any broken program:   it
may return the wrong bindings, wrong truth value or raise an exception.

Future versions  may have  an `update now'  facility.   Such a  facility
can be implemented  on top of the _l_o_g_i_c_a_l  _u_p_d_a_t_e _v_i_e_w.  It would  allow
threads to do a controlled update between processing independent jobs.


44..33..33 QQuuiicckk llooaadd ffiilleess

SWI-Prolog supports compilation of individual or  multiple Prolog source
files into `Quick Load Files'.  A `Quick Load  Files' (.qlf file) stores
the contents of the file in a precompiled format.

These files load considerably faster than source files  and are normally
more compact.    They are  machine independent  and may  thus be  loaded
on any  implementation of  SWI-Prolog.   Note however  that clauses  are
stored as virtual  machine instructions.   Changes to the compiler  will
generally make old compiled files unusable.

Quick Load Files  are created using qcompile/1.   They are loaded  using
consult/1  or one  of  the other  file-loading predicates  described  in
section 4.3.   If consult is given  the explicit .pl file, it will  load
the Prolog  source.  When  given the .qlf file,  it will load the  file.
When no extension is specified, it will load the  .qlf file when present
and the .pl file otherwise.


qqccoommppiillee((_+_F_i_l_e))
    Takes  a single  file specification  like  consult/1 (i.e.,  accepts
    constructs  like library(LibFile)  and,  in addition  to the  normal
    compilation,   creates  a   _Q_u_i_c_k  _L_o_a_d  _F_i_l_e   from  _F_i_l_e.      The
    file-extension  of this file is  .qlf.  The  base name of the  Quick
    Load File is the same as the input file.

    If   the   file  contains   `:- consult(_+_F_i_l_e)',   `:- [_+_F_i_l_e]'   or
    :- load_files(_+_F_i_l_e, [qcompile(true), ...])   statements,  the   re-
    ferred  files  are  compiled  into  the  same  .qlf  file.     Other
    directives will be stored  in the .qlf file and executed in the same
    fashion as when loading the .pl file.

    For  term_expansion/2,  the same rules  as described in section  2.10
    apply.

    Conditional  execution   or  optimisation  may  test  the  predicate
    compiling/0.

    Source  references (source_file/2) in the  Quick Load File refer  to
    the Prolog source file from which the compiled code originates.


44..44 LLiissttiinngg aanndd EEddiittoorr IInntteerrffaaccee

SWI-Prolog  offers an  extensible  interface which  allows the  user  to
edit objects  of the program:   predicates,  modules, files,  etc.   The
editor interface is  implemented by edit/1 and consists of  three parts:
_l_o_c_a_t_i_n_g, _s_e_l_e_c_t_i_n_g and _s_t_a_r_t_i_n_g _t_h_e _e_d_i_t_o_r.

Any of  these parts may  be extended or redefined  by adding clauses  to
various multi-file  (see multifile/1) predicates  defined in the  module
prolog_edit.

The built-in  edit specifications for  edit/1 (see prolog_edit:locate/3)
are described below.

  ___________________________________________________________________
  |____________________________________________FFuullllyy__ssppeecciiffiieedd__oobbjjeeccttss__________________________________________ ||
  || <Module>:<_N_a_m_e>/<_A_r_i_t_y>R|efers a predicate                       |
  | module(<_M_o_d_u_l_e>)       R|efers to a module                       |
  | file(<_P_a_t_h>)           R|efers to a file                         |

  |_source_file(<_P_a_t_h>)____R|efers_to_a_loaded_source-file___________|
  |____________________________________________AAmmbbiigguuoouuss__ssppeecciiffiiccaattiioonnss________________________________________ ||
  || <Name>/<_A_r_i_t_y>         R|efers this predicate in any module      |
  | <Name>                 |Refers  to  (1)  named  predicate in  any|
  |                        |module  with  any arity,  (2)  a (source)|
  |________________________|file_or_(3)_a_module.____________________|


eeddiitt((_+_S_p_e_c_i_f_i_c_a_t_i_o_n))
    First  exploits prolog_edit:locate/3 to translate  _S_p_e_c_i_f_i_c_a_t_i_o_n into
    a  list  of  _L_o_c_a_t_i_o_n_s.    If there  is  more than  one  `hit',  the
    user  is  asked  to select  from  the  locations found.     Finally,
    prolog_edit:edit_source/1  is used  to  invoke the  user's  preferred
    editor.   Typically, edit/1 can  be handed the name of  a predicate,
    module, basename of a file, XPCE class, XPCE method, etc.


eeddiitt
    Edit the `default' file  using edit/1.  The default file is the file
    loaded  with the  command-line option -s  or, in  windows, the  file
    loaded by double-clicking from the Windows shell.


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_F_u_l_l_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Where  _S_p_e_c is  the  specification provided  through edit/1.    This
    multifile  predicate  is  used to  enumerate  locations at  with  an
    object satisfying the given  _S_p_e_c can be found.  _F_u_l_l_S_p_e_c is unified
    with  the complete specification for  the object.  This  distinction
    is  used to  allow for ambiguous  specifications.   For example,  if
    _S_p_e_c  is  an  atom,  which appears  as  the base-name  of  a  loaded
    file  and as  the name  of a predicate,  _F_u_l_l_S_p_e_c will  be bound  to
    file(_P_a_t_h) or _N_a_m_e/_A_r_i_t_y.

    _L_o_c_a_t_i_o_n  is a list of attributes  of the location.  Normally,  this
    list  will contain  the term file(_F_i_l_e)  and ---if available---  the
    term line(_L_i_n_e).


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Same  as prolog_edit:locate/3, but only  deals with  fully-specified
    objects.


pprroolloogg__eeddiitt::eeddiitt__ssoouurrccee((_+_L_o_c_a_t_i_o_n))
    Start  editor on _L_o_c_a_t_i_o_n.   See prolog_edit:locate/3 for the  format
    of  a location  term.   This  multi-file predicate  is normally  not
    defined.  If it succeeds, edit/1 assumes the editor is started.

    If  it fails, edit/1 uses  its internal defaults, which are  defined
    by  the Prolog flag editor  and/or the environment variable  EDITOR.
    The  following  rules apply.     If the  Prolog  flag editor  is  of
    the  format $<_n_a_m_e>,  the  editor is  determined by  the environment
    variable  <_n_a_m_e>.   Else, if this flag  is pce_emacs or built_in _a_n_d
    XPCE  is  loaded or  can  be loaded,  the  built-in Emacs  clone  is
    used.  Else,  if the environment EDITOR is set, this editor is used.
    Finally,  vi  is used  as default  on Unix  systems  and notepad  on
    Windows.

    See   the  default  user   preferences  file  dotfiles/dotplrc   for
    examples.


pprroolloogg__eeddiitt::eeddiitt__ccoommmmaanndd((_+_E_d_i_t_o_r_, _-_C_o_m_m_a_n_d))
    Determines  how _E_d_i_t_o_r is  to be invoked using  shell/1.  _E_d_i_t_o_r  is
    the  determined editor  (see edit_source/1), without  the full  path
    specification,  and without  possible (exe) extension.   _C_o_m_m_a_n_d  is
    an  atom describing  the command.   The  pattern %f  is replaced  by
    the  full file-name  of the  location, and  %d by  the line  number.
    If  the  editor can  deal with  starting at  a specified  line,  two
    clauses  should be provided,  one holding only  the %f pattern,  and
    one holding both patterns.

    The  default contains  definitions for vi,  emacs, emacsclient,  vim
    and notepad (latter without line-number version).

    Please contribute your specifications to jan@swi.psy.uva.nl.


pprroolloogg__eeddiitt::llooaadd
    Normally  not-defined  multifile  predicate.    This  predicate  may
    be  defined  to provide  loading hooks  for  user-extensions to  the
    edit  module.   For example,  XPCE provides the  code below to  load
    swi_edit,  containing definitions to locate  classes and methods  as
    well as to bind this package to the PceEmacs built-in editor.

    :- multifile prolog_edit:load/0.

    prolog_edit:load :-
            ensure_loaded(library(swi_edit)).


lliissttiinngg((_+_P_r_e_d))
    List  specified predicates  (when an  atom is  given all  predicates
    with  this name will  be listed).   The listing  is produced on  the
    basis of the  internal representation, thus losing user's layout and
    variable name information.  See also portray_clause/1.


lliissttiinngg
    List all predicates of the database using listing/1.


ppoorrttrraayy__ccllaauussee((_+_C_l_a_u_s_e))
    Pretty  print a  clause.   A clause  should be specified  as a  term
    `<_H_e_a_d> :- <_B_o_d_y>'.    Facts are  represented as  `<_H_e_a_d> :- true'  or
    simply  <_H_e_a_d>.  Variables  in the clause are written as  A, B, ....
    Singleton variables are written as _.  See also portray_clause/2.


ppoorrttrraayy__ccllaauussee((_+_S_t_r_e_a_m_, _+_C_l_a_u_s_e))
    Pretty print a clause to _S_t_r_e_a_m.  See portray_clause/1 for details.


44..55 VVeerriiffyy TTyyppee ooff aa TTeerrmm


vvaarr((_+_T_e_r_m))                                                        _[_I_S_O_]
    True if _T_e_r_m currently is a free variable.


nnoonnvvaarr((_+_T_e_r_m))                                                     _[_I_S_O_]
    True if _T_e_r_m currently is not a free variable.


iinntteeggeerr((_+_T_e_r_m))                                                    _[_I_S_O_]
    True if _T_e_r_m is bound to an integer.


ffllooaatt((_+_T_e_r_m))                                                      _[_I_S_O_]
    True if _T_e_r_m is bound to a floating point number.


rraattiioonnaall((_+_T_e_r_m))
    True  if _T_e_r_m  is  bound to  a rational  number.   Rational  numbers
    include integers.


rraattiioonnaall((_+_T_e_r_m_, _-_N_u_m_e_r_a_t_o_r_, _-_D_e_n_o_m_i_n_a_t_o_r))
    True  if  _T_e_r_m  is  a  rational  number  with  given  _N_u_m_e_r_a_t_o_r  and
    _D_e_n_o_m_i_n_a_t_o_r.   The _N_u_m_e_r_a_t_o_r and _D_e_n_o_m_i_n_a_t_o_r are in  canonical form,
    which  means _D_e_n_o_m_i_n_a_t_o_r  is  a positive  integer and  there are  no
    common divisors between _N_u_m_e_r_a_t_o_r and _D_e_n_o_m_i_n_a_t_o_r.


nnuummbbeerr((_+_T_e_r_m))                                                     _[_I_S_O_]
    True if _T_e_r_m is bound to an integer or floating point number.


aattoomm((_+_T_e_r_m))                                                       _[_I_S_O_]
    True if _T_e_r_m is bound to an atom.


ssttrriinngg((_+_T_e_r_m))
    True if _T_e_r_m is  bound to a string.  Note that string here refers to
    the  built-in atomic type string as described in section  4.23, Text
    in double quotes  such as "hello" creates a _l_i_s_t of _c_h_a_r_a_c_t_e_r _c_o_d_e_s.
    We illustrate the issues in the example queries below.

    ?- write("hello").
    [104, 101, 108, 108, 111]
    ?- string("hello").
    No
    ?- is_list("hello").
    Yes


aattoommiicc((_+_T_e_r_m))                                                     _[_I_S_O_]
    True  if  _T_e_r_m is  bound to  an atom,  string,  integer or  floating
    point  number.  Note that string  refers to the built-in type.   See
    string/1.    Strings in  the classical  Prolog sense  are lists  and
    therefore compound.


ccoommppoouunndd((_+_T_e_r_m))                                                   _[_I_S_O_]
    True  if _T_e_r_m is bound to a  compound term.  See also  functor/3 and
    =../2.


ccaallllaabbllee((_+_T_e_r_m))
    True  if _T_e_r_m is bound to an atom  or a compound term, so it  can be
    handed without type-error to call/1, functor/3 and =../2.


ggrroouunndd((_+_T_e_r_m))
    True if _T_e_r_m holds no free variables.


ccyycclliicc__tteerrmm((_+_T_e_r_m))
    True  if _T_e_r_m contains cycles, i.e. is  an infinite term.   See also
    acyclic_term/1 and section 2.16.


aaccyycclliicc__tteerrmm((_+_T_e_r_m))
    True  if  _T_e_r_m  does  not contain  cycles,  i.e.  can  be  processed
    recursively   in  finite   time.      See  also   cyclic_term/1  and
    section 2.16.


44..66 CCoommppaarriissoonn aanndd UUnniiffiiccaattiioonn ooff TTeerrmmss

Although unification is mostly done implicitely while  matching the head
of a predicate, it is also provided by the predicate =/2.


_+_T_e_r_m_1 = _+_T_e_r_m_2                                                   _[_I_S_O_]
    Unify  _T_e_r_m_1 with _T_e_r_m_2.   True  if the unification  succeeds.   For
    behaviour  on cyclic  terms see the  Prolog flag  occurs_check.    It
    acts as if defined by the following rule.

    =(Term, Term).


_+_T_e_r_m_1 \= _+_T_e_r_m_2                                                  _[_I_S_O_]
    Equivalent to \+Term1 = Term2.  See also dif/2.


44..66..11 SSttaannddaarrdd OOrrddeerr ooff TTeerrmmss

Comparison and  unification of arbitrary  terms.   Terms are ordered  in
the so called ``standard order''.  This order is defined as follows:

 1. _V_a_r_i_a_b_l_e_s <_N_u_m_b_e_r_s <_A_t_o_m_s <_S_t_r_i_n_g_s <_C_o_m_p_o_u_n_d _T_e_r_m_s

 2. Variables  are  sorted  by  address.     Attaching  attributes  (see
    section 6.1) does not affect the ordering.

 3. _A_t_o_m_s are compared alphabetically.

 4. _S_t_r_i_n_g_s are compared alphabetically.

 5. _N_u_m_b_e_r_s are compared  by value.  Mixed integer/float are compared as
    floats.   If the  comparison is equal,  the float is considered  the
    smaller  value.   If the  Prolog flag iso  is defined, all  floating
    point numbers precede all integers.

 6. _C_o_m_p_o_u_n_d  terms are  first checked  on  their arity,  then on  their
    functor-name  (alphabetically)  and  finally  recursively  on  their
    arguments, leftmost argument first.


_+_T_e_r_m_1 == _+_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is  equivalent to _T_e_r_m_2.  A variable is only identical
    to a sharing variable.


_+_T_e_r_m_1 \== _+_T_e_r_m_2                                                 _[_I_S_O_]
    Equivalent to \+Term1 == Term2.


_+_T_e_r_m_1 @< _+_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is before _T_e_r_m_2 in the standard order of terms.


_+_T_e_r_m_1 @=< _+_T_e_r_m_2                                                 _[_I_S_O_]
    True if both terms  are equal (==/2) or _T_e_r_m_1 is before _T_e_r_m_2 in the
    standard order of terms.


_+_T_e_r_m_1 @> _+_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is after _T_e_r_m_2 in the standard order of terms.


_+_T_e_r_m_1 @>= _+_T_e_r_m_2                                                 _[_I_S_O_]
    True  if both terms are equal (==/2) or _T_e_r_m_1 is after _T_e_r_m_2  in the
    standard order of terms.


ccoommppaarree((_?_O_r_d_e_r_, _+_T_e_r_m_1_, _+_T_e_r_m_2))
    Determine or test  the _O_r_d_e_r between two terms in the standard order
    of terms.  _O_r_d_e_r is one of <, >  or =, with the obvious meaning.


44..66..22 SSppeecciiaall uunniiffiiccaattiioonn aanndd ccoommppaarriissoonn pprreeddiiccaatteess

This   section   describes  special   purpose   variations   on   Prolog
unification.    The  predicate unify_with_occurs_check/2 provides  sound
unification and is part of the ISO standard.   The predicates subsumes/2
and  subsumes_chk/2 define  `one-sided-unification'  and  are  found  in
many  Prolog systems.    Finally,  unifiable/3  is a  `what-if'  version
of  unification that  is  often qused  a  building block  in  constraint
reasoners.


uunniiffyy__wwiitthh__ooccccuurrss__cchheecckk((_+_T_e_r_m_1_, _+_T_e_r_m_2))                             _[_I_S_O_]
    As  =/2, but  using _s_o_u_n_d_-_u_n_i_f_i_c_a_t_i_o_n.    That is,  a variable  only
    unifies  to  a term  if  this term  does  not contain  the  variable
    itself.  To illustrate this, consider the two goals below:

    1 ?- A = f(A).

    A = f(f(f(f(f(f(f(f(f(f(...))))))))))
    2 ?- unify_with_occurs_check(A, f(A)).

    No

    I.e.   the  first  creates  a  _c_y_c_l_i_c_-_t_e_r_m,  which  is   printed  as
    an  infinitely   nested  f/1  term  (see  the  max_depth  option  of
    write_term/2).  The second executes  logically sound unification and
    thus  fails.  Note that the behaviour of unification through  =/2 as
    well  as implicit unification in the  head can be changed using  the
    Prolog flag occurs_check.


_+_T_e_r_m_1 =@= _+_T_e_r_m_2
    True  if  _T_e_r_m_1  is  `structurally  equal' to  _T_e_r_m_2.     Structural
    equivalence  is weaker  than equivalence (==/2),  but stronger  than
    unification  (=/2).  Two terms are structurally equal if  their tree
    representation  is identical  and they  have the  same `pattern'  of
    variables.  Examples:

               a  =@=  A       false
               A  =@=  B       true
          x(A,A)  =@=  x(B,C)  false
          x(A,A)  =@=  x(B,B)  true
          x(A,B)  =@=  x(C,D)  true

    The  predicates  =@=/2  and  \=@=/2  are  cycle-safe.     Attributed
    variables  are considered  structurally equal  iff their  attributes
    are  structurally  equal.    This predicate  is  known by  the  name
    variant/2 in some other Prolog systems.


_+_T_e_r_m_1 \=@= _+_T_e_r_m_2
    Equivalent to `\+Term1 =@= Term2'.


ssuubbssuummeess((_+_G_e_n_e_r_i_c_, _@_S_p_e_c_i_f_i_c))
    A  term is  told to  _s_u_b_s_u_m_e another  term if  instantiation in  the
    generic  term produces the specific term.  The  subsumption relation
    is  also  called _o_n_e  _s_i_d_e_d  _u_n_i_f_i_c_a_t_i_o_n or  _s_e_m_i_-_u_n_i_f_i_c_a_t_i_o_n.    It
    behaves as if defined by

    subsumes(General, Specific) :-
            term_variables(Specific, SVars),
            General = Specific,
            term_variables(SVars, SVars2),
            SVars == SVars2.


ssuubbssuummeess__cchhkk((_+_G_e_n_e_r_i_c_, _@_S_p_e_c_i_f_i_c))
    Equivalent to \+ \+ subsumes(Generic, Specific).


uunniiffiiaabbllee((_@_X_, _@_Y_, _-_U_n_i_f_i_e_r))
    If  _X and _Y  can unify,  unify _U_n_i_f_i_e_r with  a list of  _V_a_r = _V_a_l_u_e,
    representing  the  bindings required  to make  _X  and _Y  equivalent.
    This  predicate can handle cyclic  terms.  Attributed variables  are
    handles as normal variables.  Associated hooks are _n_o_t executed.


??==((_@_T_e_r_m_1_, _@_T_e_r_m_2))
    Decide  whether the  equality  of _T_e_r_m_1  and _T_e_r_m_2  can be  compared
    safely,  i.e. whether  the result of  Term1 == Term2 can change  due
    to  further instantiation  of  either term.    It is  defined as  by
    ?=(A,B) :- (A==B ; A \= B), !. See also dif/2.


44..77 CCoonnttrrooll PPrreeddiiccaatteess

The predicates of  this section implement control structures.   Normally
the constructs in this  section, except for repeat/0, are  translated by
the compiler.   Please  note that complex goals  passed as arguments  to
meta-predicates such  as findall/3 below cause  the goal to be  compiled
to a  temporary location before  execution.   It is  faster to define  a
sub-predicate (i.e. one_character_atom/1 in the example below)  and make
a call to this simple predicate.

one_character_atoms(As) :-
        findall(A, (current_atom(A), atom_length(A, 1)), As).


ffaaiill                                                              _[_I_S_O_]
    Always  fail.   The  predicate fail/0  is translated  into a  single
    virtual machine instruction.


ffaallssee
    Same as fail, but the name has a more declarative conotation.


ttrruuee                                                              _[_I_S_O_]
    Always  succeed.  The predicate  true/0 is translated into a  single
    virtual machine instruction.


rreeppeeaatt                                                            _[_I_S_O_]
    Always succeed, provide an infinite number of choice points.


!                                                                 _[_I_S_O_]
    Cut.    Discard choice  points of  parent frame  and frames  created
    after the parent frame.   As of SWI-Prolog 3.3, the semantics of the
    cut  are compliant with  the ISO  standard.   This implies that  the
    cut  is transparent to ;/2, ->/2  and *->/2.  Cuts appearing  in the
    _c_o_n_d_i_t_i_o_n  part of ->/2 and  *->/2 as well  as in \+/1 are local  to
    the condition.

             t1 :- (a, !, fail ; b).        % cuts a/0 and t1/0
             t2 :- (a -> b, !  ; c).        % cuts b/0 and t2/0
             t3 :- call((a, !, fail ; b)).  % cuts a/0
             t4 :- \+(a, !, fail ; b).      % cuts a/0


_+_G_o_a_l_1 , _+_G_o_a_l_2                                                   _[_I_S_O_]
    Conjunction.   True if both `Goal1'  and `Goal2' can be proved.   It
    is  defined as  (this  definition does  not lead  to a  loop as  the
    second comma is handled by the compiler):

    Goal1, Goal2 :- Goal1, Goal2.


_+_G_o_a_l_1 ; _+_G_o_a_l_2                                                   _[_I_S_O_]
    The `or' predicate is defined as:

    Goal1 ; _Goal2 :- Goal1.
    _Goal1 ; Goal2 :- Goal2.


_+_G_o_a_l_1 | _+_G_o_a_l_2
    Equivalent  to ;/2.    Retained for compatibility  only.   New  code
    should use ;/2.


_+_C_o_n_d_i_t_i_o_n -> _+_A_c_t_i_o_n                                             _[_I_S_O_]
    If-then  and  If-Then-Else.    The  ->/2  construct commits  to  the
    choices  made  at  its  left-hand  side,   destroying  choice-points
    created  inside the  clause (by  ;/2), or  by goals  called by  this
    clause.   Unlike !/0, the  choice-point of the predicate as  a whole
    (due  to multiple clauses)  is nnoott destroyed.   The combination  ;/2
    and ->/2  acts as if defines by:

    If -> Then; _Else :- If, !, Then.
    If -> _Then; Else :- !, Else.
    If -> Then :- If, !, Then.

    Please  note that (If -> Then) acts  as (If -> Then ; ffaaiill),  making
    the  construct _f_a_i_l if the condition fails.  This  unusual semantics
    is part of the ISO and all de-facto Prolog standards.


_+_C_o_n_d_i_t_i_o_n *-> _+_A_c_t_i_o_n _; _+_E_l_s_e
    This  construct implements  the so-called `soft-cut'.   The  control
    is  defined as follows:   If _C_o_n_d_i_t_i_o_n succeeds  at least once,  the
    semantics  is the same  as (_C_o_n_d_i_t_i_o_n, _A_c_t_i_o_n).   If _C_o_n_d_i_t_i_o_n  does
    not  succeed, the  semantics is that  of (\+ _C_o_n_d_i_t_i_o_n,  _E_l_s_e).   In
    other  words, If _C_o_n_d_i_t_i_o_n succeeds at least once, simply  behave as
    the conjunction of _C_o_n_d_i_t_i_o_n and _A_c_t_i_o_n, otherwise execute _E_l_s_e.

    The  construct _A *-> _B, i.e.  without an _E_l_s_e branch, is  translated
    as the normal conjunction _A, _B.


\+ _+_G_o_a_l                                                          _[_I_S_O_]
    True  if `Goal' cannot  be proven (mnemonic:   + refers to  _p_r_o_v_a_b_l_e
    and  the backslash  (\)  is normally  used to  indicate negation  in
    Prolog).


44..88 MMeettaa--CCaallll PPrreeddiiccaatteess

Meta-call predicates  are used to  call terms  constructed at run  time.
The basic meta-call mechanism offered by SWI-Prolog is  to use variables
as a  subclause (which  should of  course be bound  to a  valid goal  at
runtime).   A  meta-call is  slower than a  normal call  as it  involves
actually searching the database at runtime for the  predicate, while for
normal calls this search is done at compile time.


ccaallll((_+_G_o_a_l))                                                       _[_I_S_O_]
    Invoke  _G_o_a_l as a  goal.   Note that clauses  may have variables  as
    subclauses, which is identical to call/1.


ccaallll((_+_G_o_a_l_, _+_E_x_t_r_a_A_r_g_1_, _._._.))
    Append  _E_x_t_r_a_A_r_g_1_, _E_x_t_r_a_A_r_g_2_,  _._._.   to  the argument  list of  _G_o_a_l
    and  call the result.   For  example, call(plus(1), 2, X) will  call
    plus/3, binding _X to 3.

    The call/[2..]   construct is handled by the compiler, which implies
    that  redefinition as  a predicate has  no effect.   The  predicates
    call/[2-6]  are defined as true  predicates, so they can be  handled
    by interpreted code.


aappppllyy((_+_T_e_r_m_, _+_L_i_s_t))
    Append  the members of  _L_i_s_t to the arguments  of _T_e_r_m and call  the
    resulting  term.   For  example:   apply(plus(1), [2, X]) will  call
    plus(1, 2, X).   apply/2 is  incorporated in the virtual machine  of
    SWI-Prolog.   This implies that the overhead can be compared  to the
    overhead  of call/1.  New code should use call/[2..]   if the length
    of _L_i_s_t is  fixed, which is more widely supported and faster because
    there is no need to build and examine the argument list.


nnoott((_+_G_o_a_l))
    True  if _G_o_a_l cannot  be proven.   Retained for compatibility  only.
    New code should use \+/1.


oonnccee((_+_G_o_a_l))                                                       _[_I_S_O_]
    Defined as:

    once(Goal) :-
            Goal, !.

    once/1  can  in  many  cases  be replaced  with  ->/2.     The  only
    difference  is how the  cut behaves  (see !/0).   The following  two
    clauses are identical:

    1) a :- once((b, c)), d.
    2) a :- b, c -> d.


iiggnnoorree((_+_G_o_a_l))
    Calls  _G_o_a_l  as once/1,  but succeeds,  regardless  of whether  _G_o_a_l
    succeeded or not.  Defined as:

    ignore(Goal) :-
            Goal, !.
    ignore(_).


ccaallll__wwiitthh__ddeepptthh__lliimmiitt((_+_G_o_a_l_, _+_L_i_m_i_t_, _-_R_e_s_u_l_t))
    If  _G_o_a_l can be proven  without recursion deeper than _L_i_m_i_t  levels,
    call_with_depth_limit/3 succeeds,  binding  _R_e_s_u_l_t  to  the  deepest
    recursion  level  used  during the  proof.    Otherwise,  _R_e_s_u_l_t  is
    unified  with depth_limit_exceeded  if the limit was exceeded  during
    the  proof,  or the  entire predicate  fails if  _G_o_a_l fails  without
    exceeding _L_i_m_i_t.

    The  depth-limit is  guarded by the  internal machinery.   This  may
    differ  from the depth computed based  on a theoretical model.   For
    example,  true/0  is  translated  into an  inlined  virtual  machine
    instruction.   Also, repeat/0 is not implemented as below, but  as a
    non-deterministic foreign predicate.

    repeat.
    repeat :-
            repeat.

    As  a result,  call_with_depth_limit/3may  still loop infinitely  on
    programs  that should  theoretically finish  in finite time.    This
    problem  can be cured by  using Prolog equivalents to such  built-in
    predicates.

    This   predicate  may  be   used  for  theorem-provers  to   realise
    techniques  like  _i_t_e_r_a_t_i_v_e _d_e_e_p_e_n_i_n_g.    It  was implemented  after
    discussion with Steve Moyle smoyle@ermine.ox.ac.uk.


ccaallll__cclleeaannuupp((_:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_C_l_e_a_n_u_p))
    Calls  _G_o_a_l.   If _G_o_a_l is completely  finished, either by  determin-
    istic  success, failure,  its choice-point being  cut or raising  an
    exception  and _C_a_t_c_h_e_r unifies to the termination code  (see below),
    _C_l_e_a_n_u_p  is called.   Success or failure  of _C_l_e_a_n_u_p is ignored  and
    possible  choice-points it created  are destroyed (as  once/1).   If
    cleanup throws an exception this is executed as normal.

    _C_a_t_c_h_e_r  is  unified  with  a  term  describing  how  the  call  has
    finished.  If this unification fails, _C_l_e_a_n_u_p is _n_o_t called.

    eexxiitt
         _G_o_a_l succeeded without leaving any choice-points.

    ffaaiill
         _G_o_a_l failed.

    !
         _G_o_a_l succeeded with  choice-points and these are now  discarded
         by the execution of a cut (or other pruning of  the search tree
         such as if-then-else).

    eexxcceeppttiioonn((_E_x_c_e_p_t_i_o_n))
         _G_o_a_l raised the given _E_x_c_e_p_t_i_o_n.

    Typical  use of this predicate is cleanup of permanent  data storage
    required to execute  _G_o_a_l, close file-descriptors, etc.  The example
    below  provides a  non-deterministic search  for a term  in a  file,
    closing the stream as needed.

    term_in_file(Term, File) :-
            open(File, read, In),
            call_cleanup(term_in_stream(Term, In), _, close(In)).

    term_in_stream(Term, In) :-
            repeat,
            read(In, T),
            (   T == end_of_file
            ->  !, fail
            ;   T = Term
            ).

    Note  that  this  predicate is  impossible  to implement  in  Prolog
    other  then reading all terms into  a list, close the file  and call
    member/2  because without  call_cleanup/3 there  is no  way to  gain
    control if the choice-point left by repeat is killed by a cut.

    The  call_cleanup/2can  also be used to test determinism of  a goal,
    providing a portable alternative to deterministic/1:

    ?- call_cleanup((X=1;X=2), Det=yes).

    X = 1 ;

    X = 2,
    Det = yes ;

    This  predicate is a SWI-Prolog extension.   See also call_cleanup/2
    for compatibility with other Prolog implementations.


ccaallll__cclleeaannuupp((_:_G_o_a_l_, _:_C_l_e_a_n_u_p))
    This  predicate  is  equivalent to  call_cleanup(_G_o_a_l_,  ___,  _C_l_e_a_n_u_p),
    calling   _C_l_e_a_n_u_p   regardless  of   the  reason   for   termination
    and  without  providing   information.     This  predicate  provides
    compatibility with a number of other Prolog implementations.


sseettuupp__aanndd__ccaallll__cclleeaannuupp((_:_S_e_t_u_p_, _:_G_o_a_l_, _:_C_l_e_a_n_u_p))
    This  predicate is introduced to allow for the proper  definition of
    predicates  with  temporary side-effects  under asynchronous  inter-
    rupts from  call_with_time_limit/2(package clib) or thread_signal/2.
    It  behaves as  if defined below,  but the  _C_l_e_a_n_u_p handler is  also
    called if  the interrupt occurs between _S_e_t_u_p and the call_cleanup/2
    call.

    setup_and_call_cleanup(Setup, Goal, Cleanup) :-
            Setup,
            call_cleanup(Goal, Cleanup).


44..99 IISSOO ccoommpplliiaanntt EExxcceeppttiioonn hhaannddlliinngg

SWI-Prolog defines the predicates catch/3 and throw/1  for ISO compliant
raising  and catching  of exceptions.    In  the current  implementation
(4.0.6), most of  the built-in predicates generate exceptions,  but some
obscure predicates merely print a message, start the  debugger and fail,
which was the normal behaviour before the introduction of exceptions.


ccaattcchh((_:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_R_e_c_o_v_e_r))                                  _[_I_S_O_]
    Behaves  as call/1 if  no exception is  raised when executing  _G_o_a_l.
    If  a exception  is raised  using throw/1 while  _G_o_a_l executes,  and
    the  _G_o_a_l is the innermost goal  for which _C_a_t_c_h_e_r unifies with  the
    argument  of throw/1, all choice-points  generated by _G_o_a_l are  cut,
    the  system backtracks to the start of catch/3 while  preserving the
    thrown exception term and _R_e_c_o_v_e_r is called as in call/1.

    The  overhead of calling a  goal through catch/3 is very  comparable
    to  call/1.  Recovery from  an exception is much slower,  especially
    if the exception-term is large due to the copying thereof.


tthhrrooww((_+_E_x_c_e_p_t_i_o_n))                                                 _[_I_S_O_]
    Raise  an exception.   The  system looks  for the innermost  catch/3
    ancestor  for which _E_x_c_e_p_t_i_o_n unifies  with the _C_a_t_c_h_e_r argument  of
    the catch/3 call.  See catch/3 for details.

    ISO  demands throw/1 to make a copy of _E_x_c_e_p_t_i_o_n, walk up  the stack
    to a catch/3 call,  backtrack and try to unify the copy of _E_x_c_e_p_t_i_o_n
    with  _C_a_t_c_h_e_r.   SWI-Prolog delays  making a  copy of _E_x_c_e_p_t_i_o_n  and
    backtracking  until it actually found a matching catch/3 goal.   The
    advantage  is that we can start  the debugger at the first  possible
    location  while preserving the entire exception context if  there is
    no  matching catch/3  goal.   This  approach can  lead to  different
    behaviour  if _G_o_a_l and _C_a_t_c_h_e_r of catch/3 call share variables.   We
    assume this to be  highly unlikely and could not think of a scenario
    where this is useful.

    If  an exception is raised in a callback from C (see chapter  9) and
    not  caught in the  same call-back, PL_next_solution() fails and  the
    exception context can be retrieved using PL_exception().


44..99..11 DDeebbuuggggiinngg aanndd eexxcceeppttiioonnss

Before  the introduction  of exceptions  in SWI-Prolog  a runtime  error
was handled  by printing  an error  message, after  which the  predicate
failed.  If the  Prolog flag debug_on_errorwas in effect  (default), the
tracer was switched on.  The combination of the  error message and trace
information is generally sufficient to locate the error.

With exception handling,  things are different.   A programmer may  wish
to trap an  exception using catch/3 to avoid  it reaching the user.   If
the exception  is not  handled by user-code,  the interactive  top-level
will trap it to prevent termination.

If  we  do  not  take  special  precautions,   the  context  information
associated with an  unexpected exception (i.e., a programming  error) is
lost.  Therefore,  if an exception is raised, which is not  caught using
catch/3 and  the top-level is  running, the error  will be printed,  and
the system will enter trace mode.

If the system  is in an non-interactive  callback from foreign code  and
there is no catch/3  active in the current context, it  cannot determine
whether or  not the  exception will  be caught by  the external  routine
calling Prolog.   It  will then  base its behaviour  on the Prolog  flag
debug_on_error:

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _f_a_l_s_e_)
    The  exception does  not trap the  debugger and  is returned to  the
    foreign  routine  calling Prolog,  where it  can  be accessed  using
    PL_exception().  This is the default.

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _t_r_u_e_)
    If the exception is  not caught by Prolog in the current context, it
    will trap the tracer to help analysing the context of the error.

While looking for the  context in which an exception takes place,  it is
advised to switch on  debug mode using the predicate debug/0.   The hook
prolog_exception_hook/4 can be used to add more debugging  facilities to
exceptions.   An  example is the  library http/http_error, generating  a
full stack trace on errors in the HTTP server library.


44..99..22 TThhee eexxcceeppttiioonn tteerrmm

Built-in  predicates generates  exceptions  using a  term  error(_F_o_r_m_a_l_,
_C_o_n_t_e_x_t).    The  first argument  is  the  `formal' description  of  the
error,  specifying the class  and generic  defined context  information.
When applicable,  the ISO  error-term definition  is used.   The  second
part  describes some  additional context  to help  the programmer  while
debugging.    In its  most  generic form  this  is a  term of  the  form
context(_N_a_m_e_/_A_r_i_t_y_,  _M_e_s_s_a_g_e), where _N_a_m_e/_A_r_i_t_y  describes the  built-in
predicate  that raised  the error,  and _M_e_s_s_a_g_e  provides an  additional
description of the error.  Any part of this structure  may be a variable
if no information was present.


44..99..33 PPrriinnttiinngg mmeessssaaggeess

The predicate print_message/2 may be  used to print a message term  in a
human readable  format.   The other predicates  from this section  allow
the user  to refine  and extend  the message system.    The most  common
usage of  print_message/2 is to  print error  messages from  exceptions.
The code below  prints errors encountered during the execution  of _G_o_a_l,
without  further propagating  the  exception  and without  starting  the
debugger.

        ...,
        catch(Goal, E,
              ( print_message(error, E),
                fail
              )),
        ...

Another common  use is to  defined message_hook/3 for printing  messages
that are normally _s_i_l_e_n_t, suppressing messages,  redirecting messages or
make something happen in addition to printing the message.


pprriinntt__mmeessssaaggee((_+_K_i_n_d_, _+_T_e_r_m))
    The  predicate print_message/2 is  used to  print messages,  notably
    from  exceptions  in  a human-readable  format.    _K_i_n_d  is  one  of
    informational,   banner,  warning,  error,   help  or  silent.     A
    human-readable message is printed to the stream user_error.

    If   the  Prolog  flag  verbose   is  silent,  messages  with   _K_i_n_d
    informational, or banner are treated as silent.  See -q.

    This  predicate first translates  the _T_e_r_m into  a list of  `message
    lines'  (see print_message_lines/3for  details).  Next it  will call
    the hook  message_hook/3to allow the  user intercepting the message.
    If  message_hook/3 fails it  will print the  message unless _K_i_n_d  is
    silent.

    The  print_message/2  predicate  and  its  rules  are  in  the  file
    <_p_l_h_o_m_e>/boot/messages.pl,   which  may   be   inspected  for   more
    information  on the error messages and related error terms.   If you
    need  to report errors  from your own predicates,  we advise you  to
    stick  to the existing error terms  if you can; but should  you need
    to  invent new ones, you can define corresponding error  messages by
    asserting clauses for  prolog:message.  You will need to declare the
    predicate as multifile.

    See also message_to_string/2.


pprriinntt__mmeessssaaggee__lliinneess((_+_S_t_r_e_a_m_, _+_P_r_e_f_i_x_, _+_L_i_n_e_s))
    Print a  message (see print_message/2) that has  been translated to a
    list of message elements.  The elements of this list are:

    <_F_o_r_m_a_t>--<_A_r_g_s>
         Where _F_o_r_m_a_t is an atom and _A_r_g_s is a list  of format argument.
         Handed to format/3.

    flush
         If this  appears as the  last element,  _S_t_r_e_a_m is flushed  (see
         flush_output/1) and no final newline is generated.

    at_same_line
         If this  appears as  first element,  no prefix  is printed  for
         the first line  and the line-position is  not forced to 0  (see
         format/1, ~N).

    <_F_o_r_m_a_t>
         Handed to format/3 as format(Stream, Format, []).

    nnll
         A new line  is started and if  the message is not complete  the
         _P_r_e_f_i_x is printed too.

    See also print_message/2 and message_hook/3.


mmeessssaaggee__hhooookk((_+_T_e_r_m_, _+_K_i_n_d_, _+_L_i_n_e_s))
    Hook  predicate that may be defined in the module user  to intercept
    messages  from  print_message/2.    _T_e_r_m  and _K_i_n_d  are the  same  as
    passed to  print_message/2.  _L_i_n_e_s is a  list of format statements as
    described with print_message_lines/3.  See also message_to_string/2.

    This  predicate should  be defined  dynamic and  multifile to  allow
    other modules defining clauses for it too.


mmeessssaaggee__ttoo__ssttrriinngg((_+_T_e_r_m_, _-_S_t_r_i_n_g))
    Translates  a message-term into a string object (see  section 4.23).
    Primarily  intended  to  write  messages to  Windows  in  XPCE  (see
    section 1.5) or other GUI environments.


44..1100 HHaannddlliinngg ssiiggnnaallss

As  of  version  3.1.0,   SWI-Prolog  is  capable  to   handle  software
interrupts  (signals) in  Prolog as  well as  in foreign  (C) code  (see
section 9.6.12).

Signals are used to handle internal errors (execution  of a non-existing
CPU  instruction,  arithmetic  domain  errors,  illegal  memory  access,
resource  overflow,   etc.),  as   well  as  for  dealing   asynchronous
inter-process communication.

Signals  are  defined  by  the POSIX  standard  and  part  of  all  Unix
machines.    The  MS-Windows  Win32  provides  a subset  of  the  signal
handling  routines,   lacking  the   vital  functionality  to  raise   a
signal in  another thread for  achieving asynchronous inter-process  (or
inter-thread) communication (Unix kill() function).


oonn__ssiiggnnaall((_+_S_i_g_n_a_l_, _-_O_l_d_, _:_N_e_w))
    Determines  the reaction on  _S_i_g_n_a_l.   _O_l_d is  unified with the  old
    behaviour, while the behaviour  is switched to _N_e_w.  As with similar
    environment-control  predicates,  the  current  value  is  retrieved
    using on_signal(Signal, Current, Current).

    The  action  description  is  an  atom  denoting  the  name  of  the
    predicate  that  will be  called  if _S_i_g_n_a_l  arrives.    on_signal/3
    is  a meta-predicate, which  implies that <_M_o_d_u_l_e>:<_N_a_m_e>  refers the
    <_N_a_m_e>/1  in  the module  <_M_o_d_u_l_e>.   The  handler is  called with  a
    single  argument:  the name  of the signal as  an atom.  The  Prolog
    names for signals is explained below.

    Two  predicate-names have  special meaning.    throw implies  Prolog
    will  map  the  signal  onto  a Prolog  exception  as  described  in
    section  4.9.   default resets  the handler  to the settings  active
    before SWI-Prolog manipulated the handler.

    Signals   bound  to  a  foreign  function  through  PL_signal()  are
    reported using the term $foreign_function(_A_d_d_r_e_s_s).

    After  receiving a signal mapped to throw, the exception  raised has
    the structure

         error(signal(<_S_i_g_N_a_m_e>, <_S_i_g_N_u_m>), <_C_o_n_t_e_x_t>)

    One possible usage of  this is, for example, to limit the time spent
    on  proving a goal.  This  requires a little C-code for  setting the
    alarm timer (see chapter 9):

    #include <SWI-Prolog.h>
    #include <unistd.h>

    foreign_t
    pl_alarm(term_t time)
    { double t;

      if ( PL_get_float(time, &t) )
      { alarm((long)(t+0.5));

        PL_succeed;
      }

      PL_fail;
    }

    install_t
    install()
    { PL_register_foreign("alarm", 1, pl_alarm, 0);
    }

    Next,  we can  define the  Prolog below.   This will  run _G_o_a_l  just
    as  once/1, throwing  the exception  error(_s_i_g_n_a_l_(_a_l_r_m_,  ___)_, __) if  a
    timeout occurs.

    :- load_foreign_library(alarm).

    :- on_signal(alrm, _, throw).

    :- module_transparent
            call_with_time_limit/2.

    call_with_time_limit(MaxTime, Goal) :-
            alarm(MaxTime),
            call_cleanup(Goal, _, alarm(0)), !.

    The  signal  names are  defined  by the  POSIX standard  as  symbols
    of  the form  SIG<_S_I_G_N_A_M_E>.   The  Prolog name for  a signal  is the
    lowercase  version of <_S_I_G_N_A_M_E>.  The predicate current_signal/3 may
    be used to map between names and signals.

    Initially,  some  signals  are  mapped to  throw,  while  all  other
    signals  are default.    The following signals  throw an  exception:
    ill, fpe, segv, pipe, alrm, bus, xcpu, xfsz and vtalrm.


ccuurrrreenntt__ssiiggnnaall((_?_N_a_m_e_, _?_I_d_, _?_H_a_n_d_l_e_r))
    Enumerate  the  currently defined  signal  handling.   _N_a_m_e  is  the
    signal  name,  _I_d is  the numerical  identifier and  _H_a_n_d_l_e_r is  the
    currently defined handler (see on_signal/3).


44..1100..11 NNootteess oonn ssiiggnnaall hhaannddlliinngg

Before  deciding  to deal  with  signals  in  your  application,  please
consider the following:

  o _P_o_r_t_a_b_i_l_i_t_y
    On MS-Windows, the  signal interface is severely limited.  Different
    Unix  brands support  different sets  of signals,  and the  relation
    between signal name and number may vary.

  o _S_a_f_e_t_y
    Signal   handling   is   not   completely  safe   in   the   current
    implementation,  especially  if throw  is used  in combination  with
    external  foreign  code.    The  system  will use  the  C  longjmp()
    construct  to  direct control  to  the innermost  PL_next_solution(),
    thus  forcing an external procedure to be abandoned at  an arbitrary
    moment.  Most  likely not all SWI-Prolog's own foreign code is (yet)
    safe  too.   For  the multi-threaded  versions this  is even  worse:
    signals can easily violate thread synchronisation consistency.

    The  C-interface described  in  section 9.6.12  provides the  option
    PL_SIGSYNC for registering a signal handler  that delays delivery of
    signals  to a safe point.   Unfortunately this may cause signals  to
    be delayed for a long time if Prolog is executing foreign code.

  o _G_a_r_b_a_g_e _C_o_l_l_e_c_t_i_o_n
    The  garbage  collector  will block  all  signals that  are  handled
    by  Prolog.    While handling  a  signal, the  garbage-collector  is
    disabled.

  o _T_i_m_e _o_f _d_e_l_i_v_e_r_y
    Normally  delivery  is immediate  (or as  defined  by the  operating
    system  used).   Signals are blocked  when the garbage collector  is
    active,  and internally  delayed if  they occur  within a  `critical
    section'.  The critical sections are generally very short.


44..1111 TThhee ``bblloocckk'' ccoonnttrrooll--ssttrruuccttuurree

The  block/3 predicate  and  friends  have been  introduced  before  ISO
compatible  catch/3  exception  handling  for  compatibility  with  some
Prolog implementation.    The only  feature not covered  by catch/3  and
throw/1 is the possibility to execute global cuts.   New code should use
catch/3 and throw/1 to deal with exceptions.


bblloocckk((_+_L_a_b_e_l_, _+_G_o_a_l_, _-_E_x_i_t_V_a_l_u_e))
    Execute _G_o_a_l in a _b_l_o_c_k.   _L_a_b_e_l is the name of the block.  _L_a_b_e_l is
    normally  an atom, but  the system imposes  no type constraints  and
    may  even be  a  variable.   _E_x_i_t_V_a_l_u_e  is normally  unified to  the
    second argument of an exit/2 call invoked by _G_o_a_l.


eexxiitt((_+_L_a_b_e_l_, _+_V_a_l_u_e))
    Calling  exit/2 makes the innermost _b_l_o_c_k which _L_a_b_e_l  unifies exit.
    The  block's _E_x_i_t_V_a_l_u_e is unified with  _V_a_l_u_e.  If this  unification
    fails the block fails.


ffaaiill((_+_L_a_b_e_l))
    Calling  fail/1 makes the innermost  _b_l_o_c_k which _L_a_b_e_l unifies  fail
    immediately.  Implemented as

    fail(Label) :- !(Label), fail.


!((_+_L_a_b_e_l))
    Cut  all  choice-points created  since the  entry  of the  innermost
    _b_l_o_c_k which _L_a_b_e_l unifies.


44..1122 DDCCGG GGrraammmmaarr rruulleess

Grammar rules  form a comfortable interface  to _d_i_f_f_e_r_e_n_c_e_-_l_i_s_t_s.   They
are designed  both to support  writing parsers  that build a  parse-tree
from a list as for  generating a flat list from a term.   Unfortunately,
Definite  Clause  Grammar (DCG)  handling  is  not part  of  the  Prolog
standard.   Most Prolog  engines implement DCG,  but the details  differ
slightly.

Grammar rules  look like  ordinary clauses  using -->/2  for  separating
the head  and body rather than  :-/2.   Expanding grammar rules is  done
by expand_term/2, which  adds two additional  argument to each term  for
representing the difference list.   We will illustrate the  behaviour by
defining a rule-set for parsing an integer.

integer(I) -->
        digit(D0),
        digits(D),
        { number_chars(I, [D0|D])
        }.

digits([D|T]) -->
        digit(D), !,
        digits(T).
digits([]) -->
        [].

digit(D) -->
        [D],
        { code_type(D, digit)
        }.

The  body of  a grammar  rule  can contain  three  types of  terms.    A
compound  term interpreted  as a  reference  to a  grammar-rule.    Code
between {...}  is interpreted  as a  reference to  ordinary Prolog  code
and finally,  a list  is interpreted  as a  sequence of literals.    The
Prolog control-constructs (\+/1,  ->/2, ;//2, ,/2  and !/0) can be  used
in grammar rules.

Grammar rule-sets are called using the built-in  predicates phrase/2 and
phrase/3:


pphhrraassee((_+_R_u_l_e_S_e_t_, _+_I_n_p_u_t_L_i_s_t))
    Equivalent to phrase(_R_u_l_e_S_e_t, _I_n_p_u_t_L_i_s_t, []).


pphhrraassee((_+_R_u_l_e_S_e_t_, _+_I_n_p_u_t_L_i_s_t_, _-_R_e_s_t))
    Activate  the rule-set with given name.  `InputList' is the  list of
    tokens to parse,  `Rest' is unified with the remaining tokens if the
    sentence is parsed  correctly.  The example below calls the rule-set
    `integer' defined above.

    ?- phrase(integer(X), "42 times", Rest).

    X = 42
    Rest = [32, 116, 105, 109, 101, 115]


44..1133 DDaattaabbaassee

SWI-Prolog offers  three different database mechanisms.   The first  one
is  the common  assert/retract  mechanism  for manipulating  the  clause
database.    As facts  and clauses  asserted using  assert/1  or one  of
its  derivatives become  part of  the program  these predicates  compile
the term  given to them.    retract/1 and retractall/1  have to unify  a
term and  therefore have to  decompile the program.   For these  reasons
the assert/retract  mechanism is  expensive.   On the  other hand,  once
compiled, queries to the database are faster than  querying the recorded
database discussed below.  See also dynamic/1.

The second way of  storing arbitrary terms in the database is  using the
``recorded database''.   In  this database terms  are associated with  a
_k_e_y.   A key can be an  atom, small integer or term.   In the last  case
only the functor and arity  determine the key.  Each key has a  chain of
terms associated with it.  New terms can be added  either at the head or
at the tail of this chain.

The third mechanism is a special purpose one.   It associates an integer
or atom with  a key, which is  an atom, integer or  term.  Each key  can
only have one atom or integer associated with it.


aabboolliisshh((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                                      _[_I_S_O_]
    Removes  all clauses of a  predicate with functor _F_u_n_c_t_o_r and  arity
    _A_r_i_t_y  from  the  database.    All  predicate  attributes  (dynamic,
    multifile,  index, etc.)  are  reset to their defaults.   Abolishing
    an  imported predicate only removes  the import link; the  predicate
    will keep its old definition in its definition module.

    According  to the  ISO standard,  abolish/1 can only  be applied  to
    dynamic  procedures.    This is  odd, as  for  dealing with  dynamic
    procedures  there  is  already  retract/1 and  retractall/1.     The
    abolish/1  predicate has been introduced in DEC-10  Prolog precisely
    for dealing with  static procedures.  In SWI-Prolog, abolish/1 works
    on static procedures, unless the prolog flag iso is set to true.

    It  is advised  to use  retractall/1 for  erasing all  clauses of  a
    dynamic predicate.


aabboolliisshh((_+_N_a_m_e_, _+_A_r_i_t_y))
    Same  as abolish(_N_a_m_e_/_A_r_i_t_y).   The predicate abolish/2 conforms  to
    the Edinburgh standard, while abolish/1 is ISO compliant.


rreeddeeffiinnee__ssyysstteemm__pprreeddiiccaattee((_+_H_e_a_d))
    This  directive  may be  used  both in  module  user and  in  normal
    modules to redefine  any system predicate.  If the system definition
    is  redefined in  module user,  the  new definition  is the  default
    definition  for  all sub-modules.    Otherwise  the redefinition  is
    local  to the module.   The system definition remains in the  module
    system.

    Redefining   system   predicate   facilitates  the   definition   of
    compatibility packages.  Use in other context is discouraged.


rreettrraacctt((_+_T_e_r_m))                                                    _[_I_S_O_]
    When  _T_e_r_m  is an  atom  or a  term  it is  unified with  the  first
    unifying  fact or clause  in the database.   The  fact or clause  is
    removed from the database.


rreettrraaccttaallll((_+_H_e_a_d))
    All  facts or  clauses in the  database for  which the _h_e_a_d  unifies
    with _H_e_a_d are removed.


aasssseerrtt((_+_T_e_r_m))
    Assert  a fact or clause in the  database.  _T_e_r_m is asserted  as the
    last fact or clause of the corresponding predicate.


aasssseerrttaa((_+_T_e_r_m))                                                    _[_I_S_O_]
    Equivalent  to assert/1,  but _T_e_r_m  is asserted as  first clause  or
    fact of the predicate.


aasssseerrttzz((_+_T_e_r_m))                                                    _[_I_S_O_]
    Equivalent to assert/1.


aasssseerrtt((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent  to  assert/1, but  _R_e_f_e_r_e_n_c_e is  unified  with a  unique
    reference  to the asserted clause.  This key can later be  used with
    clause/3 or erase/1.


aasssseerrttaa((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent  to assert/2,  but _T_e_r_m  is asserted as  first clause  or
    fact of the predicate.


aasssseerrttzz((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to assert/2.


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Assert  _T_e_r_m in  the recorded  database under  key _K_e_y.    _K_e_y is  a
    small  integer (range min_tagged_integer ...max_tagged_integer,  atom
    or compound term.   If the key is a compound term, only the name and
    arity define the key.   _R_e_f_e_r_e_n_c_e is unified with a unique reference
    to the record (see erase/1).


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recorda(_K_e_y, _V_a_l_u_e,  _).


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to recorda/3, but  puts the _T_e_r_m at the tail of the terms
    recorded under _K_e_y.


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recordz(_K_e_y, _V_a_l_u_e,  _).


rreeccoorrddeedd((_+_K_e_y_, _-_V_a_l_u_e_, _-_R_e_f_e_r_e_n_c_e))
    Unify  _V_a_l_u_e  with the  first  term recorded  under _K_e_y  which  does
    unify.    _R_e_f_e_r_e_n_c_e  is  unified with  the  memory location  of  the
    record.


rreeccoorrddeedd((_+_K_e_y_, _-_V_a_l_u_e))
    Equivalent to recorded(_K_e_y, _V_a_l_u_e,  _).


eerraassee((_+_R_e_f_e_r_e_n_c_e))
    Erase  a  record or  clause from  the  database.   _R_e_f_e_r_e_n_c_e  is  an
    integer  returned by  recorda/3 or  recorded/3, clause/3,  assert/2,
    asserta/2  or assertz/2.    Other integers might  conflict with  the
    internal  consistency of the system.  Erase can only be  called once
    on  a record or clause.  A second call also might  conflict with the
    internal consistency of the system.


ffllaagg((_+_K_e_y_, _-_O_l_d_, _+_N_e_w))
    _K_e_y is an atom,  integer or term.  As with the recorded database, if
    _K_e_y is a term,  only the name and arity are used to locate the flag.
    Unify  _O_l_d with the old  value associated with _K_e_y.   If the key  is
    used  for the first time  _O_l_d is unified with  the integer 0.   Then
    store  the value  of _N_e_w, which  should be an  integer, float,  atom
    or  arithmetic expression, under  _K_e_y.   flag/3 is a fast  mechanism
    for  storing simple facts  in the  database.   The flag database  is
    shared  between threads and updates  are atomic, making it  suitable
    for generating unique integer counters.


44..1133..11 UUppddaattee vviieeww

Traditionally,  Prolog systems  used  the _i_m_m_e_d_i_a_t_e  _u_p_d_a_t_e _v_i_e_w:    new
clauses  became   visible  to   predicates  backtracking  over   dynamic
predicates   immediately   and  retracted   clauses   became   invisible
immediately.

Starting  with SWI-Prolog  3.3.0  we  adhere the  _l_o_g_i_c_a_l  _u_p_d_a_t_e  _v_i_e_w,
where backtrackable predicates that enter the definition  of a predicate
will not  see any changes  (either caused by  assert/1 or retract/1)  to
the  predicate.    This view  is the  ISO  standard, the  most  commonly
used and  the most  `safe'.   Logical  updates are  realised by  keeping
reference-counts on  predicates and  _g_e_n_e_r_a_t_i_o_n information on  clauses.
Each change  to the database  causes an increment  of the generation  of
the database.  Each  goal is tagged with the generation in which  it was
started.  Each  clause is flagged with the generation it was  created as
well as  the generation  it was  erased.   Only  clauses with  `created'
...`erased' interval  that encloses the generation  of the current  goal
are considered visible.


44..1133..22 IInnddeexxiinngg ddaattaabbaasseess

By  default,   SWI-Prolog,  as   most  other  implementations,   indexes
predicates  on their  first argument.    SWI-Prolog  allows indexing  on
other and multiple  arguments using the declaration index/1.   Dedicated
index schemas can be build using term_hash/2 or term_hash/4.


tteerrmm__hhaasshh((_+_T_e_r_m_, _-_H_a_s_h_K_e_y))                                         _[_d_e_t_]
    If  _T_e_r_m is a  ground term (see ground/1),  _H_a_s_h_K_e_y is unified  with
    a  positive integer  value that  may be used  as a  hash-key to  the
    value.    If _T_e_r_m  is not ground,  the predicate  leaves _H_a_s_h_K_e_y  an
    unbound  variable.   Hash  keys are  in the  range 0:::16;777; 215, the
    maximal  integer that can  be stored efficiently  on both 32 and  64
    bit platforms.

    This  predicate  may be  used to  build hash-tables  as  well as  to
    exploit argument-indexing to find complex terms more quickly.

    The  hash-key does not rely on temporary information  like addresses
    of atoms and  may be assumed constant over different invocations and
    versions  of SWI-Prolog.   The term_hash/2 predicate is  cycle-safe.
    Hashes for numbers differ between big and little endian machines.


tteerrmm__hhaasshh((_+_T_e_r_m_, _+_D_e_p_t_h_, _+_R_a_n_g_e_, _-_H_a_s_h_K_e_y))                         _[_d_e_t_]
    As  term_hash/2, but  only considers  _T_e_r_m to  the specified  _D_e_p_t_h.
    The  toplevel term  has depth 1,  its arguments have  depth 2,  etc.
    I.e.    _D_e_p_t_h = 0 hashes  nothing;  _D_e_p_t_h =1  hashes  atomic values
    or  the functor  and arity of  a compound term,  not its  arguments;
    _D_e_p_t_h = 2  also  indexes  the  immediate arguments,   etc.    Using
    _D_e_p_t_h = -1 makes term_hash/4 behave as  term_hash/2,  hashing ground
    terms to the full depth.

    _H_a_s_h_K_e_y  is in the range  [0:::_R_a_n_g_e-1].   _R_a_n_g_e must be  in the range
    [1:::2147483647]


44..1144 DDeeccllaarriinngg pprreeddiiccaatteess pprrooppeerrttiieess

This  section  describes  directives  which  manipulate   attributes  of
predicate  definitions.     The  functors  dynamic/1,   multifile/1  and
discontiguous/1  are  operators  of  priority  1150  (see  op/3),  which
implies  the  list of  predicates  they  involve  can just  be  a  comma
separated list:

:- dynamic
        foo/0,
        baz/2.

On SWI-Prolog all  these directives are just  predicates.  This  implies
they can also  be called by a program.   Do not rely on this  feature if
you want to maintain portability to other Prolog implementations.


ddyynnaammiicc _+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.
    Informs  the interpreter  that  the definition  of the  predicate(s)
    may  change during execution (using assert/1 and/or retract/1).   In
    the  multi-threaded version, the  clauses of dynamic predicates  are
    shared  between the threads.  The  directive thread_local/1 provides
    an  alternative where each threads  has its own clause-list for  the
    predicate.   Dynamic predicates can be turned into static ones using
    compile_predicates/1.


ccoommppiillee__pprreeddiiccaatteess((_:_L_i_s_t_O_f_N_a_m_e_A_r_i_t_y))
    Compile  a list of specified  dynamic predicates (see dynamic/1  and
    assert/1)  into  normal static  predicates.    This call  tells  the
    Prolog  environment  the  definition  will not  change  anymore  and
    further  calls  to assert/1  or retract/1  on  the named  predicates
    raise  a permission error.  This predicate is designed to  deal with
    parts  of the  program that  is generated  at runtime  but does  not
    change during the remainder of the program execution.


mmuullttiiffiillee _+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.
    Informs  the system that the  specified predicate(s) may be  defined
    over  more than one  file.  This  stops consult/1 from redefining  a
    predicate when a new definition is found.


ddiissccoonnttiigguuoouuss _+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.
    Informs  the system that the  clauses of the specified  predicate(s)
    might not be together in the source file.  See also style_check/1.


iinnddeexx((_+_H_e_a_d))
    Index  the clauses  of the predicate  with the  same name and  arity
    as  _H_e_a_d  on the  specified arguments.    _H_e_a_d is  a  term of  which
    all  arguments  are  either  `1' (denoting  `index  this  argument')
    or  `0'  (denoting `do  not index  this argument').    Indexing  has
    no  implications  for the  semantics of  a  predicate, only  on  its
    performance.    If  indexing is  enabled on  a  predicate a  special
    purpose  algorithm  is used  to select  candidate  clauses based  on
    the  actual arguments of  the goal.   This algorithm checks  whether
    indexed  arguments might  unify in  the clause  head.   Only  atoms,
    integers  and compound  terms are  considered.   Compound terms  are
    indexed  on the combination  of their name and  arity.  Indexing  is
    very useful for predicates with many clauses representing facts.

    Due to the  representation technique used at most 4 arguments can be
    indexed.  All  indexed arguments should be in the first 32 arguments
    of  the predicate.    If  more than  4 arguments  are specified  for
    indexing only the first  4 will be accepted.  Arguments above 32 are
    ignored for indexing.

    Indexing   as  specified  by  this   predicate  uses  a  quick   but
    linear  scan.     Without explicit  specification  the  system  uses
    an  algorithm  depending  on the  structure  of the  first  argument
    and  number  of clauses,  In  particular,  for predicates  that  can
    be  indexed  on  the  first argument  and  have  many  clauses,  the
    system  will use  an  automatically resizing  hash-table to  provide
    access  time  independent from  the  number of  clauses.    If---for
    example---one  wants  to  represents  sub-types using  a  fact  list
    `sub_type(Sub, Super)' that  should be used  both to determine  sub-
    and super types one should declare sub_type/2 as follows:

    :- index(sub_type(1, 1)).

    sub_type(horse, animal).
    ...
    ...

    Note that this  type of indexing makes selecting clauses much faster
    but  remains _l_i_n_e_a_r  with respect  to the number  of clauses,  while
    hashing  as described  with  hash/1 provides  constant access  time.
    See also hash/1 and term_hash/2.


hhaasshh((_+_H_e_a_d))
    Index  the given predicate by hashing  on the first argument.   This
    is done by default  on any predicate with more than 5 clauses having
    a  first argument  that  can be  indexed and  at most  two that  can
    not  be indexed.   On dynamic  predicates the hash-table is  resized
    as  the number  of clauses  grows,  providing roughly  constant-time
    access  regardless of the number  of clauses predicates that can  be
    indexed  on the first argument.   See also index/1,  term_hash/2 and
    predicate_property/2.


44..1155 EExxaammiinniinngg tthhee pprrooggrraamm


ccuurrrreenntt__aattoomm((_-_A_t_o_m))
    Successively unifies _A_t_o_m with  all atoms known to the system.  Note
    that  current_atom/1 always succeeds if  _A_t_o_m is instantiated to  an
    atom.


ccuurrrreenntt__bblloobb((_?_B_l_o_b_, _?_T_y_p_e))
    Examine the type or  enumerate blobs of the given _T_y_p_e.  Typed blobs
    are  supported through  the foreign language  interface for  storing
    arbitrary  BLOBS  (Binary  Large  Object)  or  handles  to  external
    entities.  See section 9.6.6 for details.


ccuurrrreenntt__ffuunnccttoorr((_?_N_a_m_e_, _?_A_r_i_t_y))
    Successively unifies _N_a_m_e  with the name and _A_r_i_t_y with the arity of
    functors known to the system.


ccuurrrreenntt__ffllaagg((_-_F_l_a_g_K_e_y))
    Successively  unifies  _F_l_a_g_K_e_y with  all keys  used  for flags  (see
    flag/3).


ccuurrrreenntt__kkeeyy((_-_K_e_y))
    Successively  unifies  _K_e_y  with  all keys  used  for  records  (see
    recorda/3, etc.).


ccuurrrreenntt__pprreeddiiccaattee((_?_N_a_m_e_, _?_H_e_a_d))
    Successively  unifies _N_a_m_e  with  the name  of predicates  currently
    defined and _H_e_a_d with  the most general term built from _N_a_m_e and the
    arity of the  predicate.  This predicate succeeds for all predicates
    defined  in the specified module, imported  to it, or in one  of the
    modules from which the predicate will be imported if it is called.


ccuurrrreenntt__pprreeddiiccaattee((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                             _[_I_S_O_]
    ISO   compliant  implementation   of  current_predicate/2.       Un-
    like    current_predicate/2,    the   current   implementation    of
    current_predicate/1  does  not  consider  predicates   that  can  be
    autoloaded `current'.


pprreeddiiccaattee__pprrooppeerrttyy((_:_H_e_a_d_, _?_P_r_o_p_e_r_t_y))
    True  if _H_e_a_d  refers  to a  predicate that  has property  _P_r_o_p_e_r_t_y.
    Can  be used  to test whether  a predicate  has a certain  property,
    obtain  all properties known  for _H_e_a_d,  find all predicates  having
    _p_r_o_p_e_r_t_y  or  even obtaining  all  information available  about  the
    current program.  _P_r_o_p_e_r_t_y is one of:

    bbuuiilltt__iinn
         Is true  if the predicate  is locked  as a built-in  predicate.
         This implies it  cannot be redefined  in its definition  module
         and it can normally not be seen in the tracer.

    ddyynnaammiicc
         Is true  if assert/1 and  retract/1 may be  used to modify  the
         predicate.  This property is set using dynamic/1.

    eexxppoorrtteedd
         Is true if the predicate  is in the public list of  the context
         module.

    iimmppoorrtteedd__ffrroomm((_M_o_d_u_l_e))
         Is true if  the predicate is  imported into the context  module
         from module _M_o_d_u_l_e.

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify _F_i_l_e_N_a_m_e with  the name of the  source file in which  the
         predicate is defined.  See also source_file/2.

    ffoorreeiiggnn
         Is true if the predicate is defined in the C language.

    iinnddeexxeedd((_H_e_a_d))
         Predicate is indexed (see index/1) according to _H_e_a_d.   _H_e_a_d is
         a term  whose name and  arity are  identical to the  predicate.
         The arguments are unified  with `1' for indexed arguments,  `0'
         otherwise.

    iinntteerrpprreetteedd
         Is true if the predicate is defined in Prolog.   We return true
         on this because, although the code is actually  compiled, it is
         completely transparent, just like interpreted code.

    iissoo
         Is  true if  the  predicate  is  covered by  the  ISO  standard
         (ISO/IEC 1321l-l).

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify _L_i_n_e_N_u_m_b_e_r with  the line number  of the first clause  of
         the predicate.   Fails if the predicate is not  associated with
         a file.  See also source_file/2.

    mmuullttiiffiillee
         Is true there  may be multiple  (or no) file providing  clauses
         for the predicate.  This property is set using multifile/1.

    nnooddeebbuugg
         Details of the predicate are  not shown by the debugger.   This
         is the default  for built-in predicates.   User predicates  can
         be compiled this way using the Prolog flag generate_debug_info.

    nnoottrraaccee
         Do not show ports of this predicate in the debugger.

    nnuummbbeerr__ooff__ccllaauusseess((_C_l_a_u_s_e_C_o_u_n_t))
         Unify _C_l_a_u_s_e_C_o_u_n_t to the number of clauses  associated with the
         predicate.  Fails for foreign predicates.

    tthhrreeaadd__llooccaall
         If true  (only  possible on  the multi-threaded  version)  each
         thread has its  own clauses for the  predicate.  This  property
         is set using thread_local/1.

    ttrraannssppaarreenntt
         Is true  if the  predicate  is declared  transparent using  the
         module_transparent/1 declaration.

    uunnddeeffiinneedd
         Is  true if  a procedure  definition  block for  the  predicate
         exists, but there are no clauses for it and it  is not declared
         dynamic or multifile.  This is true if the  predicate occurs in
         the body of a loaded predicate, an attempt to call  it has been
         made via one of  the meta-call predicates or the  predicate had
         a definition in  the past.   See the library package check  for
         example usage.

    vvoollaattiillee
         If  true, the  clauses  are not  saved  into a  saved-state  by
         qsave_program/[1,2].  This property is set using volatile/1.


ddwwiimm__pprreeddiiccaattee((_+_T_e_r_m_, _-_D_w_i_m))
    `Do  What I  Mean'  (`dwim') support  predicate.   _T_e_r_m  is a  term,
    which  name and arity are used  as a predicate specification.   _D_w_i_m
    is  instantiated with the most general term built from _N_a_m_e  and the
    arity  of a defined predicate  that matches the predicate  specified
    by  _T_e_r_m in the `Do  What I Mean' sense.   See dwim_match/2 for  `Do
    What  I Mean' string matching.   Internal system predicates are  not
    generated,  unless  style_check(+dollar) is  active.    Backtracking
    provides all alternative matches.


ccllaauussee((_:_H_e_a_d_, _?_B_o_d_y))                                              _[_I_S_O_]
    True  if  _H_e_a_d can  be unified  with  a clause  head and  _B_o_d_y  with
    the  corresponding  clause  body.    Gives  alternative  clauses  on
    backtracking.  For facts _B_o_d_y is unified with the atom _t_r_u_e.


ccllaauussee((_:_H_e_a_d_, _?_B_o_d_y_, _?_R_e_f_e_r_e_n_c_e))
    Equivalent  to  clause/2,   but  unifies  _R_e_f_e_r_e_n_c_e  with  a  unique
    reference to the  clause (see also assert/2, erase/1).  If _R_e_f_e_r_e_n_c_e
    is  instantiated to a reference the  clause's head and body will  be
    unified with _H_e_a_d and _B_o_d_y.


nntthh__ccllaauussee((_?_P_r_e_d_, _?_I_n_d_e_x_, _?_R_e_f_e_r_e_n_c_e))
    Provides  access to  the clauses  of a predicate  using their  index
    number.    Counting  starts at  1.   If  _R_e_f_e_r_e_n_c_e  is specified  it
    unifies  _P_r_e_d with the  most general term  with the same  name/arity
    as  the predicate  and _I_n_d_e_x  with the index-number  of the  clause.
    Otherwise  the name  and arity  of _P_r_e_d  are used  to determine  the
    predicate.    If _I_n_d_e_x is  provided _R_e_f_e_r_e_n_c_e  will be unified  with
    the  clause  reference.   If  _I_n_d_e_x  is unbound,  backtracking  will
    yield  both the  indices and the  references of  all clauses of  the
    predicate.  The following example finds the 2nd clause of member/2:

    ?- nth_clause(member(_,_), 2, Ref), clause(Head, Body, Ref).

    Ref = 160088
    Head = system : member(G575, [G578|G579])
    Body = member(G575, G579)


ccllaauussee__pprrooppeerrttyy((_+_C_l_a_u_s_e_R_e_f_, _-_P_r_o_p_e_r_t_y))
    Queries  properties  of   a  clause.     _C_l_a_u_s_e_R_e_f  is  a  reference
    to   a   clause   as   produced   by   clause/3,   nth_clause/3   or
    prolog_frame_attribute/3.  _P_r_o_p_e_r_t_y is one of the following:

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify _F_i_l_e_N_a_m_e with  the name of the  source file in which  the
         clause is defined.  Fails if the clause is not  associated to a
         file.

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify _L_i_n_e_N_u_m_b_e_r with the line number of the clause.   Fails if
         the clause is not associated to a file.

    ffaacctt
         True if the clause has no body.

    eerraasseedd
         True if  the  clause has  been erased,  but  not yet  reclaimed
         because it is referenced.


44..1166 IInnppuutt aanndd oouuttppuutt

SWI-Prolog provides two  different packages for input  and output.   The
native  I/O system  is  based on  the  ISO standard  predicates  open/3,
close/1 and  friends.   Being more widely portable  and equipped with  a
clearer and  more robust specification,  new code  is encouraged to  use
these predicates for manipulation of I/O streams.

Section 4.16.2  describes tell/1,  see/1 and friends,  providing I/O  in
the spirit  of the outdated  Edinburgh standard.   These predicates  are
layered  on  top of  the  ISO  predicates.    Both  packages  are  fully
integrated; the user may switch freely between them.


44..1166..11 IISSOO IInnppuutt aanndd OOuuttppuutt SSttrreeaammss

The  predicates described  in this  section provide  ISO compliant  I/O,
where streams are  explicitly created using the  predicate open/3.   The
resulting  stream  identifier is  then  passed  as a  parameter  to  the
reading and writing  predicates to specify the source or  destination of
the data.

This schema  is not  vulnerable to  filename and  stream ambiguities  as
well as changes  to the working directory.   New code is advised to  use
these predicates to manage input and output streams.


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _-_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))                          _[_I_S_O_]
    ISO  compliant predicate  to open  a stream.   _S_r_c_D_e_s  is either  an
    atom,  specifying a file, or a term `pipe(_C_o_m_m_a_n_d)', like  see/1 and
    tell/1.    _M_o_d_e is  one of  read,  write, append  or update.    Mode
    append  opens the file for writing, positioning the  file-pointer at
    the  end.  Mode update  opens the file for writing,  positioning the
    file-pointer  at the  beginning of the  file without truncating  the
    file.  _S_t_r_e_a_m is  either a variable, in which case it is bound to an
    integer identifying the stream,  or an atom, in which case this atom
    will  be the stream  identifier.  The  _O_p_t_i_o_n_s list can contain  the
    following options:

    ttyyppee((_T_y_p_e))
         Using type text (default), Prolog will write a  text-file in an
         operating-system compatible way.   Using type binary the  bytes
         will be read or written without any translation.   See also the
         option encoding.

    aalliiaass((_A_t_o_m))
         Gives the  stream a name.   Below  is an example.   Be  careful
         with  this  option  as stream-names  are  global.     See  also
         set_stream/2.

         ?- open(data, read, Fd, [alias(input)]).

                 ...,
                 read(input, Term),
                 ...

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Define the encoding used  for reading and writing text  to this
         stream.   The default  encoding for type  text is derived  from
         the Prolog  flag  encoding.   For  binary  streams the  default
         encoding  is octet.     For details  on  encoding  issues,  see
         section 2.17.1.

    bboomm((_B_o_o_l))
         Check for a BOM (_B_y_t_e _O_r_d_e_r _M_a_r_k_e_r) or write one.   If omitted,
         the default  is true for  mode read and  false for mode  write.
         See also stream_property/2 and especially section  2.17.1.1 for
         a discussion on this feature.

    eeooff__aaccttiioonn((_A_c_t_i_o_n))
         Defines  what  happens  if the  end  of  the  input  stream  is
         reached.   Action eof_code makes get0/1  and friends return  -1
         and read/1 and friends return the atom end_of_file.  Repetitive
         reading keeps yielding the  same result.  Action error  is like
         eof_code, but repetitive  reading will  raise an error.    With
         action reset,  Prolog will  examine the file  again and  return
         more data if the file has grown.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         Defines output  buffering.    The atom  full (default)  defines
         full buffering, line buffering  by line, and false implies  the
         stream is  fully unbuffered.   Smaller  buffering is useful  if
         another process or the user is waiting for the output  as it is
         being produced.   See also flush_output/[0,1].  This option  is
         not an ISO option.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         If  true (default),  the  stream is  closed  on an  abort  (see
         abort/0).   If  false, the  stream is  not closed.    If it  is
         an output  stream,  it will  be flushed  however.   Useful  for
         logfiles and if  the stream is  associated to a process  (using
         the pipe/1 construct).

    lloocckk((_L_o_c_k_i_n_g_M_o_d_e))
         Try to obtain a lock on the open file.  Default  is none, which
         does not lock the file.   The value read or shared  means other
         processes may  read the  file, but  not write  it.   The  value
         write or  exclusive means no  other process  may read or  write
         the file.

         Locks are  acquired through  the POSIX  function fcntl()  using
         the command F_SETLKW, which makes  a blocked call wait for  the
         lock to  be  released.    Please note  that fcntl()  locks  are
         _a_d_v_i_s_o_r_y and therefore  only other applications using the  same
         advisory locks  honour your  lock.   As there  are many  issues
         around locking  in  Unix, especially  related  to NFS  (network
         file  system), please  study  the  fcntl() manual  page  before
         trusting your locks!

         The lock option is a SWI-Prolog extension.

    The  option reposition is not supported in SWI-Prolog.   All streams
    connected to a file may be repositioned.


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _?_S_t_r_e_a_m))                                    _[_I_S_O_]
    Equivalent to open/4 with an empty option-list.


ooppeenn__nnuullll__ssttrreeaamm((_?_S_t_r_e_a_m))
    Open  an  output stream  that  produces no  output.    All  counting
    functions  are enabled on such a stream.  It can be  used to discard
    output  (like Unix  /dev/null) or exploit  the counting  properties.
    The  initial encoding of _S_t_r_e_a_m is utf8, enabling  arbitrary Unicode
    output.   The  encoding can be  changed to determine byte-counts  of
    the  output in a particular encoding or validate output  is possible
    in  a particular encoding.   For example, the code below  determines
    the number of characters emitted when writing _T_e_r_m.

    write_length(Term, Len) :-
            open_null_stream(Out),
            write(Out, Term),
            character_count(Out, Len0),
            close(Out),
            Len = Len0.


cclloossee((_+_S_t_r_e_a_m))                                                    _[_I_S_O_]
    Close the specified stream.   If _S_t_r_e_a_m is not open an error message
    is  displayed.    Please  be aware  that anonymous  streams  handles
    (streams  that have  no alias and  are represented as  $stream(_I_n_t))
    are _i_n_v_a_l_i_d after  closing.  Although the system uses some heuristic
    to  raise  an  existence error  in  these cases,  closing  a  stream
    multiple  times can  crash Prolog.   This  is particularly true  for
    multi-threaded  applications.  If  the closed stream is the  current
    input  or output stream  the terminal is  made the current input  or
    output.


cclloossee((_+_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))                                          _[_I_S_O_]
    Provides  close(_S_t_r_e_a_m_, _[_f_o_r_c_e_(_t_r_u_e_)_]) as the  only option.   Called
    this  way, any resource error  (such as write-errors while  flushing
    the output buffer) are ignored.


ssttrreeaamm__pprrooppeerrttyy((_?_S_t_r_e_a_m_, _?_S_t_r_e_a_m_P_r_o_p_e_r_t_y))                          _[_I_S_O_]
    ISO  compatible predicate for querying  status of open I/O  streams.
    _S_t_r_e_a_m_P_r_o_p_e_r_t_y is one of:

    aalliiaass((_A_t_o_m))
         If _A_t_o_m is bound,  test of the stream has the  specified alias.
         Otherwise unify _A_t_o_m with the first alias of the stream.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         SWI-Prolog  extension  to query  the  buffering  mode  of  this
         stream.   _B_u_f_f_e_r_i_n_g is one of  full, line or  false.  See  also
         open/4.

    bbuuffffeerr__ssiizzee((_I_n_t_e_g_e_r))
         SWI-Prolog  extension to  query  the  size of  the  I/O  buffer
         associated to a  stream in bytes.   Fails of the stream is  not
         buffered.

    bboomm((_B_o_o_l))
         If present  and  true, a  BOM (_B_y_t_e  _O_r_d_e_r  _M_a_r_k) was  detected
         while opening the file  for reading or a BOM was  written while
         opening the stream.  See section 2.17.1.1 for details.

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Query the encoding  used for text.   See section 2.17.1 for  an
         overview of wide character and encoding issues in SWI-Prolog.

    eenndd__ooff__ssttrreeaamm((_E))
         If _S_t_r_e_a_m is  an input stream,  unify _E with  one of the  atoms
         not, at or past.  See also at_end_of_stream/[0,1].

    eeooff__aaccttiioonn((_A))
         Unify _A with one of  eof_code,  reset or error.  See  open/4 for
         details.

    ffiillee__nnaammee((_A_t_o_m))
         If _S_t_r_e_a_m is  associated to a file,  unify _A_t_o_m to the name  of
         this file.

    ffiillee__nnoo((_I_n_t_e_g_e_r))
         If  the stream  is  associated  with a  POSIX  file-descriptor,
         unify  _I_n_t_e_g_e_r  with   the  descriptor  number.      SWI-Prolog
         extension used  primarily  for integration  with foreign  code.
         See also Sfileno() from SWI-Stream.h.

    iinnppuutt
         True if _S_t_r_e_a_m has mode read.

    mmooddee((_I_O_M_o_d_e))
         Unify  _I_O_M_o_d_e to  the  mode given  to  open/4 for  opening  the
         stream.   Values are:  read,  write, append and the  SWI-Prolog
         extension update.

    nneewwlliinnee((_N_e_w_l_i_n_e_M_o_d_e))
         One of posix or dos.   If dos, text-streams will emit  \r\n for
         \n and discard \r from  input streams.  Default depends  on the
         operating system.

    oouuttppuutt
         True if _S_t_r_e_a_m has mode write, append or update.

    ppoossiittiioonn((_T_e_r_m))
         Unify  _T_e_r_m  with the  current  stream-position.     A  stream-
         position is an opaque term whose fields can  be extracted using
         stream_position_data/3.  See also set_stream_position/2.

    rreeppoossiittiioonn((_B_o_o_l))
         Unify _B_o_o_l  with _t_r_u_e  if  the position  of the  stream can  be
         set (see seek/4).   It  is assumed the  position can be set  if
         the stream  has a  _s_e_e_k_-_f_u_n_c_t_i_o_n and is  not based  on a  POSIX
         file-descriptor that is not associated to a regular file.

    rreepprreesseennttaattiioonn__eerrrroorrss((_M_o_d_e))
         Determines behaviour of  character output if the stream  cannot
         represent a  character.   For  example, an  ISO Latin-1  stream
         cannot represent cyrillic characters.  The behaviour  is one of
         error (throw  and  I/O error  exception),  prolog (write  \...\
         escape code or  xml (write &#...; XML  character entity).   The
         initial mode is prolog  for the user streams and error  for all
         other streams.  See also section 2.17.1 and set_stream/2.

    ttiimmeeoouutt((_-_T_i_m_e))
         _T_i_m_e is the timeout currently associated with the stream.   See
         set_stream/2 with the same option.  If no timeout is specified,
         _T_i_m_e is unified to the atom infinite.

    ttyyppee((_T))
         Unify _B_o_o_l with text or binary.

    ttttyy((_B_o_o_l))
         This property is reported  with _B_o_o_l equals true if  the stream
         is associated with a terminal.  See also set_stream/2.


ccuurrrreenntt__ssttrreeaamm((_?_O_b_j_e_c_t_, _?_M_o_d_e_, _?_S_t_r_e_a_m))
    The  predicate current_stream/3 is  used to access  the status of  a
    stream as well as  to generate all open streams.  _O_b_j_e_c_t is the name
    of the file opened  if the stream refers to an open file, an integer
    file-descriptor  if  the  stream  encapsulates  an  operating-system
    stream  or the atom  [] if the stream  refers to some other  object.
    _M_o_d_e is one of read or write.


iiss__ssttrreeaamm((_+_T_e_r_m))
    True  if  _T_e_r_m is  a  stream name  or  valid stream  handle.    This
    predicate  realises a safe test for the existence of a  stream alias
    or handle.


sseett__ssttrreeaamm__ppoossiittiioonn((_+_S_t_r_e_a_m_, _+_P_o_s))                                 _[_I_S_O_]
    Set  the current  position  of _S_t_r_e_a_m  to _P_o_s.    _P_o_s is  a term  as
    returned  by  stream_property/2 using  the  position(_P_o_s)  property.
    See also seek/4.


ssttrreeaamm__ppoossiittiioonn__ddaattaa((_?_F_i_e_l_d_, _+_P_o_s_i_t_i_o_n_, _-_D_a_t_a))
    Extracts  information  from  the  opaque  stream  position  term  as
    returned  by  stream_property/2  requesting  the  position(_P_o_s_i_t_i_o_n)
    property.    _F_i_e_l_d is  one of line_count,  line_position,  char_count
    or   byte_count.       See   also   line_count/2,   line_position/2,
    character_count/2 and byte_count/2.


sseeeekk((_+_S_t_r_e_a_m_, _+_O_f_f_s_e_t_, _+_M_e_t_h_o_d_, _-_N_e_w_L_o_c_a_t_i_o_n))
    Reposition the current point  of the given _S_t_r_e_a_m.  _M_e_t_h_o_d is one of
    bof,  current or eof, indicating positioning relative to  the start,
    current  point or  end of  the underlying  object.   _N_e_w_L_o_c_a_t_i_o_n  is
    unified with the new offset, relative to the start of the stream.

    Positions  are  counted in  `units'.    A  unit is  1  byte,  except
    for  text-files using  2-byte Unicode  encoding (2  bytes) or  _w_c_h_a_r
    encoding  (sizeof(wchar_t)).    The  latter  guarantees  comfortable
    interaction  with  wide-character  text-objects.     Otherwise,  the
    use  of  seek/4  on non-binary  files  (see  open/4) is  of  limited
    use,   especially   when  using   multi-byte  text-encodings   (e.g.
    UTF-8)  or  multi-byte   newline  files  (e.g.  DOS/Windows).     On
    text-files,  SWI-Prolog offers  reliable backup  to an old  position
    using  stream_property/2  and set_stream_position/2.    Skipping  N
    character  codes is  achieved calling  get_code/2 N times  or using
    copy_stream_data/3,  directing  the output  to  a  null-stream  (see
    open_null_stream/1).   If  the seek modifies  the current  location,
    the line number and character position in the line are set to 0.

    If the  stream cannot be repositioned, a permission_error is raised.
    If  applying the offset  would result in  a file-position less  then
    zero,   a  domain_error  is  raised.     Behaviour  when  seeking  to
    positions  beyond the size  of the underlying  object depend on  the
    object  and possibly  the operating  system.   The predicate  seek/4
    is  compatible  with Quintus  Prolog,  though the  error  conditions
    and  signalling is ISO  compliant.   See also  stream_property/2 and
    set_stream_position/2.


sseett__ssttrreeaamm((_+_S_t_r_e_a_m_, _+_A_t_t_r_i_b_u_t_e))
    Modify an attribute  of an existing stream.  _A_t_t_r_i_b_u_t_e specifies the
    stream property to set.  See also stream_property/2 and open/4.

    aalliiaass((_A_l_i_a_s_N_a_m_e))
         Set the alias  of an already created  stream.  If _A_l_i_a_s_N_a_m_e  is
         the name of  one of the standard  streams is used, this  stream
         is rebound.  Thus,  set_stream(S, current_input)is the  same as
         set_input/1 and by setting the alias of a stream to user_input,
         etc. all  user terminal input is  read from this  stream.   See
         also interactor/0.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         Set the buffering mode  of an already created stream.   Buffer-
         ing is one of full, line or false.

    bbuuffffeerr__ssiizzee((_+_S_i_z_e))
         Set the  size of  the I/O buffer  of the  underlying stream  to
         _S_i_z_e bytes.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         Determine whether or not the  stream is closed by abort/0.   By
         default streams are closed.

    eennccooddiinngg((_A_t_o_m))
         Defines the mapping between bytes and character  codes used for
         the stream.  See section 2.17.1 for supported encodings.

    eeooff__aaccttiioonn((_A_c_t_i_o_n))
         Set end-of-file handling to one of eof_code, reset or error.

    nneewwlliinnee((_N_e_w_l_i_n_e_M_o_d_e))
         Set input or output translation for newlines.   See correspond-
         ing stream_property/2 for details.  In addition to the detected
         modes, an input stream can  be set in mode detect.  It  will be
         set to dos if a \r character was removed.

    ttiimmeeoouutt((_S_e_c_o_n_d_s))
         This option can be  used to make streams generate  an exception
         if it  takes longer than  _S_e_c_o_n_d_s before  any new data  arrives
         at  the  stream.    The  value  _i_n_f_i_n_i_t_e  (default)  makes  the
         stream block  indefinitely.   Like wait_for_input/3, this  call
         only  applies  to streams  that  support  the  select()  system
         call.   For  further information  about  timeout handling,  see
         wait_for_input/3.  The exception is of the form

             error(timeout_error_(_r_e_a_d_, _S_t_r_e_a_m_)_, __)

    rreeccoorrdd__ppoossiittiioonn((_B_o_o_l))
         Do/do  not  record   the  line-count  and  line-position   (see
         line_count/2 and line_position/2).

    rreepprreesseennttaattiioonn__eerrrroorrss((_M_o_d_e))
         Change the  behaviour  when writing  characters to  the  stream
         that  cannot  be  represented  by  the  encoding.     See  also
         stream_property/2 and section 2.17.1.

    ffiillee__nnaammee((_F_i_l_e_N_a_m_e))
         Set the file name associated to this stream.  This  call can be
         used to set the file for error-locations  if _S_t_r_e_a_m corresponds
         to _F_i_l_e_N_a_m_e and  is not obtained  by opening the file  directly
         but, for example, through a network service.

    ttttyy((_B_o_o_l))
         Modify whether Prolog  thinks there is  a terminal (i.e.  human
         interaction) connected  to this stream.    On Unix systems  the
         initial value  comes from isatty().   On  Windows, the  initial
         user streams are supposed to be associated to a terminal.   See
         also stream_property/2.


sseett__pprroolloogg__IIOO((_+_I_n_, _+_O_u_t_, _+_E_r_r_o_r))
    Prepare  the   given  streams  for  interactive  behaviour  normally
    associated  to  the  terminal.     _I_n  becomes  the  user_input  and
    current_input  of  the calling  thread.    _O_u_t  becomes  user_output
    and  current_output.    If _E_r_r_o_r  equals  _O_u_t an  unbuffered  stream
    is  associated to  the same  destination and  linked to  user_error.
    Otherwise  _E_r_r_o_r is used for  user_error.   Output buffering for  _O_u_t
    is  set  to line  and buffering  on _E_r_r_o_r  is disabled.    See  also
    prolog/0  and set_stream/2.  The  _c_l_i_b package provides the  library
    prolog_server creating  a TCP/IP server for creating an  interactive
    session to Prolog.


44..1166..22 EEddiinnbbuurrgghh--ssttyyllee II//OO

The  package for  implicit  input  and output  destination  is  (almost)
compatible with Edinburgh DEC-10 and C-Prolog.  The  reading and writing
predicates  refer to  resp.    the  _c_u_r_r_e_n_t  input- and  output  stream.
Initially these  streams are  connected to  the terminal.   The  current
output stream is  changed using tell/1 or  append/1.  The current  input
stream  is changed  using  see/1.   The  streams  current value  can  be
obtained using telling/1 for output- and seeing/1 for input streams.

Source  and   destination  are   either  a  file,   user,   or  a   term
`pipe(_C_o_m_m_a_n_d)'.  The reserved stream name user refers  to the terminal.
In the predicate descriptions below we will  call the source/destination
argument  `_S_r_c_D_e_s_t'.    Below are  some examples  of  source/destination
specifications.

         ?- see(data).        % Start reading from file `data'.
         ?- tell(user).       % Start writing to the terminal.
         ?- tell(pipe(lpr)).  % Start writing to the printer.

Another example  of using  the pipe/1 construct  is shown  below.   Note
that  the  pipe/1  construct  is  not  part  of  Prolog's  standard  I/O
repertoire.

getwd(Wd) :-
        seeing(Old), see(pipe(pwd)),
        collect_wd(String),
        seen, see(Old),
        atom_codes(Wd, String).

collect_wd([C|R]) :-
        get0(C), C \== -1, !,
        collect_wd(R).
collect_wd([]).


CCoommppaattiibbiilliittyy nnootteess

Unlike Edinburgh  Prolog systems, telling/1  and seeing/1 do not  return
the filename of the current input/output, but  the stream-identifier, to
ensure the design pattern below works under all circumstances.

        ...,
        telling(Old), tell(x),
        ...,
        told, tell(Old),
        ...,

The predicates tell/1 and see/1 first check for  user, the pipe(_c_o_m_m_a_n_d)
and  a stream-handle.    Otherwise, if  the argument  is an  atom it  is
first compared  to open streams  associated to a  file with _e_x_a_c_t_l_y  the
same name.   If  such a stream,  created using  tell/1 or see/1  exists,
output (input) is switch to the open stream.  Otherwise  a file with the
specified name is opened.

The  behaviour  is compatible  with  Edinburgh  Prolog.    This  is  not
without problems.  Changing directory, non-file  streams, multiple names
referring to  the same file  easily lead to unexpected  behaviour.   New
code,  especially when managing  multiple I/O  channels should  consider
using the ISO I/O predicates defined in section 4.16.1.


sseeee((_+_S_r_c_D_e_s_t))
    Open  _S_r_c_D_e_s_t  for  reading  and  make it  the  current  input  (see
    set_input/1).    If  _S_r_c_D_e_s_t is  a  stream-handle, just  makes  this
    stream  the current input.   See the introduction of section  4.16.2
    for details.


tteellll((_+_S_r_c_D_e_s_t))
    Open  _S_r_c_D_e_s_t  for  writing and  make  it  the current  output  (see
    set_output/1).    If _S_r_c_D_e_s_t  is a  stream-handle,  just makes  this
    stream  the current output.  See the introduction of  section 4.16.2
    for details.


aappppeenndd((_+_F_i_l_e))
    Similar  to tell/1,  but positions the  file pointer  at the end  of
    _F_i_l_e  rather than truncating an existing  file.  The pipe  construct
    is not accepted by this predicate.


sseeeeiinngg((_?_S_r_c_D_e_s_t))
    Same  as  current_input/1,  except  that user  is  returned  if  the
    current  input  is the  stream user_input  to improve  compatibility
    with   traditional   Edinburgh   I/O.  See   the   introduction   of
    section 4.16.2 for details.


tteelllliinngg((_?_S_r_c_D_e_s_t))
    Same  as  current_output/1, except  that  user  is returned  if  the
    current  output is the  stream user_output to improve  compatibility
    with   traditional   Edinburgh   I/O.  See   the   introduction   of
    section 4.16.2 for details.


sseeeenn
    Close  the  current input  stream.   The  new  input stream  becomes
    _u_s_e_r___i_n_p_u_t.


ttoolldd
    Close  the current  output stream.   The  new output stream  becomes
    _u_s_e_r___o_u_t_p_u_t.


44..1166..33 SSwwiittcchhiinngg BBeettwweeeenn EEddiinnbbuurrgghh aanndd IISSOO II//OO

The predicates  below can be  used for  switching between the  implicit-
and the explicit stream based I/O predicates.


sseett__iinnppuutt((_+_S_t_r_e_a_m))                                                 _[_I_S_O_]
    Set  the current input  stream to become _S_t_r_e_a_m.   Thus,  open(file,
    read, Stream), set_input(Stream) is equivalent to see(file).


sseett__oouuttppuutt((_+_S_t_r_e_a_m))                                                _[_I_S_O_]
    Set  the  current  output  stream  to  become  _S_t_r_e_a_m.     See  also
    with_output_to/2.


ccuurrrreenntt__iinnppuutt((_-_S_t_r_e_a_m))                                             _[_I_S_O_]
    Get  the current input stream.   Useful to get access to  the status
    predicates associated with streams.


ccuurrrreenntt__oouuttppuutt((_-_S_t_r_e_a_m))                                            _[_I_S_O_]
    Get the current output stream.


44..1166..44 WWrriittee oonnttoo aattoommss,, ccooddee--lliissttss,, eettcc..


wwiitthh__oouuttppuutt__ttoo((_+_O_u_t_p_u_t_, _:_G_o_a_l))
    Run  _G_o_a_l  as  once/1,  while  characters  written  to  the  current
    output  is sent to  _O_u_t_p_u_t.   The predicate is SWI-Prolog  specific,
    inspired  by  various posts  to  the mailinglist.    It  provides  a
    flexible  replacement for predicates  such as sformat/3,  swritef/3,
    term_to_atom/2, atom_number/2 converting numbers to atoms, etc.  The
    predicate format/3 accepts the same terms as output argument.

    Applications  should  generally  avoid creating  atoms  by  breaking
    and  concatenating  other atoms  as the  creation  of large  numbers
    of  intermediate atoms  generally leads  to  poor performance,  even
    more  so in  multi-threaded applications.   This predicate  supports
    creating  difference-lists from  character  data efficiently.    The
    example  below defines the DCG rule term//1 to insert a term  in the
    output:

    term(Term, In, Tail) :-
            with_output_to(codes(In, Tail), write(Term)).

    ?- phrase(term(hello), X).

    X = [104, 101, 108, 108, 111]

    AA SSttrreeaamm hhaannddllee oorr aalliiaass
         Temporary switch current output to the given stream.   Redirec-
         tion using  with_output_to/2guarantees  the original output  is
         restored, also if _G_o_a_l fails or raises an exception.   See also
         call_cleanup/2.

    aattoomm((_-_A_t_o_m))
         Create an atom  from the emitted characters.   Please note  the
         remark above.

    ssttrriinngg((_-_S_t_r_i_n_g))
         Create a string-object as defined in section 4.23.

    ccooddeess((_-_C_o_d_e_s))
         Create a list of  character codes from the emitted  characters,
         similar to atom_codes/2.

    ccooddeess((_-_C_o_d_e_s_, _-_T_a_i_l))
         Create a list of character codes as a difference-list.

    cchhaarrss((_-_C_h_a_r_s))
         Create a  list of  one-character-atoms codes  from the  emitted
         characters, similar to atom_chars/2.

    cchhaarrss((_-_C_h_a_r_s_, _-_T_a_i_l))
         Create a list of one-character-atoms as a difference-list.


44..1177 SSttaattuuss ooff ssttrreeaammss


wwaaiitt__ffoorr__iinnppuutt((_+_L_i_s_t_O_f_S_t_r_e_a_m_s_, _-_R_e_a_d_y_L_i_s_t_, _+_T_i_m_e_O_u_t))
    Wait  for input on  one of the  streams in _L_i_s_t_O_f_S_t_r_e_a_m_s and  return
    a  list  of  streams  on  which input  is  available  in  _R_e_a_d_y_L_i_s_t.
    wait_for_input/3 waits  for at most  _T_i_m_e_O_u_t seconds.   _T_i_m_e_o_u_t  may
    be  specified as  a floating  point number to  specify fractions  of
    a  second.    If  _T_i_m_e_o_u_t  equals  infinite,  wait_for_input/3 waits
    indefinitely.

    This  predicate can be used  to implement timeout while reading  and
    to  handle  input from  multiple  sources.   The  following  example
    will  wait for input from the  user and an explicitly opened  second
    terminal.  On return, _I_n_p_u_t_s may hold user or _P_4 or both.

    ?- open('/dev/ttyp4', read, P4),
       wait_for_input([user, P4], Inputs, 0).

    This  predicate  relies  on  the select()  call  on  most  operating
    systems.  On  Unix this call is implemented for any stream referring
    to  a file-handle,  which implies  all OS-based  streams:   sockets,
    terminals,  pipes, etc.   On non-Unix systems select() is  generally
    only  implemented for socket-based  streams.   See also socket  from
    the clib package.

    Note  that wait_for_input/3 returns streams that have data  waiting.
    This  does not mean you can, for example, call read/2 on  the stream
    without  blocking as the stream might hold an incomplete term.   The
    predicate  set_stream/2 using  the  option timeout(_S_e_c_o_n_d_s)  can  be
    used  to  make the  stream  generate an  exception  if no  new  data
    arrives  for within the timeout.  Suppose two  processes communicate
    by  exchanging Prolog terms.   The  following code makes the  server
    immune for clients that write an incomplete term:

            ...,
            tcp_accept(Server, Socket, _Peer),
            tcp_open(Socket, In, Out),
            set_stream(In, timeout(10)),
            catch(read(In, Term), _, (close(Out), close(In), fail)),
            ...,


bbyyttee__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Byte-position  in _S_t_r_e_a_m.   For binary streams  this is the same  as
    character_count/2.   For text files the number may be  different due
    to  multi-byte encodings  or additional record  separators (such  as
    Control-M in Windows).


cchhaarraacctteerr__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the  current character index.   For input  streams
    this  is the number  of characters read since  the open, for  output
    streams  this is the number of characters written.   Counting starts
    at 0.


lliinnee__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the  number of  lines read or  written.   Counting
    starts at 1.


lliinnee__ppoossiittiioonn((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the position on the current line.  Note  that this
    assumes  the position is 0 after the  open.  Tabs are assumed  to be
    defined on each  8-th character and backspaces are assumed to reduce
    the count by one, provided it is positive.


ffiilleeeerrrroorrss((_-_O_l_d_, _+_N_e_w))
    Define error behaviour  on errors when opening a file for reading or
    writing.   Valid values are the  atoms on (default) and off.   First
    _O_l_d  is unified with the current value.   Then the new value  is set
    to _N_e_w.

    With  the introduction of exception-handling,  it is advised to  use
    catch/3  to catch possibly  file-errors and act  accordingly.   Note
    that if _f_i_l_e_e_r_r_o_r_s is off, _n_o exception is generated.


44..1188 PPrriimmiittiivvee cchhaarraacctteerr II//OO

See section 4.2 for an overview of supported character representations.


nnll                                                                _[_I_S_O_]
    Write  a newline character  to the current output  stream.  On  Unix
    systems nl/0 is equivalent to put(10).


nnll((_+_S_t_r_e_a_m))                                                       _[_I_S_O_]
    Write a newline to _S_t_r_e_a_m.


ppuutt((_+_C_h_a_r))
    Write  _C_h_a_r  to  the  current  output  stream,  _C_h_a_r  is  either  an
    integer-expression  evaluating to  a character  code or  an atom  of
    one  character.   Depreciated.   New code  should use  put_char/1 or
    put_code/1.


ppuutt((_+_S_t_r_e_a_m_, _+_C_h_a_r))
    Write _C_h_a_r to _S_t_r_e_a_m.  See put/1 for details.


ppuutt__bbyyttee((_+_B_y_t_e))                                                    _[_I_S_O_]
    Write a single byte  to the output.  _B_y_t_e must be an integer between
    0 and 255.


ppuutt__bbyyttee((_+_S_t_r_e_a_m_, _+_B_y_t_e))                                           _[_I_S_O_]
    Write a single byte  to a stream.  _B_y_t_e must be an integer between 0
    and 255.


ppuutt__cchhaarr((_+_C_h_a_r))                                                    _[_I_S_O_]
    Write  a  character to  the  current output,  obeying  the  encoding
    defined for the current  output stream.  Note that this may raise an
    exception if the encoding of _S_t_r_e_a_m cannot represent _C_h_a_r.


ppuutt__cchhaarr((_+_S_t_r_e_a_m_, _+_C_h_a_r))                                           _[_I_S_O_]
    Write  a  character to  _S_t_r_e_a_m,  obeying  the encoding  defined  for
    _S_t_r_e_a_m.   Note that this may  raise an exception if the  encoding of
    _S_t_r_e_a_m cannot represent _C_h_a_r.


ppuutt__ccooddee((_+_C_o_d_e))                                                    _[_I_S_O_]
    Similar  to put_char/1,  but using  a _c_h_a_r_a_c_t_e_r  _c_o_d_e.    _C_o_d_e is  a
    non-negative integer.   Note that this may raise an exception if the
    encoding of _S_t_r_e_a_m cannot represent _C_o_d_e.


ppuutt__ccooddee((_+_S_t_r_e_a_m_, _+_C_o_d_e))                                           _[_I_S_O_]
    Same as put_code/1 but directing _C_o_d_e to _S_t_r_e_a_m.


ttaabb((_+_A_m_o_u_n_t))
    Writes  _A_m_o_u_n_t  spaces  on  the  current  output  stream.     _A_m_o_u_n_t
    should  be an expression that  evaluates to a positive integer  (see
    section 4.26).


ttaabb((_+_S_t_r_e_a_m_, _+_A_m_o_u_n_t))
    Writes _A_m_o_u_n_t spaces to _S_t_r_e_a_m.


fflluusshh__oouuttppuutt                                                       _[_I_S_O_]
    Flush  pending output on current  output stream.   flush_output/0 is
    automatically  generated by  read/1 and derivatives  if the  current
    input stream is user and the cursor is not at the left margin.


fflluusshh__oouuttppuutt((_+_S_t_r_e_a_m))                                              _[_I_S_O_]
    Flush  output on the specified stream.  The stream must be  open for
    writing.


ttttyyfflluusshh
    Flush pending output on stream _u_s_e_r.  See also flush_output/[0,1].


ggeett__bbyyttee((_-_B_y_t_e))                                                    _[_I_S_O_]
    Read the current input  stream and unify the next byte with _B_y_t_e (an
    integer between 0 and 255.  _B_y_t_e is unified with -1 on end of file.


ggeett__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))                                           _[_I_S_O_]
    Read  the next byte from _S_t_r_e_a_m, returning an integer between  0 and
    255.


ggeett__ccooddee((_-_C_o_d_e))                                                    _[_I_S_O_]
    Read  the current  input stream  and unify _C_o_d_e  with the  character
    code  of the  next character.   _C_o_d_e is  unified with  -1 on end  of
    file.  See also get_char/1.


ggeett__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))                                           _[_I_S_O_]
    Read the next character-code from _S_t_r_e_a_m.


ggeett__cchhaarr((_-_C_h_a_r))                                                    _[_I_S_O_]
    Read  the  current  input  stream  and  unify  _C_h_a_r  with  the  next
    character  as a  one-character-atom.   See  also atom_chars/2.    On
    end-of-file, _C_h_a_r is unified to the atom end_of_file.


ggeett__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                           _[_I_S_O_]
    Unify  _C_h_a_r with the next character from _S_t_r_e_a_m as  a one-character-
    atom.  See also get_char/2, get_byte/2 and get_code/2.


ggeett00((_-_C_h_a_r))
    Edinburgh  version  of the  ISO  get_code/1 predicate.    Note  that
    Edinburgh  prolog  didn't  support  wide  characters  and  therefore
    technically  speaking get0/1 should have been  mapped to get_byte/1.
    The intention of get0/1 however is to read character codes.


ggeett00((_+_S_t_r_e_a_m_, _-_C_h_a_r))
    Edinburgh  version  of  the ISO  get_code/2  predicate.    See  also
    get0/1.


ggeett((_-_C_h_a_r))
    Read  the  current   input  stream  and  unify  the  next  non-blank
    character with _C_h_a_r.  _C_h_a_r is unified with -1 on end of file.


ggeett((_+_S_t_r_e_a_m_, _-_C_h_a_r))
    Read the next non-blank character from _S_t_r_e_a_m.


ppeeeekk__bbyyttee((_-_B_y_t_e))                                                   _[_I_S_O_]
    Reads  the next input byte  like get_byte/1, but does not remove  it
    from the input stream.


ppeeeekk__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))                                          _[_I_S_O_]
    Reads  the next input byte  like get_byte/2, but does not remove  it
    from the stream.


ppeeeekk__ccooddee((_-_C_o_d_e))                                                   _[_I_S_O_]
    Reads  the next input code  like get_code/1, but does not remove  it
    from the input stream.


ppeeeekk__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))                                          _[_I_S_O_]
    Reads  the next input code  like get_code/2, but does not remove  it
    from the stream.


ppeeeekk__cchhaarr((_-_C_h_a_r))                                                   _[_I_S_O_]
    Reads the  next input character like get_char/1,  but does not remove
    it from the input stream.


ppeeeekk__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                          _[_I_S_O_]
    Reads the  next input character like get_char/2,  but does not remove
    it from the stream.


sskkiipp((_+_C_o_d_e))
    Read the input until  _C_h_a_r or the end of the file is encountered.  A
    subsequent  call to get_code/1 will  read the first character  after
    _C_o_d_e.


sskkiipp((_+_S_t_r_e_a_m_, _+_C_o_d_e))
    Skip input (as skip/1) on _S_t_r_e_a_m.


ggeett__ssiinnggllee__cchhaarr((_-_C_o_d_e))
    Get  a single character from input stream `user' (regardless  of the
    current  input stream).   Unlike get_code/1 this predicate does  not
    wait  for a  return.   The  character is  not echoed  to the  user's
    terminal.   This predicate is meant for keyboard menu selection etc.
    If SWI-Prolog was  started with the -tty option this predicate reads
    an  entire line of input  and returns the first non-blank  character
    on  this line,  or the  character code  of the newline  (10) if  the
    entire line consisted of blank characters.


aatt__eenndd__ooff__ssttrreeaamm                                                    _[_I_S_O_]
    Succeeds  after the last character  of the current input stream  has
    been  read.    Also succeeds  if  there is  no valid  current  input
    stream.


aatt__eenndd__ooff__ssttrreeaamm((_+_S_t_r_e_a_m))                                           _[_I_S_O_]
    Succeeds  after the last character of  the named stream is read,  or
    _S_t_r_e_a_m is not a  valid input stream.  The end-of-stream test is only
    available  on buffered  input stream (unbuffered  input streams  are
    rarely used, see open/4).


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t_, _+_L_e_n))
    Copy  _L_e_n codes from  stream _S_t_r_e_a_m_I_n to _S_t_r_e_a_m_O_u_t.   Note that  the
    copy  is  done using  the  semantics of  get_code/2 and  put_code/2,
    taking  care of possibly recoding that needs take place  between two
    text files.  See section 2.17.1.


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t))
    Copy data all (remaining) data from stream _S_t_r_e_a_m_I_n to _S_t_r_e_a_m_O_u_t.


rreeaadd__ppeennddiinngg__iinnppuutt((_+_S_t_r_e_a_m_I_n_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Read  input pending in  the input buffer  of _S_t_r_e_a_m_I_n and return  it
    in  the difference list _C_o_d_e_s-_T_a_i_l.   I.e. the available  characters
    codes  are used to  create the list _C_o_d_e_s  ending in the tail  _T_a_i_l.
    This  predicate is  intended  for efficient  unbuffered copying  and
    filtering of input coming from network connections or devices.

    The following code  fragment realises efficient non-blocking copy of
    data  from an  input- to an  output stream.   The  at_end_of_stream/1
    call  checks for  end-of-stream and fills  the input  buffer.   Note
    that  the use of a  get_code/2 and put_code/2 based loop requires  a
    flush_output/1 call  after _e_a_c_h put_code/2.   The copy_stream_data/2
    does  not allow for inspection of  the copied data and suffers  from
    the same buffering issues.

    copy(In, Out) :-
            repeat,
                (   at_end_of_stream(In)
                ->  !
                ;   read_pending_input(In, Chars, []),
                    format(Out, '~s', [Chars]),
                    flush_output(Out),
                    fail
                ).


44..1199 TTeerrmm rreeaaddiinngg aanndd wwrriittiinngg

This section  describes the basic term  reading and writing  predicates.
The  predicates  format/[1,2] and  writef/2  provide  formatted  output.
Writing  to  Prolog  datastructures  such  as  atoms  or  code-lists  is
supported by with_output_to/2and format/3.

There are  two ways  to manipulate  the output  format.   The  predicate
print/[1,2] may be programmed  using portray/1.  The format  of floating
point numbers may be manipulated using the Prolog flag float_format.

Reading  is  sensitive  to  the  Prolog  flag  character_escapes,   which
controls  the interpretation  of the  \ character  in  quoted atoms  and
strings.


wwrriittee__tteerrmm((_+_T_e_r_m_, _+_O_p_t_i_o_n_s))                                        _[_I_S_O_]
    The  predicate  write_term/2  is  the generic  form  of  all  Prolog
    term-write predicates.  Valid options are:

    aattttrriibbuutteess((_A_t_o_m))
         Define how attributed variables (see section 6.1)  are written.
         The default is determined by  the Prolog flag write_attributes.
         Defined values are  ignore (ignore the attribute), dots  (write
         the attributes  as {...}),  write (simply  hand the  attributes
         recursively to write_term/2) and  portray (hand the  attributes
         to attr_portray_hook/2).

    bbaacckkqquuootteedd__ssttrriinngg((_B_o_o_l))
         If true,  write a string  object (see  section 4.23) as  `...`.
         The default depends on the Prolog flag backquoted_string.

    cchhaarraacctteerr__eessccaappeess((_B_o_o_l))
         If true,  and  quoted(_t_r_u_e) is  active,  special characters  in
         quoted atoms and  strings are emitted as ISO  escape-sequences.
         Default is taken from the reference module (see below).

    iiggnnoorree__ooppss((_B_o_o_l))
         If true, the generic term-representation (<_f_u_n_c_t_o_r>(<_a_r_g_s> ...))
         will be  used for  all terms,  Otherwise (default),  operators,
         list-notation and  {}/1  will be  written using  their  special
         syntax.

    mmaaxx__ddeepptthh((_I_n_t_e_g_e_r))
         If the term is nested deeper than _I_n_t_e_g_e_r,  print the remainder
         as eclipse (...).  A 0 (zero) value (default)  imposes no depth
         limit.  This option  also delimits the number of printed  for a
         list.  Example:

         ?- write_term(a(s(s(s(s(0)))), [a,b,c,d,e,f]), [max_depth(3)]).
         a(s(s(...)), [a, b|...])

         Yes

         Used  by   the   top-level  and   debugger  to   limit   screen
         output.   See also the Prolog  flags toplevel_print_options and
         debugger_print_options.

    mmoodduullee((_M_o_d_u_l_e))
         Define the reference module  (default user).  This  defines the
         default value for  the character_escapes option as well as  the
         operator definitions to use.  See also op/3.

    nnuummbbeerrvvaarrss((_B_o_o_l))
         If true, terms  of the format $VAR(N), where  <_N> is a positive
         integer,  will be  written as  a variable  name.   If  _N is  an
         atom it is written  without quotes.  This extension  allows for
         writing variables  with user-provided  names.   The default  is
         false.  See also numbervars/3.

    ppaarrttiiaall((_B_o_o_l))
         If true (default  false), do not  reset the logic that  inserts
         extra  spaces that  seperate  tokens where  needed.    This  is
         intended  to this  problems  with  the  code below.     Calling
         write_value(.) writes  .., which  cannot be  read.   By  adding
         partial(_t_r_u_e) to the option,  it correctly emits . ..   Similar
         problems appear  when emitting operators  using multiple  calls
         to write_term/3.

         write_value(Value) :-
                 write_term(Value, [quoted(true)]),
                 write('.'), nl.

    ppoorrttrraayy((_B_o_o_l))
         If true, the  hook portray/1 is  called before printing a  term
         that is not  a variable.   If portray/1  succeeds, the term  is
         considered printed.  See  also print/1.  The default  is false.
         This option is an extension to the ISO write_term options.

    pprriioorriittyy((_I_n_t_e_g_e_r))
         An  integer  between  0  and  1200  representing  the  `context
         priority'.   Default is  1200.   Can be  used to write  partial
         terms appearing as the argument to an operator.  For example:

                 format('~w = ', [VarName]),
                 write_term(Value, [quoted(true), priority(699)])

    qquuootteedd((_B_o_o_l))
         If true, atoms and  functors that needs quotes will  be quoted.
         The default is false.


wwrriittee__tteerrmm((_+_S_t_r_e_a_m_, _+_T_e_r_m_, _+_O_p_t_i_o_n_s))                               _[_I_S_O_]
    As  write_term/2,  but output  is sent  to  _S_t_r_e_a_m rather  than  the
    current output.


wwrriittee__ccaannoonniiccaall((_+_T_e_r_m))                                             _[_I_S_O_]
    Write  _T_e_r_m  on  the current  output  stream using  standard  paren-
    thesised  prefix notation  (i.e.,  ignoring operator  declarations).
    Atoms  that  need  quotes are  quoted.    Terms  written  with  this
    predicate  can always be read  back, regardless of current  operator
    declarations.      Equivalent  to  write_term/2  using  the  options
    ignore_ops,  quoted  and  numbervars after  numbervars/4  using  the
    singletons option.

    Note  that due to the use of numbervars/4, non-ground terms  must be
    written  using a  _s_i_n_g_l_e write_canonical/1 call.   This  used to  be
    the  case anyhow,  as garbage collection  between multiple calls  to
    one  of the write predicates can change  the _G<_N_N_N> identity of the
    variables.


wwrriittee__ccaannoonniiccaall((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                    _[_I_S_O_]
    Write _T_e_r_m in canonical form on _S_t_r_e_a_m.


wwrriittee((_+_T_e_r_m))                                                      _[_I_S_O_]
    Write  _T_e_r_m  to the  current output,  using  brackets and  operators
    where  appropriate.  The Prolog flag  float_format controls floating
    point output format.


wwrriittee((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                             _[_I_S_O_]
    Write _T_e_r_m to _S_t_r_e_a_m.


wwrriitteeqq((_+_T_e_r_m))                                                     _[_I_S_O_]
    Write  _T_e_r_m  to the  current output,  using  brackets and  operators
    where  appropriate.    Atoms that  need quotes  are quoted.    Terms
    written  with this predicate can  be read back with read/1  provided
    the currently active operator declarations are identical.


wwrriitteeqq((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                            _[_I_S_O_]
    Write _T_e_r_m to _S_t_r_e_a_m, inserting quotes.


pprriinntt((_+_T_e_r_m))
    Prints  _T_e_r_m on the  current output stream  similar to write/1,  but
    for each (sub)term  of _T_e_r_m first the dynamic predicate portray/1 is
    called.   If this predicate succeeds _p_r_i_n_t assumes the (sub)term has
    been written.  This allows for user defined term writing.


pprriinntt((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Print _T_e_r_m to _S_t_r_e_a_m.


ppoorrttrraayy((_+_T_e_r_m))
    A dynamic predicate, which  can be defined by the user to change the
    behaviour  of print/1 on (sub)terms.   For each subterm  encountered
    that is not  a variable print/1 first calls portray/1 using the term
    as  argument.    For lists  only the  list as  a whole  is given  to
    portray/1.   If portray succeeds  print/1 assumes the term has  been
    written.


rreeaadd((_-_T_e_r_m))                                                       _[_I_S_O_]
    Read  the next Prolog term from  the current input stream and  unify
    it  with _T_e_r_m.  On a syntax error read/1 displays an  error message,
    attempts  to  skip  the erroneous  term  and  fails.    On  reaching
    end-of-file _T_e_r_m is unified with the atom end_of_file.


rreeaadd((_+_S_t_r_e_a_m_, _-_T_e_r_m))                                              _[_I_S_O_]
    Read _T_e_r_m from _S_t_r_e_a_m.


rreeaadd__ccllaauussee((_-_T_e_r_m))
    Equivalent  to read/1, but warns the user for variables  only occur-
    ring  once in  a term  (singleton variables,  see section  2.15.1.5)
    which  do  not start  with an  underscore if  style_check(singleton)
    is  active  (default).    Used  to  read Prolog  source  files  (see
    consult/1).     New code  should  use  read_term/2 with  the  option
    singletons(warning).


rreeaadd__ccllaauussee((_+_S_t_r_e_a_m_, _-_T_e_r_m))
    Read a clause from _S_t_r_e_a_m.  See read_clause/1.


rreeaadd__tteerrmm((_-_T_e_r_m_, _+_O_p_t_i_o_n_s))                                         _[_I_S_O_]
    Read  a  term from  the  current input  stream  and unify  the  term
    with  _T_e_r_m.   The  reading is controlled  by options  from the  list
    of  _O_p_t_i_o_n_s.   If  this list  is empty,  the behaviour  is the  same
    as  for read/1.    The options  are upward  compatible with  Quintus
    Prolog.    The  argument order  is according  to  the ISO  standard.
    Syntax-errors  are  always  reported using  exception-handling  (see
    catch/3).  Options:

    bbaacckkqquuootteedd__ssttrriinngg((_B_o_o_l))
         If true,  read `...`  to a  string object  (see section  4.23).
         The default depends on the Prolog flag backquoted_string.

    cchhaarraacctteerr__eessccaappeess((_B_o_o_l))
         Defines  how  to  read  \  escape-sequences  in  quoted  atoms.
         See the Prolog  flags character_escapes, current_prolog_flag/2.
         (SWI-Prolog).

    ccoommmmeennttss((_-_C_o_m_m_e_n_t_s))
         Unify _C_o_m_m_e_n_t_s with a list of _P_o_s_i_t_i_o_n-_C_o_m_m_e_n_t,  where _P_o_s_i_t_i_o_n
         is  a   stream-position  object   (see  stream_position_data/3)
         indicating  the   start  of   a  comment  and   _C_o_m_m_e_n_t  is   a
         string-object containing  the  text including  delimiters of  a
         comment.   It returns all  comments from where  the read_term/2
         call started upto the end of the term read.

    ddoouubbllee__qquuootteess((_B_o_o_l))
         Defines  how to  read  "..." strings.     See the  Prolog  flag
         double_quotes.  (SWI-Prolog).

    mmoodduullee((_M_o_d_u_l_e))
         Specify  _M_o_d_u_l_e  for  operators,   character_escapes  flag  and
         double_quotes flag.  The  value of the latter two is  overruled
         if  the corresponding  read_term/3  option  is provided.     If
         no module  is specified, the  current `source-module' is  used.
         (SWI-Prolog).

    ssiinngglleettoonnss((_V_a_r_s))
         As variable_names,  but only  reports  the variables  occurring
         only  once in  the  _T_e_r_m read.     Variables starting  with  an
         underscore (`_')  are not included  in this  list.   (ISO).  If
         _V_a_r_s is the constant warning, singleton variables  are reported
         using print_message/2.

    ssyynnttaaxx__eerrrroorrss((_A_t_o_m))
         If error  (default),  throw and  exception on  a syntax  error.
         Other values  are fail, which  causes a  message to be  printed
         using print_message/2, after which  the predicate fails,  quiet
         which causes  the predicate  to fail silently  and dec10  which
         causes syntax errors to be printed, after which read_term/[2,3]
         continues reading the next term.   Using dec10, read_term/[2,3]
         never fails.  (Quintus, SICStus).

    ssuubbtteerrmm__ppoossiittiioonnss((_T_e_r_m_P_o_s))
         Describes the  detailed layout of  the term.   The formats  for
         the various types of terms  if given below.  All  positions are
         character positions.    If  the input  is related  to a  normal
         stream,  these  positions are  relative  to the  start  of  the
         input, when  reading from  the terminal, they  are relative  to
         the start of the term.

         _F_r_o_m--_T_o
             Used for primitive types (atoms, numbers, variables).

         ssttrriinngg__ppoossiittiioonn((_F_r_o_m_, _T_o))
             Used  to indicate  the  position of  a string  enclosed  in
             double quotes (").

         bbrraaccee__tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _A_r_g))
             Term  of  the form  {...},  as used  in  DCG  rules.    _A_r_g
             describes the argument.

         lliisstt__ppoossiittiioonn((_F_r_o_m_, _T_o_, _E_l_m_s_, _T_a_i_l))
             A list.  _E_l_m_s describes the  positions of the elements.  If
             the list specifies the tail as |<_T_a_i_l_T_e_r_m>, _T_a_i_l is unified
             with  the term-position  of the  tail,  otherwise with  the
             atom none.

         tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _F_F_r_o_m_, _F_T_o_, _S_u_b_P_o_s))
             Used  for a compound  term not matching  one of the  above.
             _F_F_r_o_m  and  _F_T_o  describe  the  position  of  the  functor.
             _S_u_b_P_o_s  is a  list,  each element  of  which describes  the
             term-position of the corresponding subterm.

    tteerrmm__ppoossiittiioonn((_P_o_s))
         Unifies _P_o_s with the starting  position of the term read.   _P_o_s
         if of the same format as use by stream_property/2.

    vvaarriiaabblleess((_V_a_r_s))
         Unify  _V_a_r_s  with a  list  of  variables  in the  term.     The
         variables appear in  the order they have  been read.  See  also
         term_variables/2.  (ISO).

    vvaarriiaabbllee__nnaammeess((_V_a_r_s))
         Unify _V_a_r_s with a list  of `_N_a_m_e = _V_a_r', where _N_a_m_e is  an atom
         describing the variable name and _V_a_r is a  variable that shares
         with the corresponding variable in _T_e_r_m.  (ISO).


rreeaadd__tteerrmm((_+_S_t_r_e_a_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))                                _[_I_S_O_]
    Read term with options from _S_t_r_e_a_m.  See read_term/2.


rreeaadd__hhiissttoorryy((_+_S_h_o_w_, _+_H_e_l_p_, _+_S_p_e_c_i_a_l_, _+_P_r_o_m_p_t_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))
    Similar  to read_term/2 using the option variable_names, but  allows
    for history  substitutions.  read_history/6is used  by the top level
    to  read the user's actions.   _S_h_o_w is  the command the user  should
    type  to show  the saved  events.   _H_e_l_p is  the command  to get  an
    overview  of the capabilities.   _S_p_e_c_i_a_l is a list of commands  that
    are  not saved in the  history.  _P_r_o_m_p_t  is the first prompt  given.
    Continuation  prompts for  more  lines are  determined by  prompt/2.
    A  %w  in the  prompt  is substituted  by  the event  number.    See
    section 2.7 for available substitutions.

    SWI-Prolog calls read_history/6 as follows:

    read_history(h, '!h', [trace], '%w ?- ', Goal, Bindings)


pprroommpptt((_-_O_l_d_, _+_N_e_w))
    Set  prompt associated  with read/1  and its  derivatives.   _O_l_d  is
    first  unified with the current prompt.  On success the  prompt will
    be  set to _N_e_w if  this is an atom.   Otherwise an error message  is
    displayed.   A prompt  is printed if one  of the read predicates  is
    called  and the cursor is  at the left margin.   It is also  printed
    whenever  a newline is given and  the term has not been  terminated.
    Prompts are only printed when the current input stream is _u_s_e_r.


pprroommpptt11((_+_P_r_o_m_p_t))
    Sets  the prompt for the next line  to be read.   Continuation lines
    will be read using the prompt defined by prompt/2.


44..2200 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg TTeerrmmss


ffuunnccttoorr((_?_T_e_r_m_, _?_F_u_n_c_t_o_r_, _?_A_r_i_t_y))                                  _[_I_S_O_]
    True  if _T_e_r_m is a  term with functor _F_u_n_c_t_o_r  and arity _A_r_i_t_y.   If
    _T_e_r_m  is a  variable  it is  unified with  a new  term holding  only
    variables.    functor/3 silently  fails on  instantiation faults  If
    _T_e_r_m  is an atom or  number, _F_u_n_c_t_o_r will  be unified with _T_e_r_m  and
    arity will be unified with the integer 0 (zero).


aarrgg((_?_A_r_g_, _+_T_e_r_m_, _?_V_a_l_u_e))                                          _[_I_S_O_]
    _T_e_r_m  should be instantiated  to a term,  _A_r_g to an integer  between
    1  and  the  arity of  _T_e_r_m.    _V_a_l_u_e  is  unified with  the  _A_r_g-th
    argument  of _T_e_r_m.   _A_r_g may also  be unbound.   In this case  _V_a_l_u_e
    will  be unified  with the  successive arguments of  the term.    On
    successful  unification, _A_r_g  is unified  with the argument  number.
    Backtracking  yields alternative  solutions.    The predicate  arg/3
    fails  silently if  _A_r_g= 0 or _A_r_g > _a_r_i_t_y and raises  the exception
    domain_error(not_less_then_zero, _A_r_g)if _A_r_g <0.


_?_T_e_r_m =.. _?_L_i_s_t                                                   _[_I_S_O_]
    _L_i_s_t  is a list which head is the functor of _T_e_r_m and  the remaining
    arguments  are the arguments  of the  term.   Each of the  arguments
    may  be a variable, but not both.  This predicate is  called `Univ'.
    Examples:

    ?- foo(hello, X) =.. List.

    List = [foo, hello, X]

    ?- Term =.. [baz, foo(1)]

    Term = baz(foo(1))


nnuummbbeerrvvaarrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_E_n_d))
    Unify  the free variables  of _T_e_r_m with a  term $VAR(_N), where _N  is
    the  number of  the variable.   Counting starts  at _S_t_a_r_t.   _E_n_d  is
    unified  with the number that should be given to the  next variable.
    Example:

    ?- numbervars(foo(A, B, A), 0, End).

    A = '$VAR'(0)
    B = '$VAR'(1)
    End = 2

    See also the numbervars option to write_term/3 and numbervars/4.


nnuummbbeerrvvaarrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_E_n_d_, _+_O_p_t_i_o_n_s))
    As numbervars/3, but providing the following options:

    ffuunnccttoorr__nnaammee((_+_A_t_o_m))
         Name of the functor to use instead of $VAR.

    aattttvvaarr((_+_A_c_t_i_o_n))
         What to do if  an attributed variable is encountered.   Options
         are skip,  which causes numbervars/3  to ignore the  attributed
         variable,  bind  which causes  it  to  thread it  as  a  normal
         variable and assign the next '$VAR'(N) term to  it or (default)
         error which raises the a type_error exception.

    ssiinngglleettoonnss((_+_B_o_o_l))
         If true  (default false),  numbervars/4  does singleton  detec-
         tion.    Singleton  variables  are  unified  with  '$VAR'('_'),
         causing  them  to  be  printed  as   _  by  write_term/2  using
         the  numbervars  option.      This   option  is  exploited   by
         portray_clause/2 and write_canonical/2.


tteerrmm__vvaarriiaabblleess((_+_T_e_r_m_, _-_L_i_s_t))
    Unify  _L_i_s_t with  a list of  variables, each  sharing with a  unique
    variable  of _T_e_r_m.   The variables in _L_i_s_t  are ordered in order  of
    appearance traversing _T_e_r_m  depth-first and left-to-right.  See also
    term_variables/3.  For example:

    ?- term_variables(a(X, b(Y, X), Z), L).

    L = [G367, G366, G371]
    X = G367
    Y = G366
    Z = G371


tteerrmm__vvaarriiaabblleess((_+_T_e_r_m_, _-_L_i_s_t_, _?_T_a_i_l))
    Difference list  version of term_variables/2.  I.e.  _T_a_i_l is the tail
    of the variable-list _L_i_s_t.


ccooppyy__tteerrmm((_+_I_n_, _-_O_u_t))                                               _[_I_S_O_]
    Create  a version  if _I_n  with renamed (fresh)  variables and  unify
    it  to  _O_u_t.   Attributed  variables (see  section  6.1) have  their
    attributed  copied.    The  implementation of  copy_term/2 can  deal
    with  infinite  trees  (cyclic  terms).     As  pure  Prolog  cannot
    distinguish a ground  term from another ground term with exactly the
    same  structure, ground  sub-terms are  _s_h_a_r_e_d between  _I_n and  _O_u_t.
    Sharing  ground terms  does affect  setarg/3.   SWI-Prolog  provides
    duplicate_term/2 to create a true copy of a term.


44..2200..11 NNoonn--llooggiiccaall ooppeerraattiioonnss oonn tteerrmmss

Prolog is not capable  to _m_o_d_i_f_y instantiated parts of a term.   Lacking
that capability makes that language much safer,  but unfortunately there
are problems that suffer severely in terms of time  and/or memory usage.
Always try hard to avoid the use of these primitives, but  they can be a
good alternative  to using dynamic  predicates.   See also section  6.3,
discussing the use of global variables.


sseettaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    Extra-logical  predicate.     Assigns the  _A_r_g-th  argument  of  the
    compound  term _T_e_r_m with the given _V_a_l_u_e.  The assignment  is undone
    if  backtracking brings the  state back into  a position before  the
    setarg/3 call.  See also nb_setarg/3.

    This  predicate may  be used  for destructive  assignment to  terms,
    using  them as an  extra-logical storage  bin.   Always try hard  to
    avoid  the use of  setarg/3 as  it is not  supported by many  Prolog
    systems  and one has to be very careful about unexpected  copying as
    well as unexpected not copying of terms.


nnbb__sseettaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    Assigns  the _A_r_g-th  argument  of the  compound term  _T_e_r_m with  the
    given  _V_a_l_u_e  as  setarg/3,   but  on  backtracking  the  assignment
    is  _n_o_t  reversed.     If _T_e_r_m  is  not  atomic,  it  is  duplicated
    using  duplicate_term/2.   This  predicate uses  the same  technique
    as  nb_setval/2.     We  therefore  refer   to  the  description  of
    nb_setval/2  for details on  non-backtrackable assignment of  terms.
    This  predicate is  compatible with GNU-Prolog  setarg(_A_,_T_,_V_,_f_a_l_s_e),
    removing  the type-restriction  on _V_a_l_u_e.    See also  nb_linkarg/3.
    Below  is  an example  for counting  the number  of  solutions of  a
    goal.    Note  that this  implementation is  thread-safe,  reentrant
    and  capable of handling exceptions.  Realising these  features with
    a  traditional implementation based  on assert/retract or flag/3  is
    much more complicated.

    :- module_transparent succeeds_n_times/2.

    succeeds_n_times(Goal, Times) :-
            Counter = counter(0),
            (   Goal,
                arg(1, Counter, N0),
                N is N0 + 1,
                nb_setarg(1, Counter, N),
                fail
            ;   arg(1, Counter, Times)
            ).


nnbb__lliinnkkaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    As  nb_setarg/3,  but like nb_linkval/2 it does _n_o_t duplicate  _V_a_l_u_e.
    Use with  extreme care and consult the documentation of nb_linkval/2
    before use.


dduupplliiccaattee__tteerrmm((_+_I_n_, _-_O_u_t))
    Version  of copy_term/2 that also copies ground terms  and therefore
    ensures  destructive  modification using  setarg/3 does  not  affect
    the  copy.    See  also nb_setval/2,  nb_linkval/2, nb_setarg/3  and
    nb_linkarg/3.


ssaammee__tteerrmm((_@_T_1_, _@_T_2))                                            _[_s_e_m_i_d_e_t_]
    True  if  _T_1   and  _T_2  are  the  equivalent  and  will  remain  the
    equivalent,  even  if setarg/3  is used  on either  of them.    This
    means  _T_1 and _T_2 are the same variable, equivalent atomic data  or a
    compound term allocated at the same address.


44..2211 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg AAttoommss

These  predicates  convert   between  Prolog  constants  and  lists   of
character codes.  The predicates atom_codes/2, number_codes/2 and name/2
behave the same when  converting from a constant to a list  of character
codes.     When converting  the  other  way  around,  atom_codes/2  will
generate an  atom, number_codes/2  will generate a  number or  exception
and name/2 will return a number if possible and an atom otherwise.

The  ISO  standard  defines atom_chars/2  to  describe  the  `broken-up'
atom  as a  list of  one-character atoms  instead of  a  list of  codes.
Up-to version 3.2.x, SWI-Prolog's  atom_chars/2behaved,  compatible with
Quintus and  SICStus Prolog,  like atom_codes.    As of 3.3.x  SWI-Prolog
atom_codes/2 and atom_chars/2are compliant to the ISO standard.

To  ease  the pain  of  all  variations in  the  Prolog  community,  all
SWI-Prolog predicates  behave as  flexible as  possible.   This  implies
the  `list-side' accepts  either  a code-list  or  a char-list  and  the
`atom-side' accept all atomic types (atom, number and string).


aattoomm__ccooddeess((_?_A_t_o_m_, _?_S_t_r_i_n_g))                                         _[_I_S_O_]
    Convert  between an atom and a list of character codes.   If _A_t_o_m is
    instantiated,  if will be translated into a list of  character codes
    and  the result  is unified with  _S_t_r_i_n_g.   If _A_t_o_m  is unbound  and
    _S_t_r_i_n_g  is a list of character  codes, it will _A_t_o_m will  be unified
    with an atom constructed from this list.


aattoomm__cchhaarrss((_?_A_t_o_m_, _?_C_h_a_r_L_i_s_t))                                       _[_I_S_O_]
    As  atom_codes/2, but  _C_h_a_r_L_i_s_t  is a  list of  one-character  atoms
    rather than a list of character codes.

    ?- atom_chars(hello, X).

    X = [h, e, l, l, o]


cchhaarr__ccooddee((_?_A_t_o_m_, _?_C_o_d_e))                                            _[_I_S_O_]
    Convert  between character and character  code for a single  charac-
    ter.


nnuummbbeerr__cchhaarrss((_?_N_u_m_b_e_r_, _?_C_h_a_r_L_i_s_t))                                   _[_I_S_O_]
    Similar  to  atom_chars/2,  but  converts between  a number  and  its
    representation  as a  list of  one-character atoms.    Fails with  a
    syntax_error if _N_u_m_b_e_r  is unbound and _C_h_a_r_L_i_s_t does not  describe a
    number.


nnuummbbeerr__ccooddeess((_?_N_u_m_b_e_r_, _?_C_o_d_e_L_i_s_t))                                   _[_I_S_O_]
    As number_chars/2, but converts to a list  of character codes rather
    than one-character atoms.   In the mode -, +, both predicates behave
    identically to improve handling of non-ISO source.


aattoomm__nnuummbbeerr((_?_A_t_o_m_, _?_N_u_m_b_e_r))
    Realises  the popular combination of atom_codes/2 and number_codes/2
    to  convert  between  atom and  number  (integer  or float)  in  one
    predicate,  avoiding the  intermediate list.   Calling  in mode  +,-
    to  convert  numbers  represented  as atoms  is  often  good  style.
    Converting  numbers  to atoms,  which  in  turn are  assembled  into
    larger  units before communication them to the outside world  is bad
    style.    Consider using streams  or with_output_to/2 to reduce  the
    number of expensive intermediate atoms.


nnaammee((_?_A_t_o_m_O_r_I_n_t_, _?_S_t_r_i_n_g))
    _S_t_r_i_n_g  is a list of character  codes representing the same text  as
    _A_t_o_m.  Each of  the arguments may be a variable, but not both.  When
    _S_t_r_i_n_g  is bound  to an  character code list  describing an  integer
    and  _A_t_o_m  is a  variable  _A_t_o_m will  be  unified with  the  integer
    value  described by _S_t_r_i_n_g  (e.g.   `name(N, "300"), 400 is N + 100'
    succeeds).


tteerrmm__ttoo__aattoomm((_?_T_e_r_m_, _?_A_t_o_m))
    True if _A_t_o_m describes  a term that unifies with _T_e_r_m.  When _A_t_o_m is
    instantiated _A_t_o_m is converted  and then unified with _T_e_r_m.  If _A_t_o_m
    has no  valid syntax, a syntax_errorexception is  raised.  Otherwise
    _T_e_r_m is ``written'' on _A_t_o_m using write/1.


aattoomm__ttoo__tteerrmm((_+_A_t_o_m_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))
    Use  _A_t_o_m as  input to  read_term/2 using the  option variable_names
    and  return  the read  term in  _T_e_r_m and  the  variable bindings  in
    _B_i_n_d_i_n_g_s.   _B_i_n_d_i_n_g_s is a list of _N_a_m_e =_V_a_r couples, thus providing
    access  to the actual  variable names.   See  also read_term/2.   If
    _A_t_o_m has no valid syntax, a syntax_error exception is raised.


aattoomm__ccoonnccaatt((_?_A_t_o_m_1_, _?_A_t_o_m_2_, _?_A_t_o_m_3))                                _[_I_S_O_]
    _A_t_o_m_3  forms the concatenation of _A_t_o_m_1 and _A_t_o_m_2.  At least  two of
    the  arguments must be instantiated  to atoms, integers or  floating
    point  numbers.    For  ISO  compliance,  the  instantiation-pattern
    -, -, +  is allowed  too, non-deterministically  splitting the  3-th
    argument  into two parts  (as append/3  does for lists).   See  also
    string_concat/3.


ccoonnccaatt__aattoomm((_+_L_i_s_t_, _-_A_t_o_m))
    _L_i_s_t  is  a  list of  atoms,  integers  or floating  point  numbers.
    Succeeds  if  _A_t_o_m can  be unified  with  the concatenated  elements
    of  _L_i_s_t.    If _L_i_s_t  has exactly  2 elements  it  is equivalent  to
    atom_concat/3, allowing for variables in the list.


ccoonnccaatt__aattoomm((_?_L_i_s_t_, _+_S_e_p_a_r_a_t_o_r_, _?_A_t_o_m))
    Creates  an  atom just  like  concat_atom/2, but  inserts  _S_e_p_a_r_a_t_o_r
    between each pair of atoms.  For example:

    ?- concat_atom([gnu, gnat], ', ', A).

    A = 'gnu, gnat'

    This  predicate can  also be  used to split  atoms by  instantiating
    _S_e_p_a_r_a_t_o_r and _A_t_o_m:

    ?- concat_atom(L, -, 'gnu-gnat').

    L = [gnu, gnat]


aattoomm__lleennggtthh((_+_A_t_o_m_, _-_L_e_n_g_t_h))                                        _[_I_S_O_]
    True  if _A_t_o_m is an atom of _L_e_n_g_t_h characters long.   This predicate
    also  works for  strings (see  section 4.23).   If  the prolog  flag
    iso  is _n_o_t  set, it  also accepts integers  and floats,  expressing
    the  number of characters  output when given  to write/1 as well  as
    code-lists and character-lists, expressing the length of the list.


aattoomm__pprreeffiixx((_+_A_t_o_m_, _+_P_r_e_f_i_x))
    True if _A_t_o_m starts  with the characters from _P_r_e_f_i_x.  Its behaviour
    is equivalent to ?- sub_atom(_A_t_o_m, 0, _, _, _P_r_e_f_i_x).  Depreciated.


ssuubb__aattoomm((_+_A_t_o_m_, _?_B_e_f_o_r_e_, _?_L_e_n_, _?_A_f_t_e_r_, _?_S_u_b))                       _[_I_S_O_]
    ISO  predicate  for breaking  atoms.    It maintains  the  following
    relation:  _S_u_b is  a sub-atom of _A_t_o_m that starts at _B_e_f_o_r_e, has _L_e_n
    characters and _A_t_o_m contains _A_f_t_e_r characters after the match.

    ?- sub_atom(abc, 1, 1, A, S).

    A = 1, S = b

    The implementation  minimises non-determinism and creation of atoms.
    This  is a very flexible predicate  that can do search, prefix-  and
    suffix-matching, etc.


44..2222 CChhaarraacctteerr pprrooppeerrttiieess

SWI-Prolog   offers  two   comprehensive  predicates   for   classifying
characters and character-codes.  These predicates are  defined as built-
in predicates  to exploit the  C-character classification's handling  of
_l_o_c_a_l_e (handling of  local character-sets).  These predicates  are fast,
logical and deterministic if applicable.

In addition,  there is  the library ctype  providing compatibility  with
some other Prolog systems.   The predicates of this library  are defined
in terms of code_type/2.


cchhaarr__ttyyppee((_?_C_h_a_r_, _?_T_y_p_e))
    Tests or generates  alternative _T_y_p_es or _C_h_a_rs.  The character-types
    are inspired by the standard C <ctype.h>  primitives.

    aallnnuumm
         _C_h_a_r is a letter (upper- or lowercase) or digit.

    aallpphhaa
         _C_h_a_r is a letter (upper- or lowercase).

    ccssyymm
         _C_h_a_r  is a  letter  (upper- or  lowercase),  digit or  the  un-
         derscore  (_).      These  are  valid  C-  and   Prolog  symbol
         characters.

    ccssyymmff
         _C_h_a_r is a letter  (upper- or lowercase) or the  underscore (_).
         These are valid first characters for C- and Prolog symbols

    aasscciiii
         _C_h_a_r is a 7-bits ASCII character (0..127).

    wwhhiittee
         _C_h_a_r is a space or tab.  E.i. white space inside a line.

    ccnnttrrll
         _C_h_a_r is an ASCII control-character (0..31).

    ddiiggiitt
         _C_h_a_r is a digit.

    ddiiggiitt((_W_e_i_g_t_h))
         _C_h_a_r is a digit with value  _W_e_i_g_t_h.  I.e. char_type(X, digit(6)
         yields _X = '6'.  Useful for parsing numbers.

    xxddiiggiitt((_W_e_i_g_t_h))
         _C_h_a_r  is  a  hexa-decimal  digit  with  value  _W_e_i_g_t_h.     I.e.
         char_type(a, xdigit(X) yields _X  = '10'.    Useful for  parsing
         numbers.

    ggrraapphh
         _C_h_a_r produces  a visible mark  on a  page when printed.    Note
         that the space is not included!

    lloowweerr
         _C_h_a_r is a lower-case letter.

    lloowweerr((_U_p_p_e_r))
         _C_h_a_r is a  lower-case version of _U_p_p_e_r.   Only true if _C_h_a_r  is
         lowercase and _U_p_p_e_r uppercase.

    ttoo__lloowweerr((_U_p_p_e_r))
         _C_h_a_r is  a lower-case version  of _U_p_p_e_r.   For non-letters,  or
         letter without case,  _C_h_a_r and  _L_o_w_e_r are the same.   See  also
         upcase_atom/2 and downcase_atom/2.

    uuppppeerr
         _C_h_a_r is an upper-case letter.

    uuppppeerr((_L_o_w_e_r))
         _C_h_a_r is an upper-case version  of _L_o_w_e_r.  Only true if  _C_h_a_r is
         uppercase and _L_o_w_e_r lowercase.

    ttoo__uuppppeerr((_L_o_w_e_r))
         _C_h_a_r is an  upper-case version of _L_o_w_e_r.   For non-letters,  or
         letter without case,  _C_h_a_r and  _L_o_w_e_r are the same.   See  also
         upcase_atom/2 and downcase_atom/2.

    ppuunncctt
         _C_h_a_r is  a punctuation character.   This  is a graph  character
         that is not a letter or digit.

    ssppaaccee
         _C_h_a_r  is some  form  of layout  character  (tab,  vertical-tab,
         newline, etc.).

    eenndd__ooff__ffiillee
         _C_h_a_r is -1.

    eenndd__ooff__lliinnee
         _C_h_a_r ends a line (ASCII: 10..13).

    nneewwlliinnee
         _C_h_a_r is a the newline character (10).

    ppeerriioodd
         _C_h_a_r counts as the end of a sentence (.,!,?).

    qquuoottee
         _C_h_a_r is a quote-character (", ', `).

    ppaarreenn((_C_l_o_s_e))
         _C_h_a_r is  an  open-parenthesis and  _C_l_o_s_e is  the  corresponding
         close-parenthesis.


ccooddee__ttyyppee((_?_C_o_d_e_, _?_T_y_p_e))
    As  char_type/2,  but uses character-codes rather than  one-character
    atoms.     Please note  that  both  predicates are  as  flexible  as
    possible.    They handle  either representation if  the argument  is
    instantiated  and  only will  instantiate with  an  integer code  or
    one-character  atom depending  of the version  used.   See also  the
    Prolog flag double_quotes, atom_chars/2 and atom_codes/2.


44..2222..11 CCaassee ccoonnvveerrssiioonn

There is nothing in  the Prolog standard for converting case  in textual
data.    The SWI-Prolog  predicates code_type/2 and  char_type/2 can  be
used to test  and convert individual characters.   We have started  some
additional support:


ddoowwnnccaassee__aattoomm((_+_A_n_y_C_a_s_e_, _-_L_o_w_e_r_C_a_s_e))
    Converts  the characters  of _A_n_y_C_a_s_e  into lowercase  as char_type/2
    does  (i.e. based on  the defined _l_o_c_a_l_e  if Prolog provides  locale
    support  on the  hosting platform)  and unifies  the lowercase  atom
    with _L_o_w_e_r_C_a_s_e.


uuppccaassee__aattoomm((_+_A_n_y_C_a_s_e_, _-_U_p_p_e_r_C_a_s_e))
    Converts, similar to downcase_atom/2, an atom to upper-case.


44..2222..22 WWhhiittee ssppaaccee nnoorrmmaalliizzaattiioonn


nnoorrmmaalliizzee__ssppaaccee((_-_O_u_t_, _+_I_n))
    Normalize  white  space in  _I_n.    All  leading and  trailing  white
    space  is removed.  All non-empty sequences for Unicode  white space
    characters  are replaces by a single space (\u0020) character.   _O_u_t
    uses the same conventions as with_output_to/2 and format/3.


44..2222..33 LLaanngguuaaggee ssppeecciiffiicc ccoommppaarriissoonn

This  section  deals  with  predicates  for   language  specific  string
comparison operations.


ccoollllaattiioonn__kkeeyy((_+_A_t_o_m_, _-_K_e_y))
    Create  a _K_e_y from _A_t_o_m for locale specific comparison.  The  key is
    defined  such that if the key of atom A precedes the  key of atom B
    in the  standard order of terms, A is alphabetically smaller than B
    using the sort order of the current locale.

    The   predicate  collation_key/2  is  used  by   locale_sort/2  from
    library(sort).   Please examine the  implementation of locale_sort/2
    as an example of using this call.

    The  _K_e_y  is  an  implementation defined  and  generally  unreadable
    string.    On systems that  do not support  locale-handling, _K_e_y  is
    simply unified with _A_t_o_m.


llooccaallee__ssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Sort  a list of atoms using the current  locale.  _L_i_s_t is a  list of
    atoms or string objects  (see section 4.23).  _S_o_r_t_e_d is unified with
    a  list containing all  atoms of  _L_i_s_t, sorted to  the rules of  the
    current locale.  See also collation_key/2 and setlocale/3.


44..2233 RReepprreesseennttiinngg tteexxtt iinn ssttrriinnggss

SWI-Prolog  supports the  data type  _s_t_r_i_n_g.   Strings  are  a time  and
space efficient mechanism to handle text in Prolog.   Strings are stored
as  a byte  array  on the  global (term)  stack  and thus  destroyed  on
backtracking and reclaimed by the garbage collector.

Strings were  added to  SWI-Prolog based on  an early  draft of the  ISO
standard,  offering a mechanism  to represent  temporary character  data
efficiently.    As  SWI-Prolog  strings can  handle  0-bytes,  they  are
frequently used through  the foreign language interface (section 9)  for
storing arbitrary byte-sequences.

Starting with version  3.3, SWI-Prolog offers garbage collection  on the
atom-space as well as  representing 0-bytes in atoms.   Although strings
and  atoms still  have  different  features,  new code  should  consider
using atoms to  avoid too many representations  for text as well as  for
compatibility with other Prolog implementations.  Below are  some of the
differences:

  o _c_r_e_a_t_i_o_n
    Creating  strings  is fast,  as the  data is  simply  copied to  the
    global  stack.   Atoms are  unique and  therefore more expensive  in
    terms  of memory  and time to  create.   On the other  hand, if  the
    same  text has  to be  represented  multiple times,  atoms are  more
    efficient.

  o _d_e_s_t_r_u_c_t_i_o_n
    Backtracking destroys strings at  no cost.  They are cheap to handle
    by  the garbage  collector, but  it should be  noted that  extensive
    use  of strings will cause many  garbage collections.  Atom  garbage
    collection is generally faster.

String objects  by default have no  lexical representation and thus  can
only  be created  using  the predicates  below  or through  the  foreign
language interface (See  chapter 9.  There  are two ways to make  read/1
read text into  strings, both controlled through  Prolog flags.  One  is
by setting the double_quotes flag to string and the other  is by setting
the backquoted_string flag  to true.   In latter case, `Hello world`  is
read into a  string and write_term/2 prints strings between  back-quotes
if quoted  is true.   This flag provides  compatibility with LPA  Prolog
string handling.


ssttrriinngg__ttoo__aattoomm((_?_S_t_r_i_n_g_, _?_A_t_o_m))
    Logical  conversion between  a string  and an atom.    At least  one
    of  the two arguments  must be instantiated.   _A_t_o_m  can also be  an
    integer or floating point number.


ssttrriinngg__ttoo__lliisstt((_?_S_t_r_i_n_g_, _?_L_i_s_t))
    Logical  conversion  between  a  string  and  a  list  of  character
    codes  characters.    At least  one  of the  two arguments  must  be
    instantiated.


ssttrriinngg__lleennggtthh((_+_S_t_r_i_n_g_, _-_L_e_n_g_t_h))
    Unify  _L_e_n_g_t_h  with  the number  of  characters  in _S_t_r_i_n_g.     This
    predicate  is  functionally  equivalent  to atom_length/2  and  also
    accepts atoms, integers and floats as its first argument.


ssttrriinngg__ccoonnccaatt((_?_S_t_r_i_n_g_1_, _?_S_t_r_i_n_g_2_, _?_S_t_r_i_n_g_3))
    Similar  to atom_concat/3,  but the unbound argument will  be unified
    with  a string object rather  than an atom.   Also, if both  _S_t_r_i_n_g_1
    and  _S_t_r_i_n_g_2 are  unbound and _S_t_r_i_n_g_3  is bound to  text, it  breaks
    _S_t_r_i_n_g_3,  unifying the start with  _S_t_r_i_n_g_1 and the end with  _S_t_r_i_n_g_2
    as append does with  lists.  Note that this is not particularly fast
    on  long strings  as  for each  redo the  system has  to create  two
    entirely  new  strings, while  the list  equivalent  only creates  a
    single new list-cell and moves some pointers around.


ssuubb__ssttrriinngg((_+_S_t_r_i_n_g_, _?_S_t_a_r_t_, _?_L_e_n_g_t_h_, _?_A_f_t_e_r_, _?_S_u_b))
    _S_u_b  is a substring of _S_t_r_i_n_g starting at _S_t_a_r_t, with  length _L_e_n_g_t_h
    and  _S_t_r_i_n_g has _A_f_t_e_r  characters left  after the match.   See  also
    sub_atom/5.


44..2244 OOppeerraattoorrss

Operators  are  defined  to  improve  the  readability  of  source-code.
For  example, without  operators, to  write  2*3+4*5 one  would have  to
write +(*(2,3),*(4,5)).    In Prolog,  a number of  operators have  been
predefined.   All operators, except for  the comma (,) can be  redefined
by the user.

Some care  has to  be taken  before defining  new operators.    Defining
too many  operators might  make your  source `natural'  looking, but  at
the same  time lead  to hard to  understand the  limits of your  syntax.
To ease  the pain, as  of SWI-Prolog 3.3.0,  operators are local to  the
module  in which  they are  defined.   Operators  can  be exported  from
modules using a  term op(_P_r_e_c_e_d_e_n_c_e_, _T_y_p_e_,  _N_a_m_e) in the export list  as
specified by module/2.  This is an extension  specific to SWI-Prolog and
the advised mechanism of portability is not an important concern.

The  module-table of  the module  user  acts as  default table  for  all
modules and can be  modified explicitly from inside a module  to achieve
compatibility with other Prolog systems:

:- module(prove,
          [ prove/1
          ]).

:- op(900, xfx, user:(=>)).

Unlike  what many  users  think,  operators  and quoted  atoms  have  no
relation:  defining  an atom as an  operator does nnoott influence  parsing
characters into atoms and  quoting an atom does nnoott stop it  from acting
as an operator.   To stop an atom  acting as an operator, enclose  it in
braces like this:  (myop).


oopp((_+_P_r_e_c_e_d_e_n_c_e_, _+_T_y_p_e_, _:_N_a_m_e))                                     _[_I_S_O_]
    Declare  _N_a_m_e  to  be  an  operator of  type  _T_y_p_e  with  precedence
    _P_r_e_c_e_d_e_n_c_e.    _N_a_m_e  can also  be a  list of  names,  in which  case
    all  elements of the  list are declared  to be identical  operators.
    _P_r_e_c_e_d_e_n_c_e  is an integer between 0 and 1200.  Precedence  0 removes
    the  declaration.   _T_y_p_e is one  of:   xf, yf, xfx,  xfy, yfx,  yfy,
    fy  or fx.   The `f'  indicates the position  of the functor,  while
    x  and y  indicate the position  of the  arguments.   `y' should  be
    interpreted  as ``on this position  a term with precedence lower  or
    equal to the precedence  of the functor should occur''.  For `x' the
    precedence  of the argument must be strictly lower.   The precedence
    of  a term is  0, unless  its principal functor  is an operator,  in
    which  case the precedence  is the precedence of  this operator.   A
    term enclosed in brackets (...) has precedence 0.

    The  predefined  operators  are shown  in  table  4.1.    Note  that
    although  all  operators  can be  redefined  by the  user,  this  is
    strongly  discouraged as  it often  leads to syntax  errors or  even
    different  semantic interpretations  when loading system  libraries.
    It  is  adviced to  keep operators  local to  modules  and load  the
    system modules you need before changing operators.
     ______________________________________________________________
     | 1200 |xfx  |-->, :-                                        |
     | 1200 | fx  |:-, ?-                                         |
     | 1150 | fx  |dynamic,  discontiguous, initialization,  mod- |
     |      |     |ule_transparent,    multifile,     thread_local,|
     |      |     |volatile                                       |

     | 1100 |xfy  |;, |                                           |
     | 1050 |xfy  |->, op*->                                      |
     | 1000 |xfy  |,                                              |
     |  900 | fy  |\+                                             |
     |  900 | fx  |~                                              |
     |  700 |xfx  |<, =, =.., =@=,  =:=, =<, ==, =\=,  >, >=, @<, |
     |      |     |@=<, @>, @>=, \=, \==, is                      |
     |  600 |xfy  |:                                              |

     |  500 | yfx |+, -, /\, \/, xor                              |
     |  500 | fx  |?                                              |
     |  400 | yfx |*, /, //, rdiv, <<, >>, mod, rem               |
     |  200 |xfx  |**                                             |
     |  200 |xfy  |^                                              |
     |__200_|_fy__|+,_-,_\________________________________________|_

                      Table 4.1:  System operators


ccuurrrreenntt__oopp((_?_P_r_e_c_e_d_e_n_c_e_, _?_T_y_p_e_, _?_:_N_a_m_e))                             _[_I_S_O_]
    True  if _N_a_m_e is currently defined as an operator of type  _T_y_p_e with
    precedence _P_r_e_c_e_d_e_n_c_e.  See also op/3.


44..2255 CChhaarraacctteerr CCoonnvveerrssiioonn

Although I  wouldn't really know  for what you would  like to use  these
features, they are provided for ISO compliance.


cchhaarr__ccoonnvveerrssiioonn((_+_C_h_a_r_I_n_, _+_C_h_a_r_O_u_t))                                 _[_I_S_O_]
    Define  that term-input (see  read_term/3)  maps each character  read
    as  _C_h_a_r_I_n to the character _C_h_a_r_O_u_t.   Character conversion is  only
    executed  if  the Prolog  flag char_conversion is  set  to true  and
    not  inside quoted atoms  or strings.   The initial table maps  each
    character onto itself.  See also current_char_conversion/2.


ccuurrrreenntt__cchhaarr__ccoonnvveerrssiioonn((_?_C_h_a_r_I_n_, _?_C_h_a_r_O_u_t))                         _[_I_S_O_]
    Queries    the   current   character   conversion-table.         See
    char_conversion/2 for details.


44..2266 AArriitthhmmeettiicc

Arithmetic can be  divided into some special purpose integer  predicates
and  a series  of general  predicates for  integer,  floating point  and
rational arithmetic as  appropriate.  The general arithmetic  predicates
all handle _e_x_p_r_e_s_s_i_o_n_s.   An expression is  either a simple number or  a
_f_u_n_c_t_i_o_n.  The  arguments of a function are expressions.   The functions
are described in section 4.26.2.3.


44..2266..11 SSppeecciiaall ppuurrppoossee iinntteeggeerr aarriitthhmmeettiicc

The predicates in  this section provide more logical operations  between
integers.  They  are not covered by the ISO standard, although  they are
`part of the community' and found as either library  or built-in in many
other Prolog systems.


bbeettwweeeenn((_+_L_o_w_, _+_H_i_g_h_, _?_V_a_l_u_e))
    _L_o_w  and _H_i_g_h are  integers, _H_i_g_h >=_L_o_w.   If  _V_a_l_u_e is an  integer,
    _L_o_w=< _V_a_l_u_e=< _H_i_g_h.   When _V_a_l_u_e  is a  variable it is  successively
    bound  to  all integers  between  _L_o_w and  _H_i_g_h.    If _H_i_g_h  is  inf
    or  infinite between/3 is  true iff _V_a_l_u_e>= _L_o_w,  a feature that  is
    particularly  interesting  for generating  integers from  a  certain
    value.


ssuucccc((_?_I_n_t_1_, _?_I_n_t_2))
    True  if _I_n_t_2= _I_n_t_1+1  and _I_n_t_1>=0.   At least one of the arguments
    must  be instantiated to  a natural number.   This predicate  raises
    the  domain-error  not_less_than_zero  if  called  with  a  negative
    integer.   E.g. succ(_X_, _0)  fails silently and succ(_X_, _-_1) raises  a
    domain-error.


pplluuss((_?_I_n_t_1_, _?_I_n_t_2_, _?_I_n_t_3))
    True  if _I_n_t_3 =_I_n_t_1 +_I_n_t_2.    At least two  of the  three arguments
    must be instantiated to integers.


44..2266..22 GGeenneerraall ppuurrppoossee aarriitthhmmeettiicc

The  general   arithmetic  predicates   are  optionally  compiled   (see
set_prolog_flag/2  and  the   -O  command  line   option).      Compiled
arithmetic reduces global  stack requirements and improves  performance.
Unfortunately compiled arithmetic cannot  be traced, which is why  it is
optional.


_+_E_x_p_r_1 > _+_E_x_p_r_2                                                   _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a larger number than _E_x_p_r_2.


_+_E_x_p_r_1 < _+_E_x_p_r_2                                                   _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a smaller number than _E_x_p_r_2.


_+_E_x_p_r_1 =< _+_E_x_p_r_2                                                  _[_I_S_O_]
    True  if expression _E_x_p_r_1 evaluates to a smaller or equal  number to
    _E_x_p_r_2.


_+_E_x_p_r_1 >= _+_E_x_p_r_2                                                  _[_I_S_O_]
    True  if expression _E_x_p_r_1 evaluates to  a larger or equal number  to
    _E_x_p_r_2.


_+_E_x_p_r_1 =\= _+_E_x_p_r_2                                                 _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a number non-equal to _E_x_p_r_2.


_+_E_x_p_r_1 =:= _+_E_x_p_r_2                                                 _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a number equal to  _E_x_p_r_2.


_-_N_u_m_b_e_r iiss _+_E_x_p_r                                                  _[_I_S_O_]
    True  if _N_u_m_b_e_r has successfully  been unified with the number  _E_x_p_r
    evaluates to.   If _E_x_p_r evaluates to a float that can be represented
    using  an integer (i.e,  the value is  integer and within the  range
    that can be  described by Prolog's integer representation),  _E_x_p_r is
    unified with the integer value.

    Note  that normally, is/2 should be used with unbound  left operand.
    If equality is to be tested, =:=/2 should be used.  For example:

             ?- 1 is sin(pi/2).   Fails!.   sin(pi/2) evaluates
                                  to the float  1.0, which does
                                  not unify with the integer 1.
             ?- 1 =:= sin(pi/2).  Succeeds as expected.


44..2266..22..11 AArriitthhmmeettiicc ttyyppeess

SWI-Prolog defines the following numeric types:

  o _i_n_t_e_g_e_r
    If  SWI-Prolog is built using the _G_N_U _m_u_l_t_i_p_l_e  _p_r_e_c_i_s_i_o_n _a_r_i_t_h_m_e_t_i_c
    _l_i_b_r_a_r_y  (GMP), integer  arithmetic is _u_n_b_o_u_n_d_e_d,  which means  that
    the  size of integers is limited by available memory only.   Without
    GMP,  SWI-Prolog  integers are  64-bits,  regardless of  the  native
    integer  size  of  the  platform.    The  type  of  integer  support
    can  be detected  using the  Prolog flags  bounded, min_integer  and
    max_integer.   As the use of GMP  is default, most of the  following
    descriptions assume unbounded integer arithmetic.

    Internally,  SWI-Prolog has  three integer  representations.   Small
    integers   (defined  by  the  Prolog  flag  max_tagged_integer)  are
    encoded  directly.  Larger integers are represented as  64-bit value
    on  the  global stack.    Integers that  do not  fit  in 64-bit  are
    represented as serialised GNU MPZ structures on the global stack.

  o _r_a_t_i_o_n_a_l _n_u_m_b_e_r
    Rational  numbers  (Q) are  quotients of  two  integers.   Rational
    arithmetic  is only provided if GMP  is used (see above).   Rational
    numbers  are currently not  supported by  a Prolog type.   They  are
    represented  by the compound  term rdiv(_N_,_M). Rational numbers  that
    are  returned from is/2  are _c_a_n_o_n_i_c_a_l, which  means M  is positive
    and  N  and  M have  no  common divisors.    Rational  numbers  are
    introduced  in the computation  using the rational/1,  rationalize/1
    or  the  rdiv/2  (rational  division)  function.    Using  the  same
    functor  for  rational division  and representing  rational  numbers
    allow  for passing rational numbers between computations as  well as
    to format/3 for printing.

    On  the long  term it is  likely that  rational numbers will  become
    _a_t_o_m_i_c  as  well as  subtype of  _n_u_m_b_e_r.    User code  that  creates
    or  inspects the  rdiv(_M_,_N)  terms will  not be  portable to  future
    versions.     Rationals  are  created using  one  of  the  functions
    mentioned above and inspected using rational/3.

  o _f_l_o_a_t
    Floating point numbers  are represented using the C-type double.  On
    most today platforms these are 64-bit IEEE floating point numbers.

Arithmetic functions that require integer arguments accept,  in addition
to integers,  rational numbers with  denominator `1' and floating  point
numbers that can be  accurately converted to integers.  If  the required
argument is  a float  the argument  is converted to  float.   Note  that
conversion of integers  to floating point numbers may raise  an overflow
exception.   In  all other cases,  arguments are  converted to the  same
type using the order below.

    integer ! rational number ! floating point number


44..2266..22..22 RRaattiioonnaall nnuummbbeerr eexxaammpplleess

The use  of rational numbers  with unbounded  integers allows for  exact
integer  or _f_i_x_e_d  _p_o_i_n_t  arithmetic under  the  addition,  subtraction,
multiplication  and division.    To exploit  rational arithmetic  rdiv/2
should  be used  instead  of `/'  and  floating  point numbers  must  be
converted to  rational using  rational/1.   Omitting  the rational/1  on
floats  will  convert a  rational  operand  to float  and  continue  the
arithmetic using floating point numbers.  Here are some examples.

              A is 2 rdiv 6                  A = 1 rdiv 3
              A is 4 rdiv 3 + 1              A = 7 rdiv 3
              A is 4 rdiv 3 + 1.5            A = 2.83333
              A is 4 rdiv 3 + rational(1.5)  A = 17 rdiv 6

Note that  floats cannot  represent all  decimal numbers exactly.    The
function  rational/1 creates  an _e_x_a_c_t  equivalent of  the float,  while
rationalize/1  creates  a  rational number  that  is  within  the  float
rounding error from the original float.  Please  check the documentation
of these functions for details and examples.

Rational  numbers can  be  printed  as decimal  numbers  with  arbitrary
precision using the format/3 floating point conversion:

?- A is 4 rdiv 3 + rational(1.5),
   format('~50f~n', [A]).
2.83333333333333333333333333333333333333333333333333

A = 17 rdiv 6


44..2266..22..33 AArriitthhmmeettiicc FFuunnccttiioonnss

Arithmetic functions  are terms  which are evaluated  by the  arithmetic
predicates described in  section 4.26.2.   SWI-Prolog tries to hide  the
difference  between integer  arithmetic  and floating  point  arithmetic
from the Prolog user.  Arithmetic is done as  integer arithmetic as long
as possible and  converted to floating point arithmetic whenever  one of
the arguments  or the combination of  them requires it.   If a  function
returns  a floating  point  value which  is  whole it  is  automatically
transformed into  an integer.    There are  four types  of arguments  to
functions:

       _E_x_p_r       Arbitrary   expression,   returning  either   a
                  floating point value or an integer.
       _I_n_t_E_x_p_r    Arbitrary expression  that  must evaluate  into
                  an integer.
       _R_a_t_E_x_p_r    Arbitrary expression that must evaluate  into a
                  rational number.
       _F_l_o_a_t_E_x_p_r  Arbitrary expression that must evaluate  into a

                  floating point.

For  systems using  bounded integer  arithmetic  (default is  unbounded,
see section 4.26.2.1  for details), integer operations that  would cause
overflow automatically convert to floating point arithmetic.


- _+_E_x_p_r                                                           _[_I_S_O_]
    _R_e_s_u_l_t =-_E_x_p_r


+ _+_E_x_p_r
    _R_e_s_u_l_t = _E_x_p_r.  Note that  if + is followed by  a number the parser
    discards the +.  I.e. ?- integer(+1) succeeds.


_+_E_x_p_r_1 + _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1 +_E_x_p_r_2


_+_E_x_p_r_1 - _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1 -_E_x_p_r_2


_+_E_x_p_r_1 * _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1_*Expr2


_+_E_x_p_r_1 / _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t = _E_x_p_r_1=_E_x_p_r_2 The the flag  iso is true,  both arguments are
    converted  to float  and the  return value is  a float.    Otherwise
    (default),  if both arguments are integers the operation  returns an
    integer if the division  is exact.  If at least one of the arguments
    is  rational  and  the  other argument  is  integer,  the  operation
    returns  a rational number.  In all other cases the return  value is
    a float.  See also ///2 and rdiv/2.


_+_I_n_t_E_x_p_r_1 mmoodd _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Modulo:     _R_e_s_u_l_t = _I_n_t_E_x_p_r_1 - (_I_n_t_E_x_p_r_1 div _I_n_t_E_x_p_r_2)  * _I_n_t_E_x_p_r_2,
    where div is _f_l_o_o_r_e_d division.


_+_I_n_t_E_x_p_r_1 rreemm _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Remainder   of  integer  division.     Behaves  as  if   defined  by
    _R_e_s_u_l_t is _I_n_t_E_x_p_r_1 - (_I_n_t_E_x_p_r_1 // _I_n_t_E_x_p_r_2)  * _I_n_t_E_x_p_r_2


_+_I_n_t_E_x_p_r_1 // _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Integer division:  _R_e_s_u_l_t is truncate(_E_x_p_r_1/_E_x_p_r_2)


_+_R_a_t_E_x_p_r rrddiivv _+_R_a_t_E_x_p_r
    Rational  number  division.    This function  is only  available  if
    SWI-Prolog  has been  compiled with  rational number support.    See
    section 4.26.2.2 for details.


aabbss((_+_E_x_p_r))                                                        _[_I_S_O_]
    Evaluate _E_x_p_r and return the absolute value of it.


ssiiggnn((_+_E_x_p_r))                                                       _[_I_S_O_]
    Evaluate to -1 if _E_x_p_r <0, 1 if _E_x_p_r >0 and 0 if _E_x_p_r =0.


mmaaxx((_+_E_x_p_r_1_, _+_E_x_p_r_2))
    Evaluates  to the largest of both  _E_x_p_r_1 and _E_x_p_r_2.  Both  arguments
    are  compared after  converting to  the  same type,  but the  return
    value  is in the original type.   For example, max(2.5,  3) compares
    the  two values after converting  to float, but returns the  integer
    3.


mmiinn((_+_E_x_p_r_1_, _+_E_x_p_r_2))
    Evaluates to the smallest  of both _E_x_p_r_1 and _E_x_p_r_2.  See max/2 for a
    description of type-handling.


.((_+_I_n_t_, _[_]))
    A  list of one element evaluates to  the element.  This  implies "a"
    evaluates  to the  character  code of  the letter  `a' (97).    This
    option  is available for  compatibility only.   It will not work  if
    `style_check(+string)'  is active as  "a" will  then be  transformed
    into a string object.   The recommended way to specify the character
    code of the letter `a' is 0'a.


rraannddoomm((_+_I_n_t_E_x_p_r))
    Evaluates to  a random integer _i for which 0=< i< _I_n_t_E_x_p_r.  The seed
    of  this random  generator is  determined by the  system clock  when
    SWI-Prolog was started.


rroouunndd((_+_E_x_p_r))                                                      _[_I_S_O_]
    Evaluates _E_x_p_r and rounds the result to the nearest integer.


iinntteeggeerr((_+_E_x_p_r))
    Same as round/1 (backward compatibility).


ffllooaatt((_+_E_x_p_r))                                                      _[_I_S_O_]
    Translate  the result to a floating point number.   Normally, Prolog
    will  use integers  whenever possible.    When used  around the  2nd
    argument  of is/2, the result will  be returned as a floating  point
    number.  In other contexts, the operation has no effect.


rraattiioonnaall((_+_E_x_p_r))
    Convert  the _E_x_p_r to  a rational  number or integer.   The  function
    returns  the input on integers and  rational numbers.  For  floating
    point  numbers, the returned rational number _e_x_a_c_t_l_y  represents the
    float.    As  floats cannot  exactly represent  all decimal  numbers
    the  results may  be surprising.    In the  examples below,  doubles
    can  represent 0.25 and  the result is as  expected, in contrast  to
    the  result of rational(_0_._1).   The function rationalize/1  remedies
    this.   See section 4.26.2.2 for more information on rational number
    support.

    ?- A is rational(0.25).

    A is 1 rdiv 4
    ?- A is rational(0.1).
    A = 3602879701896397 rdiv 36028797018963968


rraattiioonnaalliizzee((_+_E_x_p_r))
    Convert  the _E_x_p_r to  a rational  number or integer.   The  function
    is  similar to rational/1,  but the result  is only accurate  within
    the rounding error  of floating point numbers, generally producing a
    much smaller denominator.

    ?- A is rationalize(0.25).

    A = 1 rdiv 4
    ?- A is rationalize(0.1).

    A = 1 rdiv 10


ffllooaatt__ffrraaccttiioonnaall__ppaarrtt((_+_E_x_p_r))                                       _[_I_S_O_]
    Fractional  part  of a  floating-point  number.   Negative  if  _E_x_p_r
    is   negative,  rational  if   _E_x_p_r  is  rational  and  0  if   _E_x_p_r
    is   integer.        The  following   relation   is   always   true:
    Xisfloatfractionalpart(X)+ floatintegerpart(X).


ffllooaatt__iinntteeggeerr__ppaarrtt((_+_E_x_p_r))                                          _[_I_S_O_]
    Integer  part  of  floating-point  number.    Negative  if  _E_x_p_r  is
    negative, _E_x_p_r if _E_x_p_r is integer.


ttrruunnccaattee((_+_E_x_p_r))                                                   _[_I_S_O_]
    Truncate  _E_x_p_r to  an integer.    If _E_x_p_r>= 0  this is  the same  as
    floor(_E_x_p_r).   For  _E_x_p_r< 0 this is  the same as  ceil(_E_x_p_r).  E.i.
    truncate rounds towards zero.


fflloooorr((_+_E_x_p_r))                                                      _[_I_S_O_]
    Evaluates  _E_x_p_r and returns the largest integer smaller or  equal to
    the result of the evaluation.


cceeiilliinngg((_+_E_x_p_r))                                                    _[_I_S_O_]
    Evaluates  _E_x_p_r and returns the smallest integer larger or  equal to
    the result of the evaluation.


cceeiill((_+_E_x_p_r))
    Same as ceiling/1 (backward compatibility).


_+_I_n_t_E_x_p_r >> _+_I_n_t_E_x_p_r                                              _[_I_S_O_]
    Bitwise  shift  _I_n_t_E_x_p_r_1  by  _I_n_t_E_x_p_r_2  bits to  the  right.     The
    operation   performs  _a_r_i_t_h_m_e_t_i_c  _s_h_i_f_t,  which  implies   that  the
    inserted  most  significant bits  are copies  of  the original  most
    significant bit.


_+_I_n_t_E_x_p_r << _+_I_n_t_E_x_p_r                                              _[_I_S_O_]
    Bitwise shift _I_n_t_E_x_p_r_1 by _I_n_t_E_x_p_r_2 bits to the left.


_+_I_n_t_E_x_p_r \/ _+_I_n_t_E_x_p_r                                              _[_I_S_O_]
    Bitwise `or' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r /\ _+_I_n_t_E_x_p_r                                              _[_I_S_O_]
    Bitwise `and' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r xxoorr _+_I_n_t_E_x_p_r
    Bitwise `exclusive or' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


\ _+_I_n_t_E_x_p_r                                                        _[_I_S_O_]
    Bitwise  negation.   The returned value  is the one's complement  of
    _I_n_t_E_x_p_r.


ssqqrrtt((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =square root of _E_x_p_r


ssiinn((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =sine of _E_x_p_r.  _E_x_p_r is the angle in radians.


ccooss((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =cosine of _E_x_p_r.  _E_x_p_r is the angle in radians.


ttaann((_+_E_x_p_r))
    _R_e_s_u_l_t =tangus of _E_x_p_r.  _E_x_p_r is the angle in radians.


aassiinn((_+_E_x_p_r))
    _R_e_s_u_l_t =inverse sine of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aaccooss((_+_E_x_p_r))
    _R_e_s_u_l_t =inverse cosine of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aattaann((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =inverse tangus of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aattaann((_+_Y_E_x_p_r_, _+_X_E_x_p_r))
    _R_e_s_u_l_t = inverse tangus of _Y_E_x_p_r / _X_E_x_p_r.   _R_e_s_u_l_t is  the angle in
    radians.    The return  value is  in the  range [-pi:::pi].   Used  to
    convert between rectangular and polar coordinate system.


lloogg((_+_E_x_p_r))                                                        _[_I_S_O_]
    Natural logarithm.  _R_e_s_u_l_t =natural logarithm of _E_x_p_r


lloogg1100((_+_E_x_p_r))
    Base-10 logarithm.  _R_e_s_u_l_t =10 base logarithm of _E_x_p_r


eexxpp((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =e to the power _E_x_p_r


_+_E_x_p_r_1 ** _+_E_x_p_r_2                                                  _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1 to the power _E_x_p_r_2.   With unbounded integers and in-
    teger values for  _E_x_p_r_1 and a non-negative integer _E_x_p_r_2, the result
    is  always  integer.    The  integer  expressions  0 to the power I,
    1 to the power I  and -1 to the power I are  guaranteed to work  for
    any integer I.   Other integer base values generate a resource error
    if the result does not fit in memory.


ppoowwmm((_+_I_n_t_E_x_p_r_B_a_s_e_, _+_I_n_t_E_x_p_r_E_x_p_, _+_I_n_t_E_x_p_r_M_o_d))
    _R_e_s_u_l_t   =  (_I_n_t_E_x_p_r_B_a_s_e to the power _I_n_t_E_x_p_r_E_x_p) modulo _I_n_t_E_x_p_r_M_o_d.
    Only  available when compiled with unbounded integer support.   This
    formula  is required  for Diffie-Hellman  key-exchange, a  technique
    where two parties can establish a secret key over a public network.


_+_E_x_p_r_1 ^ _+_E_x_p_r_2
    Same as **/2.  (backward compatibility).


ppii
    Evaluates to the mathematical constant pi (3.14159...).


ee
    Evaluates to the mathematical constant e (2.71828...).


ccppuuttiimmee
    Evaluates  to a floating  point number expressing  the cpu time  (in
    seconds)  used by Prolog  up till  now.   See also statistics/2  and
    time/1.


eevvaall((_+_E_x_p_r))
    Evaluate  _E_x_p_r.   Although ISO standard  dictates that A=1+2,  B is
    A  works and unifies  B to 3,  it is widely felt  that source-level
    variables  in arithmetic  expressions  should have  been limited  to
    numbers.   In this  view the eval function  can be used to  evaluate
    arbitrary expressions.

BBiittvveeccttoorr ffuunnccttiioonnss

The  functions below  are  not  covered by  the  standard.    The  msb/1
function is compatible with hProlog.  The others  are private extensions
that improve handling of ---unbounded--- integers as bit-vectors.


mmssbb((_+_I_n_t_E_x_p_r))
    Return  the largest integer N  such that (IntExpr >> N) /\ 1 =:= 1.
    This  is the (zero-origin)  index of the  most significant 1 bit  in
    the  value of _I_n_t_E_x_p_r,  which must evaluate  to a positive  integer.
    Errors for 0, negative integers, and non-integers.


llssbb((_+_I_n_t_E_x_p_r))
    Return  the smallest integer N such that (IntExpr >> N) /\ 1 =:= 1.
    This  is the (zero-origin) index of  the least significant 1 bit  in
    the  value of IntExpr,  which must evaluate  to a positive  integer.
    Errors for 0, negative integers, and non-integers.


ppooppccoouunntt((_+_I_n_t_E_x_p_r))
    Return  the  number  of  1s  in the  binary  representation  of  the
    non-negative integer _I_n_t_E_x_p_r.


44..2277 AAddddiinngg AArriitthhmmeettiicc FFuunnccttiioonnss

Prolog predicates  can be given  the role of arithmetic  function.   The
last  argument is  used  to  return the  result,  the  arguments  before
the last  are the  inputs.   Arithmetic  functions are  added using  the
predicate arithmetic_function/1, which takes  the head as its  argument.
Arithmetic  functions  are module  sensitive,  that  is  they  are  only
visible from the module  in which the function is defined  and declared.
Global  arithmetic  functions  should be  defined  and  registered  from
module user.   Global definitions can  be overruled locally in  modules.
The built-in functions described above can be redefined as well.


aarriitthhmmeettiicc__ffuunnccttiioonn((_+_H_e_a_d))
    Register  a Prolog  predicate as an  arithmetic function (see  is/2,
    >/2 , etc.).   The Prolog  predicate should  have one more  argument
    than  specified by _H_e_a_d, which it either a term _N_a_m_e_/_A_r_i_t_y,  an atom
    or  a complex term.   This last argument  is an unbound variable  at
    call  time and  should  be instantiated  to an  integer or  floating
    point  number.    The other  arguments  are the  parameters.    This
    predicate  is  module  sensitive  and will  declare  the  arithmetic
    function  only for the context  module, unless declared from  module
    user.  Example:

    1 ?- [user].
    :- arithmetic_function(mean/2).

    mean(A, B, C) :-
            C is (A+B)/2.
    user compiled, 0.07 sec, 440 bytes.

    Yes
    2 ?- A is mean(4, 5).

    A = 4.500000


ccuurrrreenntt__aarriitthhmmeettiicc__ffuunnccttiioonn((_?_H_e_a_d))
    Successively unifies all  arithmetic functions that are visible from
    the context module with _H_e_a_d.


44..2288 BBuuiilltt--iinn lliisstt ooppeerraattiioonnss

Most  list  operations  are  defined  in  the  library  lists  described
in  section 11.11.    Some  that  are  implemented with  more  low-level
primitives are built-in and described here.


iiss__lliisstt((_+_T_e_r_m))
    True if _T_e_r_m is  bound to the empty list ([]) or a term with functor
    `.'  and arity 2 and the second argument is a list.   This predicate
    acts  as if defined by the definition  below on _a_c_y_c_l_i_c terms.   The
    implementation is _f_a_i_l_s safely if _T_e_r_m represents a cyclic list.

    is_list(X) :-
            var(X), !,
            fail.
    is_list([]).
    is_list([_|T]) :-
            is_list(T).


mmeemmbbeerrcchhkk((_?_E_l_e_m_, _+_L_i_s_t))
    Equivalent to member/2, but leaves no choice point.


lleennggtthh((_?_L_i_s_t_, _?_I_n_t))
    True if _I_n_t represents  the number of elements of list _L_i_s_t.  Can be
    used to create a list holding only variables.


ssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    True  if _S_o_r_t_e_d can be unified  with a list holding the elements  of
    _L_i_s_t,  sorted  to the  standard order  of terms  (see section  4.6).
    Duplicates  are removed.  The implementation is in C,  using _n_a_t_u_r_a_l
    _m_e_r_g_e _s_o_r_t.   The sort/2 predicate can sort a cyclic list, returning
    a non-cyclic version with the same elements.


mmssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Equivalent to sort/2, but  does not remove duplicates.  Fails with a
    type_error if _L_i_s_t is not a list or a cyclic list.


kkeeyyssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    List  is a proper list whose elements are _K_e_y-_V_a_l_u_e, that  is, terms
    whose  principal  functor is  (-)/2,  whose  first argument  is  the
    sorting  key, and whose second argument is the satellite data  to be
    carried  along with  the key.   keysort/2  sorts _L_i_s_t like  msort/2,
    but  only compares  the  keys.   It  is used  to sort  terms not  on
    standard  order, but  on any criterion  that can  be expressed on  a
    multi-dimensional scale.   Sorting on more than one criterion can be
    done  using terms as keys,  putting the first criterion as  argument
    1,  the second as argument 2,  etc.  The order of  multiple elements
    that have the same  _K_e_y is not changed.  The implementation is in C,
    using _n_a_t_u_r_a_l  _m_e_r_g_e _s_o_r_t.  Fails with a type_error if _L_i_s_t is not a
    list or a cyclic list or one of the elements of _L_i_s_t is not a _p_a_i_r.


pprreeddssoorrtt((_+_P_r_e_d_, _+_L_i_s_t_, _-_S_o_r_t_e_d))
    Sorts  similar to sort/2, but determines  the order of two terms  by
    calling  _P_r_e_d(-_D_e_l_t_a, +_E_1, +_E_2).   This call  must unify _D_e_l_t_a  with
    one  of <, >  or =.   If built-in predicate  compare/3 is used,  the
    result is the same as sort/2.  See also keysort/2.


mmeerrggee((_+_L_i_s_t_1_, _+_L_i_s_t_2_, _-_L_i_s_t_3))
    _L_i_s_t_1  and _L_i_s_t_2 are  lists, sorted to  the standard order of  terms
    (see  section 4.6).    _L_i_s_t_3 will be  unified with  an ordered  list
    holding  both the elements of _L_i_s_t_1  and _L_i_s_t_2.  Duplicates are  nnoott
    removed.


mmeerrggee__sseett((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))
    _S_e_t_1  and _S_e_t_2 are lists without duplicates, sorted to  the standard
    order  of terms.    _S_e_t_3  is unified  with an  ordered list  without
    duplicates holding the union of the elements of _S_e_t_1 and _S_e_t_2.


44..2299 FFiinnddiinngg aallll SSoolluuttiioonnss ttoo aa GGooaall


ffiinnddaallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                                   _[_I_S_O_]
    Creates  a list of the instantiations _T_e_m_p_l_a_t_e gets  successively on
    backtracking  over _G_o_a_l and unifies the  result with _B_a_g.   Succeeds
    with  an  empty  list  if _G_o_a_l  has  no  solutions.    findall/3  is
    equivalent  to  bagof/3  with  all free  variables  bound  with  the
    existential  operator (^), except that  bagof/3 fails when goal  has
    no solutions.


ffiinnddaallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g_, _+_T_a_i_l))
    As  findall/3,   but  returns  the  result  as  the  difference-list
    _B_a_g-_T_a_i_l.  The 3-argument version is defined as

    findall(Templ, Goal, Bag) :-
            findall(Templ, Goal, Bag, [])


bbaaggooff((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                                     _[_I_S_O_]
    Unify  _B_a_g  with the  alternatives of  _T_e_m_p_l_a_t_e,  if _G_o_a_l  has  free
    variables   besides  the  one  sharing  with  _T_e_m_p_l_a_t_e   bagof  will
    backtrack  over the alternatives  of these free variables,  unifying
    _B_a_g with the  corresponding alternatives of _T_e_m_p_l_a_t_e.  The construct
    +_V_a_r^_G_o_a_l  tells bagof not to  bind _V_a_r in _G_o_a_l.   bagof/3 fails  if
    _G_o_a_l has no solutions.

    The  example below  illustrates bagof/3  and the  ^ operator.    The
    variable bindings are printed together on one line to save paper.

    2 ?- listing(foo).

    foo(a, b, c).
    foo(a, b, d).
    foo(b, c, e).
    foo(b, c, f).
    foo(c, c, g).

    Yes
    3 ?- bagof(C, foo(A, B, C), Cs).

    A = a, B = b, C = G308, Cs = [c, d] ;
    A = b, B = c, C = G308, Cs = [e, f] ;
    A = c, B = c, C = G308, Cs = [g] ;

    No
    4 ?- bagof(C, A^foo(A, B, C), Cs).

    A = G324, B = b, C = G326, Cs = [c, d] ;
    A = G324, B = c, C = G326, Cs = [e, f, g] ;

    No
    5 ?-


sseettooff((_+_T_e_m_p_l_a_t_e_, _+_G_o_a_l_, _-_S_e_t))                                     _[_I_S_O_]
    Equivalent  to bagof/3, but sorts the  result using sort/2 to get  a
    sorted list of alternatives without duplicates.


44..3300 IInnvvookkiinngg PPrreeddiiccaatteess oonn aallll MMeemmbbeerrss ooff aa LLiisstt

All the predicates in this section call a predicate on  all members of a
list or until the  predicate called fails.  The predicate is  called via
call/[2..], which  implies common arguments can be  put in front of  the
arguments obtained from the list(s).  For example:

?- maplist(plus(1), [0, 1, 2], X).

X = [1, 2, 3]

we phrase this as ``_P_r_e_d_i_c_a_t_e is applied on ...''

Currently, the predicates below are defined as built-in  predicates.  It
is planned to move  these to library(apply).  See section 11.2  for more
predicates.  The  library(apply_macros) defines macros that  compile some
of these meta-calling constructs away.


mmaapplliisstt((_:_P_r_e_d_, _+_L_i_s_t))
    _P_r_e_d  is applied successively on each element of _L_i_s_t until  the end
    of the list or _P_r_e_d fails.  In the latter case the maplist/2 fails.


mmaapplliisstt((_:_P_r_e_d_, _?_L_i_s_t_1_, _?_L_i_s_t_2))
    Apply  _P_r_e_d  on all  successive  pairs of  elements from  _L_i_s_t_1  and
    _L_i_s_t_2.    Fails if  _P_r_e_d can  not be  applied to a  pair.   See  the
    example above.


mmaapplliisstt((_:_P_r_e_d_, _?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_3))
    Apply  _P_r_e_d on all successive triples of elements from  _L_i_s_t_1, _L_i_s_t_2
    and  _L_i_s_t_3.  Fails if _P_r_e_d can not be applied to a triple.   See the
    example above.


44..3311 FFoorraallll


ffoorraallll((_:_C_o_n_d_, _:_A_c_t_i_o_n))                                        _[_s_e_m_i_d_e_t_]
    For  all alternative bindings  of _C_o_n_d  _A_c_t_i_o_n can be  proven.   The
    example  verifies that all arithmetic  statements in the list _L  are
    correct.  It does not say which is wrong if one proves wrong.

    ?- forall(member(Result = Formula, [2 = 1 + 1, 4 = 2 * 2]),
                     Result =:= Formula).


44..3322 FFoorrmmaatttteedd WWrriittee

The  current  version   of  SWI-Prolog  provides  two  formatted   write
predicates.    The  first  is writef/[1,2],  which  is  compatible  with
Edinburgh C-Prolog.   The  second is  format/[1,2], which is  compatible
with Quintus  Prolog.   We hope  the Prolog  community will once  define
a  standard formatted  write predicate.    If you  want performance  use
format/[1,2] as this predicate is defined in  C. Otherwise compatibility
reasons might tell you which predicate to use.


44..3322..11 WWrriitteeff


wwrriitteellnn((_+_T_e_r_m))
    Equivalent to write(Term), nl.


wwrriitteeff((_+_A_t_o_m))
    Equivalent to writef(Atom, []).


wwrriitteeff((_+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    Formatted  write.    _F_o_r_m_a_t  is an  atom  whose characters  will  be
    printed.    _F_o_r_m_a_t may contain  certain special character  sequences
    which   specify   certain  formatting   and  substitution   actions.
    _A_r_g_u_m_e_n_t_s then provides all the terms required to be output.

    Escape sequences to generate a single special character:

             __________________________________________________
             | \n   |Output  a  newline  character  (see  also |
             |      |nl/[0,1])                                 |
             | \l   |Output a line separator (same as \n)      |

             | \r   |Output   a   carriage-return    character |
             |      |(ASCII 13)                                |
             | \t   |Output the ASCII character TAB (9)        |
             | \\   |The character \ is output                 |
             | \%   |The character % is output                 |
             | \nnn |where <_n_n_n>  is an  integer  (1-3 digits) |
             |      |the character  with character  code <_n_n_n> |

             |______|is_output_(NB_:_<_n_n_n>_is_read_as_ddeecciimmaall)_|

    Note  that  \l,   \nnn  and  \\  are  interpreted  differently  when
    character-escapes are in effect.  See section 2.15.1.2.

    Escape  sequences to include  arguments from _A_r_g_u_m_e_n_t_s.   Each  time
    a  %  escape sequence  is found  in _F_o_r_m_a_t  the  next argument  from
    _A_r_g_u_m_e_n_t_s is formatted according to the specification.

              _________________________________________________%t

              | %w  print/1 the next item (mnemonic:  term)   |    |

              | %q  |write/1the next item                     |

              |     |writeq/1the next item                    |
              | %d  |Write the term,  ignoring operators.  See|
              |     |also  write_term/2.      Mnemonic:    old|
              | %p  |Edinburgh display/1.                     |

              |     |print/1the next item (identical to %t)   |
              | %n  |Put the  next item as  a character (i.e.,|

              |     |it is a character code)                  |
              | %r  |Write the  next item  N times where  N is|
              |     |the second item (an integer)             |
              | %s  |Write the  next item  as a String  (so it|
              |     |must be a list of characters)            |
              | %f  |Perform a ttyflush/0 (no items used)     |
              | %Nc |Write  the   next  item  Centered  in  N |

              |     |columns.                                 |
              | %Nl |Write the next  item Left justified in N |
              |     |columns.                                 |
              | %Nr |Write the next item Right justified in N |
              |     |columns.   N is a decimal number with  at|
              |     |least  one digit.   The  item must  be an|
              |_____|atom,_integer,_float_or_string.__________|_


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    Equivalent to writef/2,  but ``writes'' the result on _S_t_r_i_n_g instead
    of the current output stream.  Example:

    ?- swritef(S, '%15L%w', ['Hello', 'World']).

    S = "Hello          World"


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t))
    Equivalent to swritef(String, Format, []).


44..3322..22 FFoorrmmaatt


ffoorrmmaatt((_+_F_o_r_m_a_t))
    Defined as `format(Format) :- format(Format, []).'


ffoorrmmaatt((_+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    _F_o_r_m_a_t  is an  atom, list of  character codes,  or a Prolog  string.
    _A_r_g_u_m_e_n_t_s   provides   the   arguments  required   by   the   format
    specification.   If only one argument is required and this is  not a
    list  of character codes  the argument  need not be  put in a  list.
    Otherwise the arguments are put in a list.

    Special sequences start  with the tilde (~), followed by an optional
    numeric  argument, followed by a character describing the  action to
    be  undertaken.  A numeric argument is either a sequence  of digits,
    representing  a  positive decimal  number, a  sequence `<_c_h_a_r_a_c_t_e_r>,
    representing the character  code value of the character (only useful
    for  ~t) or a asterisk  (*), in when  the numeric argument is  taken
    from  the next  argument of  the argument  list, which  should be  a
    positive integer.

    Numeric  conversion (d, D,  e, E, f, g  and G) accept an  arithmetic
    expression  as argument.    This  is introduced  to handle  rational
    numbers  transparently (see  section 4.26.2.2.   The floating  point
    conversions  allow  for unlimited  precision for  printing  rational
    numbers in decimal form.

      ~  Output the tilde itself.

      a  Output the next argument, which  must be an atom.   This option
         is equivalent to  ww, except for  that it requires the  argument
         to be an atom.

      c  Interpret the next argument as an character code and  add it to
         the output.   This argument should  be an integer in the  range
         [0, ..., 255] (including 0 and 255).

      d  Output  next argument  as  a decimal  number.    It  should  be
         an integer.    If  a numeric  argument is  specified  a dot  is
         inserted _a_r_g_u_m_e_n_t  positions from the  right (useful for  doing
         fixed point arithmetic with integers, such as  handling amounts
         of money).

      D  Same as dd, but  makes large values easier to read  by inserting
         a comma every three digits left to the dot or right.

      e  Output next argument as a floating point  number in exponential
         notation.    The  numeric  argument  specifies  the  precision.
         Default is  6 digits.   Exact representation  depends on the  C
         library function printf().   This function is invoked  with the
         format %.<_p_r_e_c_i_s_i_o_n>e.

      E  Equivalent  to ee,  but  outputs a  capital  E to  indicate  the
         exponent.

      f  Floating point  in non-exponential  notation.    See C  library
         function printf().

      g  Floating point in ee or ff notation, whichever is shorter.

      G  Floating point in EE or ff notation, whichever is shorter.

      i  Ignore  next argument  of  the  argument  list.    Produces  no
         output.

      k  Give the next argument to (write_canonical/1).

      n  Output a newline character.

      N  Only output  a newline  if the  last character  output on  this
         stream was not a newline.  Not properly implemented yet.

      p  Give the next argument to print/1.

      q  Give the next argument to writeq/1.

      r  Print integer  in radix the  numeric argument  notation.   Thus
         ~16r prints its argument  hexadecimal.  The argument  should be
         in the range [2; :::;36].   Lower case letters are used for  digits
         above 9.

      R  Same as rr, but uses upper case letters for digits above 9.

      s  Output text  from a list  of character codes  or a string  (see
         string/1 and section 4.23) from the next argument.

      @  Interpret the next argument as  a goal and execute it.   Output
         written to the current_output stream is inserted at this place.
         Goal is  called in the  module calling format/3.   This  option
         is not  present  in the  original  definition by  Quintus,  but
         supported by some other Prolog systems.

      t  All remaining space between 2 tab stops  is distributed equally
         over ~t  statements  between the  tab  stops.   This  space  is
         padded with  spaces by  default.   If an  argument is  supplied
         this is taken  to be the character  code of the character  used
         for padding.  This  can be used to do left or  right alignment,
         centering, distributing, etc.   See also  ~| and ~+ to set  tab
         stops.  A tab stop is assumed at the start of each line.

      |  Set a  tab stop on  the current position.    If an argument  is
         supplied set  a  tab stop  on the  position  of that  argument.
         This  will  cause  all  ~t's  to  be  distributed  between  the
         previous and this tab stop.

      +  Set a tab stop relative  to the current position.   Further the
         same as ~|.

      w  Give the next argument to write/1.

      W  Give  the   next   two  argument   to  write_term/2.       E.g.
         format(' W', [Term, [numbervars(true)]]).     This   option  is
         SWI-Prolog specific.

    Example:

    simple_statistics :-
        <obtain statistics>         % left to the user
        format('~tStatistics~t~72|~n~n'),
        format('Runtime: ~`.t ~2f~34|  Inferences: ~`.t ~D~72|~n',
                                                [RunT, Inf]),
        ....

    Will output

                                 Statistics

    Runtime: .................. 3.45  Inferences: .......... 60,345


ffoorrmmaatt((_+_O_u_t_p_u_t_, _+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    As  format/2, but write  the output on  the given _O_u_t_p_u_t.   The  de-
    facto  standard only allows _O_u_t_p_u_t to  be a stream.  The  SWI-Prolog
    implementation  allows  all  valid  arguments for  with_output_to/2.
    For example:

    ?- format(atom(A), '~D', [1000000]).
    A = '1,000,000'


44..3322..33 PPrrooggrraammmmiinngg FFoorrmmaatt


ffoorrmmaatt__pprreeddiiccaattee((_+_C_h_a_r_, _+_H_e_a_d))
    If  a sequence ~c (tilde, followed by some character) is  found, the
    format  derivatives will first check whether the user has  defined a
    predicate  to handle the format.   If  not, the built in  formatting
    rules  described above are  used.   _C_h_a_r is  either an ascii  value,
    or  a one character atom,  specifying the letter to be  (re)defined.
    _H_e_a_d  is a  term, whose  name and  arity are used  to determine  the
    predicate  to call  for  the redefined  formatting character.    The
    first  argument to  the  predicate is  the numeric  argument of  the
    format  command, or the  atom default if  no argument is  specified.
    The  remaining arguments  are filled from  the argument  list.   The
    example  below redefines ~n to produce _A_r_g times return  followed by
    linefeed (so a (Grr.)  DOS machine is happy with the output).

    :- format_predicate(n, dos_newline(_Arg)).

    dos_newline(default) :- !,
            dos_newline(1).
    dos_newline(N) :-
            (   N > 0
            ->  write('\r\n'),
                N2 is N - 1,
                dos_newline(N2)
            ;   true
            ).


ccuurrrreenntt__ffoorrmmaatt__pprreeddiiccaattee((_?_C_o_d_e_, _?_:_H_e_a_d))
    Enumerates  all  user-defined  format  predicates.     _C_o_d_e  is  the
    character  code of the  format character.   _H_e_a_d  is unified with  a
    term  with  the same  name  and arity  as  the predicate.    If  the
    predicate  does not reside  in module user,  _H_e_a_d is qualified  with
    the definition module of the predicate.


44..3333 TTeerrmmiinnaall CCoonnttrrooll

The  following  predicates  form  a  simple  access   mechanism  to  the
Unix  termcap library  to provide  terminal independent  I/O for  screen
terminals.  These  predicates are only available on Unix machines.   The
SWI-Prolog Windows consoles accepts the ANSI escape sequences.


ttttyy__ggeett__ccaappaabbiilliittyy((_+_N_a_m_e_, _+_T_y_p_e_, _-_R_e_s_u_l_t))
    Get  the  capability named  _N_a_m_e  from the  termcap  library.    See
    termcap(5)  for the capability  names.   _T_y_p_e specifies the type  of
    the  expected result, and is one of string, number or bool.   String
    results  are returned as  an atom, number  result as an integer  and
    bool  results as the atom on or off.   If an option cannot  be found
    this predicate fails  silently.  The results are only computed once.
    Successive queries on the same capability are fast.


ttttyy__ggoottoo((_+_X_, _+_Y))
    Goto  position  (_X, _Y) on  the screen.    Note  that the  predicates
    line_count/2  and  line_position/2 will  not  have  a  well  defined
    behaviour while using this predicate.


ttttyy__ppuutt((_+_A_t_o_m_, _+_L_i_n_e_s))
    Put  an  atom  via the  termcap  library  function tputs().     This
    function  decodes padding  information  in the  strings returned  by
    tty_get_capability/3 and  should be  used to  output these  strings.
    _L_i_n_e_s is the number  of lines affected by the operation, or 1 if not
    applicable (as in almost all cases).


sseett__ttttyy((_-_O_l_d_S_t_r_e_a_m_, _+_N_e_w_S_t_r_e_a_m))
    Set  the  output  stream,  used by  tty_put/2  and tty_goto/2  to  a
    specific stream.  Default is user_output.


ttttyy__ssiizzee((_-_R_o_w_s_, _-_C_o_l_u_m_n_s))
    Determine the size of the terminal.  Platforms:

    UUnniixx  If  the  system  provides _i_o_c_t_l  calls  for  this,  these  are
         used and tty_size/2 properly  reflects the actual size after  a
         user resize  of the window.    As a fallback,  the system  uses
         tty_get_capability/3 using li  and co  capabilities.   In  this
         case the reported size reflects the size at the  first call and
         is not updated after a user-initiated resize of the terminal.

    WWiinnddoowwss  Getting  the   size  of  the   terminal  is  provided   for
         plwin.exe.   The  requested  value reflects  the current  size.
         For the multi-threaded  version the console that is  associated
         with the user_input stream is used.


44..3344 OOppeerraattiinngg SSyysstteemm IInntteerraaccttiioonn


sshheellll((_+_C_o_m_m_a_n_d_, _-_S_t_a_t_u_s))
    Execute  _C_o_m_m_a_n_d on the operating system.   _C_o_m_m_a_n_d is given to  the
    Bourne  shell (/bin/sh).  _S_t_a_t_u_s is unified with the exit  status of
    the command.

    On  _W_i_n_3_2  systems,  shell/[1,2]  executes  the  command  using  the
    CreateProcess()  API and  waits for the  command to  terminate.   If
    the  command  ends with  a &  sign,  the command  is  handed to  the
    WinExec()  API, which does not wait  for the new task to  terminate.
    See  also  win_exec/2  and  win_shell/2.     Please  note  that  the
    CreateProcess()  API does nnoott imply the Windows  command interpreter
    (command.exe  on  Windows  95/98  and  cmd.exe  on  Windows-NT)  and
    therefore  commands  built-in to  the command-interpreter  can  only
    be   activated  using  the  command  interpreter.      For  example:
    'command.exe /C copy file1.txt file2.txt'


sshheellll((_+_C_o_m_m_a_n_d))
    Equivalent to `shell(Command, 0)'.


sshheellll
    Start  an  interactive  Unix  shell.     Default  is  /bin/sh,   the
    environment  variable SHELL overrides this  default.  Not  available
    for Win32 platforms.


wwiinn__eexxeecc((_+_C_o_m_m_a_n_d_, _+_S_h_o_w))
    Win32  systems only.    Spawns a  Windows task  without waiting  for
    its  completion.   _S_h_o_w is one of  the Win32 SW_* constants  written
    in  lowercase  without the  SW_*:   hide maximize  minimize  restore
    show showdefault  showmaximized showminimized showminnoactive showna
    shownoactive  shownormal.   In  addition,  iconic is  a synonym  for
    minimize and normal for shownormal


wwiinn__sshheellll((_+_O_p_e_r_a_t_i_o_n_, _+_F_i_l_e_, _+_S_h_o_w))
    Win32  systems only.    Opens the  document _F_i_l_e  using the  windows
    shell-rules  for doing  so.   _O_p_e_r_a_t_i_o_n  is  one of  open, print  or
    explore  or  another operation  registered with  the  shell for  the
    given document-type.   On modern systems it is also possible to pass
    a  URL as _F_i_l_e, opening  the URL in Windows  default browser.   This
    call interfaces to  the Win32 API ShellExecute().  The _S_h_o_w argument
    determines  the initial state  of the opened window  (if any).   See
    win_exec/2 for defined values.


wwiinn__sshheellll((_+_O_p_e_r_a_t_i_o_n_, _+_F_i_l_e))
    Same as win_shell(_O_p_e_r_a_t_i_o_n_, _F_i_l_e_, _n_o_r_m_a_l)


wwiinn__rreeggiissttrryy__ggeett__vvaalluuee((_+_K_e_y_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Win32  systems only.   Fetches  the value of  a Win32 registry  key.
    _K_e_y  is  an  atom  formed  as a  path-name  describing  the  desired
    registry  key.    _N_a_m_e is  the desired  attribute name  of the  key.
    _V_a_l_u_e  is unified with the  value.  If  the value is of type  DWORD,
    the  value is  returned as an  integer.   If the  value is a  string
    it  is returned as  a Prolog atom.   Other  types are currently  not
    supported.    The default  `root' is HKEY_CURRENT_USER. Other  roots
    can be  specified explicitly as HKEY_CLASSES_ROOT, HKEY_CURRENT_USER,
    HKEY_LOCAL_MACHINE  or HKEY_USERS.  The  example below  fetches  the
    extension  to use for  Prolog files (see  README.TXT on the  Windows
    version):

    ?- win_registry_get_value('HKEY_LOCAL_MACHINE/Software/SWI/Prolog',
                              fileExtension,
                              Ext).

    Ext = pl


wwiinn__ffoollddeerr((_?_N_a_m_e_, _-_D_i_r_e_c_t_o_r_y))
    Is  true if  _N_a_m_e is  the Windows  `CSIDL' of  _D_i_r_e_c_t_o_r_y.   If  _N_a_m_e
    is  unbound all  known Windows special  paths are  generated.   _N_a_m_e
    is  the  CSIDL after  deleting the  leading CSIDL_  and mapping  the
    constant  to lowercase.    Check the Windows  documentation for  the
    function  SHGetSpecialFolderPath() for a description of  the defined
    constants.  This example extracts the `My Documents' folder:

    ?- win_folder(personal, MyDocuments).

    MyDocuments = 'C:/Documents and Settings/jan/My Documents'


ggeetteennvv((_+_N_a_m_e_, _-_V_a_l_u_e))
    Get  environment variable.    Fails  silently if  the variable  does
    not  exist.     Please  note that  environment  variable  names  are
    case-sensitive on Unix systems and case-insensitive on Windows.


sseetteennvv((_+_N_a_m_e_, _+_V_a_l_u_e))
    Set  an environment variable.   _N_a_m_e and _V_a_l_u_e must be  instantiated
    to  atoms or  integers.   The  environment variable  will be  passed
    to  shell/[0-2] and  can be  requested using  getenv/2.   They  also
    influence  expand_file_name/2.    Environment variables  are  shared
    between  threads.  Depending  on the underlying C library,  setenv/2
    and  unsetenv/1 may not be  thread-safe and may cause memory  leaks.
    Only  changing the environment once  and before starting threads  is
    safe in all versions of SWI-Prolog.


uunnsseetteennvv((_+_N_a_m_e))
    Remove  an environment variable from the environment.   Some systems
    lack  the underlying unsetenv() library function.  On  these systems
    unsetenv/1 sets the variable to the empty string.


sseettllooccaallee((_+_C_a_t_e_g_o_r_y_, _-_O_l_d_, _+_N_e_w))
    Set/Query  the  _l_o_c_a_l_e  setting which  tells  the C-library  how  to
    interpret  text-files,  write  numbers, dates,  etc.    Category  is
    one  of all, collate,  ctype, messages,  monetary, numeric or  time.
    For  details,  please consult  the  C-library locale  documentation.
    See  also section 2.17.1.    Please note that  the locale is  shared
    between  all  threads and  thread-safe usage  of  setlocale/3 is  in
    general  not  possible.     Do  locale  operations  before  starting
    threads  or thoroughly  study  threading aspects  of locale  support
    in  your  environment  before use  in  multi-threaded  environments.
    Locale  settings  are  used  by format_time/3,  collation_key/2  and
    locale_sort/2.


uunniixx((_+_C_o_m_m_a_n_d))
    This  predicate comes  from  the Quintus  compatibility library  and
    provides  a partial implementation thereof.   It provides access  to
    some operating system  features and unlike the name suggests, is not
    operating system specific.  Defined _C_o_m_m_a_n_d's are below.

    ssyysstteemm((_+_C_o_m_m_a_n_d))
         Equivalent to calling shell/1.  Use for compatibility only.

    sshheellll((_+_C_o_m_m_a_n_d))
         Equivalent to calling shell/1.  Use for compatibility only.

    sshheellll
         Equivalent to calling shell/0.  Use for compatibility only.

    ccdd
         Equivalent to calling working_directory/2 to the expansion (see
         expand_file_name/2) of ~.  For compatibility only.

    ccdd((_+_D_i_r_e_c_t_o_r_y))
         Equivalent to calling working_directory/2.  Use for compatibil-
         ity only.

    aarrggvv((_-_A_r_g_v))
         Unify _A_r_g_v with the list of command-line  arguments provides to
         this Prolog run.  Please note that  Prolog system-arguments and
         application arguments are separated  by --.  Integer  arguments
         are  passed as  Prolog  integers,  float arguments  and  Prolog
         floating  point  numbers and  all  other  arguments  as  Prolog
         atoms.  New applications should use the Prolog flag argv.   See
         also prolog Prolog flag argv.

         A  stand-alone program  could  use  the following  skeleton  to
         handle command-line arguments.  See also section 2.10.2.4.

         main :-
                 current_prolog_flag(argv, Argv),
                 append(_PrologArgs, [--|AppArgs], Argv), !,
                 main(AppArgs).


44..3344..11 DDeeaalliinngg wwiitthh ttiimmee aanndd ddaattee

Representing  time in  a computer  system  is surprisingly  complicated.
There are a large number of time representations in  use and the correct
choice depends  on factors such as  compactness, resolution and  desired
operations.   Humans tend to  think about time  in hours, days,  months,
years or  centuries.   Physicists  think about time  in seconds.    But,
a  month does  not  have a  defined  number  of seconds.    Even  a  day
does not  have a defined  number of seconds  as sometimes a  leap-second
is introduced  to synchronise properly  with our earth's  rotation.   At
the same  time, resolution demands  range from better then  pico-seconds
to millions  of years.    Finally, civilizations  have a  wide range  of
calendars.   Although there  exist libraries dealing  with most if  this
complexity,  our desire  to keep  Prolog clean  and lean  stops us  from
fully supporting these.

For human-oriented tasks,  time can be broken into years, months,  days,
hours,  minutes, seconds  and a  timezone.   Physicists  prefer to  have
time in an arithmetic type representing seconds or  fraction thereof, so
basic arithmetic  deal with  comparison and  durations.   An  additional
advantage  of the  physicists approach  is that  it  requires much  less
space.   For these  reasons, SWI-Prolog uses an  arithmetic type as  its
prime time representation.

Many C  libraries deal with time  using fixed-point arithmetic,  dealing
with a large  but finite time interval at  constant resolution.  In  our
opinion using  a floating point  number is a more  natural choice as  we
can use a natural unit and the interface does not need  to be changed if
a higher resolution  is required in the future.   Our unit of choice  is
the second as it is  the scientific unit.  We have placed our  origin at
1970-1-1T0:0:0Z for compatibility with the POSIX notion of  time as well
as with older time support provided by SWI-Prolog.

Where  older versions  of  SWI-Prolog  relied on  the  POSIX  conversion
functions, the current implementation uses libtai  to realise conversion
between  time-stamps and  calendar  dates for  a  period of  10  million
years.


44..3344..11..11 TTiimmee aanndd ddaattee ddaattaa--ssttrruuccttuurreess

We use the following time representations

TTiimmeeSSttaammpp
    A  TimeStamp  is a  floating  point number  expression the  time  in
    seconds since the Epoch at 1970-1-1.

ddaattee((_Y_,_M_,_D_,_H_,_M_n_,_S_,_O_f_f_,_T_Z_,_D_S_T))
    We  call this term a  _d_a_t_e_-_t_i_m_e structure.   The first 5 fields  are
    integers  expressing  the year,  month  (1..12), day  (1..31),  hour
    (0..23),  Minute  (0..59).    The _S  field holds  the  seconds as  a
    floating  point number  between 0.0  and 60.0.   _O_f_f  is an  integer
    representing  the offset relative to  UTC in seconds where  positive
    values  are west of Greenwhich.   If converted from local time  (see
    stamp_date_time/3, _T_Z holds the name of the local timezone.   If the
    timezone  is not known _T_Z is  the atom -.   _D_S_T is true if  daylight
    saving  time applies to the  current time, false if daylight  saving
    time is relevant but not  effective and - if unknown or the timezone
    has no daylight saving time.

ddaattee((_Y_,_M_._D))
    Date  using the  same values as  described above.   Extracted  using
    date_time_value/3.

ttiimmee((_H_,_M_n_,_S))
    Time  using the  same values as  described above.   Extracted  using
    date_time_value/3.


44..3344..11..22 TTiimmee aanndd ddaattee pprreeddiiccaatteess


ggeett__ttiimmee((_-_T_i_m_e_S_t_a_m_p))
    Return  the current time as a _T_i_m_e_S_t_a_m_p.  The granularity  is system
    dependent.  See section 4.34.1.1.


ssttaammpp__ddaattee__ttiimmee((_+_T_i_m_e_S_t_a_m_p_, _-_D_a_t_e_T_i_m_e_, _+_T_i_m_e_Z_o_n_e))
    Convert  a _T_i_m_e_S_t_a_m_p  to a _D_a_t_e_T_i_m_e  in the  given time zone.    See
    section 4.34.1.1 for  details on the data-types.  _T_i_m_e_Z_o_n_e describes
    the timezone for the  conversion.  It is one of local to extract the
    local  time, 'UTC' to extract at  UTC time or an integer  describing
    the seconds west of Greenwhich.


ddaattee__ttiimmee__ssttaammpp((_+_D_a_t_e_T_i_m_e_, _-_T_i_m_e_S_t_a_m_p))
    Compute  the timestamp from a date/9  term.  Values for month,  day,
    hour,  minute or second  need not be  normalized.  This  flexibility
    allows  for easy  computation of  the time  at any  given number  of
    these  units from a given timestamp.  Normalization can  be achieved
    following  this call with stamp_date_time/3.  This example  computes
    the date 200 days after 2006-7-14:

    ?- date_time_stamp(date(2006,7,214,0,0,0,0,-,-), Stamp),
       stamp_date_time(Stamp, D, 0),
       date_time_value(date, D, Date).
    Date = date(2007, 1, 30)


ddaattee__ttiimmee__vvaalluuee((_?_K_e_y_, _+_D_a_t_e_T_i_m_e_, _?_V_a_l_u_e))
    Extract values from a date/9 term.  Provided keys are:

       ______________________________________________________________kkeeyyvvaalluuee
       ____________________________________________________________________________________________________________________________yearCalendar year as an integer

        month            Calendar month as an integer 1..12
        day              Calendar day as an integer 1..31
        hour             Clock hour as an integer 0..23

        minute           Clock minute as an integer 0..59
        second           Clock second as a float 0.0..60.0
        utc_offset       Offset to UTC in seconds (positive is west)
        time_zone        Name of timezone; fails if unknown
        daylight_saving  Bool (true) if dst is effective
        date             Term date(_Y_,_M_,_D)
       _time_____________Term_time(_H_,_M_,_S)____________________________


ffoorrmmaatt__ttiimmee((_+_O_u_t_, _+_F_o_r_m_a_t_, _+_S_t_a_m_p_O_r_D_a_t_e_T_i_m_e))
    Modelled  after POSIX strftime(),  using GNU extensions.   _O_u_t is  a
    destination  as specified with with_output_to/2.  _F_o_r_m_a_t is  an atom
    or string with  the following conversions.  Conversions start with a
    tilde (%) character.

      a  The abbreviated weekday  name according to the current  locale.
         Use format_time/4 for POSIX locale.

      A  The full  weekday name according  to the current  locale.   Use
         format_time/4 for POSIX locale.

      b  The abbreviated  month name  according to  the current  locale.
         Use format_time/4 for POSIX locale.

      B  The full  month name  according  to the  current locale.    Use
         format_time/4 for POSIX locale.

      c  The preferred  date  and time  representation for  the  current
         locale.

      C  The century number (year/100) as a 2-digit integer.

      d  The day of the month as a decimal number (range 01 to 31).

      D  Equivalent  to  %m/%d/%y.      (Yecch    for  Americans   only.
         Americans  should note  that  in  other countries  %d/%m/%y  is
         rather common.   This means that in international  context this
         format is ambigu ous and should not be used.)

      e  Like %d,  the  day of  the month  as a  decimal number,  but  a
         leading zero is replaced by a space.

      E  Modifier.  Not implemented.

      F  Equivalent to %Y-%m-%d (the ISO 8601 date format).

      g  Like  %G,  but without  century,  i.e.,  with  a  2-digit  year
         (00-99).

      G  The ISO  8601  year with  century as  a decimal  number.    The
         4-digit year  corresponding to  the ISO week  number (see  %V).
         This has the  same format and value as  %y, except that if  the
         ISO week  number belongs  to the  previous or  next year,  that
         year is used instead.

      V  The ISO 8601:1988 week number of the current year  as a decimal
         number, range  01 to 53,  where week 1 is  the first week  that
         has at least  4 days in  the current year,  and with Monday  as
         the first day of the week.  See also %U and %W.

      h  Equivalent to %b.

      H  The hour as  a decimal number using  a 24-hour clock (range  00
         to 23).

      I  The hour as  a decimal number using  a 12-hour clock (range  01
         to 12).

      j  The day of the year as a decimal number (range 001 to 366).

      k  The hour (24-hour clock)  as a decimal number (range 0  to 23);
         single digits are preceded by a blank.  (See also %H.)

      l  The hour (12-hour clock)  as a decimal number (range 1  to 12);
         single digits are preceded by a blank.  (See also %I.)

      m  The month as a decimal number (range 01 to 12).

      M  The minute as a decimal number (range 00 to 59).

      n  A newline character.

      O  Modifier.  Not implemented.

      p  Either `AM' or `PM'  according to the given time value,  or the
         corresponding strings for the current locale.   Noon is treated
         as `pm' and midnight as `am'.

      P  Like %p  but in  lowercase:  `am'  or `pm'  or a  corresponding
         string for the current locale.

      r  The time in  a.m. or p.m. notation.   In the POSIX locale  this
         is equivalent to `%I:%M:%S %p'.

      R  The time in 24-hour  notation (%H:%M). For a version  including
         the seconds, see %T below.

      s  The number of seconds  since the Epoch, i.e., since  1970-01-01
         00:00:00 UTC.

      S  The second as  a decimal number (range 00  to 60).  (The  range
         is up to 60 to allow for occasional leap seconds.)

      t  A tab character.

      T  The time in 24-hour notation (%H:%M:%S).

      u  The day of the  week as a decimal,  range 1 to 7, Monday  being
         1.  See also %w.

      U  The week number of the current year as a  decimal number, range
         00 to 53,  starting with the first  Sunday as the first day  of
         week 01.  See also %V and %W.

      w  The day of the  week as a decimal,  range 0 to 6, Sunday  being
         0.  See also %u.

      W  The week number of the current year as a  decimal number, range
         00 to 53,  starting with the first  Monday as the first day  of
         week 01.

      x  The  preferred  date  representation  for  the  current  locale
         without the time.

      X  The  preferred  time  representation  for  the  current  locale
         without the date.

      y  The year  as a decimal  number without a  century (range 00  to
         99).

      Y  The year as a decimal number including the century.

      z  The  time-zone  as hour  offset  from  GMT.  Required  to  emit
         RFC822-conformant dates (using "%a, %d %b %Y %H:%M:%S %z").

      Z  The time zone or name or abbreviation.

      +  The date and time in date(1) format.

      %  A literal `%' character.


ffoorrmmaatt__ttiimmee((_+_O_u_t_, _+_F_o_r_m_a_t_, _+_S_t_a_m_p_O_r_D_a_t_e_T_i_m_e_, _+_L_o_c_a_l_e))
    Format  time  given  a  specified  _L_o_c_a_l_e.    This  predicate  is  a
    work-around  for   lacking  proper  portable  and  thread-safe  time
    and  locale  handling  in current  C  libraries.    In  its  current
    implementation  the only value  allowed for  _L_o_c_a_l_e is posix,  which
    currently  only modifies the behaviour or  the a, A, b and  B format
    specifiers.   The predicate is used to be able to emit  POSIX locale
    week  and month names for emitting standardised time-stamps  such as
    RFC1123.


ppaarrssee__ttiimmee((_+_T_e_x_t_, _-_S_t_a_m_p))
    Parse  a  textual  time  representation,   producing  a  time-stamp.
    Supported formats for _T_e_x_t are:

                 __________________________________________
                 |__NNaammee__________||EExxaammppllee______________________________________________||
                 ||_RFC_1123_|Fri,_08_Dec_2006_15:29:44_GMT_|


44..3344..22 CCoonnttrroolllliinngg tthhee PLWIN.EXE ccoonnssoollee wwiinnddooww

The Windows executable  PLWIN.EXE console has a number of  predicates to
control the  appearance of  the console.    Being totally  non-portable,
we do  not advice using  it for your  own application,  but use XPCE  or
another  portable GUI  platform instead.    We give  the predicates  for
reference here.


wwiinnddooww__ttiittllee((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d with the  title displayed in  the console and change  the
    title to _N_e_w.


wwiinn__wwiinnddooww__ppooss((_+_L_i_s_t_O_f_O_p_t_i_o_n_s))
    Interface  to the  MS-Windows  SetWindowPos() function,  controlling
    size,  position and stacking order of the window.   _L_i_s_t_O_f_O_p_t_i_o_n_s is
    a list that may hold any number of the terms below.

    ssiizzee((_W_, _H))
         Change the  size of  the window.    _W  and _H  are expressed  in
         character-units.

    ppoossiittiioonn((_X_, _Y))
         Change the  top-left corner  of  the window.    The values  are
         expressed in pixel units.

    zzoorrddeerr((_Z_O_r_d_e_r))
         Change the  location  in the  window stacking  order.    Values
         are bottom, top,  topmost and notopmost.   _T_o_p_m_o_s_t windows  are
         displayed above all other windows.

    sshhooww((_B_o_o_l))
         If true, show the window, if false hide the window.

    aaccttiivvaattee
         If present, activate the window.


wwiinn__hhaass__mmeennuu
    True if win_insert_menu/2 and win_insert_menu_item/4are present.


wwiinn__iinnsseerrtt__mmeennuu((_+_L_a_b_e_l_, _+_B_e_f_o_r_e))
    Insert  a new entry  (pulldown) in the  menu.   If the menu  already
    contains  this entry,  nothing  is done.    The _L_a_b_e_l  is the  label
    and  using the  Windows conventions,  a  letter prefixed  with &  is
    underlined  and defines the associated  accelerator key.  _B_e_f_o_r_e  is
    the label before which this one  must be inserted.  Using - adds the
    new  entry at the end (right).   For example, the call below  adds a
    Application entry just before the Help menu.

    win_insert_menu('&Application', '&Help')


wwiinn__iinnsseerrtt__mmeennuu__iitteemm((_+_P_u_l_l_d_o_w_n_, _+_L_a_b_e_l_, _+_B_e_f_o_r_e_, _:_G_o_a_l))
    Add  an  item  to  the  named  _P_u_l_l_d_o_w_n menu.     _L_a_b_e_l  and  _B_e_f_o_r_e
    are  handled  as in  win_insert_menu/2,  but the  label -  inserts  a
    _s_e_p_a_r_a_t_o_r.  _G_o_a_l is called if the user selects the item.


44..3355 FFiillee SSyysstteemm IInntteerraaccttiioonn


aacccceessss__ffiillee((_+_F_i_l_e_, _+_M_o_d_e))
    True  if _F_i_l_e  exists and  can be  accessed by  this prolog  process
    under  mode _M_o_d_e.   _M_o_d_e is  one of the  atoms read, write,  append,
    exist,  none or execute.  _F_i_l_e may also be the name  of a directory.
    Fails  silently otherwise.   access_file(File, none)simply  succeeds
    without testing anything.

    If  `Mode' is write or append,  this predicate also succeeds if  the
    file  does not exist and the user has write-access to  the directory
    of the specified location.


eexxiissttss__ffiillee((_+_F_i_l_e))
    True if _F_i_l_e exists  and is a regular file.  This does not imply the
    user has read and/or write permission for the file.


ffiillee__ddiirreeccttoorryy__nnaammee((_+_F_i_l_e_, _-_D_i_r_e_c_t_o_r_y))
    Extracts  the  directory-part  of  _F_i_l_e.    The  returned  _D_i_r_e_c_t_o_r_y
    name  does  not end  in  /.   There  are  two special  cases.    The
    directory-name of /  is / itself and the directory-name if _F_i_l_e does
    not contain any / characters is ..


ffiillee__bbaassee__nnaammee((_+_F_i_l_e_, _-_B_a_s_e_N_a_m_e))
    Extracts the filename part  from a path specification.  If _F_i_l_e does
    not contain any directory separators, _F_i_l_e is returned.


ssaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    True  if both  filenames  refer to  the same  physical file.    That
    is,  if _F_i_l_e_1  and _F_i_l_e_2  are the  same string or  both names  exist
    and  point to the  same file (due to  hard or symbolic links  and/or
    relative vs.  absolute paths).


eexxiissttss__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    True  if  _D_i_r_e_c_t_o_r_y exists  and  is  a directory.    This  does  not
    imply  the user  has read, search  and or  write permission for  the
    directory.


ddeelleettee__ffiillee((_+_F_i_l_e))
    Remove _F_i_l_e from the file system.


rreennaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    Rename  _F_i_l_e_1 into _F_i_l_e_2.   Currently  files cannot be moved  across
    devices.


ssiizzee__ffiillee((_+_F_i_l_e_, _-_S_i_z_e))
    Unify _S_i_z_e with the size of _F_i_l_e in characters.


ttiimmee__ffiillee((_+_F_i_l_e_, _-_T_i_m_e))
    Unify  the last  modification time of  _F_i_l_e with  _T_i_m_e.   _T_i_m_e is  a
    floating  point number expressing the  seconds elapsed since Jan  1,
    1970.  See also convert_time/[2,8] and get_time/1.


aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e_, _-_A_b_s_o_l_u_t_e))
    Expand  a  local file-name  into an  absolute path.    The  absolute
    path  is canonised:   references  to .  and ..  are deleted.    This
    predicate  ensures that  expanding a file-name  it returns the  same
    absolute  path regardless of how the file is addressed.   SWI-Prolog
    uses  absolute file  names to register  source files independent  of
    the  current working directory.  See also absolute_file_name/3.   See
    also absolute_file_name/3 and expand_file_name/2.


aabbssoolluuttee__ffiillee__nnaammee((_+_S_p_e_c_, _+_O_p_t_i_o_n_s_, _-_A_b_s_o_l_u_t_e))
    Converts  the  given  file  specification  into  an  absolute  path.
    _O_p_t_i_o_n is a list of options to guide the conversion:

    eexxtteennssiioonnss((_L_i_s_t_O_f_E_x_t_e_n_s_i_o_n_s))
         List of  file-extensions to  try.   Default is  ''.   For  each
         extension,  absolute_file_name/3 will first  add the  extension
         and then verify  the conditions imposed  by the other  options.
         If the  condition  fails, the  next extension  of  the list  is
         tried.   Extensions  may be specified  both as  ..ext or  plain
         ext.

    rreellaattiivvee__ttoo((_+_F_i_l_e_O_r_D_i_r))
         Resolve the path relative  to the given directory or  directory
         the  holding   the  given   file.       Without  this   option,
         paths  are   resolved   relative  to   the  working   directory
         (see   working_directory/2)   or,   if   _S_p_e_c  is   atomic   and
         absolute_file_name/[2,3] is executed  in a  directive, it  uses
         the current source-file as reference.

    aacccceessss((_M_o_d_e))
         Imposes the condition  access_file(_F_i_l_e, _M_o_d_e).   _M_o_d_e is on  of
         read, write, append, exist or none.  See also access_file/2.

    ffiillee__ttyyppee((_T_y_p_e))
         Defines  extensions.    Current  mapping:   txt  implies  [''],
         prolog  implies ['.pl', ''],  executable  implies  ['.so', ''],
         qlf implies  ['.qlf', '']  and  directory implies  [''].    The
         file-type source is an alias for prolog  for compatibility with
         SICStus Prolog.  See also prolog_file_type/2.

    ffiillee__eerrrroorrss((_f_a_i_l_/_e_r_r_o_r))
         If error (default), throw and  existence_error exception  if the
         file cannot be found.  If fail, stay silent.

    ssoolluuttiioonnss((_f_i_r_s_t_/_a_l_l))
         If  first (default),  the  predicates leaves  no  choice-point.
         Otherwise a  choice-point  will be  left and  backtracking  may
         yield more solutions.

    eexxppaanndd((_t_r_u_e_/_f_a_l_s_e))
         If  true  (default   is  false)  and   _S_p_e_c  is  atomic,   call
         expand_file_name/2  followed  by   member/2   on  _S_p_e_c   before
         proceeding.  This is a SWI-Prolog extension.

    The  Prolog  flag verbose_file_search can  be set  to  true to  help
    debugging Prolog's search for files.

    Compatibility  considerations with common  argument-order in ISO  as
    well  as SICStus absolute_file_name/3forced us to  be flexible here.
    If  the last argument is a list  and the 2nd not, the  arguments are
    swapped,  making the call absolute_file_name(_+_S_p_e_c_,  _-_P_a_t_h_, _+_O_p_t_i_o_n_s)
    valid as well.


iiss__aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e))
    True  if _F_i_l_e specifies  and absolute path-name.   On Unix  systems,
    this   implies  the  path  starts  with  a  `/'.      For  Microsoft
    based   systems  this  implies  the   path  starts  with  <_l_e_t_t_e_r>:.
    This   predicate   is  intended   to  provide   platform-independent
    checking  for  absolute paths.    See also  absolute_file_name/2 and
    prolog_to_os_filename/2.


ffiillee__nnaammee__eexxtteennssiioonn((_?_B_a_s_e_, _?_E_x_t_e_n_s_i_o_n_, _?_N_a_m_e))
    This  predicate is used to add, remove or test  filename extensions.
    The  main reason  for  its introduction  is to  deal with  different
    filename  properties  in a  portable manner.    If  the file  system
    is   case-insensitive,  testing  for  an  extension  will   be  done
    case-insensitive too.   _E_x_t_e_n_s_i_o_n may be specified with or without a
    leading  dot (.).  If an _E_x_t_e_n_s_i_o_n is generated, it will  not have a
    leading dot.


eexxppaanndd__ffiillee__nnaammee((_+_W_i_l_d_C_a_r_d_, _-_L_i_s_t))
    Unify  _L_i_s_t with  a  sorted list  of files  or directories  matching
    _W_i_l_d_C_a_r_d.   The  normal Unix wildcard  constructs `?', `*',  `[...]'
    and  `{...}'  are recognised.    The  interpretation  of `{...}'  is
    interpreted  slightly different  from  the C  shell (csh(1)).    The
    comma  separated  argument  can  be  arbitrary  patterns,  including
    `{...}'  patterns.  The empty pattern is legal as  well:  `\{.pl,\}'
    matches either `.pl' or the empty string.

    If  the pattern  does contains  wildcard  characters, only  existing
    files  and directories are returned.  Expanding a  `pattern' without
    wildcard  characters returns the argument, regardless on  whether or
    not it exists.

    Before  expanding wildcards, the construct  $_v_a_r is expanded to  the
    value  of the  environment  variable _v_a_r  and a  possible leading  ~
    character is expanded to the user's home directory..


pprroolloogg__ttoo__ooss__ffiilleennaammee((_?_P_r_o_l_o_g_P_a_t_h_, _?_O_s_P_a_t_h))
    Converts  between the internal  Prolog pathname conventions and  the
    operating-system  pathname conventions.    The internal  conventions
    are  Unix and this predicates is  equivalent to =/2 (unify) on  Unix
    systems.   On  DOS systems it  will change the  directory-separator,
    limit  the filename length map dots,  except for the last one,  onto
    underscores.


rreeaadd__lliinnkk((_+_F_i_l_e_, _-_L_i_n_k_, _-_T_a_r_g_e_t))
    If _F_i_l_e points to  a symbolic link, unify _L_i_n_k with the value of the
    link and _T_a_r_g_e_t to  the file the link is pointing to.  _T_a_r_g_e_t points
    to  a file, directory or non-existing entry in the file  system, but
    never  to a link.   Fails if _F_i_l_e  is not a link.   Fails always  on
    systems that do not support symbolic links.


ttmmpp__ffiillee((_+_B_a_s_e_, _-_T_m_p_N_a_m_e))
    Create  a name for a temporary file.  _B_a_s_e is an  identifier for the
    category  of file.  The _T_m_p_N_a_m_e is guaranteed to be unique.   If the
    system  halts, it  will automatically  remove all created  temporary
    files.    _B_a_s_e is  used as  part of the  final filename.    Portable
    applications should limit themselves to alphanumerical characters.

    Because  it is possible to  guess the generated filename,  attackers
    may  create the  filesystem entry as  a link  and possibly create  a
    security  issue.   This call must be  replaced with a new  predicate
    that  combines generating the filename and creating the  file, based
    on mkstemp() or tmpfile().


mmaakkee__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    Create  a  new directory  (folder) on  the filesystem.    Raises  an
    exception  on failure.   On Unix systems,  the directory is  created
    with default permissions (defined by the process _u_m_a_s_k setting).


ddeelleettee__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    Delete directory (folder)  from the filesystem.  Raises an exception
    on failure.   Please note that in general it will not be possible to
    delete a non-empty directory.


wwoorrkkiinngg__ddiirreeccttoorryy((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d with an  absolute path to  the current working  directory
    and   change  working   directory  to   _N_e_w.      Use  the   pattern
    working_directory(_C_W_D_, _C_W_D) to get the current directory.   See also
    absolute_file_name/2 and chdir/1.   Note that the working  directory
    is shared between all threads.


cchhddiirr((_+_P_a_t_h))
    Compatibility predicate.  New code should use working_directory/2.


44..3366 UUsseerr TToopp--lleevveell MMaanniippuullaattiioonn


bbrreeaakk
    Recursively  start a new  Prolog top level.   This Prolog top  level
    has its own  stacks, but shares the heap with all break environments
    and  the top level.  Debugging  is switched off on entering  a break
    and  restored on leaving one.   The break environment is  terminated
    by  typing the  system's end-of-file character  (control-D). If  the
    -t toplevel  command  line  option is  given  this goal  is  started
    instead of entering the default interactive top level (prolog/0).


aabboorrtt
    Abort  the Prolog  execution  and restart  the top  level.   If  the
    -t toplevel  command  line options  is given  this  goal is  started
    instead of entering the default interactive top level.

    There  are two  implementations of abort/0.    The default one  uses
    the  exception  mechanism  (see  throw/1),  throwing  the  exception
    $aborted.   The other one uses the C-construct longjmp()  to discard
    the  entire environment  and rebuild a  new one.   Using  exceptions
    allows  for  proper recovery  of predicates  exploiting  exceptions.
    Rebuilding  the  environment  is  safer if  the  Prolog  stacks  are
    corrupt.    Therefore the  system will use  the rebuild-strategy  if
    the  abort was generated  by an internal  consistency check and  the
    exception  mechanism otherwise.   Prolog  can be  forced to use  the
    rebuild-strategy  setting  the Prolog  flag  abort_with_exception to
    false.


hhaalltt                                                              _[_I_S_O_]
    Terminate  Prolog  execution.   Open  files are  closed  and if  the
    command  line option  -tty is  not active the  terminal status  (see
    Unix  stty(1)) is restored.  Hooks may be registered both  in Prolog
    and  in foreign code.  Prolog hooks  are registered using at_halt/1.
    halt/0 is equivalent to halt(0).


hhaalltt((_+_S_t_a_t_u_s))                                                     _[_I_S_O_]
    Terminate  Prolog  execution  with  given  status.    Status  is  an
    integer.  See also halt/0.


pprroolloogg
    This  goal starts the  default interactive top  level.  Queries  are
    read from  the stream user_input.  See  also the Prolog flag history.
    The  prolog/0  predicate  is  terminated (succeeds)  by  typing  the
    end-of-file character (typically control-D).

The following  two hooks allow  for expanding  queries and handling  the
result of  a query.    These hooks are  used by  the top-level  variable
expansion mechanism described in section 2.8.


eexxppaanndd__qquueerryy((_+_Q_u_e_r_y_, _-_E_x_p_a_n_d_e_d_, _+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook  in module  user, normally  not defined.    _Q_u_e_r_y and  _B_i_n_d_i_n_g_s
    represents  the  query read  from  the user  and  the names  of  the
    free  variables as obtained  using read_term/3.   If this  predicate
    succeeds, it should  bind _E_x_p_a_n_d_e_d and _E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s to the query
    and  bindings to be  executed by the top-level.   This predicate  is
    used  by the  top-level (prolog/0).    See also  expand_answer/2 and
    term_expansion/2.


eexxppaanndd__aannsswweerr((_+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook  in module user,  normally not defined.   Expand the result  of
    a  successfully executed  top-level query.   _B_i_n_d_i_n_g_s  is the  query
    <_N_a_m_e>= <_V_a_l_u_e>binding list  from the query.  _E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s must
    be unified with the bindings the top-level should print.


44..3377 CCrreeaattiinngg aa PPrroottooccooll ooff tthhee UUsseerr IInntteerraaccttiioonn

SWI-Prolog offers the  possibility to log the interaction with  the user
on  a file.    All  Prolog interaction,  including warnings  and  tracer
output, are written on the protocol file.


pprroottooccooll((_+_F_i_l_e))
    Start  protocolling on file  _F_i_l_e.  If  there is already a  protocol
    file open then close it first.  If _F_i_l_e exists it is truncated.


pprroottooccoollaa((_+_F_i_l_e))
    Equivalent  to protocol/1,  but  does not  truncate the  _F_i_l_e if  it
    exists.


nnoopprroottooccooll
    Stop  making a protocol of the user interaction.  Pending  output is
    flushed on the file.


pprroottooccoolllliinngg((_-_F_i_l_e))
    True  if a protocol was  started with protocol/1 or protocola/1  and
    unifies _F_i_l_e with the current protocol output file.


44..3388 DDeebbuuggggiinngg aanndd TTrraacciinngg PPrrooggrraammss

This section is a  reference to the debugger interaction predicates.   A
more use-oriented overview of the debugger is in section 2.9.

If you have installed  XPCE, you can use the graphical front-end  of the
tracer.  This front-end is installed using the predicate guitracer/0.


ttrraaccee
    Start  the tracer.   trace/0  itself cannot be  seen in the  tracer.
    Note  that the  Prolog top-level  treats trace/0  special; it  means
    `trace the next goal'.


ttrraacciinngg
    True  if the tracer is currently switched on.  tracing/0  itself can
    not be seen in the tracer.


nnoottrraaccee
    Stop the tracer.  notrace/0 itself cannot be seen in the tracer.


gguuiittrraacceerr
    Installs  hooks  (see prolog_trace_interception/4) into  the  system
    that  redirects tracing  information  to a  GUI front-end  providing
    structured  access to variable-bindings,  graphical overview of  the
    stack and highlighting of relevant source-code.


nnoogguuiittrraacceerr
    Reverts back to the textual tracer.


ttrraaccee((_+_P_r_e_d))
    Equivalent to trace(_P_r_e_d, +all).


ttrraaccee((_+_P_r_e_d_, _+_P_o_r_t_s))
    Put  a  trace-point  on  all  predicates  satisfying  the  predicate
    specification  _P_r_e_d.   _P_o_r_t_s is  a list of  port names (call,  redo,
    exit,  fail).   The atom all refers  to all ports.   If the port  is
    preceded  by a - sign the trace-point  is cleared for the port.   If
    it is preceded by a + the trace-point is set.

    The  predicate trace/2  activates debug  mode (see debug/0).    Each
    time  a port (of the 4-port model) is passed that has  a trace-point
    set  the goal is printed as  with trace/0.  Unlike trace/0  however,
    the  execution is continued without asking for  further information.
    Examples:

        ?- trace(hello).         Trace all  ports of hello  with any
                                 arity in any module.
        ?- trace(foo/2, +fail).  Trace  failures  of  foo/2  in  any
                                 module.
        ?- trace(bar/1, -all).   Stop tracing bar/1.

    The predicate debugging/0 shows all currently defined trace-points.


nnoottrraaccee((_+_G_o_a_l))
    Call  _G_o_a_l,  but  suspend  the  debugger while  _G_o_a_l  is  executing.
    The  current implementation  cuts  the choice-points  of _G_o_a_l  after
    successful completion.   See once/1.  Later implementations may have
    the same semantics as call/1.


ddeebbuugg
    Start  debugger.     In  debug  mode,   Prolog  stops  at  spy-  and
    trace-points,   disables   last-call  optimisation  and   aggressive
    destruction   of  choice  points   to  make  debugging   information
    accessible.  Implemented by the Prolog flag debug.


nnooddeebbuugg
    Stop  debugger.   Implemented by the  Prolog flag debug.   See  also
    debug/0.


ddeebbuuggggiinngg
    Print  debug status and  spy points on current  output stream.   See
    also the Prolog flag debug.


ssppyy((_+_P_r_e_d))
    Put  a spy point on all predicates meeting the  predicate specifica-
    tion _P_r_e_d.  See section 4.4.


nnoossppyy((_+_P_r_e_d))
    Remove   spy  point  from  all  predicates  meeting   the  predicate
    specification _P_r_e_d.


nnoossppyyaallll
    Remove all spy points from the entire program.


lleeaasshh((_?_P_o_r_t_s))
    Set/query leashing (ports  which allow for user interaction).  _P_o_r_t_s
    is  one of _+_N_a_m_e, _-_N_a_m_e,  _?_N_a_m_e or a list  of these.  _+_N_a_m_e  enables
    leashing  on that  port,  _-_N_a_m_e disables  it and  _?_N_a_m_e succeeds  or
    fails  according to  the  current setting.    Recognised ports  are:
    call, redo, exit,  fail and unify.  The special shorthand all refers
    to  all ports, full  refers to all ports  except for the unify  port
    (default).  half refers to the call, redo and fail port.


vviissiibbllee((_+_P_o_r_t_s))
    Set the ports shown  by the debugger.  See leash/1 for a description
    of the port specification.  Default is full.


uunnkknnoowwnn((_-_O_l_d_, _+_N_e_w))
    Edinburgh-prolog  compatibility predicate,  interfacing  to the  ISO
    prolog  flag unknown.   Values are  trace (meaning error) and  fail.
    If  the unknown flag is set to warning, unknown/2 reports  the value
    as trace.


ssttyyllee__cchheecckk((_+_S_p_e_c))
    Set  style checking options.   _S_p_e_c  is either  +<_o_p_t_i_o_n>, -<_o_p_t_i_o_n>,
    ?(<_o_p_t_i_o_n>) or  a list  of  such options.    +<_o_p_t_i_o_n> sets a  style
    checking  option,  -<_o_p_t_i_o_n> clears it  and ?(<_o_p_t_i_o_n>) succeeds  or
    fails  according to the current setting.  consult/1  and derivatives
    resets the style  checking options to their value before loading the
    file.   If---for  example---a file containing  long atoms should  be
    loaded the user can start the file with:

    :- style_check(-atom).

    Currently available options are:

    ____________________________________________________________________
    |_Name__________|Default_|Description_______________________________|
    | singleton     |  on    |                                          |
    |               |        |read_clause/1 (used by  consult/1)  warns |
    |               |        |on variables  only  appearing once  in  a |
    |               |        |term  (clause)  which  have  a  name  not |
    |               |        |starting  with  an   underscore.      See |
    |               |        |section 2.15.1.5 for details on  variable |
    ||atom          || on    |handling|and warnings.                    ||

    |               |        |read/1 and  derivatives will  produce  an |
    |               |        |error message on quoted atoms or  strings |

    |               |        |longer than 5 lines.                      |
    | dollar        |  off   |Accept dollar as a lower case  character, |
    |               |        |thus avoiding the need for quoting  atoms |
    |               |        |with dollar  signs.   System  maintenance |
    |               |        |use only.                                 |
    | discontiguous |  on    |Warn if the clauses  for a predicate  are |
    |               |        |not together in the same source file.     |

    | string        |  off   |Backward    compatibility.            See |
    |               |        |the     Prolog     flag     double_quotes |
    |               |        |(current_prolog_flag/2).                  |
    | charset       |  off   |Warn on atoms and variables holding  non- |
    |               |        |ASCII characters  that  are  not  quoted. |
    |_______________|________|See_also_section_2.15.1.1.________________|


44..3399 OObbttaaiinniinngg RRuunnttiimmee SSttaattiissttiiccss


ssttaattiissttiiccss((_+_K_e_y_, _-_V_a_l_u_e))
    Unify system statistics  determined by _K_e_y with _V_a_l_u_e.  The possible
    keys  are given  in  the table  4.2.   The  last part  of the  table
    contains  keys for compatibility  with other Prolog  implementations
    (Quintus)  for improved  portability.   Note that  the ISO  standard
    does  not  define  methods to  collect  system  statistics.    Space
    unit  is bytes.   Times  are in seconds,  represented as a  floating
    point  number.    The Quintus  compatibility keys  express times  in
    milliseconds.
_________________________________________________________________________
| agc                    |Number of atom garbage-collections performed   |
| agc_gained             N|umber of atoms removed                        |
| agc_time               T|ime spent in atom garbage-collections         |
| cputime                |(User) cpu  time since  Prolog  was started  in|
|                        |seconds                                        |
| inferences             |Total number  of passes via  the call and  redo|

|                        |ports since Prolog was started.                |
| heap                   |Estimated  total   size   of  the   heap   (see|
|                        |section 2.18.1.1)                              |
| heapused               |Bytes heap in use by Prolog.                   |
| heaplimit              |Maximum   size   of   the   heap    (see   sec-|
|                        |tion 2.18.1.1)                                 |
| local                  |Allocated size of the local stack in bytes.    |
| localused              |Number of bytes in use on the local stack.     |

| locallimit             |Size to  which the  local stack  is allowed  to|
|                        |grow                                           |
| global                 |Allocated size of the global stack in bytes.   |
| globalused             |Number of bytes in use on the global stack.    |
| globallimit            |Size to  which the global  stack is allowed  to|
|                        |grow                                           |
| trail                  |Allocated size of the trail stack in bytes.    |

| trailused              |Number of bytes in use on the trail stack.     |
| traillimit             |Size to  which the  trail stack  is allowed  to|
|                        |grow                                           |
| atoms                  |Total number of defined atoms.                 |
| functors               |Total number of defined name/arity pairs.      |
| predicates             |Total number of predicate definitions.         |
| modules                |Total number of module definitions.            |
| codes                  |Total amount of byte codes in all clauses.     |

| threads                |MT-version:  number of active threads          |
| threads_created        M|T-version:  number of created threads         |
| thread_cputime         M|T-version:  seconds CPU time used  by finished|
|                        t|hreads.   Supported on  Windows-NT and  later,|
|                        L|inux and  possibly  a few  more.    Verify  it|
|________________________g|ives_plausible_results_before_using.__________|
|_______________Compatibility_keys_(times_in_milliseconds)_______________ |

| runtime                |[   CPU   time,   CPU   time   since   last   ]|
|                        |(milliseconds, excluding time spent  in garbage|
|                        |collection)                                    |
| system_time            [|System CPU  time, System CPU time since  last |
|                        ]|(milliseconds)                                |
| real_time              [| Wall  time,  Wall time  since  last  ]  (see |
|                        g|et_time/1)                                    |

| memory                 |[  Total unshared  data,  free memory  ]  (Uses|
|                        |getrusage() if available, otherwise  incomplete|
|                        |own statistics.)                               |
| stacks                 |[ global use, local use ]                      |
| program                |[ heap, 0 ]                                    |
| global_stack           [|global use, global free ]                     |
| local_stack            [|local use, local free ]                       |
| trail                  |[ trail use, 0 ]                               |

| garbage_collection     [|number of GC, bytes gained, time spent ]      |
| stack_shifts           [|global  shifts,  local shifts,  time spent  ] |
|                        (|fails if no shifter in this version)          |
| atoms                  |[ number, memory use, 0 ]                      |
| atom_garbage_collection[|number of AGC, bytes gained, time spent ]     |
|_core___________________|Same_as_memory_________________________________|

                   Table 4.2:  Keys for statistics/2


ssttaattiissttiiccss
    Display a table of system statistics on the current output stream.


ttiimmee((_+_G_o_a_l))
    Execute  _G_o_a_l just  like once/1  (i.e., leaving  no choice  points),
    but  print used time, number  of logical inferences and the  average
    number  of  _l_i_p_s  (logical  inferences  per  second).     Note  that
    SWI-Prolog  counts the actual  executed number of inferences  rather
    than  the number of passes through  the call- and redo ports of  the
    theoretical 4-port model.


44..4400 EExxeeccuuttiioonn pprrooffiilliinngg

This section  describes the  hierarchical execution profiler  introduced
in  SWI-Prolog 5.1.10.    This profiler  is based  on  ideas from  gprof
described  in [Graham _e_t _a_l_., 1982].     The profiler  consists  of  two
parts:   the  information-gathering  is built  into  the kernel,  and  a
presentation component which is defined in the statistics library.   The
latter can be  hooked, which is used by the  XPCE module swi/pce_profile
to provide an interactive graphical representation of results.


44..4400..11 PPrrooffiilliinngg pprreeddiiccaatteess

Currently, the interface is  kept compatible with the old profiler.   As
experience grows, it is  likely that the old interface is  replaced with
one that  better reflects the  new capabilities.   Feel free to  examine
the internal interfaces and report useful application thereof.


pprrooffiillee((_:_G_o_a_l))
    Execute  _G_o_a_l just like time/1, collecting profiling  statistics and
    call  show_profile(_p_l_a_i_n_, _2_5).   With  XPCE installed  this opens  a
    graphical interface to the collected profiling data.


pprrooffiillee((_:_G_o_a_l_, _+_S_t_y_l_e_, _+_N_u_m_b_e_r))
    Execute  _G_o_a_l just like  time/1.   Collect profiling statistics  and
    show  the top _N_u_m_b_e_r  procedures on the  current output stream  (see
    show_profile/1) using _S_t_y_l_e.   The results are kept in  the database
    until  reset_profiler/0or  profile/3 is called and can  be displayed
    again  with show_profile/1.  The  profile/1 predicate is a  backward
    compatibility interface to  profile/1.  The other predicates in this
    section are low-level predicates for special cases.


sshhooww__pprrooffiillee((_+_S_t_y_l_e_, _+_N_u_m_b_e_r))
    Show  the collected  results  of the  profiler.   It  shows the  top
    _N_u_m_b_e_r predicates according  the percentage cpu-time used.  If _S_t_y_l_e
    is  plain the time spent in the predicates itself is displayed.   If
    _S_t_y_l_e  is cumulative  the time  spent in its  siblings (callees)  is
    added to the predicate.

    This  predicate first calls  prolog:show_profile_hook/2.   If XPCE  is
    loaded  this hook is used to  activate a GUI interface to  visualise
    the profile results.


sshhooww__pprrooffiillee((_+_N_u_m_b_e_r))
    Compatibility.  Same as show_profile(_p_l_a_i_n_, _N_u_m_b_e_r).


pprrooffiilleerr((_-_O_l_d_, _+_N_e_w))
    Query  or  change the  status of  the profiler.    The  status is  a
    boolean  (true or  false)  stating whether  or not  the profiler  is
    collecting  data.   It can  be used to  enable or disable  profiling
    certain parts of the program.


rreesseett__pprrooffiilleerr
    Switches the profiler to false and clears all collected statistics.


nnoopprrooffiillee((_+_N_a_m_e_/_+_A_r_i_t_y_, _._._.))
    Declares  the predicate _N_a_m_e/_A_r_i_t_y to be invisible to  the profiler.
    The  time  spend in  the  named predicate  is  added to  the  caller
    and  the  callees are  linked  directly  to the  caller.    This  is
    particularly  useful  for  simple meta-predicates  such  as  call/1,
    ignore/1, catch/3, etc.


44..4400..22 VViissuuaalliizziinngg pprrooffiilliinngg ddaattaa

Browsing the annotated  call-tree as described in section 4.40.3  itself
is  not very  attractive.    Therefore,  the  results are  combined  per
predicate,  collecting  all _c_a_l_l_e_r_s  and  and  _c_a_l_l_e_e_s as  well  as  the
propagation  of time  and activations  in both  directions.   Figure  ????
illustrates  this.     The  central  yellowish  line  is  the  `current'
predicate with  counts for time  spent in  the predicate (`Self'),  time
spent in  its children  (`Siblings'), activations through  the call  and
redo ports.   Above  that are the _c_a_l_l_e_r_s.   Here,  the two time  fields
indicate  how much  time is  spent serving  each of  the callers.    The
columns sum to the time in the yellowish  line.  The caller <_r_e_c_u_r_s_i_v_e>
are  the number  of recursive  calls.   Below  the  yellowish lines  are
the callees, with  the time spent in  the callee itself for serving  the
current  predicate and  the time  spent  in the  callees of  the  callee
('Siblings'), so  the whole time-block adds  up to the `Siblings'  field
of the current predicate.   The `Access' fields show how many  times the
current predicate accesses each of the callees.

The predicates have a  menu that allows changing the view of  the detail
window to the given  caller or callee, showing the documentation  (if it
is a built-in) and/or jumping to the source.

The  statistics  shown  in  the  report-field  of  figure  ????  show  the
following information:

  o _s_a_m_p_l_e_s
    Number  of  times  the call-tree  was  sampled for  collecting  time
    statistics.   On  most hardware the  resolution of SIGPROF is  1/100
    second.    This number must  be sufficiently  large to get  reliable
    timing  figures.   The  Time menu  allows viewing  time as  samples,
    relative time or absolute time.

  o _s_e_c
    Total user CPU time with the profiler active.

  o _p_r_e_d_i_c_a_t_e_s
    Total  count of predicates that have  been called at least one  time
    during the profile.

  o _n_o_d_e_s
    Number of nodes in the call-tree.

  o _d_i_s_t_o_r_t_i_o_n
    How  much  of  the  time  is  spend  building  the  call-tree  as  a
    percentage  of the total execution time.   Timing samples while  the
    profiler is building the call-tree are not added to the call-tree.


44..4400..33 IInnffoorrmmaattiioonn ggaatthheerriinngg

While  the program  executes under  the profiler,  the  system builds  a
_d_y_n_a_m_i_c call-tree.    It does this  using three  hooks from the  kernel:
one that starts  a new goal (_p_r_o_f_C_a_l_l),  one the tells the system  which
goal  is  resumed after  an  _e_x_i_t  (_p_r_o_f_E_x_i_t)  and one  that  tells  the
system which  goal is  resumed after  a _f_a_i_l  (i.e. which  goal is  used
to _r_e_t_r_y  (_p_r_o_f_R_e_d_o)).   The  profCall() function finds  or creates  the
subnode for  the argument predicate below  the current node,  increments
the call-count of this  link and returns the sub-node which  is recorded
in the Prolog  stack-frame.  Choice-points  are marked with the  current
profiling  node.   profExit()  and profRedo()  pass  the profiling  node
where execution resumes.

Just using the above  algorithm would create a much too big tree  due to
recursion.  For this reason the system performs  detection of recursion.
In the  simplest case,  recursive procedures  increment the  `recursive'
count on  the current  node.   Mutual  recursion however  is not  easily
detected.   For example,  call/1 can call a  predicate that uses  call/1
itself.   This  can be  viewed as a  recursive invocation,  but this  is
generally not  desirable.   Recursion is currently  assumed if the  same
predicate _w_i_t_h _t_h_e _s_a_m_e _p_a_r_e_n_t appears higher in the  call-graph.  Early
experience with a some arbitrary non-trivial programs are promising.

The last part of  the profiler collects statistics on the  CPU-time used
in  each node.    On  systems  providing  setitimer() with  SIGPROF,  it
`ticks' the  current node of  the call-tree each  time the timer  fires.
On Windows a MM-timer  in a separate thread checks 100 times  per second
how much  time is  spent in  the profiled thread  and adds  this to  the
current node.  See section 4.40.3.1 for details.


44..4400..33..11 PPrrooffiilliinngg iinn tthhee WWiinnddoowwss IImmpplleemmeennttaattiioonn

Profiling  in the  Windows version  is  similar but  as profiling  is  a
statistical process  it is good  to be aware  of the implementation  for
proper interpretation of the results.

Windows  does not  provide  timers that  fire  asynchronously,  frequent
and proportional  to the CPU  time used  by the process.   Windows  does
provide multi-media timers that can run at high frequency.   Such timers
however run  in a  separate thread of  execution and  they are fired  on
the wall-clock rather  than the amount of CPU  time used.  The  profiler
installs such a timer running, for saving CPU  time, rather inaccurately
at about 100 Hz.  Each time it is fired,  it determines the milliseconds
CPU time  used by  Prolog since the  last time it  was fired.   If  this
value is non-zero, active predicates are incremented with this value.


44..4411 MMeemmoorryy MMaannaaggeemmeenntt


ggaarrbbaaggee__ccoolllleecctt
    Invoke  the global-  and trail  stack garbage collector.    Normally
    the  garbage   collector  is  invoked  automatically  if  necessary.
    Explicit  invocation  might   be  useful  to  reduce  the  need  for
    garbage  collections in time critical segments  of the code.   After
    the  garbage  collection  trim_stacks/0 is  invoked to  release  the
    collected memory resources.


ggaarrbbaaggee__ccoolllleecctt__aattoommss
    Reclaim  unused  atoms.     Normally  invoked  after  agc_margin  (a
    Prolog  flag) atoms have been  created.  On multi-threaded  versions
    the   actual  collection  is  delayed  until  there  there   are  no
    threads  performing  normal  garbage  collection.     In  this  case
    garbage_collect_atoms/0  returns immediately.    Note  this  implies
    there  is no guarantee  it will _e_v_e_r happen  as there may always  be
    threads performing garbage collection.


ttrriimm__ssttaacckkss
    Release  stack memory resources that are not in use at  this moment,
    returning them to the  operating system.  Trim stack is a relatively
    cheap  call.    It can  be used  to release  memory  resources in  a
    backtracking  loop, where the  iterations require typically  seconds
    of execution time  and very different, potentially large, amounts of
    stack space.  Such a loop should be written as follows:

    loop :-
            generator,
                trim_stacks,
                potentially_expensive_operation,
            stop_condition, !.

    The  prolog top level  loop is written  this way, reclaiming  memory
    resources after every user query.


sseett__pprroolloogg__ssttaacckk((_+_S_t_a_c_k_, _+_K_e_y_, _+_V_a_l_u_e))
    Set  a  parameter for  a runtime  stack.   _S_t_a_c_k  is  one of  local,
    global, trail or  argument.  The table below describes the _K_e_y/_V_a_l_u_e
    pairs.

    llooww
         Do not perform GC below this amount (bytes).

    ffaaccttoorr
         Run next GC if memory exceeds max(low;checked)f *actor.

    mmiinn__ffrreeee
         Enlarge  stack if  free memory  is  below this  value  (bytes).
         This option  is  only provided  if the  system  is compiled  to
         support the stack-shifter; otherwise it is silently ignored.

    Not   all  flags  have  impact  for  all  stacks  and   the  current
    implementation lacks proper  checking for sensible values.  Use with
    extreme care.


44..4422 WWiinnddoowwss DDDDEE iinntteerrffaaccee

The  predicates in  this  section  deal with  MS-Windows  `Dynamic  Data
Exchange'  or DDE  protocol.    A Windows  DDE  conversation is  a  form
of interprocess  communication based  on sending reserved  window-events
between the communicating processes.

See also section 9.4 for loading Windows DLL's into SWI-Prolog.


44..4422..11 DDDDEE cclliieenntt iinntteerrffaaccee

The DDE client interface  allows Prolog to talk to DDE  server programs.
We  will demonstrate  the use  of the  DDE interface  using the  Windows
PROGMAN (Program Manager) application:

1 ?- open_dde_conversation(progman, progman, C).

C = 0
2 ?- dde_request(0, groups, X)

--> Unifies X with description of groups

3 ?- dde_execute(0, '[CreateGroup("DDE Demo")]').

Yes

4 ?- close_dde_conversation(0).

Yes

For  details   on  interacting  with   progman,   use  the  SDK   online
manual  section on  the  Shell  DDE interface.     See also  the  Prolog
library(progman),  which  may be  used  to  write simple  Windows  setup
scripts in Prolog.


ooppeenn__ddddee__ccoonnvveerrssaattiioonn((_+_S_e_r_v_i_c_e_, _+_T_o_p_i_c_, _-_H_a_n_d_l_e))
    Open a conversation  with a server supporting the given service name
    and  topic (atoms).    If successful,  _H_a_n_d_l_e  may be  used to  send
    transactions  to the server.    If no willing  server is found  this
    predicate fails silently.


cclloossee__ddddee__ccoonnvveerrssaattiioonn((_+_H_a_n_d_l_e))
    Close  the  conversation   associated  with  _H_a_n_d_l_e.     All  opened
    conversations  should  be  closed  when they're  no  longer  needed,
    although  the system  will  close any  that remain  open on  process
    termination.


ddddee__rreeqquueesstt((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _-_V_a_l_u_e))
    Request  a value from the server.   _I_t_e_m is an atom  that identifies
    the  requested  data,  and  _V_a_l_u_e will  be  a string  (CF_TEXT  data
    in  DDE  parlance)  representing  that  data,   if  the  request  is
    successful.    If unsuccessful, _V_a_l_u_e  will be  unified with a  term
    of  form error(<_R_e_a_s_o_n>),  identifying the problem.   This call  uses
    SWI-Prolog  string objects  to return  the value  rather then  atoms
    to  reduce the  load on  the atom-space.    See section  4.23 for  a
    discussion on this data type.


ddddee__eexxeeccuuttee((_+_H_a_n_d_l_e_, _+_C_o_m_m_a_n_d))
    Request  the  DDE   server  to  execute  the  given  command-string.
    Succeeds  if the  command  could be  executed and  fails with  error
    message otherwise.


ddddee__ppookkee((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _+_C_o_m_m_a_n_d))
    Issue  a POKE command to the server on the specified _I_t_e_m.   Command
    is passed as data of type CF_TEXT.


44..4422..22 DDDDEE sseerrvveerr mmooddee

The (autoload)  library(dde) defines  primitives to  realise simple  DDE
server applications in  SWI-Prolog.  These  features are provided as  of
version 2.0.6 and should be regarded prototypes.  The  C-part of the DDE
server can  handle some  more primitives,  so if you  need features  not
provided by this interface, please study library(dde).


ddddee__rreeggiisstteerr__sseerrvviiccee((_+_T_e_m_p_l_a_t_e_, _+_G_o_a_l))
    Register  a server  to handle  DDE request or  DDE execute  requests
    from  other applications.  To register a service for a  DDE request,
    _T_e_m_p_l_a_t_e is of the form:

         +Service(+Topic, +Item, +Value)

    _S_e_r_v_i_c_e  is the name  of the DDE  service provided (like progman  in
    the  client example  above).   _T_o_p_i_c is either  an atom,  indicating
    _G_o_a_l  only handles requests  on this topic  or a variable that  also
    appears  in _G_o_a_l.  _I_t_e_m and _V_a_l_u_e are variables that also  appear in
    _G_o_a_l.  _I_t_e_m represents the request data as a Prolog atom.

    The   example  below  registers   the  Prolog  current_prolog_flag/2
    predicate  to be accessible  from other applications.   The  request
    may  be  given  from  the  same  Prolog  as  well  as  from  another
    application.

    ?- dde_register_service(prolog(current_prolog_flag, F, V),
                            current_prolog_flag(F, V)).

    ?- open_dde_conversation(prolog, current_prolog_flag, Handle),
       dde_request(Handle, home, Home),
       close_dde_conversation(Handle).

    Home = '/usr/local/lib/pl-2.0.6/'

    Handling  DDE execute requests  is very similar.   In this case  the
    template is of the form:

         +Service(+Topic, +Item)

    Passing  a _V_a_l_u_e argument is  not needed as execute requests  either
    succeed  or fail.  If _G_o_a_l  fails, a `not processed' is  passed back
    to the caller of the DDE request.


ddddee__uunnrreeggiisstteerr__sseerrvviiccee((_+_S_e_r_v_i_c_e))
    Stop  responding  to  _S_e_r_v_i_c_e.     If  Prolog  is  halted,  it  will
    automatically call this on all open services.


ddddee__ccuurrrreenntt__sseerrvviiccee((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently registered services and the topics served on them.


ddddee__ccuurrrreenntt__ccoonnnneeccttiioonn((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently open conversations.


44..4433 MMiisscceellllaanneeoouuss


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2))
    True  if _A_t_o_m_1 matches _A_t_o_m_2 in `Do What I Mean' sense.   Both _A_t_o_m_1
    and _A_t_o_m_2 may also be integers or floats.  The two atoms match if:

      o  They are identical

      o  They differ by one character (spy  spu)

      o  One character is inserted/deleted (debug  deug)

      o  Two characters are transposed (trace  tarce)

      o  `Sub-words' are glued  differently (existsfile   existsFile
         exists_file)

      o  Two   adjacent  sub   words  are   transposed   (existsFile
         fileExists)


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2_, _-_D_i_f_f_e_r_e_n_c_e))
    Equivalent  to  dwim_match/2,  but unifies  _D_i_f_f_e_r_e_n_c_e  with an  atom
    identifying  the difference  between _A_t_o_m_1  and _A_t_o_m_2.   The  return
    values  are (in the same  order as above):   equal, mismatched_char,
    inserted_char, transposed_char, separated and transposed_word.


wwiillddccaarrdd__mmaattcchh((_+_P_a_t_t_e_r_n_, _+_S_t_r_i_n_g))
    True  if _S_t_r_i_n_g matches  the wildcard pattern  _P_a_t_t_e_r_n.  _P_a_t_t_e_r_n  is
    very  similar the Unix csh pattern matcher.  The patterns  are given
    below:

     ?      Matches one arbitrary character.
     *      Matches any number of arbitrary characters.
     [...]  Matches one of the characters specified between the brackets.
            <_c_h_a_r_1>-<_c_h_a_r_2>indicates a range.
     {...}  Matches any of the patterns of the comma separated list between the braces.

    Example:

    ?- wildcard_match('[a-z]*.{pro,pl}[%~]', 'a_hello.pl%').

    Yes


sslleeeepp((_+_T_i_m_e))
    Suspend  execution _T_i_m_e seconds.   _T_i_m_e  is either a floating  point
    number  or an  integer.   Granularity is  dependent on the  system's
    timer  granularity.   A  negative time  causes the  timer to  return
    immediately.   On  most non-realtime operating  systems we can  only
    ensure execution is suspended for aatt lleeaasstt _T_i_m_e seconds.

    On  Unix systems the  sleep/1 predicate is  realised ---in order  of
    preference---  by nanosleep(),  usleep(),  select() if  the time  is
    below 1 minute or sleep().  On Windows systems Sleep() is used.


CChhaapptteerr 55..  UUSSIINNGG MMOODDUULLEESS


55..11 WWhhyy UUssiinngg MMoodduulleess??

In  traditional Prolog  systems the  predicate  space was  flat.    This
approach   is  not   very  suitable   for  the   development  of   large
applications, certainly not if these applications are  developed by more
than  one programmer.     In many  cases,  the  definition of  a  Prolog
predicate requires  sub-predicates that  are intended  only to  complete
the definition of the main predicate.  With a  flat and global predicate
space these support predicates will be visible from the entire program.

For this  reason, it is  desirable that each source  module has its  own
predicate space.    A module  consists of  a declaration  for its  name,
its _p_u_b_l_i_c  _p_r_e_d_i_c_a_t_e_s and  the predicates  themselves.   This  approach
allows the programmer to use short (local) names  for support predicates
without worrying  about name  conflicts with the  support predicates  of
other  modules.    The  module  declaration also  makes  explicit  which
predicates are  meant for public usage  and which for private  purposes.
Finally,  using the  module information,  cross  reference programs  can
indicate possible problems much better.


55..22 NNaammee--bbaasseedd vveerrssuuss PPrreeddiiccaattee--bbaasseedd MMoodduulleess

Two approaches to  realize a module system  are commonly used in  Prolog
and other  languages.  The  first one is  the _n_a_m_e _b_a_s_e_d module  system.
In these  systems, each  atom read  is tagged  (normally prefixed)  with
the module  name, with  the exception  of those atoms  that are  defined
_p_u_b_l_i_c.   In the  second approach, each  module actually implements  its
own predicate space.

A  critical  problem with  using  modules  in Prolog  is  introduced  by
the  meta-predicates  that  transform between  Prolog  data  and  Prolog
predicates.  Consider the case where we write:

:- module(extend, [add_extension/3]).

add_extension(Extension, Plain, Extended) :-
        maplist(extend_atom(Extension), Plain, Extended).

extend_atom(Extension, Plain, Extended) :-
        atom_concat(Plain, Extension, Extended).

In this case  we would like maplist to  call extend_atom/3 in the  module
extend.   A name based module  system will do this  correctly.  It  will
tag the atom  extend_atom  with the module and  maplist will use this  to
construct the tagged  term extend_atom/3.   A name based module  however,
will not only tag the  atoms that will eventually be used to refer  to a
predicate, but aallll atoms that are not declared public.   So, with a name
based module system also  data is local to the module.   This introduces
another serious problem:

:- module(action, [action/3]).

action(Object, sleep, Arg) :- ....
action(Object, awake, Arg) :- ....

:- module(process, [awake_process/2]).

awake_process(Process, Arg) :-
        action(Process, awake, Arg).

This code  uses a simple  object-oriented implementation technique  were
atoms are used as  method selectors.  Using a name based  module system,
this code will  not work, unless we  declare the selectors public  atoms
in all  modules that use them.   Predicate  based module systems do  not
require particular precautions for handling this case.

It  appears  we  have to  choose  either  to  have  local  data,  or  to
have  trouble with  meta-predicates.    Probably it  is best  to  choose
for  the  predicate  based approach  as  novice  users  will  not  often
write  generic meta-predicates  that  have to  be used  across  multiple
modules, but are likely  to write programs that pass data  around across
modules.   Experienced Prolog  programmers should be  able to deal  with
the complexities of meta-predicates in a predicate based module system.


55..33 DDeeffiinniinngg aa MMoodduullee

Modules normally are  created by loading a _m_o_d_u_l_e  _f_i_l_e.  A module  file
is a file holding a module/2 directive as its first term.   The module/2
directive declares  the name and the  public (i.e., externally  visible)
predicates of  the module.   The  rest of  the file is  loaded into  the
module.  Below is an example of a module file, defining reverse/2.

:- module(reverse, [reverse/2]).

reverse(List1, List2) :-
        rev(List1, [], List2).

rev([], List, List).
rev([Head|List1], List2, List3) :-
        rev(List1, [Head|List2], List3).


55..44 IImmppoorrttiinngg PPrreeddiiccaatteess iinnttoo aa MMoodduullee

As  explained  before,  in  the  predicate  based  approach  adapted  by
SWI-Prolog, each  module has its  own predicate space.   In  SWI-Prolog,
a module  initially is  completely empty.   Predicates  can be added  to
a  module by  loading a  module  file as  demonstrated in  the  previous
section, using assert or by _i_m_p_o_r_t_i_n_g them from another module.

Two mechanisms for  importing predicates explicitly from another  module
exist.   The use_module/[1,2] predicates load  a module file and  import
(part of  the) public predicates  of the file.   The import/1  predicate
imports any predicate from any module.


uussee__mmoodduullee((_+_F_i_l_e))
    Load  the  file(s) specified  with _F_i_l_e  just like  ensure_loaded/1.
    The  files must all be module  files.  All exported predicates  from
    the  loaded  files are  imported  into the  context  module.    This
    predicate  is equivalent to  ensure_loaded/1,  except that it  raises
    an error if _F_i_l_e is not a module file.


uussee__mmoodduullee((_+_F_i_l_e_, _+_I_m_p_o_r_t_L_i_s_t))
    Load  the file  specified  with _F_i_l_e  (only one  file is  accepted).
    _F_i_l_e  must be  a module file.    _I_m_p_o_r_t_L_i_s_t is a  list of  predicate
    indicators  specifying the  predicates  that will  be imported  from
    the  loaded  module.    If  a predicate  is  specified that  is  not
    exported  from the loaded  module a  warning will be  printed.   The
    predicate  will  nevertheless  be imported  to  simplify  debugging.
    _I_m_p_o_r_t_L_i_s_t  also  allows for  renaming or  import-everything-except.
    See  also import option  of load_files/2.   The first example  below
    loads  member/2  from  the  lists library  and  append/2  under  the
    name  list_concat, which  how this predicate  is named  in YAP.  The
    second  example loads a all exports from library option,  except for
    meta_options/3.   These  renaming facilities  are generally used  to
    deal with portability  issues with as few as possible changes to the
    actual code.  See also section 13 and section 5.5.

    :- use_module(library(lists), [ member/2,
                                    append/2 as list_concat
                                  ]).
    :- use_module(library(option), except([meta_options/3])).


iimmppoorrtt((_+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))
    Import   predicate  _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r  into  the  current   context
    module.    _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r must specify  the source module  using
    the  <_m_o_d_u_l_e>:<_p_i>construct.    Note  that predicates  are  normally
    imported  using  one  of  the  directives  use_module/[1,2].     The
    import/1 alternative is  meant for handling imports into dynamically
    created modules.  See also export/1 and export_list/2.

It  would  be rather  inconvenient  to  have to  import  each  predicate
referred to by  the module, including the  system predicates.  For  this
reason each  module is  assigned a _d_e_f_a_u_l_t  _m_o_d_u_l_e.   All predicates  in
the default  module are  available without  extra declarations.    Their
definition however can be overruled in the local module.   This schedule
is implemented  by the exception handling  mechanism of SWI-Prolog:   if
an  undefined predicate  exception is  raised for  a  predicate in  some
module, the exception  handler first tries to import the  predicate from
one of  the module's _i_m_p_o_r_t  _m_o_d_u_l_e_s.  On  success, normal execution  is
resumed.


55..44..11 RReesseerrvveedd MMoodduulleess

SWI-Prolog contains two  special modules.   The first one is the  module
system.    This module  contains all  built-in  predicates described  in
this  manual.   Module  system has  no default  module  assigned to  it.
The second  special module is the  module user.   This module forms  the
initial  working space  of the  user.    Initially  it is  empty.    The
import module  of module user is  system, making all built-in  predicate
definitions available  as defaults.    Built-in predicates  thus can  be
overruled by defining them in module user before they are used.

All  other modules  import from  the module  user.    This implies  they
can use all  predicates imported into user without explicitly  importing
them.


55..55 CCoommppoossiinngg mmoodduulleess ffrroomm ootthheerr mmoodduulleess

The predicates in this  section are intended to create new  modules from
the  content of  other  modules.    Below is  an  example is  to  define
a  _c_o_m_p_o_s_i_t_e module.    The  example exports  all public  predicates  of
module_1, module_2 and  module_3, pred/1  from module_4, all  predicates
from module_5 except do_not_use/1 and all predicates from module_6 while
renaming pred/1 into mypred/1.

:- module(my_composite, []).
:- reexport([ module_1,
              module_2,
              module_3
            ]).
:- reexport(module_4, [ pred/1 ]).
:- reexport(module_5, except([do_not_use/1])).
:- reexport(module_6, except([pred/1 as mypred])).


rreeeexxppoorrtt((_+_F_i_l_e_s))
    Load  and  import  predicates  as  use_modules/1 and  re-export  all
    imported  predicates.   The reexport  declarations must  immediately
    follow the module declaration.


rreeeexxppoorrtt((_+_F_i_l_e_, _+_I_m_p_o_r_t))
    Import  from   _F_i_l_e  as  use_module/2 and   re-export  the  imported
    predicates.   The reexport declarations must immediately  follow the
    module declaration.


55..66 UUssiinngg tthhee MMoodduullee SSyysstteemm

The  current structure  of  the module  system  has been  designed  with
some specific  organisations for  large programs  in mind.   Many  large
programs  define a  basic  library layer  on  top  of which  the  actual
program itself  is defined.    The module  user, acting  as the  default
module for all  other modules of the  program can be used to  distribute
these definitions over  all program module without introducing the  need
to  import this  common layer  each time  explicitly.   It  can also  be
used to  redefine built-in predicates  if this  is required to  maintain
compatibility  to some  other Prolog  implementation.    Typically,  the
loadfile of a large application looks like this:

:- use_module(compatibility).   % load XYZ prolog compatibility

:- use_module(                  % load generic parts
        [ error                 % errors and warnings
        , goodies               % general goodies (library extensions)
        , debug                 % application specific debugging
        , virtual_machine       % virtual machine of application
        , ...                   % more generic stuff
        ]).

:- ensure_loaded(
        [ ...                   % the application itself
        ]).

The  `use_module' declarations  will  import the  public predicates  from
the  generic  modules  into  the  user  module.     The  `ensure_loaded'
directive  loads the  modules that  constitute  the actual  application.
It is  assumed these  modules import  predicates from  each other  using
use_module/[1,2] as far as necessary.

In combination  with the  object-oriented schema described  below it  is
possible  to define  a neat  modular  architecture.   The  generic  code
defines general utilities  and the message passing predicates  (invoke/3
in the  example below).    The application modules  define classes  that
communicate using the message passing predicates.


55..66..11 OObbjjeecctt OOrriieenntteedd PPrrooggrraammmmiinngg

Another typical  way to use  the module system  is for defining  classes
within  an object  oriented  paradigm.    The  class structure  and  the
methods  of  a class  can  be  defined  in a  module  and  the  explicit
module-boundary overruling  describes in  section 5.7.2 can  by used  by
the message passing  code to invoke the behaviour.   An outline of  this
mechanism is given below.

%       Define class point

:- module(point, []).           % class point, no exports

%        name           type,           default access
%                                       value

variable(x,             integer,        0,      both).
variable(y,             integer,        0,      both).

%         method name   predicate name  arguments

behaviour(mirror,       mirror,         []).

mirror(P) :-
        fetch(P, x, X),
        fetch(P, y, Y),
        store(P, y, X),
        store(P, x, Y).

The predicates fetch/3  and store/3 are predicates that change  instance
variables of instances.  The figure below indicates  how message passing
can easily be implemented:

%       invoke(+Instance, +Selector, ?ArgumentList)
%       send a message to an instance

invoke(I, S, Args) :-
        class_of_instance(I, Class),
        Class:behaviour(S, P, ArgCheck), !,
        convert_arguments(ArgCheck, Args, ConvArgs),
        Goal =.. [P|ConvArgs],
        Class:Goal.

The construct  <_M_o_d_u_l_e>:<_G_o_a_l> explicitly  calls _G_o_a_l  in module  _M_o_d_u_l_e.
It is discussed in more detail in section 5.7.


55..77 MMeettaa--PPrreeddiiccaatteess iinn MMoodduulleess

As indicated  in the introduction,  the problem  with a predicate  based
module system lies in the difficulty to find the  correct predicate from
a Prolog  term.   The predicate `solution(Solution)'  can exist in  more
than one  module, but `assert(solution(4))'  in some module is  supposed
to refer to the correct version of solution/1.

Various  approaches are  possible to  solve this  problem.    One is  to
add an extra  argument to all predicates (e.g. `assert(Module,  Term)').
Another is to tag  the term somehow to indicate which module  is desired
(e.g. `assert(Module:Term)').   Both approaches are not very  attractive
as  they make  the user  responsible for  choosing  the correct  module,
inviting  unclear  programming by  asserting  in  other modules.     The
predicate assert/1  is supposed  to assert  in the module  it is  called
from and should do  so without being told explicitly.  For  this reason,
the notion _c_o_n_t_e_x_t _m_o_d_u_l_e has been introduced.


55..77..11 DDeeffiinniittiioonn aanndd CCoonntteexxtt MMoodduullee

Each  predicate  of  the  program  is  assigned  a  module,  called  its
_d_e_f_i_n_i_t_i_o_n _m_o_d_u_l_e.   The definition module of a predicate is  always the
module in which the predicate was originally defined.   Each active goal
in the Prolog system has a _c_o_n_t_e_x_t _m_o_d_u_l_e assigned to it.

The  context module  is used  to  find predicates  from a  Prolog  term.
By  default, this  module  is the  definition  module of  the  predicate
running the  goal.   For meta-predicates  however, this  is the  context
module of the  goal that invoked them.   We call this _m_o_d_u_l_e___t_r_a_n_s_p_a_r_e_n_t
in SWI-Prolog.    In the `using  maplist' example  above, the  predicate
maplist/3  is declared  module_transparent.    This  implies the  context
module remains extend, the  context module of add_extension/3.   This way
maplist/3 can decide to call extend_atom in module extend rather than in
its own definition module.

All built-in predicates that  refer to predicates via a Prolog  term are
declared module_transparent.  Below is the code defining maplist.

:- module(maplist, maplist/3).

:- module_transparent maplist/3.

%       maplist(+Goal, +List1, ?List2)
%       True if Goal can successfully be applied to all succes-
sive pairs
%       of elements of List1 and List2.

maplist(_, [], []).
maplist(Goal, [Elem1|Tail1], [Elem2|Tail2]) :-
        apply(Goal, [Elem1, Elem2]),
        maplist(Goal, Tail1, Tail2).


55..77..22 OOvveerrrruulliinngg MMoodduullee BBoouunnddaarriieess

The  mechanism  above  is sufficient  to  create  an  acceptable  module
system.   There are however cases in which  we would like to be  able to
overrule this  schema and  explicitly call  a predicate  in some  module
or assert  explicitly in some  module.   The first  is useful to  invoke
goals  in some  module  from the  user's  top-level  or to  implement  a
object-oriented system (see above).  The latter is  useful to create and
modify _d_y_n_a_m_i_c _m_o_d_u_l_e_s (see section 5.8).

For  this purpose,  the reserved  term :/2  has  been introduced.    All
built-in predicates  that transform  a term into  a predicate  reference
will check whether  this term is of  the form `<_M_o_d_u_l_e>:<_T_e_r_m>'.  If  so,
the predicate is  searched for in _M_o_d_u_l_e  instead of the goal's  context
module.   The :  operator may be  nested, in  which case the  inner-most
module is used.

The special  calling construct  <_M_o_d_u_l_e>:<_G_o_a_l>pretends  _G_o_a_l is  called
from _M_o_d_u_l_e instead of the context module.  Examples:

?- assert(world:done).  % asserts done/0 into module world
?- world:assert(done).  % the same
?- world:done.          % calls done/0 in module world


55..88 DDyynnaammiicc MMoodduulleess

So  far,   we  discussed  modules  that   were  created  by  loading   a
module-file.     These  modules  have  been   introduced  on  facilitate
the  development  of  large  applications.     The   modules  are  fully
defined at  load-time of the  application and  normally will not  change
during  execution.   Having  the  notion of  a set  of  predicates as  a
self-contained world can be attractive for other purposes as  well.  For
example, assume  an application that  can reason about multiple  worlds.
It is attractive  to store the data of  a particular world in a  module,
so we extract information from a world simply by  invoking goals in this
world.

Dynamic modules  can easily  be created.   Any  built-in predicate  that
tries  to locate  a predicate  in  a specific  module will  create  this
module as a side-effect if it did not yet exist.  Example:

?- assert(world_a:consistent),
   world_a:unknown(_, fail).

These  calls  create  a  module  called  `world_a'  and  make  the  call
`world_a:consistent'  succeed.  Undefined  predicates will not start  the
tracer or autoloader for this module (see unknown/2).

Import and  export from dynamically  created world  is arranged via  the
predicates import/1 and export/1:

?- world_b:export(solve(_,_)).          % exports solve/2 from world_b
?- world_c:import(world_b:solve(_,_)).  % and import it to world_c


55..99 MMoodduullee HHaannddlliinngg PPrreeddiiccaatteess

This section gives the predicate definitions for  the remaining built-in
predicates that handle modules.


::-- mmoodduullee((_+_M_o_d_u_l_e_, _+_P_u_b_l_i_c_L_i_s_t))
    This  directive can  only  be used  as the  first term  of a  source
    file.   It declares  the file to be  a _m_o_d_u_l_e _f_i_l_e, defining  _M_o_d_u_l_e
    and  exporting  the  predicates of  _P_u_b_l_i_c_L_i_s_t.    _P_u_b_l_i_c_L_i_s_t  is  a
    list  of predicate indicators  (name/arity or name//arity pairs)  or
    operator  declarations using the format op(_P_r_e_c_e_d_e_n_c_e_, _T_y_p_e_,  _N_a_m_e).
    Operators  defined  in  the export  list  are available  inside  the
    module  as well  as  to modules  importing this  module.   See  also
    section 4.24.


mmoodduullee__ttrraannssppaarreenntt _+_P_r_e_d_s
    _P_r_e_d_s   is  a  comma  separated  list  of  name/arity   pairs  (like
    dynamic/1).     Each goal  associated  with a  transparent  declared
    predicate will inherit the _c_o_n_t_e_x_t _m_o_d_u_l_e from its parent goal.


mmeettaa__pprreeddiiccaattee _+_H_e_a_d_s
    This  predicate  is  defined  in  quintus  and  provides  a  partial
    emulation  of  the  Quintus  predicate.    See  section  5.10.1  for
    details.


ccuurrrreenntt__mmoodduullee((_-_M_o_d_u_l_e))
    Generates all currently known modules.


ccuurrrreenntt__mmoodduullee((_?_M_o_d_u_l_e_, _?_F_i_l_e))
    Is  true if _F_i_l_e is the file from which _M_o_d_u_l_e was loaded.   _F_i_l_e is
    the internal canonical filename.  See also source_file/[1,2].


ccoonntteexxtt__mmoodduullee((_-_M_o_d_u_l_e))
    Unify   _M_o_d_u_l_e  with  the  context  module  of  the   current  goal.
    context_module/1 itself is transparent.


ssttrriipp__mmoodduullee((_+_T_e_r_m_, _-_M_o_d_u_l_e_, _-_P_l_a_i_n))
    Used  in  module  transparent  or  meta-predicates  to  extract  the
    referenced  module and plain  term.   If _T_e_r_m is a  module-qualified
    term, i.e. of  the format _M_o_d_u_l_e:_P_l_a_i_n, _M_o_d_u_l_e and _P_l_a_i_n are unified
    to  these values.  Otherwise _P_l_a_i_n is unified to _T_e_r_m and  _M_o_d_u_l_e to
    the context module.


eexxppoorrtt((_+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.))
    Add  a predicate to  the public list  of the context  module.   This
    implies  the predicate will be imported into another module  if this
    module is  imported with use_module/[1,2].   Note that predicates are
    normally  exported using the directive module/2.  export/1  is meant
    to handle export from dynamically created modules.


eexxppoorrtt__lliisstt((_+_M_o_d_u_l_e_, _?_E_x_p_o_r_t_s))
    Unifies  _E_x_p_o_r_t_s with a list  of predicate indicators, one for  each
    public  predicate of  _M_o_d_u_l_e.   The order  of the  terms in  _E_x_p_o_r_t_s
    is  not  defined.     Predicate indicators  are  in  canonical  form
    (i.e.  always using Name/Arity and never the DCG  form Name//Arity).
    Future  versions  may  also use  the  DCG  form and  include  public
    operators.  See also predicate_property/2.


iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _-_I_m_p_o_r_t))
    True  if _I_m_p_o_r_t  is defined as  an import  module for _M_o_d_u_l_e.    All
    normal  modules only import  from user,  which imports from  system.
    The predicates  add_import_module/3and delete_import_module/2 can be
    used to manipulate the import list.


aadddd__iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _+_I_m_p_o_r_t_, _+_S_t_a_r_t_O_r_E_n_d))
    If  _I_m_p_o_r_t is not  already an  import module for  _M_o_d_u_l_e, add it  to
    this  list at the start  or end depending on  _S_t_a_r_t_O_r_E_n_d.  See  also
    import_module/2 and delete_import_module/2.


ddeelleettee__iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _+_I_m_p_o_r_t))
    Delete  _I_m_p_o_r_t from the  list of import modules  for _M_o_d_u_l_e.   Fails
    silently if _I_m_p_o_r_t is not in the list.


ddeeffaauulltt__mmoodduullee((_+_M_o_d_u_l_e_, _-_D_e_f_a_u_l_t))
    Successively  unifies _D_e_f_a_u_l_t  with the  module names  from which  a
    call  in _M_o_d_u_l_e  attempts to  use the definition.    For the  module
    user,  this will generate  user and system.   For any other  module,
    this will generate the module itself, followed by user and system.

    Backward compatibility.  New code should use import_module/2.


mmoodduullee((_+_M_o_d_u_l_e))
    The  call module(_M_o_d_u_l_e) may be  used to switch the default  working
    module  for the interactive top-level (see  prolog/0).  This may  be
    used  to when  debugging  a module.    The example  below lists  the
    clauses of file_of_label/2 in the module tex.

    1 ?- module(tex).

    Yes
    tex: 2 ?- listing(file_of_label/2).
    ...


55..1100 CCoommppaattiibbiilliittyy ooff tthhee MMoodduullee SSyysstteemm

The  principles behind  the  module system  of  SWI-Prolog differ  in  a
number of aspects from the Quintus Prolog module system.

  o The  SWI-Prolog module  system allows  the user  to redefine  system
    predicates.

  o All  predicates that are  available in the  system and user  modules
    are visible in all other modules as well.

  o Quintus  has the `meta_predicate/1' declaration were SWI-Prolog  has
    the module_transparent/1 declaration.

  o Operator declarations are local to a module and may be exported.

The meta_predicate/1 declaration  causes the  compiler to tag  arguments
that pass  module sensitive information  with the  module using the  :/2
operator.  This approach has some disadvantages:

  o Changing   a  meta_predicate   declaration  implies  all   predicates
    ccaalllliinngg  the predicate need to be reloaded.  This can  cause serious
    consistency problems.

  o It  does not help for dynamically defined predicates  calling module
    sensitive predicates.

  o It   slows  down   the  compiler   (at  least   in  the   SWI-Prolog
    architecture).

  o At  least within the  SWI-Prolog architecture the run-time  overhead
    is   larger  than  the   overhead  introduced  by  the   transparent
    mechanism.

Unfortunately  the   transparent  predicate   approach  also  has   some
disadvantages.   If a  predicate A passes  module sensitive information
to a  predicate B, passing  the same information to  a module sensitive
system predicate both  A and B  should be declared transparent.   Using
the Quintus approach only A needs to be treated special (i.e., declared
with  meta_predicate/1).    A  second problem  arises if  the  body of  a
transparent  predicate uses  module sensitive  predicates  for which  it
wants to refer to its  own module.  Suppose we want to  define findall/3
using assert/1  and retract/1.    The example  in figure  5.1 gives  the
solution.
:- module(findall, [findall/3]).

:- dynamic

        solution/1.

:- module_transparent
        findall/3,
        store/2.

findall(Var, Goal, Bag) :-

        assert(findall:solution('$mark')),
        store(Var, Goal),
        collect(Bag).

store(Var, Goal) :-
        Goal,                   % refers to context module of
                                % caller of findall/3
        assert(findall:solution(Var)),

        fail.
store(_, _).

collect(Bag) :-
        ...,

                  Figure 5.1:  findall/3 using modules


55..1100..11 EEmmuullaattiinngg mmeettaa__pprreeddiiccaattee

The Quintus  meta_predicate/1 directive can  in many  cases be  replaced
by  the   transparent  declaration.      Below  is  the  definition   of
meta_predicate/1 as available from quintus.

:- op(1150, fx, (meta_predicate)).

meta_predicate((Head, More)) :- !,
        meta_predicate1(Head),
        meta_predicate(More).
meta_predicate(Head) :-
        meta_predicate1(Head).

meta_predicate1(Head) :-
        Head =.. [Name|Arguments],
        member(Arg, Arguments),
        module_expansion_argument(Arg), !,
        functor(Head, Name, Arity),
        module_transparent(Name/Arity).
meta_predicate1(_).             % just a mode declaration

module_expansion_argument(:).
module_expansion_argument(N) :- integer(N).

The discussion above  about the problems with the transparent  mechanism
show the two cases in which this simple transformation does not work.


CChhaapptteerr 66..  SSPPEECCIIAALL VVAARRIIAABBLLEESS AANNDD CCOORROOUUTTIINNIINNGG

This  chapter  deals  with  extensions  primarily  designed  to  support
constraint logic programming (CLP).


66..11 AAttttrriibbuutteedd vvaarriiaabblleess

_A_t_t_r_i_b_u_t_e_d  _v_a_r_i_a_b_l_e_s  provide  a technique  for  extending  the  Prolog
unification  algorithm  [Holzbaur, 1992]  by  hooking  the   binding  of
attributed  variables.     There  is  little  consensus  in  the  Prolog
community  on   the  exact  definition   and  interface  to   attributed
variables.   The SWI-Prolog interface is  identical to the one  realised
by Bart Demoen for hProlog [Demoen, 2002].

Binding  an attributed  variable  schedules a  goal  to be  executed  at
the  first possible  opportunity.   In  the  current implementation  the
hooks are  executed immediately  after a successful  unification of  the
clause-head or  successful completion of  a foreign language  (built-in)
predicate.    Each attribute  is associated  to a  module  and the  hook
(attr_unify_hook/2)  is  executed in  this  module.   The  example  below
realises a very simple and incomplete finite domain reasoner.

:- module(domain,
          [ domain/2                    % Var, ?Domain
          ]).
:- use_module(library(ordsets)).

domain(X, Dom) :-
        var(Dom), !,
        get_attr(X, domain, Dom).
domain(X, List) :-
        list_to_ord_set(List, Domain),
        put_attr(Y, domain, Domain),
        X = Y.

%       An attributed variable with attribute value Domain has been
%       assigned the value Y

attr_unify_hook(Domain, Y) :-
        (   get_attr(Y, domain, Dom2)
        ->  ord_intersection(Domain, Dom2, NewDomain),
            (   NewDomain == []
            ->  fail
            ;   NewDomain = [Value]
            ->  Y = Value
            ;   put_attr(Y, domain, NewDomain)
            )
        ;   var(Y)
        ->  put_attr( Y, domain, Domain )
        ;   ord_memberchk(Y, Domain)
        ).

%       Translate attributes from this module to residual goals

attribute_goals(X) -->
        { get_attr(X, domain, List) },
        [domain(X, List)].

Before explaining the code we give some example queries:

 ?- domain(X, [a,b]), X = c                fail
 ?- domain(X, [a,b]), domain(X, [a,c]).    X = a
 ?- domain(X, [a,b,c]), domain(X, [a,c]).  domain(X, [a, c])

The  predicate  domain/2  fetches  (first  clause)  or  assigns  (second
clause) the variable a  _d_o_m_a_i_n, a set of values it can be  unified with.
In the second clause  first associates the domain with a  fresh variable
and then unifies X to this variable to deal with  the possibility that X
already has a domain.   The predicate attr_unify_hook/2is a  hook called
after a variable with a domain is assigned a value.   In the simple case
where the variable is bound to a concrete value  we simply check whether
this value is in the domain.  Otherwise we take  the intersection of the
domains and  either fail if the  intersection is empty (first  example),
simply assign the value  if there is only one value in  the intersection
(second example)  or assign the  intersection as the  new domain of  the
variable (third  example).   The  nonterminal attribute_goals/3 is  used
to  translate remaining  attributes to  user-readable goals  that,  when
executed, reinstate these attributes.


aattttvvaarr((_@_T_e_r_m))
    Succeeds  if _T_e_r_m is an attributed  variable.  Note that var/1  also
    succeeds on attributed  variables.  Attributed variables are created
    with put_attr/3.


ppuutt__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e_, _+_V_a_l_u_e))
    If  _V_a_r is  a variable  or attributed  variable, set  the value  for
    the  attribute named _M_o_d_u_l_e  to _V_a_l_u_e.   If  an attribute with  this
    name  is already  associated with  _V_a_r, the old  value is  replaced.
    Backtracking  will restore  the old  value (i.e. an  attribute is  a
    mutable  term.    See  also  setarg/3).    This predicate  raises  a
    representation  error if _V_a_r is not  a variable and a type error  if
    _M_o_d_u_l_e is not an atom.


ggeett__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e_, _-_V_a_l_u_e))
    Request  the  current _v_a_l_u_e  for the  attribute named  _M_o_d_u_l_e.    If
    _V_a_r  is not  an attributed variable  or the  named attribute is  not
    associated  to _V_a_r this predicate fails silently.  If _M_o_d_u_l_e  is not
    an atom, a type error is raised.


ddeell__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e))
    Delete  the named attribute.    If _V_a_r loses  its last attribute  it
    is  transformed back into a traditional Prolog variable.   If _M_o_d_u_l_e
    is  not an atom, a  type error is raised.   In all other cases  this
    predicate succeeds regardless  whether or not the named attribute is
    present.


aattttrr__uunniiffyy__hhooookk((_+_A_t_t_V_a_l_u_e_, _+_V_a_r_V_a_l_u_e))
    Hook  that must  be  defined in  the module  an attributed  variable
    refers  to.   Is is  called _a_f_t_e_r the  attributed variable has  been
    unified  with a non-var term, possibly another  attributed variable.
    _A_t_t_V_a_l_u_e  is  the  attribute that  was  associated to  the  variable
    in  this  module and  _V_a_r_V_a_l_u_e is  the new  value  of the  variable.
    Normally  this  predicate  fails to  veto  binding the  variable  to
    _V_a_r_V_a_l_u_e,  forcing backtracking to  undo the binding.   If  _V_a_r_V_a_l_u_e
    is  another  attributed variable  the hook  often  combines the  two
    attribute and associates  the combined attribute with _V_a_r_V_a_l_u_e using
    put_attr/3.


aattttrr__ppoorrttrraayy__hhooookk((_+_A_t_t_V_a_l_u_e_, _+_V_a_r))
    Called by  write_term/2and friends for each  attribute if the option
    attributes(_p_o_r_t_r_a_y)  is  in  effect.    If  the  hook  succeeds  the
    attribute is considered  printed.  Otherwise Module = ... is printed
    to indicate the existence of a variable.


aattttrriibbuuttee__ggooaallss((_+_V_a_r_, _-_G_s_, _+_G_s_R_e_s_t))
    This  nonterminal,  if  it  is  defined in  a  module,  is  used  by
    copy_term/3 to project attributes of that  module to residual goals.
    It  is also  used by  the toplevel  to obtain  residual goals  after
    executing a query.


66..11..11 SSppeecciiaall ppuurrppoossee pprreeddiiccaatteess ffoorr aattttrriibbuutteess

Normal user code should deal with put_attr/3, get_attr/3 and del_attr/2.
The routines in this  section fetch or set the entire attribute  list of
a variables.   Use of these  predicates is anticipated to be  restricted
to printing and other special purpose operations.


ggeett__aattttrrss((_+_V_a_r_, _-_A_t_t_r_i_b_u_t_e_s))
    Get  all  attributes of  _V_a_r.   _A_t_t_r_i_b_u_t_e_s  is a  term  of the  form
    att(_M_o_d_u_l_e_,  _V_a_l_u_e_, _M_o_r_e_A_t_t_r_i_b_u_t_e_s), where _M_o_r_e_A_t_t_r_i_b_u_t_e_s is  [] for
    the last attribute.


ppuutt__aattttrrss((_+_V_a_r_, _-_A_t_t_r_i_b_u_t_e_s))
    Set  all attributes of  _V_a_r.  See  get_attrs/2 for a description  of
    _A_t_t_r_i_b_u_t_e_s.


ccooppyy__tteerrmm((_+_T_e_r_m_, _-_C_o_p_y_, _-_G_s))
    Create  a  regular  term  _C_o_p_y  as  a  copy  of  _T_e_r_m  (without  any
    attributes),  and a list  _G_s of goals  that when executed  reinstate
    all  attributes onto _C_o_p_y.   The nonterminal  attribute_goals//1,  as
    defined in the  modules the attributes stem from, is used to convert
    attributes to lists of goals.


ccooppyy__tteerrmm__nnaatt((_+_T_e_r_m_, _-_C_o_p_y))
    As copy_term/2.  Attributes however, are _n_o_t  copied but replaced by
    fresh variables.


66..22 CCoorroouuttiinniinngg

Coroutining  deals with  having  Prolog  goals scheduled  for  execution
as  soon  as  some  conditions are  fulfilled.     In  Prolog  the  most
commonly used  condition is the instantiation  (binding) of a  variable.
Scheduling  a goal  to execute  immediately after  a  variable is  bound
can be used  to avoid instantiation errors for some  built-in predicates
(e.g. arithmetic),  do work _l_a_z_y, prevent  the binding of a variable  to
a particular  value, etc.   Using freeze/2 for  example we can define  a
variable can only be assigned an even number:

?- freeze(X, X mod 2 =:= 0), X = 3

No


ffrreeeezzee((_+_V_a_r_, _:_G_o_a_l))
    Delay  the execution  of  _G_o_a_l until  _V_a_r is  bound (i.e.  is not  a
    variable  or  attributed  variable).    If  _V_a_r is  bound  on  entry
    freeze/2  is  equivalent  to call/1.     The freeze/2  predicate  is
    realised  using an  attributed variable associated  with the  module
    freeze.   Use frozen(Var, Goal) to find out whether and  which goals
    are delayed on _V_a_r.


ffrroozzeenn((_@_V_a_r_, _-_G_o_a_l))
    Unify  _G_o_a_l with the  goal or conjunction  of goals delayed on  _V_a_r.
    If no goals are frozen on _V_a_r, _G_o_a_l is unified to true.


wwhheenn((_@_C_o_n_d_i_t_i_o_n_, _:_G_o_a_l))
    Execute  _G_o_a_l when  _C_o_n_d_i_t_i_o_n becomes  true.   _C_o_n_d_i_t_i_o_n  is one  of
    ?=(_X_, _Y), nonvar(_X), ground(_X),  ,(_C_o_n_d_1_, _C_o_n_d_2) or ;(_C_o_n_d_1_, _C_o_n_d_2).
    See  also freeze/2  and dif/2.    The implementation  can deal  with
    cyclic terms in _X and _Y.

    The   when/2  predicate  is   realised  using  attributed   variable
    associated  with the module  when.   It is  defined in the  autoload
    library when.


ddiiff((_@_A_, _@_B))
    The  dif/2 predicate  provides  a constraint  stating that  _A and  _B
    are  different terms.   If _A  and _B can  never unify dif/2  succeeds
    deterministically.   If _A and  _B are identical it fails  immediately
    and  finally, if _A and _B  can unify, goals are delayed  that prevent
    _A  and  _B to  become  equal.    The dif/2  predicate behaves  as  if
    defined  by  dif(X, Y) :- when(?=(X, Y), X \== Y).  See  also  ?=/2.
    The implementation can deal with cyclic terms.

    The   dif/2  predicate   is  realised   using  attributed   variable
    associated  with the  module dif.   It  is defined  in the  autoload
    library dif.


ccaallll__rreessiidduuee__vvaarrss((_:_G_o_a_l_, _-_V_a_r_s))
    Find residual attributed  variables left by _G_o_a_l.  This predicate is
    intended  for debugging programs  using coroutining or  constraints.
    Consider   a  program  that  poses  contracting  constraints   on  a
    variable.   Such programs should fail, but sometimes succeed because
    the  constraint  solver is  too weak  to  detect the  contradiction.
    Ideally,  delayed goals and constraints are all executed at  the end
    of  the computation.   The meta  predicate call_residue_vars/2 finds
    variables  that are given  attributes variables or whose  attributes
    are modified by  _G_o_a_l, regardless or not whether these variables are
    reachable from the arguments of _G_o_a_l.

    The  predicate has considerable implications.  During  the execution
    of   _G_o_a_l,  the  garbage  collector  does  not   reclaim  attributed
    variables.   This  causes some  degradation of GC  performance.   In
    a  well-behaved program there  are no such  variables, so the  space
    impact  is generally  minimal.   The  actual collection  of _V_a_r_s  is
    implemented using a scan of the trail- and global stacks.


66..33 GGlloobbaall vvaarriiaabblleess

Global  variables are  associations  between  names (atoms)  and  terms.
They differ in  various ways from storing information using  assert/1 or
recorda/3.

  o The  value lives on  the Prolog (global) stack.   This implies  that
    lookup  time is  independent from the  size of  the term.   This  is
    particularly  interesting for large  data structures such as  parsed
    XML documents or the CHR global constraint store.

  o They   support  both   global  assignment   using  nb_setval/2   and
    backtrackable assignment using b_setval/2.

  o Only  one value (which can be an arbitrary complex Prolog  term) can
    be associated to a variable at a time.

  o Their  value cannot be  shared among threads.   Each thread has  its
    own namespace and values for global variables.

  o Currently  global variables are  scoped globally.   We may  consider
    module scoping in future versions.

Both  b_setval/2 and nb_setval/2  implicitly create  a  variable if  the
referenced name does not already refer to a variable.

Global  variables  may  be initialised  from  directives  to  make  them
available  during the  program  lifetime,  but some  considerations  are
necessary  for saved-states  and threads.    Saved-states  to not  store
global  variables,   which  implies  they  have  to  be   declared  with
initialization/1 to recreate them  after loading the saved state.   Each
thread  has its  own set  of global  variables, starting  with an  empty
set.    Using thread_initialization/1  to define  a global  variable  it
will be  defined, restored  after reloading  a saved  state and  created
in  all threads  that are  created  _a_f_t_e_r the  registration.    Finally,
global  variables can  be initialised  using the  exception hook  called
exception/3.  The latter technique is by CHR (see chapter 7.


bb__sseettvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associate  the  term  _V_a_l_u_e  with  the atom  _N_a_m_e  or  replaces  the
    currently  associated value  with _V_a_l_u_e.    If _N_a_m_e  does not  refer
    to  an existing  global variable  a variable with  initial value  []
    is  created (the  empty list).   On  backtracking the assignment  is
    reversed.


bb__ggeettvvaall((_+_N_a_m_e_, _-_V_a_l_u_e))
    Get the value  associated with the global variable _N_a_m_e and unify it
    with _V_a_l_u_e.   Note that this unification may further instantiate the
    value  of the global  variable.  If  this is undesirable the  normal
    precautions  (double negation or  copy_term/2) must be  taken.   The
    b_getval/2 predicate generates errors if _N_a_m_e is not  an atom or the
    requested variable does not exist.


nnbb__sseettvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associates  a copy of  _V_a_l_u_e created with duplicate_term/2 with  the
    atom  _N_a_m_e.   Note that  this can be  used to  set an initial  value
    other than [] prior to backtrackable assignment.


nnbb__ggeettvvaall((_+_N_a_m_e_, _-_V_a_l_u_e))
    The  nb_getval/2 predicate is  a synonym for  b_getval/2,  introduced
    for  compatibility  and  symmetry.    As  most  scenarios  will  use
    a  particular  global  variable  either  using  non-backtracable  or
    backtrackable assignment,  using nb_getval/2can be  used to document
    that the variable is used non-backtracable.


nnbb__lliinnkkvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associates  the term _V_a_l_u_e  with the atom  _N_a_m_e without copying  it.
    This  is a  fast special-purpose  variation of  nb_setval/2 intended
    for  expert  users   only  because  the  semantics  on  backtracking
    to  a  point  before  creating  the  link  are  poorly  defined  for
    compound  terms.    The  principal term  is always  left  untouched,
    but  backtracking behaviour on arguments  is undone if the  original
    assignment  was  _t_r_a_i_l_e_d and  left  alone otherwise,  which  implies
    that  the history  that created  the term affects  the behaviour  on
    backtracking.  Please consider the following example:

    demo_nb_linkval :-
            T = nice(N),
            (   N = world,
                nb_linkval(myvar, T),
                fail
            ;   nb_getval(myvar, V),
                writeln(V)
            ).


nnbb__ccuurrrreenntt((_?_N_a_m_e_, _?_V_a_l_u_e))
    Enumerate  all defined  variables with their  value.   The order  of
    enumeration is undefined.


nnbb__ddeelleettee((_+_N_a_m_e))
    Delete the named global variable.


66..33..11 CCoommppaattiibbiilliittyy ooff SSWWII--PPrroolloogg GGlloobbaall VVaarriiaabblleess

Global variables have been introduced by  various Prolog implementations
recently.  The implementation of them in SWI-Prolog  is based on hProlog
by  Bart Demoen.    In  discussion with  Bart it  was  decided that  the
semantics if hProlog nb_setval/2, which is equivalent to nb_linkval/2 is
not acceptable  for normal Prolog users  as the behaviour is  influenced
by  how built-in  predicates constructing  terms (read/1,  =../2,  etc.)
are implemented.

GNU-Prolog provides  a rich set of  global variables, including  arrays.
Arrays  can be  implemented  easily in  SWI-Prolog using  functor/3  and
setarg/3 due to the unrestricted arity of compound terms.


CChhaapptteerr 77..  CCHHRR:: CCOONNSSTTRRAAIINNTT HHAANNDDLLIINNGG RRUULLEESS

This chapter is written by Tom Schrijvers, K.U.  Leuven, and adjustments
by Jan Wielemaker.

The CHR system of SWI-Prolog is the _K_._U_._L_e_u_v_e_n _C_H_R _s_y_s_t_e_m.   The runtime
environment is  written by Christian Holzbaur  and Tom Schrijvers  while
the compiler  is written by  Tom Schrijvers.   Both are integrated  with
SWI-Prolog  and licensed  under  compatible conditions  with  permission
from the authors.

The main reference for the K.U.Leuven CHR system is:

  o T.   Schrijvers,  and   B.  Demoen,   _T_h_e  _K_._U_._L_e_u_v_e_n  _C_H_R   _S_y_s_t_e_m_:
    _I_m_p_l_e_m_e_n_t_a_t_i_o_n   _a_n_d  _A_p_p_l_i_c_a_t_i_o_n,  First  Workshop   on  Constraint
    Handling Rules:   Selected Contributions (Fr"uhwirth, T. and Meister,
    M., eds.), pp.  1--5, 2004.

On  the K.U.Leuven  CHR  website  (http://www.cs.kuleuven.be/~toms/CHR/)
you can find more related papers, references and example programs.


77..11 IInnttrroodduuccttiioonn

Constraint  Handling  Rules  (CHR)  is  a   committed-choice  rule-based
language embedded  in Prolog.    It is designed  for writing  constraint
solvers and  is particularly  useful for providing  application-specific
constraints.   It  has been  used in  many kinds  of applications,  like
scheduling, model checking, abduction, type checking among many others.

CHR has  previously been implemented in  other Prolog systems  (SICStus,
Eclipse,  Yap), Haskell  and Java.    This CHR  system is  based on  the
compilation scheme and runtime environment of CHR in SICStus.

In this documentation  we restrict ourselves to giving a  short overview
of  CHR  in general  and  mainly  focus  on elements  specific  to  this
implementation.    For  a  more thorough  review  of  CHR we  refer  the
reader to  [Fr"uhwirth, 1998].   More background on CHR  can be found  at
[Fr"uhwirth,].

In  section 7.2  we present  the syntax  of CHR  in  Prolog and  explain
informally its  operational semantics.    Next, section  7.3 deals  with
practical issues  of writing  and compiling  Prolog programs  containing
CHR.  Section  7.4  explains  the  currently   primitive  CHR  debugging
facilities.  Section  7.4.3 provides a few useful predicates  to inspect
the constraint  store and section 7.5  illustrates CHR with two  example
programs.  In section 7.6 some compatibility issues  with older versions
of this system and SICStus' CHR system.   Finally, section 7.7 concludes
with a few practical guidelines for using CHR.


77..22 SSyynnttaaxx aanndd SSeemmaannttiiccss


77..22..11 SSyynnttaaxx

The syntax of CHR rules is the following:

rules --> rule, rules.
rules --> [].

rule --> name, actual_rule, pragma, [atom('.')].

name --> atom, [atom('@')].
name --> [].

actual_rule --> simplification_rule.
actual_rule --> propagation_rule.
actual_rule --> simpagation_rule.

simplification_rule --> head, [atom('<=>')], guard, body.
propagation_rule --> head, [atom('==>')], guard, body.
simpagation_rule --> head, [atom('\')], head, [atom('<=>')],
                     guard, body.

head --> constraints.

constraints --> constraint, constraint_id.
constraints --> constraint, constraint_id, [atom(',')], constraints.

constraint --> compound_term.

constraint_id --> [].
constraint_id --> [atom('#')], variable.
constraint_id --> [atom('#')], [atom('passive')] .

guard --> [].
guard --> goal, [atom('|')].

body --> goal.

pragma --> [].
pragma --> [atom('pragma')], actual_pragmas.

actual_pragmas --> actual_pragma.
actual_pragmas --> actual_pragma, [atom(',')], actual_pragmas.

actual_pragma --> [atom('passive(')], variable, [atom(')')].

Note that  the guard of  a rule may  not contain any  goal that binds  a
variable in  the head of  the rule with a  non-variable or with  another
variable in the  head of the rule.   It may however bind variables  that
do  not appear  in the  head of  the rule,  e.g.  an auxiliary  variable
introduced in the guard.


77..22..22 SSeemmaannttiiccss

In  this subsection  the  operational semantics  of  CHR in  Prolog  are
presented informally.   They  do not differ  essentially from other  CHR
systems.

When a constraint is  called, it is considered an active  constraint and
the system  will try  to apply the  rules to it.    Rules are tried  and
executed sequentially in the order they are written.

A rule is conceptually  tried for an active constraint in  the following
way.  The active constraint is matched with a constraint  in the head of
the rule.   If more constraints appear  in the head they are looked  for
among the  suspended constraints, which  are called passive  constraints
in this context.  If the necessary passive constraints  can be found and
all match with the head of the rule and the guard  of the rule succeeds,
then the rule  is committed and the body of  the rule executed.   If not
all the  necessary passive constraint can  be found, the matching  fails
or the  guard fails, then the  body is not  executed and the process  of
trying and  executing simply  continues with  the following rules.    If
for a  rule,  there are  multiple constraints  in the  head, the  active
constraint  will try  the rule  sequentially multiple  times, each  time
trying to match with another constraint.

This process ends either when the active constraint  disappears, i.e. it
is removed by some rule, or after the last rule has  been processed.  In
the latter case the active constraint becomes suspended.

A  suspended constraint  is  eligible as  a  passive constraint  for  an
active constraint.  The other way it may interact  again with the rules,
is when a variable  appearing in the constraint becomes bound  to either
a non-variable or another variable involved in one  or more constraints.
In that  case the  constraint is triggered,  i.e. it  becomes an  active
constraint and all the rules are tried.

RRuullee TTyyppeess There  are three different  kinds of  rules, each with  their
specific semantics:

  o _s_i_m_p_l_i_f_i_c_a_t_i_o_n
    The  simplification rule  removes the  constraints in  its head  and
    calls its body.

  o _p_r_o_p_a_g_a_t_i_o_n
    The   propagation  rule  calls  its   body  exactly  once  for   the
    constraints in its head.

  o _s_i_m_p_a_g_a_t_i_o_n
    The  simpagation rule removes the constraints in its head  after the
    \ and then  calls its body.  It is an optimization of simplification
    rules of the form:

                  constraints1;constraints2<=> constraints1;body

    Namely, in the simpagation form:

                       constraints1\constraints2<=> body
    The constraints1constraints are not called in the body.

RRuullee NNaammeess

Naming  a rule  is optional  and has  no semantical  meaning.   It  only
functions as documentation for the programmer.

PPrraaggmmaass The semantics of the pragmas are:

ppaassssiivvee((_I_d_e_n_t_i_f_i_e_r))
    The  constraint in the  head of a rule  _I_d_e_n_t_i_f_i_e_r can only match  a
    passive  constraint in that  rule.   There is an abbreviated  syntax
    for this pragma.  Instead of:

                    ..., c # Id, ... <=> ... pragma passive(Id)

    you can also write

                    ..., c # passive, ... <=> ...

Additional pragmas may be released in the future.


::-- cchhrr__ooppttiioonn((_+_O_p_t_i_o_n_, _+_V_a_l_u_e))
    It  is  possible  to specify  options  that  apply to  all  the  CHR
    rules  in the module.   Options are specified  with the chr_option/2
    declaration:

    :- chr_option(Option,Value).

    and  may appear  in the  file anywhere after  the first  constraints
    declaration.

    Available options are:

    cchheecckk__gguuaarrdd__bbiinnddiinnggss
         This  option controls  whether  guards  should be  checked  for
         (illegal) variable bindings or  not.  Possible values  for this
         option are on,  to enable the checks,  and off, to disable  the
         checks.   If this option is on,  any guard fails when it  binds
         a variable  that appears in  the head of  the rule.   When  the
         option is  off  (default), the  behavior of  a  binding in  the
         guard is undefined.

    ooppttiimmiizzee
         This option  controls the  degree  of optimization.    Possible
         values are  full, to  enable all  available optimizations,  and
         off (default),  to  disable  all optimizations.    The  default
         is derived  from the  SWI-Prolog flag optimise,  where true  is
         mapped to full.  Therefore the command-line  option -O provides
         full CHR optimization.   If optimization is enabled,  debugging
         must be disabled.

    ddeebbuugg
         This options enables or  disables the possibility to debug  the
         CHR code.    Possible values  are on (default)  and off.    See
         section 7.4  for more  details on debugging.    The default  is
         derived  from the  Prolog  flag  generate_debug_info,  which  is
         true by  default.   See  -nodebug.   If  debugging is  enabled,
         optimization must be disabled.


77..33 CCHHRR iinn SSWWII--PPrroolloogg PPrrooggrraammss


77..33..11 EEmmbbeeddddiinngg iinn PPrroolloogg PPrrooggrraammss

The CHR constraints defined in a .pl file are  associated with a module.
The default module is  user.  One should never load different  .pl files
with the same CHR module name.


77..33..22 CCoonnssttrraaiinntt ddeeccllaarraattiioonn


::-- cchhrr__ccoonnssttrraaiinntt((_+_S_p_e_c_i_f_i_e_r))
    Every  constraint  used in  CHR  rules has  to  be declared  with  a
    chr_constraint/1  declaration  by the  _c_o_n_s_t_r_a_i_n_t  _s_p_e_c_i_f_i_e_r.    For
    convenience  multiple constraints may be  declared at once with  the
    same  chr_constraint/1  declaration followed  by  a  comma-separated
    list of constraint specifiers.

    A  constraint specifier is,  in its compact form,  F/A where F  and
    A  are respectively the  functor name and arity  of the constraint,
    e.g.:

    :- chr_constraint foo/1.
    :- chr_constraint bar/2, baz/3.

    In  its extended form, a constraint specifier is c(A1,...,An) where
    c  is the constraint's functor, n its arity and  the Aiare  argument
    specifiers.   An argument  specifier is a mode, optionally  followed
    by a type.  E.g.

    :- chr_constraint get_value(+,?).
    :- chr_constraint domain(?int, +list(int)),
                      alldifferent(?list(int)).

MMooddeess

A mode is one of:

-
    The corresponding argument  of every occurrence of the constraint is
    always unbound.

+
    The corresponding argument  of every occurrence of the constraint is
    always ground.

?
    The  corresponding argument  of every occurrence  of the  constraint
    can  have any instantiation,  which may change over  time.  This  is
    the default value.

TTyyppeess

A type can be a user-defined type or one of the built-in  types.  A type
comprises a  (possibly infinite) set  of values.   The type  declaration
for  a  constraint  argument means  that  for  every  instance  of  that
constraint the  corresponding argument is only  ever bound to values  in
that set.   It does  not state that the  argument necessarily has to  be
bound to a value.

The built-in types are:

iinntt
    The corresponding argument  of every occurrence of the constraint is
    an integer number.

ddeennssee__iinntt
    The corresponding argument  of every occurrence of the constraint is
    an  integer that can be used as an  array index.  Note that  if this
    argument takes values in [0; n], the array takes O(n) space.

ffllooaatt
    ...a floating point number.

nnuummbbeerr
    ...a number.

nnaattuurraall
    ...a positive integer.

aannyy
    The  corresponding argument  of every occurrence  of the  constraint
    can have any type.  This is the default value.


::-- cchhrr__ttyyppee((_+_T_y_p_e_D_e_c_l_a_r_a_t_i_o_n))
    User-defined  types are algebraic  data types,  similar to those  in
    Haskell  or the discriminated unions in Mercury.  An  algebraic data
    type is defined using chr_type/1:

    :- chr_type type ---> body.

    If  the type term is a functor  of arity zero (i.e. one  having zero
    arguments),  it names  a monomorphic type.   Otherwise,  it names  a
    polymorphic  type;  the arguments of  the functor  must be  distinct
    type  variables.     The body  term  is  defined as  a  sequence  of
    constructor definitions separated by semi-colons.

    Each  constructor  definition  must  be a  functor  whose  arguments
    (if  any)  are  types.    Discriminated  union definitions  must  be
    transparent:   all type  variables occurring in  the body must  also
    occur in the type.

    Here are some examples of algebraic data type definitions:

    :- chr_type color ---> red ; blue ; yellow ; green.

    :- chr_type tree --->  empty ; leaf(int) ; branch(tree, tree).

    :- chr_type list(T) ---> [] ; [T | list(T)].

    :- chr_type pair(T1, T2) ---> (T1 - T2).

    Each  algebraic data  type  definition introduces  a distinct  type.
    Two  algebraic data types that  have the same bodies are  considered
    to be distinct types (name equivalence).

    Constructors may be  overloaded among different types:  there may be
    any  number of constructors with a given name and arity, so  long as
    they all have different types.

    Aliases can be defined  using ==.  For example, if your program uses
    lists of lists of integers, you can define an alias as follows:

    :- chr_type lli == list(list(int)).

TTyyppee CChheecckkiinngg

Currently two complementary forms of type checking are performed:

 1. Static  type checking is  always performed by the  compiler.  It  is
    limited to CHR rule heads and CHR constraint calls in rule bodies.

    Two  kinds  of type  error  are detected.    The  first is  where  a
    variable has to belong to two types.  For example, in the program:

    :-chr_type foo ---> foo.
    :-chr_type bar ---> bar.

    :-chr_constraint abc(?foo).
    :-chr_constraint def(?bar).

    foobar @ abc(X) <=> def(X).

    the  variable  X has  to be  of both  type foo  and bar.    This  is
    reported by the type clash error:

    CHR compiler ERROR:
        `--> Type clash for variable _G5398 in rule foobar:
                    expected type foo in body goal def(_G5398, _G5448)
                    expected type bar in head def(_G5448, _G5398)

    The  second kind of error is where  a functor is used that  does not
    belong to the declared type.  For example in:

    :-chr_type foo ---> foo.
    :-chr_type bar ---> bar.

    :-chr_constraint abc(?foo).

    foo @ abc(bar) <=> true.

    in  the head of the rule bar appears where something of type  foo is
    expected.  This is reported as:

    CHR compiler ERROR:
        `--> Invalid functor in head abc(bar) of rule foo:
                    found `bar',
                    expected type `foo'!

    No runtime overhead is incurred in static type checking.

 2. Dynamic  type checking checks at runtime, during  program execution,
    whether  the arguments  of  CHR constraints  respect their  declared
    types.   The  when/2 co-routining library  is used to delay  dynamic
    type checks until variables are instantiated.

    The  kind of  error detected  by dynamic  type checking  is where  a
    functor  is used that does  not belong to the  declared type.   E.g.
    for the program:

    :-chr_type foo ---> foo.

    :-chr_constraint abc(?foo).

    we get the following error in an erroneous query:

    ?- abc(bar).
    ERROR: Type error: `foo' expected, found `bar' (CHR Run-
    time Type Error)

    Dynamic  type checking is  weaker than static  type checking in  the
    sense  that it only checks the particular program execution  at hand
    rather  than all possible executions.   It is stronger in the  sense
    that it tracks types throughout the whole program.

    Note  that it  is enabled  only in  debug  mode, as  it incurs  some
    (minor) runtime overhead.


77..33..33 CCoommppiillaattiioonn

The  SWI-Prolog   CHR  compiler   exploits  term_expansion/2  rules   to
translate the constraint  handling rules to plain  Prolog.  These  rules
are loaded  from the library chr.   They  are activated if the  compiled
file  has the  .chr extension  or  after finding  a declaration  of  the
format below.

:- chr_constraint ...

It is  advised to define CHR  rules in a  module file, where the  module
declaration  is  immediately  followed  by  including  the  library(chr)
library as exemplified below:

:- module(zebra, [ zebra/0 ]).
:- use_module(library(chr)).

:- chr_constraint ...

Using this style CHR  rules can be defined in ordinary Prolog  .pl files
and the operator  definitions required by CHR  do not leak into  modules
where they might cause conflicts.


77..44 DDeebbuuggggiinngg

The  CHR  debugging facilities  are  currently  rather limited.     Only
tracing is  currently available.   To use  the CHR debugging  facilities
for a  CHR file it  must be  compiled for debugging.   Generating  debug
info is  controlled by the  CHR option debug,  whose default is  derived
from the SWI-Prolog  flag generate_debug_info.   Therefore debug info  is
provided unless the -nodebug is used.


77..44..11 PPoorrttss

For CHR constraints the four standard ports are defined:

ccaallll
    A new constraint is called and becomes active.

eexxiitt
    An  active  constraint  exits:    it has  either  been  inserted  in
    the  store  after trying  all rules  or has  been  removed from  the
    constraint store.

ffaaiill
    An active constraint fails.

rreeddoo
    An active constraint starts looking for an alternative solution.

In addition  to the above  ports, CHR  constraints have five  additional
ports:

wwaakkee
    A suspended constraint is woken and becomes active.

iinnsseerrtt
    An  active constraint has  tried all rules  and is suspended in  the
    constraint store.

rreemmoovvee
    An  active  or passive  constraint is  removed  from the  constraint
    store.

ttrryy
    An  active  constraints  tries a  rule  with possibly  some  passive
    constraints.  The  try port is entered just before committing to the
    rule.

aappppllyy
    An  active constraints commits to a rule with possibly  some passive
    constraints.   The  apply port is  entered just after committing  to
    the rule.


77..44..22 TTrraacciinngg

Tracing is enabled with the chr_trace/0 predicate and disabled  with the
chr_notrace/0 predicate.

When enabled  the tracer will  step through the  call, exit, fail,  wake
and apply  ports, accepting  debug commands,  and simply  write out  the
other ports.

The following debug commands are currently supported:

        CHR debug options:

                <cr>    creep           c       creep
                s       skip
                g       ancestors
                n       nodebug
                b       break
                a       abort
                f       fail
                ?       help            h       help

Their meaning is:

ccrreeeepp
    Step to the next port.

sskkiipp
    Skip to exit port of this call or wake port.

aanncceessttoorrss
    Print list of ancestor call and wake ports.

nnooddeebbuugg
    Disable the tracer.

bbrreeaakk
    Enter a recursive Prolog top-level.  See break/0.

aabboorrtt
    Exit to the top-level.  See abort/0.

ffaaiill
    Insert failure in execution.

hheellpp
    Print the above available debug options.


77..44..33 CCHHRR DDeebbuuggggiinngg PPrreeddiiccaatteess

The chr  module contains  several predicates that  allow inspecting  and
printing the content of the constraint store.


cchhrr__ttrraaccee
    Activate  the CHR tracer.   By default  the CHR tracer is  activated
    and  deactivated automatically by the Prolog predicates  trace/0 and
    notrace/0.


cchhrr__nnoottrraaccee
    De-activate the CHR tracer.   By default the CHR tracer is activated
    and  deactivated automatically by the Prolog predicates  trace/0 and
    notrace/0.


cchhrr__lleeaasshh((_+_S_p_e_c))
    Define  the set of CHR ports on  which the CHR tracer asks  for user
    intervention  (i.e. stops).    _S_p_e_c  is either  a list  of ports  as
    defined  in section 7.4.1 or a predefined `alias'.   Defined aliases
    are:   full to  stop at all ports,  none or off  to never stop,  and
    default to stop at  the call, exit, fail, wake and apply ports.  See
    also leash/1.


cchhrr__sshhooww__ssttoorree((_+_M_o_d))
    Prints  all  suspended constraints  of module  _M_o_d  to the  standard
    output.   This predicate  is automatically called by the  SWI-Prolog
    top-level  at the end of each  query for every CHR module  currently
    loaded.    The Prolog flag  chr_toplevel_show_store controls  whether
    the  top-level shows the constraint stores.  The value  true enables
    it.  Any other value disables it.


ffiinndd__cchhrr__ccoonnssttrraaiinntt((_-_C_o_n_s_t_r_a_i_n_t))
    Returns  a constraint in  the constraint store.   Via  backtracking,
    all constraints in the store can be enumerated.


77..55 EExxaammpplleess

Here are two example constraint solvers written in CHR.

  o The  program below  defines a  solver with  one constraint,  leq/2/,
    which  is a less-than-or-equal constraint,  also known as a  partial
    order constraint.

    :- module(leq,[leq/2]).
    :- use_module(library(chr)).

    :- chr_constraint leq/2.
    reflexivity  @ leq(X,X) <=> true.
    antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.
    idempotence  @ leq(X,Y) \ leq(X,Y) <=> true.
    transitivity @ leq(X,Y), leq(Y,Z) ==> leq(X,Z).

    When the above program  is saved in a file and loaded in SWI-Prolog,
    you can call the leq/2 constraints in a query, e.g.:

    ?- leq(X,Y), leq(Y,Z).
    leq(_G23837, _G23841)
    leq(_G23838, _G23841)
    leq(_G23837, _G23838)

    X = _G23837{leq = ...}
    Y = _G23838{leq = ...}
    Z = _G23841{leq = ...}

    Yes

    When  the  query  succeeds,  the  SWI-Prolog  top-level  prints  the
    content  of  the  CHR constraint  store  and displays  the  bindings
    generate  during  the  query.    Some  of the  query  variables  may
    have  been bound to  attributed variables, as  you see in the  above
    example.

  o The  program  below implements  a  simple finite  domain  constraint
    solver.

    :- module(dom,[dom/2]).
    :- use_module(library(chr)).

    :- chr_constraint dom(?int,+list(int)).
    :- chr_type list(T) ---> [] ; [T|list(T)].

    dom(X,[]) <=> fail.
    dom(X,[Y]) <=> X = Y.
    dom(X,L) <=> nonvar(X) | memberchk(X,L).
    dom(X,L1), dom(X,L2) <=> intersection(L1,L2,L3), dom(X,L3).

    When the above program  is saved in a file and loaded in SWI-Prolog,
    you can call the dom/2 constraints in a query, e.g.:

    ?- dom(A,[1,2,3]), dom(A,[3,4,5]).

    A = 3

    Yes


77..66 BBaacckkwwaarrddss CCoommppaattiibbiilliittyy


77..66..11 TThhee OOlldd SSIICCSSttuuss CCHHRR iimmpplleemmeennaattiioonn

There are  small differences between the  current K.U.Leuven CHR  system
in  SWI-Prolog, older  versions  of the  same  system and  SICStus'  CHR
system.

The  current  system maps  old  syntactic  elements onto  new  ones  and
ignores a number  of no longer required elements.   However, for each  a
_d_e_p_r_e_c_a_t_e_d warning  is issued.   You  are strongly  urged to replace  or
remove deprecated features.

Besides  differences in  available options  and pragmas,  the  following
differences should be noted:

  o _T_h_e constraints/1 _d_e_c_l_a_r_a_t_i_o_n
    This  declaration is  deprecated.   It  has been  replaced with  the
    chr_constraint/1 declaration.

  o _T_h_e option/2 _d_e_c_l_a_r_a_t_i_o_n
    This  declaration is  deprecated.   It  has been  replaced with  the
    chr_option/2 declaration.

  o _T_h_e handler/1 _d_e_c_l_a_r_a_t_i_o_n
    In  SICStus  every  CHR  module  requires  a  handler/1  declaration
    declaring  a unique handler name.  This declaration is  valid syntax
    in  SWI-Prolog, but will have  no effect.   A warning will be  given
    during compilation.

  o _T_h_e rules/1 _d_e_c_l_a_r_a_t_i_o_n
    In  SICStus, for every  CHR module it is  possible to only enable  a
    subset of the  available rules through the rules/1 declaration.  The
    declaration  is valid syntax in  SWI-Prolog, but has  no effect.   A
    warning is given during compilation.

  o _G_u_a_r_d _b_i_n_d_i_n_g_s
    The   check_guard_bindings  option   only  turns  invalid  calls   to
    unification  into failure.   In SICStus this  option does more:   it
    intercepts  instantiation errors from Prolog built-ins such  as is/2
    and turns them into  failure.  In SWI-Prolog, we do not go this far,
    as  we like to separate  concerns more.   The CHR compiler is  aware
    of  the CHR code, the Prolog  system and programmer should be  aware
    of  the appropriate meaning of the  Prolog goals used in guards  and
    bodies of CHR rules.


77..66..22 TThhee OOlldd EECCLLiiPPSSee CCHHRR iimmpplleemmeennaattiioonn

The old  ECLiPSe CHR implementations  features a  label_with/1 construct
for  labeling variables  in CHR  constraints.    This feature  has  long
since been abandoned.   However, a simple transformation is all  that is
required to port the functionality.

label_with Constraint1 if Condition1.
...
label_with ConstraintN if ConditionN.
Constraint1 :- Body1.
...
ConstraintN :- BodyN.

is transformed into

:- chr_constraint my_labeling/0.

my_labeling \ Constraint1 <=> Condition1 | Body1.
...
my_labeling \ ConstraintN <=> ConditionN | BodyN.
my_labeling <=> true.

Be sure to  put this code after all other  rules in your program!   With
my_labeling/0 (or another predicate name of your choosing)  the labeling
is initiated, rather than ECLiPSe's chr_labeling/0.


77..77 PPrrooggrraammmmiinngg TTiippss aanndd TTrriicckkss

In this section we  cover several guidelines on how to use CHR  to write
constraint solvers and how to do so efficiently.

  o _C_h_e_c_k _g_u_a_r_d _b_i_n_d_i_n_g_s _y_o_u_r_s_e_l_f
    It  is considered bad practice  to write guards that bind  variables
    of  the head and to  rely on the system  to detect this at  runtime.
    It is inefficient and obscures the working of the program.

  o _S_e_t _s_e_m_a_n_t_i_c_s
    The  CHR system allows the  presence of identical constraints,  i.e.
    multiple  constraints with  the same functor,  arity and  arguments.
    For  most constraint  solvers, this  is not desirable:   it  affects
    efficiency and possibly  termination.  Hence appropriate simpagation
    rules should be added of the form:

                         constraint\constraint <=>true

  o _M_u_l_t_i_-_h_e_a_d_e_d _r_u_l_e_s
    Multi-headed   rules  are   executed  more   efficiently  when   the
    constraints share one or more variables.

  o _M_o_d_e _a_n_d _t_y_p_e _d_e_c_l_a_r_a_t_i_o_n_s
    Provide  mode and  type declarations to  get more efficient  program
    execution.     Make sure  to  disable  debug (-nodebug)  and  enable
    optimization (-O).

  o _C_o_m_p_i_l_e _o_n_c_e_, _r_u_n _m_a_n_y _t_i_m_e_s
    Does  consulting your CHR  program take a  long time in  SWI-Prolog?
    Probably  it takes the CHR compiler  a long time to compile the  CHR
    rules  into Prolog  code.   When you  disable optimizations the  CHR
    compiler  will be  a lot  quicker,  but you  may loose  performance.
    Alternatively, you  can just use SWI-Prolog's qcompile/1 to generate
    a  .qlf  file once  from your  .pl file.    This  .qlf contains  the
    generated  code of  the CHR  compiler (be  it in  a binary  format).
    When you consult the  .qlf file, the CHR compiler is not invoked and
    consultation is much faster.

  o _F_i_n_d_i_n_g _C_o_n_s_t_r_a_i_n_t_s
    The  find_chr_constraint/1 predicate  is fairly  expensive.    Avoid
    it,  if  possible.   If  you must  use it,  try  to use  it with  an
    instantiated toplevel constraint symbol.


77..88 CCoommppiilleerr EErrrroorrss aanndd WWaarrnniinnggss

In  this section  we  summarize the  most  important error  and  warning
messages of the CHR compiler.


77..88..11 CCHHRR CCoommppiilleerr EErrrroorrss

TTyyppee ccllaasshh  for variable ...  in rule ...

    This  error indicates  an inconsistency  between declared  types;  a
    variable should belong to two types.  See static type checking.

IInnvvaalliidd ffuunnccttoorr  in head ...  of rule ...

    This  error indicates an inconsistency  between a declared type  and
    the use of a functor in a rule.  See static type checking.

CCyycclliicc aalliiaass  definition:  ...  == ...

    You  have defined a type alias  in terms of itself, either  directly
    or indirectly.

AAmmbbiigguuoouuss ttyyppee aalliiaasseess  You have defined two overlapping type aliases.

MMuullttiippllee ddeeffiinniittiioonnss  for type

    You have defined the same type multiple times.

NNoonn--ggrroouunndd ttyyppee  in constraint definition:  ...

    You have declared a non-ground type for a constraint argument.

CCoouulldd nnoott ffiinndd ttyyppee ddeeffiinniittiioonn  for ...

    You have used an undefined type in a type declaration.

IIlllleeggaall mmooddee//ttyyppee ddeeccllaarraattiioonn  You  have  used   invalid  syntax  in   a
    constraint declaration.

CCoonnssttrraaiinntt mmuullttiippllyy ddeeffiinneedd  There is more than one declaration  for the
    same constraint.

UUnnddeeccllaarreedd ccoonnssttrraaiinntt  ...  in head of ...

    You have used an  undeclared constraint in the head of a rule.  This
    often  indicates a  misspelled constrained name  or wrong number  of
    arguments.

IInnvvaalliidd pprraaggmmaa  ...  in ...  Pragma should not be a variable.

    You  have used  a variable  as a  pragma in  a rule.    This is  not
    allowed.

IInnvvaalliidd iiddeennttiiffiieerr  ...  in pragma passive in ...

    You  have  used an  identifier in  a passive  pragma  that does  not
    correspond  to an identifier in  the head of the  rule.  Likely  the
    identifier name is misspelled.

UUnnkknnoowwnn pprraaggmmaa  ...  in ...

    You  have used an unknown  pragma in a rule.   Likely the pragma  is
    misspelled or not supported.

SSoommeetthhiinngg uunneexxppeecctteedd  happened in the CHR compiler

    You have most likely  bumped into a bug in the CHR compiler.  Please
    contact Tom Schrijvers to notify him of this error.


CChhaapptteerr 88..  MMUULLTTII--TTHHRREEAADDEEDD AAPPPPLLIICCAATTIIOONNSS

SWI-Prolog multithreading is  based on standard C-language  multithread-
ing support.   It is not  like _P_a_r_L_o_g or other parallel  implementations
of the Prolog language.   Prolog threads have their own stacks  and only
share the  Prolog _h_e_a_p:   predicates,  records, flags  and other  global
non-backtrackable data.  SWI-Prolog thread support is  designed with the
following goals in mind.

  o _M_u_l_t_i_-_t_h_r_e_a_d_e_d _s_e_r_v_e_r _a_p_p_l_i_c_a_t_i_o_n_s
    Todays   computing  services  often   focus  on  (internet)   server
    applications.   Such applications often have need  for communication
    between  services  and/or  fast  non-blocking  service  to  multiple
    concurrent  clients.   The shared  heap provides fast  communication
    and thread creation is relatively cheap.

  o _I_n_t_e_r_a_c_t_i_v_e _a_p_p_l_i_c_a_t_i_o_n_s
    Interactive   applications   often   need   to   perform   extensive
    computation.   If  such computations are  executed in a new  thread,
    the  main thread  can process events  and allow  the user to  cancel
    the  ongoing computation.    User interfaces can  also use  multiple
    threads,  each thread dealing  with input from  a distinct group  of
    windows.  See also section 8.8.

  o _N_a_t_u_r_a_l _i_n_t_e_g_r_a_t_i_o_n _w_i_t_h _f_o_r_e_i_g_n _c_o_d_e
    Each Prolog thread  runs in a native thread of the operating system,
    automatically  making them cooperate with _M_T_-_s_a_f_e foreign-code.   In
    addition,  any foreign thread can  create its own Prolog engine  for
    dealing with calling Prolog from C-code.

SWI-Prolog  multi-threading  is  based  on  the  POSIX  thread  standard
[Butenhof, 1997] used  on most  popular systems  except for  MS-Windows.
On Windows  it uses the pthread-win32  emulation of POSIX threads  mixed
with the Windows native API for smoother and faster operation.


88..11 CCrreeaattiinngg aanndd ddeessttrrooyyiinngg PPrroolloogg tthhrreeaaddss


tthhrreeaadd__ccrreeaattee((_:_G_o_a_l_, _-_I_d_, _+_O_p_t_i_o_n_s))
    Create  a new Prolog thread  (and underlying C-thread) and start  it
    by  executing _G_o_a_l.    If the  thread is  created successfully,  the
    thread-identifier  of the created thread is unified to _I_d.   _O_p_t_i_o_n_s
    is  a list of  options.   The currently  defined options are  below.
    Stack  size options can also take  the value inf or infinite,  which
    is mapped to the maximum stack size supported by the platform.

    aalliiaass((_A_l_i_a_s_N_a_m_e))
         Associate an `alias-name' with  the thread.  This named  may be
         used to refer to the thread and remains valid  until the thread
         is joined (see thread_join/2).

    aarrgguummeenntt((_K_-_B_y_t_e_s))
         Set the limit  to which the argument  stack of this thread  may
         grow.   If omitted,  the limit of the  calling thread is  used.
         See also the -A command-line option.

    aatt__eexxiitt((_:_A_t_E_x_i_t))
         Register _A_t_E_x_i_t  as using thread_at_exit/1 before entering  the
         thread  goal.    Unlike  calling  thread_at_exit/1 as  part  of
         the normal  _G_o_a_l,  this _e_n_s_u_r_e_s  the  _G_o_a_l is  called.    Using
         thread_at_exit/1,  the thread  may be  signalled or  run out  of
         resources before thread_at_exit/1is reached.

    ddeettaacchheedd((_B_o_o_l))
         If  false  (default),  the  thread  can  be  waited  for  using
         thread_join/2.   thread_join/2 must  be called  on this  thread
         to  reclaim  the  all  resources  associated  to   the  thread.
         If  true, the  system  will  reclaim all  associated  resources
         automatically after  the thread  finishes.    Please note  that
         thread identifiers are freed for reuse after  a detached thread
         finishes  or a  normal  thread  has  been joined.     See  also
         thread_join/2 and thread_detach/1.

         If a detached  thread dies due to  failure or exception of  the
         initial goal the thread prints a message using print_message/2.
         If  such termination  is considered  normal  the code  must  be
         wrapped  using ignore/1  and/or  catch/3 to  ensure  successful
         completion.

    gglloobbaall((_K_-_B_y_t_e_s))
         Set the  limit to  which the global  stack of  this thread  may
         grow.   If omitted,  the limit of the  calling thread is  used.
         See also the -G command-line option.

    llooccaall((_K_-_B_y_t_e_s))
         Set the  limit to  which  the local  stack of  this thread  may
         grow.   If omitted,  the limit of the  calling thread is  used.
         See also the -L command-line option.

    ssttaacckk((_K_-_B_y_t_e_s))
         Set  the  limit  to which  the  system  stack  of  this  thread
         may  grow.    The  default,  minimum  and  maximum  values  are
         system-dependant.

    ttrraaiill((_K_-_B_y_t_e_s))
         Set the  limit to  which  the trail  stack of  this thread  may
         grow.   If omitted,  the limit of the  calling thread is  used.
         See also the -T command-line option.

    The _G_o_a_l argument is  _c_o_p_i_e_d to the new Prolog engine.  This implies
    further  instantiation of this term  in either thread does not  have
    consequences  for the  other thread:   Prolog threads  do not  share
    data from their stacks.


tthhrreeaadd__sseellff((_-_I_d))
    Get  the Prolog thread  identifier of  the running thread.   If  the
    thread has an alias, the alias-name is returned.


tthhrreeaadd__jjooiinn((_+_I_d_, _-_S_t_a_t_u_s))
    Wait  for the termination of thread with  given _I_d.  Then  unify the
    result-status  of  the thread  with _S_t_a_t_u_s.    After this  call,  _I_d
    becomes  invalid and  all resources associated  with the thread  are
    reclaimed.    Note that  threads with  the attribute  detached(_t_r_u_e)
    cannot be joined.  See also thread_property/2.

    A thread  that has been completed without thread_join/2 being called
    on  it is partly reclaimed:  the Prolog stacks are released  and the
    C-thread  is destroyed.    A small  data-structure representing  the
    exit-status of  the thread is retained until thread_join/2 is called
    on the thread.  Defined values for _S_t_a_t_u_s are:

    ttrruuee
         The goal has been proven successfully.

    ffaallssee
         The goal has failed.

    eexxcceeppttiioonn((_T_e_r_m))
         The thread is terminated on an  exception.  See print_message/2
         to turn system exceptions into readable messages.

    eexxiitteedd((_T_e_r_m))
         The thread  is terminated on  thread_exit/1 using the  argument
         _T_e_r_m.


tthhrreeaadd__ddeettaacchh((_+_I_d))
    Switch  thread  into detached-state  (see detached(_B_o_o_l)  option  at
    thread_create/3)  at  runtime.     _I_d  is   the  identifier  of  the
    thread  placed  in detached  state.    This  may  be the  result  of
    PL_thread_self/1.

    One   of  the  possible  applications  is  to   simplify  debugging.
    Threads  that  are  created as  _d_e_t_a_c_h_e_d  leave  no traces  if  they
    crash.   For not-detached threads the status can be  inspected using
    thread_property/2.   Threads  nobody is waiting  for may be  created
    normally  and detach themselves  just before completion.   This  way
    they  leave no  traces  on normal  completion and  their reason  for
    failure can be inspected.


tthhrreeaadd__eexxiitt((_+_T_e_r_m))                                          _[_d_e_p_r_e_c_a_t_e_d_]
    Terminates  the thread immediately, leaving exited(_T_e_r_m)  as result-
    state  for   thread_join/2.     If  the   thread  has  the  attribute
    detached(_t_r_u_e)  it  terminates,   but  its  exit  status  cannot  be
    retrieved  using thread_join/2 making the value of _T_e_r_m  irrelevant.
    The Prolog stacks and C-thread are reclaimed.

    The  current implementation does  not guarantee proper releasing  of
    all  mutexes  and proper  cleanup in  call_cleanup/2,  etc.    Please
    use  the  exception mechanism  (throw/1)  to abort  execution  using
    non-standard control.


tthhrreeaadd__iinniittiiaalliizzaattiioonn((_:_G_o_a_l))
    Run  _G_o_a_l  when   thread  is  started.     This  predicate  must  be
    compared  with initialization/1, but is intended  for initialization
    operations  of the runtime stacks, such as setting  global variables
    as  described  in section  6.3.    _G_o_a_l is  run on  four  occasions:
    at  the call  to this  predicate, after  loading a  saved state,  on
    starting  a new thread and on  creating a Prolog engine through  the
    C  interface.   On  loading a saved  state, _G_o_a_l  is executed  _a_f_t_e_r
    running the initialization/1 hooks.


tthhrreeaadd__aatt__eexxiitt((_:_G_o_a_l))
    Run  _G_o_a_l just before  releasing the thread resources.   This is  to
    be  compared to at_halt/1, but only for  the current thread.   These
    hooks  are ran  regardless of why  the execution  of the thread  has
    been  completed.    As  these  hooks  are run,  the  return-code  is
    already  available  through thread_property/2  using the  result  of
    thread_self/1  as thread-identifier.    See  also the  at_exit(_G_o_a_l)
    argmument of thread_create/3.


tthhrreeaadd__sseettccoonnccuurrrreennccyy((_-_O_l_d_, _+_N_e_w))
    Determine  the  concurrency of  the  process,  which is  defined  as
    the  maximum number of concurrently  active threads.  `Active'  here
    means  they are  using CPU time.    This option is  provided if  the
    thread-implementation  provides  pthread_setconcurrency().    Solaris
    is  a  typical example  of  this  family.    On other  systems  this
    predicate unifies _O_l_d to 0 (zero) and succeeds silently.


88..22 MMoonniittoorriinngg tthhrreeaaddss

Normal multi-threaded applications should not need  these the predicates
from  this section  because  almost any  usage  of these  predicates  is
unsafe.     For  example checking  the  existence  of  a  thread  before
signalling it  is of  no use  as it may  vanish between  the two  calls.
Catching exceptions  using catch/3  is the  only safe way  to deal  with
thread-existence errors.

These predicates are provided  for diagnosis and monitoring tasks.   See
also section 8.5, describing more high-level primitives.


tthhrreeaadd__pprrooppeerrttyy((_?_I_d_, _?_P_r_o_p_e_r_t_y))
    True  if thread  _I_d  has _P_r_o_p_e_r_t_y.    Either or  both arguments  may
    be  unbound, enumerating  all relations  on backtracking.    Calling
    thread_property/2  does  not  influence  any  thread.      See  also
    thread_join/2.   For threads that  have an alias-name, this name  is
    returned in _I_d  instead of the numerical thread identifier.  Defined
    properties are:

    aalliiaass((_A_l_i_a_s))
         _A_l_i_a_s is the alias name of thread _I_d.

    ddeettaacchheedd((_B_o_o_l_e_a_n))
         Current detached status of the thread.

    ssttaattuuss((_S_t_a_t_u_s))
         Current status of the thread.  _S_t_a_t_u_s is one of:

         rruunnnniinngg
             The  thread is running.   This is  the initial status of  a
             thread.   Please  note that  threads waiting for  something
             are considered running too.

         ffaallssee
             The _G_o_a_l of the thread has been completed and failed.

         ttrruuee
             The _G_o_a_l of the thread has been completed and succeeded.

         eexxiitteedd((_T_e_r_m))
             The   _G_o_a_l  of  the  thread   has  been  terminated   using
             thread_exit/1 with  _T_e_r_m as  argument.   If the  underlying
             native  thread has  exited  (using pthread_exit()) _T_e_r_m  is
             unbound.

         eexxcceeppttiioonn((_T_e_r_m))
             The  _G_o_a_l  of the  thread has  been  terminated due  to  an
             uncaught exception (see throw/1 and catch/3).


tthhrreeaadd__ssttaattiissttiiccss((_+_I_d_, _+_K_e_y_, _-_V_a_l_u_e))
    Obtains  statistical information on  thread _I_d as statistics/2  does
    in  single-threaded  applications.    This  call supports  all  keys
    of  statistics/2,  although  only stack  sizes  and CPU  time  yield
    different values for each thread.


mmuutteexx__ssttaattiissttiiccss
    Print  usage statistics on  internal mutexes and mutexes  associated
    with  dynamic predicates.  For  each mutex two numbers are  printed:
    the  number  of times  the  mutex was  acquired  and the  number  of
    _c_o_l_l_i_s_i_o_n_s:   the number  times the calling  thread has to wait  for
    the  mutex.   The  collision-count is not  available on  MS-Windows.
    Generally collision count is close to zero on single-CPU hardware.


88..33 TThhrreeaadd ccoommmmuunniiccaattiioonn


88..33..11 MMeessssaaggee qquueeuueess

Prolog  threads can  exchange data  using dynamic  predicates,  database
records,  and other globally  shared data.   These  provide no  suitable
means to wait for data or a condition as they can  only be checked in an
expensive polling loop.   _M_e_s_s_a_g_e _q_u_e_u_e_s provide a means for  threads to
wait for data or conditions without using the CPU.

Each thread  has a message-queue  attached to it  that is identified  by
the thread.  Additional queues are created using message_queue_create/1.


tthhrreeaadd__sseenndd__mmeessssaaggee((_+_Q_u_e_u_e_O_r_T_h_r_e_a_d_I_d_, _+_T_e_r_m))
    Place  _T_e_r_m in  the given queue  or default  queue of the  indicated
    thread  (which  can  even  be  the  message  queue  of  itself  (see
    thread_self/1).    Any  term  can  be  placed in  a  message  queue,
    but  note  that the  term  is copied  to  the receiving  thread  and
    variable-bindings are thus lost.  This call returns immediately.

    If  more than one thread is waiting for messages on the  given queue
    and  at least one of these is waiting with a  partially instantiated
    _T_e_r_m, the waiting  threads are _a_l_l sent a wake-up signal, starting a
    rush  for the available messages in  the queue.  This behaviour  can
    seriously  harm performance  with many threads  waiting on the  same
    queue  as all-but-the-winner  perform a useless  scan of the  queue.
    If  there is  only one waiting  thread or  all waiting threads  wait
    with  an unbound variable an  arbitrary thread is restarted to  scan
    the queue.


tthhrreeaadd__ggeett__mmeessssaaggee((_?_T_e_r_m))
    Examines the thread  message queue and if necessary blocks execution
    until  a term that unifies  to _T_e_r_m arrives in  the queue.  After  a
    term  from the queue has been  unified to _T_e_r_m, the term  is deleted
    from the queue.

    Please  note that not-unifying messages remain in the queue.   After
    the  following has been  executed, thread 1  has the term b(_g_n_u)  in
    its queue and continues execution using _A = gnat.

       <thread 1>
       thread_get_message(a(A)),

       <thread 2>
       thread_send_message(Thread_1, b(gnu)),
       thread_send_message(Thread_1, a(gnat)),

    See also thread_peek_message/1.


tthhrreeaadd__ppeeeekk__mmeessssaaggee((_?_T_e_r_m))
    Examines  the thread  message-queue  and compares  the queued  terms
    with   _T_e_r_m  until  one  unifies  or  the  end  of  the   queue  has
    been  reached.    In  the first  case  the call  succeeds  (possibly
    instantiating  _T_e_r_m.   If no term from  the queue unifies this  call
    fails.


mmeessssaaggee__qquueeuuee__ccrreeaattee((_?_Q_u_e_u_e))
    If  _Q_u_e_u_e is an atom, create a  named queue.  To avoid  ambiguity of
    thread_send_message/2, the name  of a queue may  not be in use as  a
    thread-name.  If  _Q_u_e_u_e is unbound an anonymous queue is created and
    _Q_u_e_u_e is unified to its identifier.


mmeessssaaggee__qquueeuuee__ccrreeaattee((_-_Q_u_e_u_e_, _+_O_p_t_i_o_n_s))
    Create a message queue from _O_p_t_i_o_n_s.  Defined options are.

    aalliiaass((_+_A_l_i_a_s))
         Same as  message_queue_create(_A_l_i_a_s), but  according to the  ISO
         draft on Prolog threads.

    mmaaxx__ssiizzee((_+_S_i_z_e))
         Maximum number  of  terms in  the queue.    If  this number  is
         reached,  thread_send_message/2 will  suspend until  the  queue
         is drained.   The  option can  be used if  the source,  sending
         messages to the queue, is faster than the  drain, consuming the
         messages.


mmeessssaaggee__qquueeuuee__ddeessttrrooyy((_+_Q_u_e_u_e))
    Destroy  a message  queue created  with message_queue_create/1.    It
    is  _n_o_t allowed to  destroy the queue  of a thread.   Neither is  it
    allowed to destroy a queue other threads are waiting for.


tthhrreeaadd__ggeett__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m))
    As  thread_get_message/1, operating on a given queue.   It is allowed
    (but not advised) to get messages from the queue of other threads.


tthhrreeaadd__ppeeeekk__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m))
    As  thread_peek_message/1,  operating on  a  given  queue.    It  is
    allowed  to peek into another  thread's message queue, an  operation
    that  can be used to check whether a thread has swallowed  a message
    sent to it.


mmeessssaaggee__qquueeuuee__pprrooppeerrttyy((_?_Q_u_e_u_e_, _?_P_r_o_p_e_r_t_y))
    True if _P_r_o_p_e_r_t_y is a property of _Q_u_e_u_e.  Defined properties are:

    aalliiaass((_A_l_i_a_s))
         Queue has the given alias name.

    ssiizzee((_S_i_z_e))
         Queue  currently  contains  _S_i_z_e terms.     Note  that  due  to
         concurrent access the returned value may be  outdated before it
         is returned.  It can be used for debugging purposes  as well as
         work distribution purposes.

Explicit  message queues  are  designed with  the _w_o_r_k_e_r_-_p_o_o_l  model  in
mind,  where  multiple  threads wait  on  a  single queue  and  pick  up
the first  goal to  execute.   Below  is a  simple implementation  where
the workers  execute arbitrary  Prolog goals.   Note  that this  example
provides no means to tell when all work is done.   This must be realised
using additional synchronisation.

%       create_workers(+Id, +N)
%
%       Create a pool with given Id and number of workers.

create_workers(Id, N) :-
        message_queue_create(Id),
        forall(between(1, N, _),
               thread_create(do_work(Id), _, [])).

do_work(Id) :-
        repeat,
          thread_get_message(Id, Goal),
          (   catch(Goal, E, print_message(error, E))
          ->  true
          ;   print_message(error, goal_failed(Goal, worker(Id)))
          ),
        fail.

%       work(+Id, +Goal)
%
%       Post work to be done by the pool

work(Id, Goal) :-
        thread_send_message(Id, Goal).


88..33..22 SSiiggnnaalllliinngg tthhrreeaaddss

These  predicates provide  a mechanism  to make  another thread  execute
some  goal as  an  _i_n_t_e_r_r_u_p_t.    Signalling  threads  is safe  as  these
interrupts  are only  checked at  safe points  in  the virtual  machine.
Nevertheless,  signalling  in  multi-threaded   environments  should  be
handled  with  care as  the  receiving  thread  may hold  a  _m_u_t_e_x  (see
with_mutex).   Signalling  probably only makes  sense to start  debugging
threads and to  cancel no-longer-needed threads with throw/1,  where the
receiving thread  should be designed carefully  do handle exceptions  at
any point.


tthhrreeaadd__ssiiggnnaall((_+_T_h_r_e_a_d_I_d_, _:_G_o_a_l))
    Make thread _T_h_r_e_a_d_I_d execute  _G_o_a_l at the first opportunity.  In the
    current  implementation, this implies at the first pass  through the
    _C_a_l_l_-_p_o_r_t.   The  predicate thread_signal/2 itself places _G_o_a_l  into
    the signalled-thread's signal queue and returns immediately.

    Signals  (interrupts)  do  not  cooperate well  with  the  world  of
    multi-threading,  mainly  because the  status of  mutexes cannot  be
    guaranteed  easily.   At the call-port,  the Prolog virtual  machine
    holds no locks and therefore the asynchronous execution is safe.

    _G_o_a_l  can be any  valid Prolog goal,  including throw/1 to make  the
    receiving thread generate  an exception and trace/0 to start tracing
    the receiving thread.

    In  the Windows version,  the receiving thread immediately  executes
    the  signal  if  it  reaches  a  Windows  GetMessage()  call,  which
    generally happens of the thread is waiting for (user-)input.


88..33..33 TThhrreeaaddss aanndd ddyynnaammiicc pprreeddiiccaatteess

Besides  queues (section  8.3.1)  threads can  share and  exchange  data
using dynamic  predicates.  The  multi-threaded version knows about  two
types of dynamic predicates.   By default, a predicate  declared _d_y_n_a_m_i_c
(see dynamic/1)  is shared  by all  threads.   Each  thread may  assert,
retract and  run the dynamic predicate.   Synchronisation inside  Prolog
guarantees  the consistency  of the  predicate.    Updates are  _l_o_g_i_c_a_l:
visible  clauses  are  not affected  by  assert/retract  after  a  query
started on  the predicate.   In  many cases  primitive from section  8.4
should be  used to ensure  application invariants  on the predicate  are
maintained.

Besides shared predicates,  dynamic predicates can be declared  with the
thread_local/1 directive.   Such predicates share their attributes,  but
the clause-list is different in each thread.


tthhrreeaadd__llooccaall _+_F_u_n_c_t_o_r_/_+_A_r_i_t_y_, _._._.
    This  directive is  related to the  dynamic/1 directive.   It  tells
    the  system  that  the predicate  may  be modified  using  assert/1,
    retract/1,  etc. during  execution of  the program.   Unlike  normal
    shared dynamic data  however each thread has its own clause-list for
    the  predicate.   As  a thread starts,  this clause  list is  empty.
    If  there  are still  clauses  as the  thread terminates  these  are
    automatically  reclaimed by the system  (see also volatile/1).   The
    thread_local property implies the properties dynamic and volatile.

    Thread-local   dynamic  predicates  are  intended  for   maintaining
    thread-specific state or intermediate results of a computation.

    It  is not recommended to  put clauses for a thread-local  predicate
    into  a file as in the example  below as the clause is  only visible
    from  the thread  that loaded the  source-file.   All other  threads
    start with an empty clause-list.

    :- thread_local
            foo/1.

    foo(gnat).

    DDIISSCCLLAAIIMMEERR  Whether or  not this declaration  is appropriate in  the
    sense  of the proper mechanism to  reach the goal is still  debated.
    If  you have strong feeling in favour or against, please  share them
    in the SWI-Prolog mailing list.


88..44 TThhrreeaadd ssyynncchhrroonniissaattiioonn

All  internal Prolog  operations  are thread-safe.    This  implies  two
Prolog  threads  can  operate on  the  same  dynamic  predicate  without
corrupting the consistency  of the predicate.   This section deals  with
user-level  _m_u_t_e_x_e_s (called  _m_o_n_i_t_o_r_s  in  ADA or  _c_r_i_t_i_c_a_l_-_s_e_c_t_i_o_n_s  by
Microsoft).   A  mutex is a  MMUUTTual EEXXclusive device,  which implies  at
most one thread can _h_o_l_d a mutex.

Mutexes are  used to  realise related  updates to  the Prolog  database.
With `related', we refer to the situation where  a `transaction' implies
two  or more  changes to  the Prolog  database.   For  example, we  have
a  predicate address/2,  representing the  address of  a  person and  we
want  to change  the address  by retracting  the old  and asserting  the
new address.    Between these  two operations the  database is  invalid:
this person  has either no  address or two  addresses, depending on  the
assert/retract order.

Here is how to realise a correct update:

:- initialization
        mutex_create(addressbook).

change_address(Id, Address) :-
        mutex_lock(addressbook),
        retractall(address(Id, _)),
        asserta(address(Id, Address)),
        mutex_unlock(addressbook).


mmuutteexx__ccrreeaattee((_?_M_u_t_e_x_I_d))
    Create  a mutex.  if _M_u_t_e_x_I_d  is an atom, a _n_a_m_e_d mutex  is created.
    If  it is  a variable,  an  anonymous mutex  reference is  returned.
    There is no limit to the number of mutexes that can be created.


mmuutteexx__ccrreeaattee((_-_M_u_t_e_x_I_d_, _+_O_p_t_i_o_n_s))
    Create a mutex using options.  Defined options are:

    aalliiaass((_A_l_i_a_s))
         Set the  alias name.   Using mutex_create(_X_, _[_a_l_i_a_s_(_n_a_m_e_)_])  is
         prefered over the equivalent mutex_create(_n_a_m_e).


mmuutteexx__ddeessttrrooyy((_+_M_u_t_e_x_I_d))
    Destroy  a mutex.    After this  call, _M_u_t_e_x_I_d  becomes invalid  and
    further references yield an existence_error exception.


wwiitthh__mmuutteexx((_+_M_u_t_e_x_I_d_, _:_G_o_a_l))
    Execute  _G_o_a_l while holding _M_u_t_e_x_I_d.  If _G_o_a_l  leaves choice-points,
    these  are  destroyed  (as  in  once/1).    The  mutex  is  unlocked
    regardless  of whether _G_o_a_l succeeds, fails or raises  an exception.
    An  exception thrown by _G_o_a_l is  re-thrown after the mutex has  been
    successfully unlocked.  See also mutex_create/1 and call_cleanup/3.

    Although  described in  the thread-section,  this predicate is  also
    available  in the single-threaded  version, where it behaves  simply
    as once/1.


mmuutteexx__lloocckk((_+_M_u_t_e_x_I_d))
    Lock the mutex.   Prolog mutexes are _r_e_c_u_r_s_i_v_e mutexes:  they can be
    locked  multiple times  by the same  thread.   Only after  unlocking
    it  as many times as it  is locked, the mutex becomes  available for
    locking  by other threads.   If another thread has locked the  mutex
    the calling thread is suspended until to mutex is unlocked.

    If  _M_u_t_e_x_I_d is  an atom,  and there  is no current  mutex with  that
    name,  the  mutex  is  created automatically  using  mutex_create/1.
    This implies named mutexes need not be declared explicitly.

    Please  note that  locking and  unlocking mutexes  should be  paired
    carefully.    Especially make  sure to  unlock mutexes  even if  the
    protected  code  fails or  raises an  exception.    For most  common
    cases  use with_mutex/2,  which provides  a safer  way for  handling
    Prolog-level  mutexes.  The predicate  call_cleanup/[2-3]is  another
    way  to  guarantee  that  the  mutex  is  unlocked  while  retaining
    non-determinism.


mmuutteexx__ttrryylloocckk((_+_M_u_t_e_x_I_d))
    As  mutex_lock/1,  but if the mutex  is held by another thread,  this
    predicates fails immediately.


mmuutteexx__uunnlloocckk((_+_M_u_t_e_x_I_d))
    Unlock  the mutex.  This can only be called if the mutex  is held by
    the  calling thread.   If this is  not the case,  a permission_error
    exception is raised.


mmuutteexx__uunnlloocckk__aallll
    Unlock  all  mutexes held  by the  current  thread.   This  call  is
    especially  useful  to handle  thread-termination using  abort/0  or
    exceptions.  See also thread_signal/2.


mmuutteexx__pprrooppeerrttyy((_?_M_u_t_e_x_I_d_, _?_P_r_o_p_e_r_t_y))
    True if Property is a property of MutexId.  Defined properties are:

    aalliiaass((_A_l_i_a_s))
         Mutex has  defined alias  name.   See mutex_create/2 using  the
         `alias' option.

    ssttaattuuss((_S_t_a_t_u_s))
         Current status  of the mutex.    One of unlocked  if the  mutex
         is currently  not locked  or locked(_O_w_n_e_r_, _C_o_u_n_t)  if mutex  is
         locked _C_o_u_n_t times by  threads _O_w_n_e_r.  Note that,  unless _O_w_n_e_r
         is the  calling thread,  the locked  status can  change at  any
         time.  There is no useful application of  this property, except
         for diagnostic purposes.


88..55 TThhrreeaadd--ssuuppppoorrtt lliibbrraarryy((tthhrreeaadduuttiill))

This library  defines a  couple of useful  predicates for  demonstrating
and debugging  multi-threaded applications.   This library is  certainly
not complete.


tthhrreeaaddss
    Lists all current threads and their status.


jjooiinn__tthhrreeaaddss
    Join all terminated  threads.  For normal applications, dealing with
    terminated  threads must be  part of  the application logic,  either
    detaching  the thread before termination  or making sure it will  be
    joined.   The  predicate join_threads/0 is intended for  interactive
    sessions  to reclaim resources  from threads that died  unexpectedly
    during development.


iinntteerraaccttoorr
    Create  a  new console  and run  the Prolog  top-level  in this  new
    console.   See also attach_console/0.  In the Windows version  a new
    interactor can also be created from the Run/New thread menu.


88..55..11 DDeebbuuggggiinngg tthhrreeaaddss

Support  for  debugging threads  is  still  very  limited.    Debug  and
trace  mode are  flags  that  are local  to  each  thread.    Individual
threads can  be debugged either using  the graphical debugger  described
in  section 3.5  (see tspy/1  and  friends) or  by attaching  a  console
to the  thread and  running the traditional  command-line debugger  (see
attach_console/0).   When  using the  graphical debugger,  the  debugger
must  be _l_o_a_d_e_d  from  the main  thread  (for example  using  guitracer)
before gtrace/0 can be called from a thread.


aattttaacchh__ccoonnssoollee
    If  the  current thread  has no  console  attached yet,  attach  one
    and  redirect the  user streams (input,  output, and  error) to  the
    new  console  window.   On  Unix  systems the  console is  an  xterm
    application.    On  Windows systems  this requires  the GUI  version
    plwin.exe rather than the console based plcon.exe.

    This  predicate has  a couple  of useful applications.    One is  to
    separate (debugging) I/O  of different threads.  Another is to start
    debugging  a thread that  is running in the  background.  If  thread
    10  is running,  the following  sequence starts the  tracer on  this
    thread:

    ?- thread_signal(10, (attach_console, trace)).


ttddeebbuugg((_+_T_h_r_e_a_d_I_d))
    Prepare  _T_h_r_e_a_d_I_d for debugging  using the graphical  tracer.   This
    implies installing the  tracer hooks in the thread and switching the
    thread  to debug-mode  using debug/0.    The call  is injected  into
    the  thread using thread_signal/2.   We  refer to the  documentation
    of  this predicate for asynchronous  interaction with threads.   New
    threads  created  inherit  their  debug-mode from  the  thread  that
    created them.


ttddeebbuugg
    Call tdebug/1 in all running threads.


ttnnooddeebbuugg((_+_T_h_r_e_a_d_I_d))
    Disable debugging thread _T_h_r_e_a_d_I_d.


ttnnooddeebbuugg
    Disable debugging in all threads.


ttssppyy((_:_S_p_e_c_, _+_T_h_r_e_a_d_I_d))
    Set  a spy-point as spy/1 and enable the thread for  debugging using
    tdebug/1.   Note that  a spy-point is a  global flag on a  predicate
    that  is visible from all threads.   Spy points are honoured  in all
    threads  that are in debug-mode and  ignored in threads that are  in
    nodebug mode.


ttssppyy((_:_S_p_e_c))
    Set  a  spy-point  as spy/1  and  enable  debugging in  all  threads
    using  tdebug/0.   Note that removing  spy-points can be done  using
    nospy/1.   Disabling spy-points in a specific thread is  achieved by
    tnodebug/1.


88..55..22 PPrrooffiilliinngg tthhrreeaaddss

In the  current implementation, at  most one thread  can be profiled  at
any moment.   Any thread can call profile/1 to profile the  execution of
some part of  its code.   The predicate tprofile/1 allows for  profiling
the execution of another thread until the user  stops collecting profile
data.


ttpprrooffiillee((_+_T_h_r_e_a_d_I_d))
    Start  collecting profile data in _T_h_r_e_a_d_I_d  and ask the user to  hit
    <return> to stop the  profiler.  See section 4.40 for details on the
    execution profiler.


88..66 UUnnbboouunnddeedd tthhrreeaadd ccrreeaattiioonn

(SWI-)Prolog threads are  rather heavyweight objects, notably on  32-bit
systems  because each  thread  uses  a considerable  amount  of  _v_i_r_t_u_a_l
address space.    SWI-Prolog threads  claim the stack  _l_i_m_i_t in  virtual
address space for  each of the runtime  stacks, while on 32-bit  systems
this resource  is generally limited  somewhere between  1GB and 3.5  GB,
depending on the operating system and operating configuration.

If SWI-Prolog starts  a thread it copies  the initial goal and starts  a
POSIX thread  which allocates a  new Prolog  engine that starts  proving
the given  goal.  If  allocation of the  engine fails, typically due  to
lack of virtual memory  space, the thread is still created  with minimal
(8 Kbyte)  stacks and  immediately calls  its exit  handlers.   See  the
option  at_exit(_G_o_a_l).    Although this  mechnanism  allows for  handling
this type of error gracefully it is not safe to rely  on it.  Allocating
an engine that nearly exhausts virtual address space  may cause failures
in normal memory  allocation that can appear  anywhere in Prolog or  the
foreign libraries used  by it.   Such errors typically kill the  process
with a fatal error.

Especially  on   32-bit  hardware,   the  design   of  the   application
must  consider  this  issue  and  avoid  ungracefull  termination  being
conservative with the dynamic creation of new threads.


88..77 MMuullttii--tthhrreeaaddeedd mmiixxeedd CC aanndd PPrroolloogg aapppplliiccaattiioonnss

All foreign-code  linked to  the multi-threading  version of  SWI-Prolog
should  be   thread-safe  (_r_e_e_n_t_r_a_n_t)   or  guarded   in  Prolog   using
with_mutex/2 from  simultaneous  access  from multiple  Prolog  threads.
If  you want  to write  mixed multi-threaded  C  and Prolog  application
you  should  first  familiarise  yourself  with  writing  multi-threaded
applications in C (C++).

If you are  using SWI-Prolog as an  embedded engine in a  multi-threaded
application you  can access the Prolog  engine from multiple threads  by
creating an _e_n_g_i_n_e in  each thread from which you call Prolog.   Without
creating an engine, a thread can only use functions that  do _n_o_t use the
term_t type (for example PL_new_atom()).

The system supports  two models.   Section 8.7.1 describes the  original
one-to-one mapping.   In this schema  a native thread attaches a  Prolog
thread if  it needs  to call Prolog  and detaches is  when finished,  as
opposed to the  model from section 8.7.2  where threads temporary use  a
Prolog engine.


88..77..11 AA PPrroolloogg tthhrreeaadd ffoorr eeaacchh nnaattiivvee tthhrreeaadd ((oonnee--ttoo--oonnee))

In  the one-to-one  model, the  thread  that called  PL_initialise()  has
a  Prolog  engine  attached.     If  another  C-thread   in  the  system
wishes  to   call  Prolog  it   must  first   attach  an  engine   using
PL_thread_attach_engine()  and  call  PL_thread_destroy_engine()  after  all
Prolog  work is  finished.    This  model  is especially  suitable  with
long  running threads  that  need to  do Prolog  work  regularly.    See
section 8.7.2 for the alternative many-to-many model.


int PPLL__tthhrreeaadd__sseellff()
    Returns  the  integer  Prolog identifier  of  the  engine or  -1  if
    the  calling thread has  no Prolog  engine.   This function is  also
    provided  in the  single-threaded version  of  SWI-Prolog, where  it
    returns -2.


int PPLL__uunniiffyy__tthhrreeaadd__iidd(_t_e_r_m___t _t_, _i_n_t _i)
    Unify  _t with the  Prolog thread  identifier for thread  _i.   Thread
    identifiers are  normally returned from PL_thread_self().   Returns -1
    if the thread does not exists or the unification result.


int PPLL__tthhrreeaadd__aattttaacchh__eennggiinnee(_c_o_n_s_t _P_L___t_h_r_e_a_d___a_t_t_r___t _*_a_t_t_r)
    Creates  a new Prolog engine in the calling thread.  If  the calling
    thread  already has an engine the  reference count of the engine  is
    incremented.  The  _a_t_t_r argument can be NULL to create a thread with
    default  attributes.  Otherwise it is a pointer to a  structure with
    the  definition below.   For any field  with value `0', the  default
    is  used.    The cancel  field may  be filled  with a  pointer to  a
    function  that is  called when  PL_cleanup()  terminates the  running
    Prolog  engines.  If this  function is not present or returns  FALSE
    pthread_cancel() is used.

    typedef struct
    { unsigned long     local_size;    /* Stack sizes (K-bytes) */
      unsigned long     global_size;
      unsigned long     trail_size;
      unsigned long     argument_size;
      char *            alias;         /* alias name */
      int              (*cancel)(int thread);
    } PL_thread_attr_t;

    The  structure may  be destroyed  after PL_thread_attach_engine()  has
    returned.    On success  it returns  the Prolog  identifier for  the
    thread (as  returned by PL_thread_self()).  If  an error occurs, -1 is
    returned.   If this Prolog  is not compiled for multi-threading,  -2
    is returned.


int PPLL__tthhrreeaadd__ddeessttrrooyy__eennggiinnee()
    Destroy  the  Prolog engine  in  the calling  thread.    Only  takes
    effect  if  PL_thread_destroy_engine()  is  called as  many  times  as
    PL_thread_attach_engine() in this  thread.   Returns TRUE on  success
    and  FALSE if the calling thread  has no engine or this Prolog  does
    not support threads.

    Please  note  that  construction  and  destruction  of  engines  are
    relatively  expensive  operations.     Only  destroy  an  engine  if
    performance is not critical and memory is a critical resource.


int PPLL__tthhrreeaadd__aatt__eexxiitt(_v_o_i_d _(_*_f_u_n_c_t_i_o_n_)_(_v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e_, _i_n_t _g_l_o_b_a_l)
    Register  a handle to be called  as the Prolog engine is  destroyed.
    The  handler function  is called  with one  void * argument  holding
    _c_l_o_s_u_r_e.    If  _g_l_o_b_a_l is  TRUE, the  handler is  installed _f_o_r  _a_l_l
    _t_h_r_e_a_d_s.     Globally  installed handlers  are  executed  after  the
    thread-local  handlers.  If the  handler is installed local for  the
    current thread only (_g_l_o_b_a_l  == FALSE) it is stored in the same FIFO
    queue as used by thread_at_exit/1.


88..77..22 PPoooolliinngg PPrroolloogg eennggiinneess ((mmaannyy--ttoo--mmaannyy))

In this model Prolog engines live as entities that  are independent from
threads.  If a  thread needs to call Prolog it takes one of  the engines
from the pool and returns the engine when done.   This model is suitable
in the following identified cases:

  o _C_o_m_p_a_t_i_b_i_l_i_t_y _w_i_t_h _t_h_e _s_i_n_g_l_e_-_t_h_r_e_a_d_e_d _v_e_r_s_i_o_n
    In  the  single-threaded  version,  foreign threads  must  serialise
    access the one and  only thread engine.  Functions from this section
    allow sharing one engine among multiple threads.

  o _M_a_n_y _n_a_t_i_v_e _t_h_r_e_a_d_s _w_i_t_h _i_n_f_r_e_q_u_e_n_t _P_r_o_l_o_g _w_o_r_k
    Prolog  threads are expensive in terms of memory and time  to create
    and  destroy them.  Systems that use a large number of  threads that
    only  infrequently need  to call  Prolog are better  take an  engine
    from a pool and return it there.

  o _P_r_o_l_o_g _s_t_a_t_u_s _m_u_s_t _b_e _h_a_n_d_e_d _t_o _a_n_o_t_h_e_r _t_h_r_e_a_d
    This  situation has  been identified  by Uwe Lesta  when creating  a
    .NET  interface for SWI-Prolog.   .NET  distributes work for  active
    internet  connection over a  pool of  threads.   If a Prolog  engine
    contains  state for a connection, it must be possible to  detach the
    engine  from a thread  and re-attach it  to another thread  handling
    the same connection.


PL_engine_t PPLL__ccrreeaattee__eennggiinnee(_P_L___t_h_r_e_a_d___a_t_t_r___t _*_a_t_t_r_i_b_u_t_e_s)
    Create  a  new   Prolog  engine.     _a_t_t_r_i_b_u_t_e_s  is  described  with
    PL_thread_attach_engine().    Any thread  can  make this  call  after
    PL_initialise()  returned success.     The returned  engine  is  not
    attached  to any thread  and lives until PL_destroy_engine() is  used
    on the returned handle.

    In  the  single-threaded  version  this call  always  returns  NULL,
    indicating failure.


int PPLL__ddeessttrrooyy__eennggiinnee(_P_L___e_n_g_i_n_e___t _e)
    Destroy  the given engine.  Destroying an engine is only  allowed if
    the engine is not  attached to any thread or attached to the calling
    thread.    On success  this function  returns TRUE,  on failure  the
    return value is FALSE.


int PPLL__sseett__eennggiinnee(_P_L___e_n_g_i_n_e___t _e_n_g_i_n_e_, _P_L___e_n_g_i_n_e___t _*_o_l_d)
    Make  the calling thread ready  to use _e_n_g_i_n_e.   If _o_l_d is  non-NULL
    the  current engine  associated with  the calling  thread is  stored
    at  the  given  location.     If  _e_n_g_i_n_e equals  PL_ENGINE_MAIN  the
    initial  engine is attached  to the  calling thread.   If _e_n_g_i_n_e  is
    PL_ENGINE_CURRENT the  engine is  not  changed.   This  can be  used
    to  query the current  engine.   This call  returns PL_ENGINE_SET  if
    the  engine was switched successfully,  PL_ENGINE_INVAL if _e_n_g_i_n_e  is
    not  a  valid engine  handle and  PL_ENGINE_INUSE  if  the engine  is
    currently in use by another thread.

    Engines  can be changed  at any time.   For  example, it is  allowed
    to  select an engine to initiate a  Prolog goal, detach it and  at a
    later  moment execute the  goal from another  thread.  Note  however
    that  the term_t, qid_t and fid_t types are interpreted relative  to
    the  engine for which they are created.  Behaviour when  passing one
    of these types from one engine to another is undefined.

    In  the single-threaded  version this call  only succeeds if  _e_n_g_i_n_e
    refers to the main engine.


88..77..22..11 EEnnggiinneess iinn ssiinnggllee--tthhrreeaaddeedd SSWWII--PPrroolloogg

In  theory it  is possible  to  port the  API of  section  8.7.2 to  the
single-threaded  version of  SWI-Prolog.    This  allows  C-programs  to
control multiple  Prolog engines concurrently.   This  has not yet  been
realised.


88..88 MMuullttiitthhrreeaaddiinngg aanndd tthhee XXPPCCEE ggrraapphhiiccss ssyysstteemm

GUI applications  written in  XPCE can benefit  from the  multi-threaded
version of  XPCE/SWI-Prolog if  they need to  do expensive  computations
that block to UI in the single-threaded version.

Due  to  various  technical  problems  on  both   Windows  and  Unix/X11
threading is  best exploited by handing  long computations to their  own
thread.

The XPCE message  passing system is guarded  with a single _m_u_t_e_x,  which
synchronises both  access from  Prolog and activation  through the  GUI.
In  MS-Windows, GUI  events are  processed by  the  thread that  created
the window  in which the  event occurred, whereas  in Unix/X11 they  are
processed by the thread that dispatches messages.

Some  tentative work  is  underway to  improve the  integration  between
XPCE  and multi-threaded  SWI-Prolog.   There  are two  sets of  support
predicates.    The  first model  assumes that  XPCE  is running  in  the
main thread  and background threads  are used for computation.   In  the
second model, XPCE  event dispatching runs in the background,  while the
foreground thread is used for Prolog.

XXPPCCEE  iinn  tthhee   ffoorreeggrroouunndd Using  XPCE  in  the  foreground   simplifies
debugging  of  the  UI  and  generally  provides  the  most  comfortable
development  environment.       The  GUI  creates   new  threads   using
thread_create/3  and,   after   work  in   the   thread  is   completed,
the  sub-thread  signals  the  main  thread  of   the  completion  using
in_pce_thread/1.


iinn__ppccee__tthhrreeaadd((_:_G_o_a_l))
    Assuming  XPCE is running in the foreground thread, this  call gives
    background  threads  the  opportunity  to make  calls  to  the  XPCE
    thread.    A call to  in_pce_thread/1 succeeds immediately,  copying
    _G_o_a_l  to the XPCE  thread.   _G_o_a_l is added  to the XPCE  event-queue
    and  executed  synchronous to  normal user  events  like typing  and
    clicking.

XXPPCCEE iinn tthhee bbaacckkggrroouunndd

In this model a thread for  running XPCE is created using pce_dispatch/1
and actions are sent to this thread using pce_call/1.


ppccee__ddiissppaattcchh((_+_O_p_t_i_o_n_s))
    Create  a Prolog  thread  with the  alias-name pce  for XPCE  event-
    handling.    In  the X11  version this  call creates  a thread  that
    executes  the X11  event-dispatch loop.   In  MS-Windows it  creates
    a  thread that  executes a windows  event-dispatch loop.   The  XPCE
    event-handling  thread has  the alias  pce.   _O_p_t_i_o_n_s specifies  the
    thread-attributes as thread_create/3.


ppccee__ccaallll((_:_G_o_a_l))
    Post  _G_o_a_l to  the pce  thread,  executing it  synchronous with  the
    thread's  event-loop.  The pce_call/1 predicate returns  immediately
    without waiting.  Note that _G_o_a_l is _c_o_p_i_e_d to the pce thread.

For          further           information          about           XPCE
in         threaded         applications,           please         visit
http://gollem.science.uva.nl/twiki/pl/bin/view/Development/MultiThreadsXPCE


CChhaapptteerr 99..  FFOORREEIIGGNN LLAANNGGUUAAGGEE IINNTTEERRFFAACCEE

SWI-Prolog      offers      a     powerful      interface      to      C
[Kernighan & Ritchie, 1978].     The  main  design   objectives  of  the
foreign language interface  are flexibility and performance.   A foreign
predicate  is a  C-function that  has the  same number  of arguments  as
the predicate  represented.   C-functions  are provided  to analyse  the
passed terms,  convert them to basic C-types  as well as to  instantiate
arguments using unification.   Non-deterministic foreign predicates  are
supported,  providing the  foreign  function with  a handle  to  control
backtracking.

C can  call Prolog  predicates, providing  both an  query interface  and
an interface  to extract  multiple solutions  from an  non-deterministic
Prolog predicate.   There is no limit  to the nesting of Prolog  calling
C, calling Prolog,  etc.  It is also  possible to write the `main'  in C
and use Prolog as an embedded logical engine.


99..11 OOvveerrvviieeww ooff tthhee IInntteerrffaaccee

A special include file called SWI-Prolog.h should be included  with each
C-source file  that is  to be  loaded via the  foreign interface.    The
installation process installs this file in the directory  include in the
SWI-Prolog home  directory (?- current_prolog_flag(home, Home).).   This
C-header file defines various data types, macros and  functions that can
be used  to communicate with  SWI-Prolog.  Functions  and macros can  be
divided into the following categories:

  o Analysing Prolog terms

  o Constructing new terms

  o Unifying terms

  o Returning control information to Prolog

  o Registering foreign predicates with Prolog

  o Calling Prolog from C

  o Recorded database interactions

  o Global actions on Prolog (halt, break, abort, etc.)


99..22 LLiinnkkiinngg FFoorreeiiggnn MMoodduulleess

Foreign modules  may be  linked to  Prolog in two  ways.   Using  _s_t_a_t_i_c
_l_i_n_k_i_n_g, the extensions,  a (short) file defining main()  which attaches
the extensions calls  Prolog and the SWI-Prolog kernel distributed  as a
C-library are linked together  to form a new executable.   Using _d_y_n_a_m_i_c
_l_i_n_k_i_n_g,  the extensions are  linked to  a shared library  (.so file  on
most  Unix systems)  or  dynamic-link library  (.DLL file  on  Microsoft
platforms) and loaded into the running Prolog process..


99..22..11 WWhhaatt lliinnkkiinngg iiss pprroovviiddeedd??

The _s_t_a_t_i_c  _l_i_n_k_i_n_g schema can  be used on  all versions of  SWI-Prolog.
Whether or  not dynamic  linking is  supported can be  deduced from  the
Prolog  flag open_shared_object (see  current_prolog_flag/2).    If  this
Prolog flag yields true, open_shared_object/2 and related predicates are
defined.  See  section 9.4 for a suitable high-level interface  to these
predicates.


99..22..22 WWhhaatt kkiinndd ooff llooaaddiinngg sshhoouulldd II bbee uussiinngg??

All  described  approaches  have  their  advantages  and  disadvantages.
Static linking  is portable and allows  for debugging on all  platforms.
It is relatively  cumbersome and the libraries  you need to pass to  the
linker may vary from  system to system, though the utility  program plld
described in section 9.7 often hides these problems from the user.

Loading  shared objects  (DLL  files on  Windows) provides  sharing  and
protection  and is  generally the  best choice.    If  a saved-state  is
created using qsave_program/[1,2], an initialization/1 directive  may be
used to load the appropriate library at startup.

Note  that  the  definition of  the  foreign  predicates  is  the  same,
regardless of the linking type used.


99..33 DDyynnaammiicc LLiinnkkiinngg ooff sshhaarreedd lliibbrraarriieess

The interface  defined in this  section allows the  user to load  shared
libraries  (.so files  on most  Unix systems,  .dll  files on  Windows).
This  interface is  portable to  Windows  as well  as to  Unix  machines
providing  dlopen(2)  (Solaris,  Linux,  FreeBSD, Irix  and  many  more)
or  shl_open(2) (HP/UX).  It  is  advised to  use  the  predicates  from
section 9.4 in your application.


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _-_H_a_n_d_l_e))
    _F_i_l_e  is  the name  of a  shared object  file  (called dynamic  load
    library  in  MS-Windows).   This  file is  attached  to the  current
    process  and  _H_a_n_d_l_e  is  unified  with a  handle  to  the  library.
    Equivalent   to  open_shared_object(File, [], Handle).      See  also
    load_foreign_library/[1,2].

    On  errors, an  exception shared_object(_A_c_t_i_o_n_, _M_e_s_s_a_g_e) is  raised.
    _M_e_s_s_a_g_e is the return value from dlerror().


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _-_H_a_n_d_l_e_, _+_O_p_t_i_o_n_s))
    As  open_shared_object/2, but  allows  for  additional flags  to  be
    passed.   _O_p_t_i_o_n_s is a list of  atoms.  now implies the  symbols are
    resolved  immediately rather  than lazy (default).   global  implies
    symbols of the  loaded object are visible while loading other shared
    objects (by default they  are local).  Note that these flags may not
    be  supported by your operating system.  Check the  documentation of
    dlopen() or equivalent  on your operating system.  Unsupported flags
    are silently ignored.


cclloossee__sshhaarreedd__oobbjjeecctt((_+_H_a_n_d_l_e))
    Detach the shared object identified by _H_a_n_d_l_e.


ccaallll__sshhaarreedd__oobbjjeecctt__ffuunnccttiioonn((_+_H_a_n_d_l_e_, _+_F_u_n_c_t_i_o_n))
    Call the named function  in the loaded shared library.  The function
    is  called  without  arguments  and  the  return-value  is  ignored.
    Normally  this function installs  foreign language predicates  using
    calls to PL_register_foreign().


99..44 UUssiinngg tthhee lliibbrraarryy sshhlliibb ffoorr .DLL aanndd .so ffiilleess

This  section discusses  the  functionality  of the  (autoload)  library
shlib.pl, providing an interface to shared libraries.   This library can
only be used if the Prolog flag open_shared_objectis enabled.


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_L_i_b_, _+_E_n_t_r_y))
    Search  for the  given foreign library  and link  it to the  current
    SWI-Prolog  instance.  The library may be specified with  or without
    the  extension.    First,  absolute_file_name/3 is  used  to  locate
    the  file.    If  this succeeds,  the  full path  is passed  to  the
    low-level  function  to open  the library.    Otherwise,  the  plain
    library  name  is passed,  exploiting  the operating-system  defined
    search  mechanism for  the shared  library.   The file_search_path/2
    alias  mechanism  defines the  alias foreign,  which  refers to  the
    directories <_p_l_h_o_m_e>/lib/<_a_r_c_h>and <_p_l_h_o_m_e>/lib, in this order.

    If  the library  can be loaded,  the function  called _E_n_t_r_y will  be
    called  without arguments.    The return  value of  the function  is
    ignored.

    The  _E_n_t_r_y  function  will  normally  call  PL_register_foreign()  to
    declare functions in the library as foreign predicates.


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_L_i_b))
    Equivalent  to load_foreign_library/2.   For  the entry-point,  this
    function  first identifies the `base-name' of the library,  which is
    defined  to be the file-name with path nor extension.  It  will then
    try  the  entry-point install-<_b_a_s_e>.    On  failure it  will try  to
    function install().  Otherwise no install function will be called.


uunnllooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_L_i_b))
    If  the foreign  library defines  the function  uninstall_<_b_a_s_e>() or
    uninstall(),  this  function will  be called  without arguments  and
    its  return value is  ignored.   Next, abolish/2  is used to  remove
    all  known foreign predicates defined in  the library.  Finally  the
    library itself is detached from the process.


ccuurrrreenntt__ffoorreeiiggnn__lliibbrraarryy((_-_L_i_b_, _-_P_r_e_d_i_c_a_t_e_s))
    Query  the currently loaded foreign libraries and  their predicates.
    _P_r_e_d_i_c_a_t_e_s  is  a  list  with  elements  of  the  form  _M_o_d_u_l_e_:_H_e_a_d,
    indicating  the predicates installed with  PL_register_foreign()  when
    the entry-point of the library was called.

Figure  9.1 connects  a Windows  message-box using  a foreign  function.
This example was tested using Windows NT and Microsoft Visual C++ 2.0.

#include <windows.h>
#include <SWI-Prolog.h>

static foreign_t
pl_say_hello(term_t to)
{ char *a;

  if ( PL_get_atom_chars(to, &a) )
  { MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);

    PL_succeed;
  }

  PL_fail;
}

install_t
install()
{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);
}

            Figure 9.1:  MessageBox() example in Windows NT


99..44..11 SSttaattiicc LLiinnkkiinngg

Below  is an  outline of  the files  structure  required for  statically
linking SWI-Prolog  with foreign extensions.    \ldots/pl refers to  the
SWI-Prolog home directory (see the  Prolog flag home).  <_a_r_c_h> refers to
the architecture identifier  that may be obtained using the  Prolog flag
arch.

      .../pl/runtime/<_a_r_c_h>/libpl.a SWI-Library
      .../pl/include/SWI-Prolog.h   Include file
      .../pl/include/SWI-Stream.h   Stream I/O include file
      .../pl/include/SWI-Exports    Export declarations (AIX only)
      .../pl/include/stub.c         Extension stub

The  definition   of  the  foreign  predicates   is  the  same  as   for
dynamic  linking.   Unlike  with dynamic  linking however,  there is  no
initialisation  function.   Instead,  the file  \ldots/pl/include/stub.c
may  be copied  to  your project  and  modified  to define  the  foreign
extensions.   Below is  stub.c, modified to  link the lowercase  example
described later in this chapter:

#include <stdio.h>
#include <SWI-Prolog.h>

extern foreign_t pl_lowercase(term, term);

PL_extension predicates[] =
{
/*{ "name",      arity,  function,      PL_FA_<flags> },*/

  { "lowercase", 2       pl_lowercase,  0 },
  { NULL,        0,      NULL,          0 }     /* terminating line */
};

int
main(int argc, char **argv)
{ PL_register_extensions(predicates);

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_install_readline();                /* delete if not required */

  PL_halt(PL_toplevel() ? 0 : 1);
}

Now,  a  new  executable may  be  created  by compiling  this  file  and
linking  it to  libpl.a from  the runtime  directory  and the  libraries
required  by both  the  extensions and  the  SWI-Prolog  kernel.    This
may  be  done  by   hand,  or  using  the  plld  utility   described  in
secrefplld.   If the  linking is performed  `by hand', the  command-line
option -dump-runtime-variables (see  section 2.4) can be used to  obtain
the  required paths,  libraries  and linking  options  to link  the  new
executable.


99..55 IInntteerrffaaccee DDaattaa ttyyppeess


99..55..11 TTyyppee term_t::  aa rreeffeerreennccee ttoo aa PPrroolloogg tteerrmm

The principal  data-type is term_t.   Type term_t is what Quintus  calls
QP_term_ref.   This name indicates  better what the type represents:   it
is a _h_a_n_d_l_e for a  term rather than the term itself.  Terms can  only be
represented and manipulated  using this type, as  this is the only  safe
way to  ensure the  Prolog kernel is  aware of  all terms referenced  by
foreign code  and thus allows the  kernel to perform  garbage-collection
and/or stack-shifts while foreign  code is active, for example  during a
callback from C.

A term  reference is  a C unsigned  long, representing  the offset of  a
variable on the Prolog environment-stack.  A foreign  function is passed
term references for the predicate-arguments, one for each  argument.  If
references for intermediate  results are needed, such references  may be
created using  PL_new_term_ref() or  PL_new_term_refs().   These  references
normally live till the foreign function returns control  back to Prolog.
Their scope  can be explicitly  limited using PL_open_foreign_frame()  and
PL_close_foreign_frame()/PL_discard_foreign_frame().

A term_t  always refers to a valid Prolog term (variable,  atom, integer,
float  or compound  term).    A  term  lives either  until  backtracking
takes  us back  to a  point before  the term  was created,  the  garbage
collector  has collected  the  term or  the  term  was created  after  a
PL_open_foreign_frame() and PL_discard_foreign_frame() has been called.

The  foreign-interface functions  can either  _r_e_a_d,  _u_n_i_f_y or  _w_r_i_t_e  to
term-references.   In the  this document we  use the following  notation
for arguments of type term_t:

     term_t +t  Accessed   in  read-mode.       The   `+'
                indicates the argument is `input'.
     term_t -t  Accessed in write-mode.
     term_t ?t  Accessed in unify-mode.

Term references are obtained in any of the following ways.

  o _P_a_s_s_e_d _a_s _a_r_g_u_m_e_n_t
    The  C-functions implementing  foreign predicates  are passed  their
    arguments  as term-references.    These  references may  be read  or
    unified.  Writing to these variables causes undefined behaviour.

  o _C_r_e_a_t_e_d _b_y _P_L___n_e_w___t_e_r_m___r_e_f_(_)
    A  term  created  by  PL_new_term_ref()  is  normally  used  to  build
    temporary  terms or be  written by one  of the interface  functions.
    For example,  PL_get_arg() writes a reference  to the term-argument in
    its last argument.

  o _C_r_e_a_t_e_d _b_y _P_L___n_e_w___t_e_r_m___r_e_f_s_(_i_n_t _n_)
    This   function  returns  a   set  of  term   refs  with  the   same
    characteristics as PL_new_term_ref().  See PL_open_query().

  o _C_r_e_a_t_e_d _b_y _P_L___c_o_p_y___t_e_r_m___r_e_f_(_t_e_r_m___t _t_)
    Creates a new term-reference  to the same term as the argument.  The
    term may be written to.  See figure 9.3.

Term-references  can safely  be  copied  to other  C-variables  of  type
term_t, but all copies will always refer to the same term.


term_t PPLL__nneeww__tteerrmm__rreeff()
    Return  a fresh reference  to a  term.   The reference is  allocated
    on  the _l_o_c_a_l  stack.   Allocating  a term-reference  may trigger  a
    stack-shift  on machines  that cannot  use sparse-memory  management
    for allocation the  Prolog stacks.  The returned reference describes
    a variable.


term_t PPLL__nneeww__tteerrmm__rreeffss(_i_n_t _n)
    Return  _n  new  term  references.     The  first  term-reference  is
    returned.   The others are _t +1, _t +2, etc.   There are two reasons
    for  using this function.   PL_open_query() expects the arguments  as
    a  set of  consecutive term references  and _v_e_r_y time-critical  code
    requiring a number of term-references can be written as:

    pl_mypredicate(term_t a0, term_t a1)
    { term_t t0 = PL_new_term_refs(2);
      term_t t1 = t0+1;

      ...
    }


term_t PPLL__ccooppyy__tteerrmm__rreeff(_t_e_r_m___t _f_r_o_m)
    Create a new term  reference and make it point initially to the same
    term  as _f_r_o_m.  This function  is commonly used to copy  a predicate
    argument to a term reference that may be written.


void PPLL__rreesseett__tteerrmm__rreeffss(_t_e_r_m___t _a_f_t_e_r)
    Destroy  all term  references that  have been  created after  _a_f_t_e_r,
    including  _a_f_t_e_r itself.    Any  reference to  the invalidated  term
    references after this call results in undefined behaviour.

    Note  that  returning  from  the  foreign  context  to  Prolog  will
    reclaim  all references  used in  the foreign  context.   This  call
    is  only necessary  if  references are  created inside  a loop  that
    never  exits  back  to  Prolog.    See  also  PL_open_foreign_frame(),
    PL_close_foreign_frame() and PL_discard_foreign_frame().


99..55..11..11 IInntteerraaccttiioonn wwiitthh tthhee ggaarrbbaaggee ccoolllleeccttoorr aanndd ssttaacckk--sshhiifftteerr

Prolog implements two  mechanisms for avoiding stack overflow:   garbage
collection and stack expansion.   On machines that allow for  it, Prolog
will use virtual  memory management to detect stack overflow  and expand
the  runtime stacks.    On  other machines  Prolog will  reallocate  the
stacks and update all pointers to them.  To do so,  Prolog needs to know
which data is  referenced by C-code.  As  all Prolog data known by  C is
referenced through term references (term_t), Prolog has  all information
necessary to perform  its memory management without special  precautions
from the C-programmer.


99..55..22 OOtthheerr ffoorreeiiggnn iinntteerrffaaccee ttyyppeess

aattoomm__tt An atom in Prologs  internal representation.  Atoms  are pointers
    to  an  opaque structure.    They are  a  unique representation  for
    represented  text, which  implies that  atom A  represents the same
    text as atom B  if-and-only-if A and B are the same pointer.

    Atoms  are  the  central  representation for  textual  constants  in
    Prolog  The  transformation  of C  a  character  string to  an  atom
    implies  a hash-table lookup.  If the same atom is needed  often, it
    is  advised to  store its reference  in a  global variable to  avoid
    repeated lookup.

ffuunnccttoorr__tt A  functor is  the  internal  representation of  a  name/arity
    pair.   They are used to find the name and arity of  a compound term
    as  well as to construct new compound  terms.  Like atoms  they live
    for the whole Prolog session and are unique.

pprreeddiiccaattee__tt Handle  to a  Prolog  predicate.    Predicate  handles  live
    forever (although they can loose their definition).

qqiidd__tt Query         Identifier.                          Used         by
    PL_open_query()/PL_next_solution()/PL_close_query()  to  handle   back-
    tracking from C.

ffiidd__tt Frame         Identifier.                          Used         by
    PL_open_foreign_frame()/PL_close_foreign_frame().

mmoodduullee__tt A module is  a unique handle to a  Prolog module.  Modules  are
    used only to call predicates in a specific module.

ffoorreeiiggnn__tt Return type for a C-function implementing a Prolog predicate.

ccoonnttrrooll__tt Passed  as additional  argument to  non-deterministic  foreign
    functions.  See PL_retry*() and PL_foreign_context*().

iinnssttaallll__tt Type for the install() and uninstall() functions  of shared or
    dynamic link libraries.  See secrefshlib.

iinntt6644__tt Actually  part of  the C99  standard  rather than  Prolog.    As
    of  version  5.5.6,  Prolog integers  are  64-bit on  all  hardware.
    The  C99 type  int64_t  is defined  in the  stdint.h standard  header
    and  provides platform independent 64-bit  integers.  Portable  code
    accessing  Prolog should use this  type to exchange integer  values.
    Please  note that PL_get_long() can  return FALSE on Prolog  integers
    outside  the long domain.  Robust code should not assume any  of the
    integer fetching functions  to succeed if the Prolog term is know to
    be an integer.


99..66 TThhee FFoorreeiiggnn IInncclluuddee FFiillee


99..66..11 AArrgguummeenntt PPaassssiinngg aanndd CCoonnttrrooll

If  Prolog encounters  a foreign  predicate  at run  time it  will  call
a  function  specified  in  the  predicate  definition  of  the  foreign
predicate.   The arguments 1;:::; <_a_r_i_t_y>pass the  Prolog arguments to the
goal as  Prolog terms.   Foreign  functions should  be declared of  type
foreign_t.   Deterministic foreign  functions have  two alternatives  to
return control back to Prolog:


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__ssuucccceeeedd(())
    Succeed deterministically.  PL_succeed is defined as return TRUE.


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__ffaaiill(())
    Fail  and  start  Prolog  backtracking.     PL_fail  is  defined  as
    return FALSE.


99..66..11..11 NNoonn--ddeetteerrmmiinniissttiicc FFoorreeiiggnn PPrreeddiiccaatteess

By  default   foreign  predicates   are  deterministic.      Using   the
PL_FA_NONDETERMINISTIC   attribute  (see   PL_register_foreign())  it   is
possible  to register  a  predicate  as a  non-deterministic  predicate.
Writing   non-deterministic   foreign  predicates   is   slightly   more
complicated  as  the  foreign function  needs  context  information  for
generating  the next  solution.   Note  that the  same foreign  function
should  be  prepared  to be  simultaneously  active  in  more  than  one
goal.     Suppose  the  natural_number_below_n/2  is  a  non-deterministic
foreign predicate, backtracking over all natural numbers  lower than the
first argument.  Now consider the following predicate:

quotient_below_n(Q, N) :-
        natural_number_below_n(N, N1),
        natural_number_below_n(N, N2),
        Q =:= N1 / N2, !.

In  this predicate  the function  natural_number_below_n/2  simultaneously
generates solutions for both its invocations.

Non-deterministic foreign functions  should be prepared to handle  three
different calls from Prolog:

  o _I_n_i_t_i_a_l _c_a_l_l _(PL_FIRST_CALL_)
    Prolog  has just created a frame  for the foreign function and  asks
    it to produce the first answer.

  o _R_e_d_o _c_a_l_l _(PL_REDO_)
    The previous invocation  of the foreign function associated with the
    current  goal indicated it was possible  to backtrack.  The  foreign
    function should produce the next solution.

  o _T_e_r_m_i_n_a_t_e _c_a_l_l _(PL_CUTTED_)
    The choice point  left by the foreign function has been destroyed by
    a  cut.  The foreign function is given the opportunity to  clean the
    environment.

Both  the  context  information  and  the  type  of   call  is  provided
by  an  argument  of  type  control_t  appended  to  the  argument  list
for  deterministic foreign  functions.    The macro  PL_foreign_control()
extracts  the   type  of  call   from  the  control   argument.      The
foreign  function  can  pass  a context  handle  using  the  PL_retry*()
macros  and  extract  the handle  from  the  extra  argument  using  the
PL_foreign_context*() macro.


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__rreettrryy((_l_o_n_g))
    The  foreign function  succeeds while leaving  a choice  point.   On
    backtracking  over this  goal the  foreign function  will be  called
    again,  but the control argument now  indicates it is a `Redo'  call
    and  the  macro PL_foreign_context() returns  the  handle passed  via
    PL_retry().   This handle is  a 30 bits signed  value (two bits  are
    used  for status indication).  Defined  as return _PL_retry(n).   See
    also PL_succeed().


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__rreettrryy__aaddddrreessss((_v_o_i_d _*))
    As  PL_retry(),  but ensures an  address as  returned by malloc()  is
    correctly  recovered  by  PL_foreign_context_address().    Defined  as
    return  _PL_retry_address(n).  See also PL_succeed().


_i_n_t PPLL__ffoorreeiiggnn__ccoonnttrrooll((_c_o_n_t_r_o_l___t))
    Extracts  the type of  call from the control  argument.  The  return
    values  are  described above.    Note that  the  function should  be
    prepared  to handle the PL_CUTTED case and should be aware  that the
    other arguments are not valid in this case.


_l_o_n_g PPLL__ffoorreeiiggnn__ccoonntteexxtt((_c_o_n_t_r_o_l___t))
    Extracts  the context from the context  argument.  In the call  type
    is  PL_FIRST_CALL the context value is 0L. Otherwise it  is the value
    returned  by the last PL_retry() associated with this goal (both  if
    the call type is PL_REDO as PL_CUTTED).


_v_o_i_d _* PPLL__ffoorreeiiggnn__ccoonntteexxtt__aaddddrreessss((_c_o_n_t_r_o_l___t))
    Extracts an address as passed in by PL_retry_address().

Note:  If a  non-deterministic foreign function returns using PL_succeed
or  PL_fail,   Prolog  assumes  the  foreign  function  has  cleaned  its
environment.  NNoo call with control argument PL_CUTTED will follow.

The code of figure 9.2 shows a skeleton for  a non-deterministic foreign
predicate definition.

typedef struct                  /* define a context structure */
{ ...
} context;

foreign_t
my_function(term_t a0, term_t a1, control_t handle)
{ struct context * ctxt;

  switch( PL_foreign_control(handle) )
  { case PL_FIRST_CALL:
        ctxt = malloc(sizeof(struct context));
        ...
        PL_retry_address(ctxt);
    case PL_REDO:

        ctxt = PL_foreign_context_address(handle);
        ...
        PL_retry_address(ctxt);
    case PL_CUTTED:
        ctxt = PL_foreign_context_address(handle);
        ...
        free(ctxt);
        PL_succeed;

  }
}

     Figure 9.2:  Skeleton for non-deterministic foreign functions


99..66..22 AAttoommss aanndd ffuunnccttoorrss

The  following  functions  provide for  communication  using  atoms  and
functors.


atom_t PPLL__nneeww__aattoomm(_c_o_n_s_t _c_h_a_r _*)
    Return an atom handle  for the given C-string.  This function always
    succeeds.    The returned handle  is valid  as long as  the atom  is
    referenced (see section 9.6.2.1).


const char* PPLL__aattoomm__cchhaarrss(_a_t_o_m___t _a_t_o_m)
    Return  a C-string for the text represented by the given atom.   The
    returned  text will not be changed by Prolog.  It is  not allowed to
    modify  the contents, not even `temporary' as the string  may reside
    in  read-only memory.   The returned  string becomes invalid if  the
    atom is garbage-collected  (see section 9.6.2.1).  Foreign functions
    that  require the text from an atom passed in  a term_t  normally use
    PL_get_atom_chars() or PL_get_atom_nchars().


functor_t PPLL__nneeww__ffuunnccttoorr(_a_t_o_m___t _n_a_m_e_, _i_n_t _a_r_i_t_y)
    Returns  a _f_u_n_c_t_o_r  _i_d_e_n_t_i_f_i_e_r, a  handle for  the name/arity  pair.
    The returned handle is valid for the entire Prolog session.


atom_t PPLL__ffuunnccttoorr__nnaammee(_f_u_n_c_t_o_r___t _f)
    Return an atom representing the name of the given functor.


int PPLL__ffuunnccttoorr__aarriittyy(_f_u_n_c_t_o_r___t _f)
    Return the arity of the given functor.


99..66..22..11 AAttoommss aanndd aattoomm--ggaarrbbaaggee ccoolllleeccttiioonn

With  the introduction  of  atom-garbage  collection in  version  3.3.0,
atoms  no  longer  live  as  long  as  the  process.    Instead,   their
lifetime is  guaranteed only as  long as  they are referenced.   In  the
single-threaded version,  atom garbage collections  are only invoked  at
the _c_a_l_l_-_p_o_r_t.    In the multi-threaded  version (see  section 8),  they
appear asynchronously, except for the invoking thread.

For dealing with  atom garbage collection, two additional  functions are
provided:


void PPLL__rreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Increment  the reference  count of the  atom by  one.   PL_new_atom()
    performs  this automatically,  returning  an atom  with a  reference
    count of at least one.


void PPLL__uunnrreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Decrement  the reference count of the atom.  If  the reference-count
    drops below zero, an assertion error is raised.

Please note that the  following two calls are different with  respect to
atom garbage collection:

PL_unify_atom_chars(t, "text");
PL_unify_atom(t, PL_new_atom("text"));

The  latter increments  the  reference count  of  the atom  text,  which
effectively ensures the atom will never be collected.   It is advised to
use the *_chars() or *_nchars() functions whenever applicable.


99..66..33 AAnnaallyyssiinngg TTeerrmmss vviiaa tthhee FFoorreeiiggnn IInntteerrffaaccee

Each argument  of a foreign function  (except for the control  argument)
is of type term_t, an opaque  handle to a Prolog term.  Three  groups of
functions are  available for  the analysis  of terms.    The first  just
validates the type,  like the Prolog  predicates var/1, atom/1, etc  and
are  called PL_is_*().    The second  group  attempts to  translate  the
argument into a C primitive type.   These predicates take a term_t and a
pointer to the appropriate C-type and return TRUE or  FALSE depending on
successful or unsuccessful translation.   If the translation fails,  the
pointed-to data is never modified.


99..66..33..11 TTeessttiinngg tthhee ttyyppee ooff aa tteerrmm


int PPLL__tteerrmm__ttyyppee(_t_e_r_m___t)
    Obtain  the type  of a  term,  which should  be a  term returned  by
    one  of the  other interface  predicates or passed  as an  argument.
    The  function  returns the  type  of  the Prolog  term.    The  type
    identifiers  are listed below.   Note that the extraction  functions
    PL_ge_t*() also validate  the type and  thus the two sections  below
    are equivalent.

            if ( PL_is_atom(t) )
            { char *s;

              PL_get_atom_chars(t, &s);
              ...;
            }

    or

            char *s;
            if ( PL_get_atom_chars(t, &s) )
            { ...;
            }

    ___________________________________________________________________
    | PL_VARIABLE            |An unbound variable.   The value  of term|
    |                        |as such  is a  unique identifier  for the|

    |                        |variable.                                |
    | PL_ATOM                |A Prolog atom.                           |
    | PL_STRING              |A Prolog string.                         |
    | PL_INTEGER             |A Prolog integer.                        |
    | PL_FLOAT               |A Prolog floating point number.          |
    | PL_TERM                |A compound term.   Note that a  list is a|
    |________________________|compound_term_./2._______________________|

The functions PL_is_<_t_y_p_e> are an alternative to PL_term_type().  The test
PL_is_variable(term) is equivalent to  PL_term_type(term) == PL_VARIABLE,
but  the first  is considerably  faster.   On  the other  hand, using  a
switch over  PL_term_type() is  faster and  more readable  then using  an
if-then-else using  the functions  below.   All  these functions  return
either TRUE or FALSE.


int PPLL__iiss__vvaarriiaabbllee(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a variable.


int PPLL__iiss__ggrroouunndd(_t_e_r_m___t)
    Returns  non-zero if  _t_e_r_m is  a ground term.    See also  ground/1.
    This function is cycle-safe.


int PPLL__iiss__aattoomm(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an atom.


int PPLL__iiss__ssttrriinngg(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a string.


int PPLL__iiss__iinntteeggeerr(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an integer.


int PPLL__iiss__ffllooaatt(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a float.


int PPLL__iiss__ccoommppoouunndd(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a compound term.


int PPLL__iiss__ffuunnccttoorr(_t_e_r_m___t_, _f_u_n_c_t_o_r___t)
    Returns  non-zero if _t_e_r_m  is compound and  its functor is  _f_u_n_c_t_o_r.
    This test  is equivalent to PL_get_functor(),  followed by testing the
    functor, but easier to write and faster.


int PPLL__iiss__lliisstt(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m  is a compound term with functor ./2 or the
    atom [].


int PPLL__iiss__aattoommiicc(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is atomic (not variable or compound).


int PPLL__iiss__nnuummbbeerr(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an integer or float.


int PPLL__iiss__aaccyycclliicc(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is acyclic (i.e. a finite tree).


99..66..33..22 RReeaaddiinngg ddaattaa ffrroomm aa tteerrmm

The functions PL_get_*() read information from  a Prolog term.  Most  of
them take two arguments.  The first is the input  term and the second is
a pointer to the output value or a term-reference.


int PPLL__ggeett__aattoomm(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_a)
    If _t is an atom,  store the unique atom identifier over _a.  See also
    PL_atom_chars() and PL_new_atom().  If there is no need  to access the
    data  (characters) of  an atom,  it is advised  to manipulate  atoms
    using  their handle.  As the  atom is referenced by _t, it  will live
    at  least as long as _t does.   If longer live-time is required,  the
    atom should be locked using PL_register_atom().


int PPLL__ggeett__aattoomm__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s)
    If  _t is an atom, store a  pointer to a 0-terminated C-string  in _s.
    It is explicitly  nnoott allowed to modify the contents of this string.
    Some  built-in  atoms may  have the  string  allocated in  read-only
    memory, so `temporary manipulation' can cause an error.


int PPLL__ggeett__ssttrriinngg__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _i_n_t _*_l_e_n)
    If  _t  is  a  string  object,  store a  pointer  to  a  0-terminated
    C-string  in _s  and the  length of  the string in  _l_e_n.   Note  that
    this pointer  is invalidated by backtracking, garbage-collection and
    stack-shifts,  so generally the only save operations are to  pass it
    immediately to a C-function that doesn't involve Prolog.


int PPLL__ggeett__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Convert  the argument term _t to  a 0-terminated C-string.  _f_l_a_g_s  is
    a  bitwise disjunction  from two  groups of  constants.   The  first
    specifies  which term-types should converted and the second  how the
    argument  is stored.  Below  is a specification of these  constants.
    BUF_RING implies, if  the data is not static (as from an  atom), the
    data  is copied to the next buffer from a ring of 16 buffers.   This
    is  a convenient way  of converting multiple  arguments passed to  a
    foreign  predicate to C-strings.    If BUF_MALLOC  is used, the  data
    must be freed using PL_free() when not needed any longer.

    With  the introduction of wide-characters (see section 2.17.1),  not
    all  atoms can be converted into a char*.  This function  fails if _t
    is  of the wrong type, but  also if the text cannot  be represented.
    See the REP_* flags below for details.
    ___________________________________________________________________
    | CVT_ATOM               |Convert if term is an atom               |
    | CVT_STRING             |Convert if term is a string              |
    | CVT_LIST               |Convert  if term  is a  list of  integers|
    |                        |between 1 and 255                        |

    | CVT_INTEGER            |Convert if term is an integer (using %d) |
    | CVT_FLOAT              |Convert if term is a float (using %f)    |
    | CVT_NUMBER             |Convert if term is a integer or float    |
    | CVT_ATOMIC             |Convert if term is atomic                |
    | CVT_VARIABLE           |Convert variable to print-name           |
    | CVT_WRITE              |Convert any  term that  is not  converted|
    |                        |by any of the  other flags using write/1.|
    |                        |If  no  BUF_*  is  provided,  BUF_RING  is|

    |                        |implied.                                 |
    | CVT_ALL                |Convert  if term  is  any  of the  above,|
    |________________________|except_for_CVT_VARIABLE_and_CVT_WRITE____|
    | CVT_EXCEPTION          |If conversion fails due  to a type error,|
    |                        |raise a  Prolog type  error exception  in|
    |________________________|addition_to_failure______________________|
    | BUF_DISCARDABLE        |Data must copied immediately             |

    | BUF_RING               |Data is stored in a ring of buffers      |
    | BUF_MALLOC             |Data is  copied to a new  buffer returned|
    |                        |by PL_malloc(3).   When no  longer needed|
    |________________________|the_user_must_call_PL_free()_on_the_data.|_
    | REP_ISO_LATIN_1        |(0,  default).   Text  is in ISO  Latin-1|
    |                        |encoding  and  the  call  fails  if  text|
    |                        |cannot be represented.                   |

    | REP_UTF8               |Convert  the  text  to  a  UTF-8  string.|
    |                        |This works for all text.                 |
    | REP_MB                 |Convert to  default locale-defined  8-bit|
    |                        |string.   Success depends on  the locale.|
    |                        |Conversion  is done  using the  wcrtomb()|
    |________________________|C-library_function.______________________|


int PPLL__ggeett__lliisstt__cchhaarrss(_+_t_e_r_m___t _l_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Same  as PL_get_chars(_l, _s, CVT_LIST|_f_l_a_g_s), provided _f_l_a_g_s  contains
    no of the CVT_* flags.


int PPLL__ggeett__iinntteeggeerr(_+_t_e_r_m___t _t_, _i_n_t _*_i)
    If  _t is  a Prolog  integer, assign  its value over  _i.   On  32-bit
    machines,  this is  the same as  PL_get_long(),  but avoids a  warning
    from the compiler.  See also PL_get_long().


int PPLL__ggeett__lloonngg(_t_e_r_m___t _+_t_, _l_o_n_g _*_i)
    If  _t is a Prolog integer that can be represented as a  long, assign
    its value over _i.   If _t is an integer that cannot be represented by
    a  C long,  this function returns  FALSE. If _t  is a floating  point
    number that can  be represented as a long, this function succeeds as
    well.  See also PL_get_int64()


int PPLL__ggeett__iinntt6644(_t_e_r_m___t _+_t_, _i_n_t_6_4___t _*_i)
    If  _t is  a Prolog integer  or float  that can be  represented as  a
    int64_t,  assign its value over  _i.   Currently all Prolog  integers
    can  be  represented  using this  type,  but  this might  change  if
    SWI-Prolog introduces unbounded integers.


int PPLL__ggeett__iinnttppttrr(_t_e_r_m___t _+_t_, _i_n_t_p_t_r___t _*_i)
    Get  an integer that is at  least as wide a as  a pointer.  On  most
    platforms  this is the same  as PL_get_long(), but on Win64  pointers
    are 8  bytes and longs only 4.  Unlike PL_get_pointer(), the value is
    not modified.


int PPLL__ggeett__bbooooll(_t_e_r_m___t _+_t_, _i_n_t _*_v_a_l)
    If _t has the value  true or false, set _v_a_l to the C constant TRUE or
    FALSE and return success.  otherwise return failure.


int PPLL__ggeett__ppooiinntteerr(_t_e_r_m___t _+_t_, _v_o_i_d _*_*_p_t_r)
    In  the  current system,  pointers  are  represented by  Prolog  in-
    tegers,   but  need   some  manipulation  to   make  sure  they   do
    not  get  truncated   due  to  the  limited  Prolog  integer  range.
    PL_put_pointer()/PL_get_pointer() guarantees pointers in the  range of
    malloc() are handled without truncating.


int PPLL__ggeett__ffllooaatt(_t_e_r_m___t _+_t_, _d_o_u_b_l_e _*_f)
    If _t is a float or integer, its value is assigned over _f.


int PPLL__ggeett__ffuunnccttoorr(_t_e_r_m___t _+_t_, _f_u_n_c_t_o_r___t _*_f)
    If  _t  is  compound  or  an  atom,   the  Prolog  representation  of
    the   name-arity  pair  will  be  assigned   over  _f.     See   also
    PL_get_name_arity() and PL_is_functor().


int PPLL__ggeett__nnaammee__aarriittyy(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_n_a_m_e_, _i_n_t _*_a_r_i_t_y)
    If  _t is  compound or  an atom,  the functor-name  will be  assigned
    over  _n_a_m_e and the arity over  _a_r_i_t_y.  See  also PL_get_functor()  and
    PL_is_functor().


int PPLL__ggeett__mmoodduullee(_t_e_r_m___t _+_t_, _m_o_d_u_l_e___t _*_m_o_d_u_l_e)
    If _t is an  atom, the system will lookup or create the corresponding
    module and assign an opaque pointer to it over _m_o_d_u_l_e,.


int PPLL__ggeett__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    If  _t is  compound and  index is  between 1  and arity  (including),
    assign _a with a term-reference to the argument.


int _PPLL__ggeett__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    Same as  PL_get_arg(), but no checking is performed,  nor whether _t is
    actually a term, nor whether _i_n_d_e_x is a valid argument-index.


99..66..33..33 EExxcchhaannggiinngg tteexxtt uussiinngg lleennggtthh aanndd ssttrriinngg

All  internal text-representation  of  SWI-Prolog is  represented  using
char * plus length and  allow for _0_-_b_y_t_e_s in them.  The  foreign library
supports this by implementing  a *_nchars() function for  each applicable
*_chars()  function.   Below we briefly present  the signatures of  these
functions.  For full documentation consult the *_chars() function.


int PPLL__ggeett__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s)
    See PL_get_atom_chars().


int PPLL__ggeett__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s)
    See PL_get_list_chars().


int PPLL__ggeett__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _i_n_t _f_l_a_g_s)
    See PL_get_chars().


int PPLL__ppuutt__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_atom_chars().


int PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_string_chars().


int PPLL__ppuutt__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_list_codes().


int PPLL__ppuutt__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_list_chars().


int PPLL__uunniiffyy__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_atom_chars().


int PPLL__uunniiffyy__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_string_chars().


int PPLL__uunniiffyy__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_codes().


int PPLL__uunniiffyy__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_list_chars().

In  addition, the  following functions  are available  for creating  and
inspecting atoms:


atom_t PPLL__nneeww__aattoomm__nncchhaarrss(_s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    Create a new atom as PL_new_atom(), but from length and characters.


const char * PPLL__aattoomm__nncchhaarrss(_a_t_o_m___t _a_, _s_i_z_e___t _*_l_e_n)
    Extract text and length of an atom.


99..66..33..44 WWiiddee cchhaarraacctteerr vveerrssiioonnss

Support  for  exchange   of  wide  character  strings  is  still   under
consideration.    The  functions dealing  with 8-bit  character  strings
return failure when operating on a wide character atom  or Prolog string
object.  The  functions below can extract and unify both 8-bit  and wide
atoms and  string objects.   Wide character  strings are represented  as
C arrays  of objects of the  type pl_wchar_t,  which is guaranteed to  be
the same as wchar_t on platforms supporting this type.   For example, on
MS-Windows, this represents 16-bit UCS2 characters, while  using the GNU
C library (glibc) this represents 32-bit UCS4 characters.


atom_t PPLL__nneeww__aattoomm__wwcchhaarrss(_s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Create  atom from wide-character  string as PL_new_atom_nchars()  does
    for ISO-Latin-1 strings.   If _s only contains ISO-Latin-1 characters
    a normal byte-array atom is created.


pl_wchar_t* PPLL__aattoomm__wwcchhaarrss(_a_t_o_m___t _a_t_o_m_, _i_n_t _*_l_e_n)
    Extract  characters  from a  wide-character atom.    Fails  (returns
    NULL)  if  _a_t_o_m  is  not  a  wide-character  atom.     This  is  the
    wide-character  version of PL_atom_nchars().   Note that only one  of
    these  functions succeeds on a  particular atom.  Especially,  after
    creating an atom with  PL_new_atom_wchars(), extracting the text using
    PL_atom_wchars()  will fail  if the  atom  only contains  ISO-Latin-1
    characters.


int PPLL__ggeett__wwcchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _p_l___w_c_h_a_r___t _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Wide-character version  of PL_get_chars().  The  _f_l_a_g_s argument is the
    same as for PL_get_chars().


int PPLL__uunniiffyy__wwcchhaarrss(_t_e_r_m___t _t_, _i_n_t _t_y_p_e_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Unify _t with  a textual representation of the C wide character array
    _s.   The _a_r_gtype argument  defines the Prolog representation and  is
    one of PL_ATOM, PL_STRING, PL_CODE_LIST or PL_CHAR_LIST.


int PPLL__uunniiffyy__wwcchhaarrss__ddiiffff(_t_e_r_m___t _+_t_, _t_e_r_m___t _-_t_a_i_l_, _i_n_t _t_y_p_e_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Difference  list version  of PL_unify_wchars(),  only supporting  the
    types  PL_CODE_LIST  and PL_CHAR_LIST. It serves  two purposes.    It
    allows  for returning very long lists  from data read from a  stream
    without  the need  for a  resizing buffer  in  C. Also,  the use  of
    difference  lists  is  often  practical for  further  processing  in
    Prolog.   Examples can be found in packages/clib/readutil.c from the
    source distribution.


99..66..33..55 RReeaaddiinngg aa lliisstt

The functions from this section are intended to read  a Prolog list from
C. Suppose we expect a list of atoms, the following  code will print the
atoms, each on a line:

foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();      /* variable for the elements */
  term_t list = PL_copy_term_ref(l);    /* copy as we need to write */

  while( PL_get_list(list, head, list) )
  { char *s;

    if ( PL_get_atom_chars(head, &s) )
      Sprintf("%s\n", s);
    else
      PL_fail;
  }

  return PL_get_nil(list);              /* test end for [] */
}


int PPLL__ggeett__lliisstt(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    If  _l is a list and not [] assign a term-reference to the  head to _h
    and to the tail to _t.


int PPLL__ggeett__hheeaadd(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h)
    If _l is a list and not [] assign a term-reference to the head to _h.


int PPLL__ggeett__ttaaiill(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_t)
    If _l is a list and not [] assign a term-reference to the tail to _t.


int PPLL__ggeett__nniill(_t_e_r_m___t _+_l)
    Succeeds if  represents the atom [].


99..66..33..66 AAnn eexxaammppllee::  ddeeffiinniinngg write/1 iinn CC

Figure  9.3 shows  a  simplified  definition of  write/1  to  illustrate
the described  functions.   This simplified version  does not deal  with
operators.    It is  called  display/1, because  it mimics  closely  the
behaviour of this Edinburgh predicate.
foreign_t
pl_display(term_t t)

{ functor_t functor;
  int arity, len, n;
  char *s;

  switch( PL_term_type(t) )
  { case PL_VARIABLE:
    case PL_ATOM:

    case PL_INTEGER:
    case PL_FLOAT:
      PL_get_chars(t, &s, CVT_ALL);
      Sprintf("%s", s);
      break;
    case PL_STRING:
      PL_get_string_chars(t, &s, &len);
      Sprintf("\"%s\"", s);

      break;
    case PL_TERM:
    { term_t a = PL_new_term_ref();

      PL_get_name_arity(t, &name, &arity);
      Sprintf("%s(", PL_atom_chars(name));
      for(n=1; n<=arity; n++)

      { PL_get_arg(n, t, a);
        if ( n > 1 )
          Sprintf(", ");
        pl_display(a);
      }
      Sprintf(")");
      break;
    default:

      PL_fail;                          /* should not happen */
  }

  PL_succeed;
}

             Figure 9.3:  A Foreign definition of display/1


99..66..44 CCoonnssttrruuccttiinngg TTeerrmmss

Terms  can  be  constructed  using  functions from  the  PL_put_*()  and
PL_cons_*()  families.    This  approach  builds the  term  `inside-out',
starting  at  the  leaves  and  subsequently  creating  compound  terms.
Alternatively,   terms  may  be  created   `top-down',  first   creating
a  compound  holding  only  variables  and   subsequently  unifying  the
arguments.   This section  discusses functions  for the first  approach.
This approach is generally used for creating arguments for PL_call() and
PL_open_query.


void PPLL__ppuutt__vvaarriiaabbllee(_t_e_r_m___t _-_t)
    Put  a fresh variable in  the term.   The new variable lives on  the
    global  stack.   Note that the initial  variable lives on the  local
    stack  and is  lost after  a write to  the term-references.    After
    using this function, the variable will continue to live.


void PPLL__ppuutt__aattoomm(_t_e_r_m___t _-_t_, _a_t_o_m___t _a)
    Put  an  atom  in the  term  reference from  a  handle.    See  also
    PL_new_atom() and PL_atom_chars().


void PPLL__ppuutt__aattoomm__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put an atom  in the term-reference constructed from the 0-terminated
    string.  The  string itself will never be referenced by Prolog after
    this function.


void PPLL__ppuutt__ssttrriinngg__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  a zero-terminated string in the term-reference.  The  data will
    be copied.  See also PL_put_string_nchars().


void PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _-_t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  a string,  represented by  a length/start pointer  pair in  the
    term-reference.   The data will be copied.  This interface  can deal
    with 0-bytes in the string.  See also section 9.6.19.


void PPLL__ppuutt__lliisstt__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put a list of ASCII values in the term-reference.


void PPLL__ppuutt__iinntteeggeerr(_t_e_r_m___t _-_t_, _l_o_n_g _i)
    Put a Prolog integer in the term reference.


void PPLL__ppuutt__iinntt6644(_t_e_r_m___t _-_t_, _i_n_t_6_4___t _i)
    Put a Prolog integer in the term reference.


void PPLL__ppuutt__ppooiinntteerr(_t_e_r_m___t _-_t_, _v_o_i_d _*_p_t_r)
    Put a Prolog integer  in the term-reference.  Provided ptr is in the
    `malloc()-area', PL_get_pointer() will get the pointer back.


void PPLL__ppuutt__ffllooaatt(_t_e_r_m___t _-_t_, _d_o_u_b_l_e _f)
    Put a floating-point value in the term-reference.


void PPLL__ppuutt__ffuunnccttoorr(_t_e_r_m___t _-_t_, _f_u_n_c_t_o_r___t _f_u_n_c_t_o_r)
    Create  a new compound  term from _f_u_n_c_t_o_r and  bind _t to this  term.
    All arguments of the  term will be variables.  To create a term with
    instantiated  arguments, either instantiate the arguments  using the
    PL_unify_*() functions or use PL_cons_functor().


void PPLL__ppuutt__lliisstt(_t_e_r_m___t _-_l)
    Same as PL_put_functor(l, PL_new_functor(PL_new_atom("."), 2)).


void PPLL__ppuutt__nniill(_t_e_r_m___t _-_l)
    Same as PL_put_atom_chars("[]").


void PPLL__ppuutt__tteerrmm(_t_e_r_m___t _-_t_1_, _t_e_r_m___t _+_t_2)
    Make _t_1 point to the same term as _t_2.


void PPLL__ccoonnss__ffuunnccttoorr(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _._._.)
    Create  a term,  whose arguments are  filled from variable  argument
    list  holding the same number of term_t objects as the arity  of the
    functor.  To create the term animal(gnu, 50), use:

    { term_t a1 = PL_new_term_ref();
      term_t a2 = PL_new_term_ref();
      term_t t  = PL_new_term_ref();
      functor_t animal2;

      /* animal2 is a constant that may be bound to a global
         variable and re-used
      */
      animal2 = PL_new_functor(PL_new_atom("animal"), 2);

      PL_put_atom_chars(a1, "gnu");
      PL_put_integer(a2, 50);
      PL_cons_functor(t, animal2, a1, a2);
    }

    After  this sequence, the term-references _a_1 and _a_2 may be  used for
    other purposes.


void PPLL__ccoonnss__ffuunnccttoorr__vv(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _t_e_r_m___t _a_0)
    Creates  a compound term like  PL_cons_functor(),  but _a_0 is an  array
    of  term references as returned by PL_new_term_refs().  The  length of
    this  array should  match the  number of arguments  required by  the
    functor.


void PPLL__ccoonnss__lliisstt(_t_e_r_m___t _-_l_, _t_e_r_m___t _+_h_, _t_e_r_m___t _+_t)
    Create  a list (cons-) cell in _l from  the head and tail.   The code
    below  creates a list of  atoms from a char **.   The list is  built
    tail-to-head.   The  PL_unify_*()  functions can be  used to build  a
    list head-to-tail.

    void
    put_list(term_t l, int n, char **words)
    { term_t a = PL_new_term_ref();

      PL_put_nil(l);
      while( --n >= 0 )
      { PL_put_atom_chars(a, words[n]);
        PL_cons_list(l, a, l);
      }
    }

    Note  that _l can  be redefined  within a PL_cons_list call as  shown
    here because operationally  its old value is consumed before its new
    value is set.


99..66..55 UUnniiffyyiinngg ddaattaa

The  functions  of  this  sections  _u_n_i_f_y  terms  with  other  terms  or
translated C-data structures.   Except for  PL_unify(), the functions  of
this section  are specific  to SWI-Prolog.   They  have been  introduced
to make translation  of old code easier,  but also because they  provide
for a faster mechanism  for returning data to Prolog that  requires less
term-references.  Consider the case where we want  a foreign function to
return the  host name of the  machine Prolog is running  on.  Using  the
PL_get_*() and PL_put_*() functions, the code becomes:

foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
  { term_t tmp = PL_new_term_ref();

    PL_put_atom_chars(tmp, buf);
    return PL_unify(name, tmp);
  }

  PL_fail;
}

Using PL_unify_atom_chars(), this becomes:

foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
    return PL_unify_atom_chars(name, buf);

  PL_fail;
}


int PPLL__uunniiffyy(_t_e_r_m___t _?_t_1_, _t_e_r_m___t _?_t_2)
    Unify two Prolog terms and return non-zero on success.


int PPLL__uunniiffyy__aattoomm(_t_e_r_m___t _?_t_, _a_t_o_m___t _a)
    Unify _t with the atom _a and return non-zero on success.


int PPLL__uunniiffyy__cchhaarrss(_t_e_r_m___t _?_t_, _i_n_t _f_l_a_g_s_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    New  function  to  deal  with  unification  of  char*  with  various
    encodings  to a  Prolog representation.    The _f_l_a_g_s  argument is  a
    bitwise  _o_r specifying the  Prolog target type  and the encoding  of
    _c_h_a_r_s.   Prolog types  is one of PL_ATOM, PL_STRING, PL_CODE_LIST  or
    PL_CHAR_LIST. Representations is one of  REP_ISO_LATIN_1, REP_UTF8 or
    REP_MB.  See PL_get_chars() for  a definition  of the  representation
    types.   If _l_e_n is -1  _c_h_a_r_s must be 0-terminated and the  length is
    computed from _c_h_a_r_s using strlen().

    If  _f_l_a_g_s includes PL_DIFF_LIST and  type is one  of PL_CODE_LIST  or
    PL_CHAR_LIST, the text is converted to a _d_i_f_f_e_r_e_n_c_e _l_i_s_t.   The tail
    of the difference list is t +1.


int PPLL__uunniiffyy__aattoomm__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify  _t with  an atom  created from  _c_h_a_r_s and  return non-zero  on
    success.


int PPLL__uunniiffyy__lliisstt__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _t with a list of ASCII characters constructed from _c_h_a_r_s.


void PPLL__uunniiffyy__ssttrriinngg__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify  _t  with  a  Prolog  string  object  created  from  the  zero-
    terminated  string  _c_h_a_r_s.   The  data will  be copied.    See  also
    PL_unify_string_nchars().


void PPLL__uunniiffyy__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _?_t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _t with  a Prolog string object created from the string created
    from  the _l_e_n/_c_h_a_r_s pair.  The data will be copied.   This interface
    can deal with 0-bytes in the string.  See also section 9.6.19.


int PPLL__uunniiffyy__iinntteeggeerr(_t_e_r_m___t _?_t_, _l_o_n_g _n)
    Unify _t with a Prolog integer from _n.


int PPLL__uunniiffyy__iinntt6644(_t_e_r_m___t _?_t_, _i_n_t_6_4___t _n)
    Unify _t with a Prolog integer from _n.


int PPLL__uunniiffyy__ffllooaatt(_t_e_r_m___t _?_t_, _d_o_u_b_l_e _f)
    Unify _t with a Prolog float from _f.


int PPLL__uunniiffyy__ppooiinntteerr(_t_e_r_m___t _?_t_, _v_o_i_d _*_p_t_r)
    Unify  _t with a  Prolog integer  describing the pointer.   See  also
    PL_put_pointer() and PL_get_pointer().


int PPLL__uunniiffyy__ffuunnccttoorr(_t_e_r_m___t _?_t_, _f_u_n_c_t_o_r___t _f)
    If  _t is a compound term with  the given functor, just succeed.   If
    it  is unbound,  create a term  and bind the  variable, else  fails.
    Note  that this function does not  create a term if the argument  is
    already instantiated.


int PPLL__uunniiffyy__lliisstt(_t_e_r_m___t _?_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    Unify  _l with a list-cell (./2).   If successful, write  a reference
    to  the head of  the list to _h  and a reference  to the tail of  the
    list  into _t.   This reference may be  used for subsequent calls  to
    this  function.   Suppose we  want to  return a list  of atoms  from
    a  char **.   We could  use the  example described  by PL_put_list(),
    followed by  a call to PL_unify(), or we can use the code  below.  If
    the  predicate argument is unbound,  the difference is minimal  (the
    code  based on PL_put_list() is  probably slightly faster).   If  the
    argument  is bound, the code below may fail before reaching  the end
    of  the word-list, but even  if the unification succeeds, this  code
    avoids a duplicate (garbage) list and a deep unification.

    foreign_t
    pl_get_environ(term_t env)
    { term_t l = PL_copy_term_ref(env);
      term_t a = PL_new_term_ref();
      extern char **environ;
      char **e;

      for(e = environ; *e; e++)
      { if ( !PL_unify_list(l, a, l) ||
             !PL_unify_atom_chars(a, *e) )
          PL_fail;
      }

      return PL_unify_nil(l);
    }


int PPLL__uunniiffyy__nniill(_t_e_r_m___t _?_l)
    Unify _l with the atom [].


int PPLL__uunniiffyy__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _?_t_, _t_e_r_m___t _?_a)
    Unifies the _i_n_d_e_x_-_t_h argument (1-based) of _t with _a.


int PPLL__uunniiffyy__tteerrmm(_t_e_r_m___t _?_t_, _._._.)
    Unify  _t with a (normally) compound  term.  The remaining  arguments
    is  a  sequence  of a  type  identifier,  followed by  the  required
    arguments.      This  predicate  is  an  extension  to  the  Quintus
    and  SICStus foreign  interface  from which  the SWI-Prolog  foreign
    interface  has been  derived, but has  proved to  be a powerful  and
    comfortable  way to create compound terms from C. Due to  the vararg
    packing/unpacking and  the required type-switching this interface is
    slightly  slower than using the primitives.   Please note that  some
    bad  C-compilers have fairly low  limits on the number of  arguments
    that may be passed to a function.

    Special  attention is required when  passing numbers.  C  `promotes'
    any  integral  smaller than  int  to  int.    I.e. the  types  char,
    short  and  int  are all  passed  as int.    In  addition,  on  most
    32-bit  platforms int and long are  the same.  Up-to version  4.0.5,
    only  PL_INTEGER  could be specified which  was taken from the  stack
    as  long.   Such  code fails when  passing small  integral types  on
    machines  where int  is smaller than  long.   It is  advised to  use
    PL_SHORT, PL_INT or  PL_LONG  as appropriate.   Similar, C  compilers
    promote  float to  double and  therefore PL_FLOAT and  PL_DOUBLE  are
    synonyms.

    The type identifiers are:

    PL_VARIABLE _n_o_n_e
         No op.  Used in arguments of PL_FUNCTOR.

    PL_BOOL _i_n_t
         Unify the argument with true or false.

    PL_ATOM _a_t_o_m___t
         Unify the argument with an atom, as in PL_unify_atom().

    PL_CHARS _c_o_n_s_t _c_h_a_r _*
         Unify the argument  with an atom,  constructed from the C  char
         *, as in PL_unify_atom_chars().

    PL_NCHARS _s_i_z_e___t_, _c_o_n_s_t _c_h_a_r _*
         Unify the argument  with an atom,  constructed from length  and
         char* as in PL_unify_atom_nchars().

    PL_UTF8_CHARS _c_o_n_s_t _c_h_a_r _*
         Create an atom from a UTF-8 string.

    PL_UTF8_STRING _c_o_n_s_t _c_h_a_r _*
         Create a packed string object from a UTF-8 string.

    PL_MBCHARS _c_o_n_s_t _c_h_a_r _*
         Create an atom from a multi-byte string in the current locale.

    PL_MBCODES _c_o_n_s_t _c_h_a_r _*
         Create a list  of character codes  from a multi-byte string  in
         the current locale.

    PL_MBSTRING _c_o_n_s_t _c_h_a_r _*
         Create a packed string  object from a multi-byte string  in the
         current locale.

    PL_NWCHARS _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create an atom from a length and a wide character pointer.

    PL_NWCODES _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create an  list of  character codes from  a length  and a  wide
         character pointer.

    PL_NWSTRING _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create  a  packed  string object  from  a  length  and  a  wide
         character pointer.

    PL_SHORT _s_h_o_r_t
         Unify the  argument with an  integer, as  in PL_unify_integer().
         As short is promoted to int, PL_SHORT is a synonym for PL_INT.

    PL_INTEGER _l_o_n_g
         Unify the argument with an integer, as in PL_unify_integer().

    PL_INT _i_n_t
         Unify the argument with an integer, as in PL_unify_integer().

    PL_LONG _l_o_n_g
         Unify the argument with an integer, as in PL_unify_integer().

    PL_INT64 _i_n_t_6_4___t
         Unify   the   argument   with   a  64-bit   integer,    as   in
         PL_unify_int64().

    PL_INTPTR _i_n_t_p_t_r___t
         Unify the  argument with an  integer with the  same width as  a
         pointer.   On most  machines this is  the same as  PL_LONG.  but
         on 64-bit MS-Windows pointers  are 64-bit while longs are  only
         32-bits.

    PL_DOUBLE _d_o_u_b_l_e
         Unify  the  argument  with  a  float,  as  in  PL_unify_float().
         Note  that,  as the  argument  is  passed using  the  C  vararg
         conventions, a float must be casted to a double explicitly.

    PL_FLOAT _d_o_u_b_l_e
         Unify the argument with a float, as in PL_unify_float().

    PL_POINTER _v_o_i_d _*
         Unify the argument with a pointer, as in PL_unify_pointer().

    PL_STRING _c_o_n_s_t _c_h_a_r _*
         Unify   the   argument   with   a   string   object,    as   in
         PL_unify_string_chars().

    PL_TERM _t_e_r_m___t
         Unify  a  subterm.    Note  this  may the  return  value  of  a
         PL_new_term_ref() call to get access to a variable.

    PL_FUNCTOR _f_u_n_c_t_o_r___t_, _._._.
         Unify the argument  with a compound  term.  This  specification
         should be  followed by  exactly as many  specifications as  the
         number of arguments of the compound term.

    PL_FUNCTOR_CHARS _c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _._._.
         Create a functor from the given name and arity  and then behave
         as PL_FUNCTOR.

    PL_LIST _i_n_t _l_e_n_g_t_h_, _._._.
         Create  a  list  of  the  indicated  length.     The  following
         arguments contain the elements of the list.

    For  example, to  unify an argument  with the term  language(dutch),
    the following skeleton may be used:

    static functor_t FUNCTOR_language1;

    static void
    init_constants()
    { FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"), 1);
    }

    foreign_t
    pl_get_lang(term_t r)
    { return PL_unify_term(r,
                           PL_FUNCTOR, FUNCTOR_language1,
                               PL_CHARS, "dutch");
    }

    install_t
    install()
    { PL_register_foreign("get_lang", 1, pl_get_lang, 0);
      init_constants();
    }


int PPLL__cchhaarrss__ttoo__tteerrmm(_c_o_n_s_t _c_h_a_r _*_c_h_a_r_s_, _t_e_r_m___t _-_t)
    Parse  the string _c_h_a_r_s  and put the  resulting Prolog term into  _t.
    _c_h_a_r_s  may or may not  be closed using  a Prolog full-stop (i.e.,  a
    dot  followed by  a blank).   Returns  FALSE if a  syntax error  was
    encountered  and TRUE after successful  completion.  In addition  to
    returning  FALSE, the exception-term  is returned in  _t on a  syntax
    error.  See also term_to_atom/2.

    The following example build a goal-term from a string and calls it.

    int
    call_chars(const char *goal)
    { fid_t fid = PL_open_foreign_frame();
      term_t g = PL_new_term_ref();
      BOOL rval;

      if ( PL_chars_to_term(goal, g) )
        rval = PL_call(goal, NULL);
      else
        rval = FALSE;

      PL_discard_foreign_frame(fid);
      return rval;
    }

      ...
      call_chars("consult(load)");
      ...


char * PPLL__qquuoottee(_i_n_t _c_h_r_, _c_o_n_s_t _c_h_a_r _*_s_t_r_i_n_g)
    Return a quoted version of  _s_t_r_i_n_g.  If _c_h_r is '\'', the result is a
    quoted  atom.  If _c_h_r  is '"', the result is  a string.  The  result
    string  is stored in the same ring of buffers as described  with the
    BUF_RING argument of PL_get_chars();

    In  the current implementation, the string is surrounded by  _c_h_r and
    any occurrence of _c_h_r  is doubled.  In the future the behaviour will
    depend on the character_escapes Prolog flag.


99..66..66 BBLLOOBBSS:: UUssiinngg aattoommss ttoo ssttoorree aarrbbiittrraarryy bbiinnaarryy ddaattaa

SWI-Prolog atoms as well as strings can represent  arbitrary binary data
of arbitrary length.   This facility  is attractive for storing  foreign
data such  as images in an  atom.   An atom is  a unique handle to  this
data and the  atom garbage collector is  able to destroy atoms that  are
no longer  referenced by  the Prolog  engine.   This  property of  atoms
makes them  attractive as a  handle to foreign  resources, such as  Java
atoms, Microsoft's  COM objects, etc.,  providing safe combined  garbage
collection.

To  exploit   these  features   safely  and  in   an  organised   manner
the  SWI-Prolog  foreign  interface allows  for  creating  `atoms'  with
additional type  information.   The type is  represented by a  structure
holding C  function pointers that  tell Prolog  how to handle  releasing
the  atom,  writing it,  sorting  it,  etc.    Two  atoms  created  with
different types  can represent the  same sequence of bytes.   Atoms  are
first ordered on the rank  number of the type and then on the  result of
the compare()  function.   Rank numbers  are assigned  when the type  is
registered.


99..66..66..11 DDeeffiinniinngg aa BBLLOOBB ttyyppee

The  type PL_blob_t represents  a structure  with  the layout  displayed
above.  The structure contains additional fields at  the ...for internal
bookkeeping as well as future extension.

typedef struct PL_blob_t
{ unsigned long         magic;          /* PL_BLOB_MAGIC */
  unsigned long         flags;          /* Bitwise or of PL_BLOB_* */
  char *                name;           /* name of the type */
  int                   (*release)(atom_t a);
  int                   (*compare)(atom_t a, atom_t b);
  int                   (*write)(IOSTREAM *s, atom_t a, int flags);
  int                   (*acquire)(atom_t a);
  ...
} PL_blob_t;

For each  type exactly  one such  structure should  be allocated.    Its
first field must be initialised to PL_BLOB_MAGIC. The _f_l_a_g_s is a bitwise
or of the following constants:

PPLL__BBLLOOBB__TTEEXXTT
    If  specified the blob is assumed to contain text and  is considered
    a normal Prolog atom.

PPLL__BBLLOOBB__UUNNIIQQUUEE
    If  specified the system  ensures that the  blob-handle is a  unique
    reference  for a blob with the given  type, length and content.   If
    this flag is not specified each lookup creates a new blob.

PPLL__BBLLOOBB__NNOOCCOOPPYY
    By  default the  content of the  blob is  copied.   Using this  flag
    the  blob references  the external  data directly.    The user  must
    ensure  the provided  pointer is valid  as long  as the atom  lives.
    If  PL_BLOB_UNIQUE  is  also specified  uniqueness is  determined  by
    comparing the pointer rather than the data pointed at.

The _n_a_m_e  field represents the type  name as available  to Prolog.   See
also current_blob/2.   The other field  are function pointers that  must
be initialised to proper functions or NULL to get  the default behaviour
of built-in atoms.  Below are the defined member functions:


void aaccqquuiirree(_a_t_o_m___t _a)
    Called  if a new blob  of this type is  created through PL_put_blob()
    or  PL_unify_blob().   This callback  may be used  together with  the
    release hook to deal with reference counted external objects.


int rreelleeaassee(_a_t_o_m___t _a)
    The  blob (atom)  _a is  about to  be released.    This function  can
    retrieve  the data of the blob  using PL_blob_data().  If it  returns
    FALSE the atom garbage collector will _n_o_t reclaim the atom.


int ccoommppaarree(_a_t_o_m___t _a_, _a_t_o_m___t _b)
    Compare the blobs _a  and _b, both of which are of the type associated
    to  this blob-type.   Return values  are, as memcmp(),  <0  if _a is
    less then _b, = 0 if both are equal and >0 otherwise.


int wwrriittee(_I_O_S_T_R_E_A_M _*_s_, _a_t_o_m___t _a_, _i_n_t _f_l_a_g_s)
    Write  the content of the blob _a to the stream _s and  respecting the
    _f_l_a_g_s.   The _f_l_a_g_s are a bitwise or  of zero or more of the PL_WRT_*
    flags  defined in SWI-Prolog.h.  This prototype is available if  the
    undocumented SWI-Stream.h is included _b_e_f_o_r_e SWI-Prolog.h.

    If  this function is not provided, write/1 emits the content  of the
    blob  for blobs of type PL_BLOB_TEXT or a string of  the format <#_h_e_x
    _d_a_t_a> for binary blobs.

If  a blob  type is  registered from  a loadable  object (shared  object
or DLL)  the blob-type  must be  deregistered before the  object may  be
released.


int PPLL__uunnrreeggiisstteerr__bblloobb__ttyyppee(_P_L___b_l_o_b___t _*_t_y_p_e)
    Unlink  the blob  type from  the registered type  and transform  the
    type  of possible  living blobs  to  unregistered, avoiding  further
    reference  to the type structure,  functions referred by it as  well
    as  the data.  This function  returns TRUE if no blobs of  this type
    existed  and FALSE otherwise.   PL_unregister_blob_type() is  intended
    for  the  uninstall()  hook of  foreign  modules,  avoiding  further
    references to the module.


99..66..66..22 AAcccceessssiinngg bblloobbss

The blob access  functions are similar to the atom  accessing functions.
Blobs being atoms, the  atom functions operate on blobs and  visa versa.
For clarity and  possible future compatibility issues however it  is not
advised to rely on this.


int PPLL__iiss__bblloobb(_t_e_r_m___t _t_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    Succeeds  if _t refers to a blob,  in which case _t_y_p_e is  filled with
    the type of the blob.


int PPLL__uunniiffyy__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_b_l_o_b_, _s_i_z_e___t _l_e_n_, _P_L___b_l_o_b___t _*_t_y_p_e)
    Unify  _t  to  a  new  blob  constructed  from  the  given  data  and
    associated to the given type.  See also PL_unify_atom_nchars().


int PPLL__ppuutt__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_b_l_o_b_, _s_i_z_e___t _l_e_n_, _P_L___b_l_o_b___t _*_t_y_p_e)
    Store  the described blob in _t.  The return value  indicates whether
    a  new blob  was allocated  (FALSE) or the  blob is  a reference  to
    an  existing  blob (TRUE).  Reporting new/existing  can  be used  to
    deal  with external objects having their  own reference counts.   If
    the  return is  TRUE this  reference count must  be incremented  and
    it  must be  decremented on  blob destruction  callback.   See  also
    PL_put_atom_nchars().


int PPLL__ggeett__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_*_b_l_o_b_, _s_i_z_e___t _*_l_e_n_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    If  _t holds a blob  or atom get the  data and type and return  TRUE.
    Otherwise  return FALSE. Each result  pointer may be NULL, in  which
    case the requested information is ignored.


void * PPLL__bblloobb__ddaattaa(_a_t_o_m___t _a_, _s_i_z_e___t _*_l_e_n_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    Get  the  data  and  type associated  to  a  blob.    This  function
    is   mainly  used   from   the  callback   functions  described   in
    section 9.6.6.1.


99..66..77 EExxcchhaannggiinngg GGMMPP nnuummbbeerrss

If  SWI-Prolog is  linked  with the  GNU Multiple  Precision  Arithmetic
Library  (GMP,  used   by  default),  the  foreign   interface  provides
functions  for   exchanging  numeric   values  to   GMP  types.       To
access  these functions  the  header  <gmp.h> must  be  included  _b_e_f_o_r_e
<SWI-Prolog.h>.   Foreign code using GMP  linked to SWI-Prolog asks  for
some considerations.

  o SWI-Prolog  normally  rebinds  the GMP  allocation  functions  using
    mp_set_memory_functions().  This means SWI-Prolog must be initialised
    before  the  foreign  code  touches  any GMP  function.     You  can
    call  PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, TRUE) to force  Prolog's
    GMP   initialization  without   doing   the  rest   of  the   Prolog
    initialization.      If  you  do  not  want  Prolog   rebinding  the
    GMP  allocation,  call  PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, FALSE)
    _b_e_f_o_r_e initializing Prolog.

  o On  Windows, each DLL  has its own  memory pool.   To make  exchange
    of  GMP numbers between  Prolog and foreign  code possible you  must
    either  let Prolog rebind the allocation functions (default)  or you
    must  recompile  SWI-Prolog to  link to  a DLL  version  of the  GMP
    library.

Here is an example exploiting the function mpz_nextprime():

#include <gmp.h>
#include <SWI-Prolog.h>

static foreign_t
next_prime(term_t n, term_t prime)
{ mpz_t mpz;
  int rc;

  mpz_init(mpz);
  if ( PL_get_mpz(n, mpz) )
  { mpz_nextprime(mpz, mpz);

    rc = PL_unify_mpz(prime, mpz);
  } else
    rc = FALSE;

  mpz_clear(mpz);
  return rc;
}

install_t
install()
{ PL_register_foreign("next_prime", 2, next_prime, 0);
}


int PPLL__ggeett__mmppzz(_t_e_r_m___t _t_, _m_p_z___t _m_p_z)
    If  _t represents an  integer _m_p_z  is filled with  the value and  the
    function  returns TRUE. Otherwise _m_p_z is untouched and  the function
    returns  FALSE.  Note that  _m_p_z must  have  been initialised  before
    calling  this  function and  must  be cleared  using  mpz_clear()  to
    reclaim any storage associated with it.


int PPLL__ggeett__mmppqq(_t_e_r_m___t _t_, _m_p_q___t _m_p_q)
    If  _t is an integer or  rational number (term rdiv/2) _m_p_q is  filled
    with  the _n_o_r_m_a_l_i_s_e rational number  and the function returns  TRUE.
    Otherwise  _m_p_q is  untouched and  the function  returns FALSE.  Note
    that  _m_p_q must  have been initialised  before calling this  function
    and  must  be  cleared  using  mpq_clear()  to  reclaim  any  storage
    associated with it.


int PPLL__uunniiffyy__mmppzz(_t_e_r_m___t _t_, _m_p_z___t _m_p_z)
    Unify  _t with the integer value  represented by _m_p_z and return  _T_R_U_E
    on success.  The _m_p_z argument is not changed.


int PPLL__uunniiffyy__mmppqq(_t_e_r_m___t _t_, _m_p_q___t _m_p_q)
    Unify  _t with a rational number  represented by _m_p_q and return  _T_R_U_E
    on  success.    Note  that  _t is  unified  with  an integer  if  the
    denominator is 1.  The _m_p_q argument is not changed.


99..66..88 CCaalllliinngg PPrroolloogg ffrroomm CC

The Prolog  engine can be  called from C. There  are two interfaces  for
this.    For the  first, a  term is  created that  could be  used as  an
argument to  call/1 and  next PL_call()  is used  to call Prolog.    This
system is simple,  but does not allow  to inspect the different  answers
to  a non-deterministic  goal  and is  relatively  slow as  the  runtime
system needs  to find the predicate.   The  other interface is based  on
PL_open_query(), PL_next_solution() and  PL_cut_query()  or PL_close_query().
This mechanism is more powerful, but also more complicated to use.


99..66..88..11 PPrreeddiiccaattee rreeffeerreenncceess

This  section  discusses   the  functions  used  to  communicate   about
predicates.   Though a Prolog predicate  may defined or not,  redefined,
etc., a Prolog predicate has a handle that is  not destroyed, nor moved.
This handle is known by the type predicate_t.


predicate_t PPLL__pprreedd(_f_u_n_c_t_o_r___t _f_, _m_o_d_u_l_e___t _m)
    Return  a handle to a predicate for the specified name/arity  in the
    given module.   This function always succeeds, creating a handle for
    an  undefined predicate if no handle  was available.  If the  module
    argument _m is NULL, the current context module is used.


predicate_t PPLL__pprreeddiiccaattee(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _c_o_n_s_t _c_h_a_r_* _m_o_d_u_l_e)
    Same  a PL_pred(),  but provides a  more convenient interface to  the
    C-programmer.


void PPLL__pprreeddiiccaattee__iinnffoo(_p_r_e_d_i_c_a_t_e___t _p_, _a_t_o_m___t _*_n_, _i_n_t _*_a_, _m_o_d_u_l_e___t _*_m)
    Return  information on the  predicate _p.   The  name is stored  over
    _n,  the  arity  over _a,  while  _m  receives the  definition  module.
    Note  that  the  latter need  not  be  the same  as  specified  with
    PL_predicate().  If the predicate is imported into  the module given
    to  PL_predicate(), this  function will return  the module where  the
    predicate is defined.


99..66..88..22 IInniittiiaattiinngg aa qquueerryy ffrroomm CC

This  section discusses  the  functions  for creating  and  manipulating
queries from C. Note that a foreign context can have  at most one active
query.    This  implies it  is allowed  to  make strictly  nested  calls
between  C and  Prolog (Prolog  calls C,  calls Prolog,  calls C,  etc.,
but it  is nnoott  allowed to  open multiple queries  and start  generating
solutions for  each of them  by calling PL_next_solution().   Be sure  to
call PL_cut_query()  or PL_close_query() on  any query  you opened  before
opening the next or returning control back to Prolog.


qid_t PPLL__ooppeenn__qquueerryy(_m_o_d_u_l_e___t _c_t_x_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_, _t_e_r_m___t _+_t_0)
    Opens  a query  and returns  an identifier for  it.   This  function
    always  succeeds,  regardless whether  the predicate  is defined  or
    not.    _c_t_x is  the _c_o_n_t_e_x_t  _m_o_d_u_l_e of  the goal.    When NULL,  the
    context  module of  the calling  context will  be used,  or user  if
    there  is no calling  context (as may  happen in embedded  systems).
    Note  that the  context module  only matters  for _m_o_d_u_l_e___t_r_a_n_s_p_a_r_e_n_t
    predicates.   See context_module/1 and module_transparent/1.   The _p
    argument  specifies the  predicate, and  should be the  result of  a
    call  to PL_pred() or PL_predicate().   Note that  it is allowed  to
    store  this handle as global data  and reuse it for future  queries.
    The  term-reference _t_0 is the  first of a vector of  term-references
    as returned by PL_new_term_refs(n).

    The  _f_l_a_g_s  arguments provides  some additional  options  concerning
    debugging  and  exception handling.    It  is a  bitwise or  of  the
    following values:

    PL_Q_NORMAL
         Normal operation.  The debugger inherits its  settings from the
         environment.   If an  exception occurs that  is not handled  in
         Prolog,  a message  is printed  and the  tracer  is started  to
         debug the error.

    PL_Q_NODEBUG
         Switch off the debugger while executing the goal.   This option
         is used by many  calls to hook-predicates to avoid  tracing the
         hooks.   An example is  print/1 calling portray/1 from  foreign
         code.

    PL_Q_CATCH_EXCEPTION
         If an  exception is  raised while  executing the  goal, do  not
         report it, but make it available for PL_exception().

    PL_Q_PASS_EXCEPTION
         As PL_Q_CATCH_EXCEPTION,  but do  not invalidate the  exception-
         term  while   calling  PL_close_query().       This  option   is
         experimental.

    The  example below opens a query to the predicate is_a/2  to find the
    ancestor of for some name.

    char *
    ancestor(const char *me)
    { term_t a0 = PL_new_term_refs(2);
      static predicate_t p;

      if ( !p )
        p = PL_predicate("is_a", 2, "database");

      PL_put_atom_chars(a0, me);
      PL_open_query(NULL, PL_Q_NORMAL, p, a0);
      ...
    }


int PPLL__nneexxtt__ssoolluuttiioonn(_q_i_d___t _q_i_d)
    Generate the first (next)  solution for the given query.  The return
    value  is TRUE if  a solution  was found, or  FALSE to indicate  the
    query  could not be proven.  This function may be  called repeatedly
    until it fails to generate all solutions to the query.


void PPLL__ccuutt__qquueerryy(_q_i_d)
    Discards  the query,  but does not  delete any  of the data  created
    by  the query.  It just  invalidate _q_i_d, allowing for a new  call to
    PL_open_query() in this context.


void PPLL__cclloossee__qquueerryy(_q_i_d)
    As  PL_cut_query(),  but all  data and bindings  created by the  query
    are destroyed.


int PPLL__ccaallll__pprreeddiiccaattee(_m_o_d_u_l_e___t _m_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_r_e_d_, _t_e_r_m___t _+_t_0)
    Shorthand   for  PL_open_query(),   PL_next_solution(),  PL_cut_query(),
    generating  a single solution.   The arguments  are the same as  for
    PL_open_query(), the return value is the same as PL_next_solution().


int PPLL__ccaallll(_t_e_r_m___t_, _m_o_d_u_l_e___t)
    Call term just like  the Prolog predicate once/1.  _T_e_r_m is called in
    the  specified module, or in the context  module if module_t  = NULL.
    Returns  TRUE if  the call succeeds,  FALSE otherwise.   Figure  9.4
    shows an example to  obtain the number of defined atoms.  All checks
    are omitted to improve readability.


99..66..99 DDiissccaarrddiinngg DDaattaa

The Prolog  data created and  term-references needed  to setup the  call
and/or analyse  the result can  in most cases  be discarded right  after
the  call.    PL_close_query()  allows  for destructing  the  data,  while
leaving the  term-references.   The calls below may  be used to  destroy
term-references and data.  See figure 9.4 for an example.


fid_t PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee()
    Created  a foreign  frame,  holding a  mark that  allows the  system
    to  undo  bindings and  destroy data  created after  it  as well  as
    providing  the  environment  for  creating term-references.     This
    function   is  called  by  the  kernel  before  calling   a  foreign
    predicate.


void PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Discard  all term-references  created  after the  frame was  opened.
    All  other Prolog data is retained.  This function is called  by the
    kernel whenever a foreign function returns control back to Prolog.


void PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Same  as PL_close_foreign_frame(), but  also undo  all bindings  made
    since the open and destroy all Prolog data.


void PPLL__rreewwiinndd__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Undo all bindings  and discard all term-references created since the
    frame was created, but  does not pop the frame.  I.e. the same frame
    can  be rewinded multiple  times, and must  eventually be closed  or
    discarded.

It is obligatory to call either of the two  closing functions to discard
a foreign frame.  Foreign frames may be nested.

int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
  term_t goal  = PL_new_term_ref();
  term_t a1    = PL_new_term_ref();
  term_t a2    = PL_new_term_ref();
  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);

  int atoms;

  PL_put_atom_chars(a1, "atoms");
  PL_cons_functor(goal, s2, a1, a2);
  PL_call(goal, NULL);         /* call it in current module */

  PL_get_integer(a2, &atoms);
  PL_discard_foreign_frame(fid);

  return atoms;
}

                      Figure 9.4:  Calling Prolog


99..66..1100 FFoorreeiiggnn CCooddee aanndd MMoodduulleess

Modules are  identified via a  unique handle.   The following  functions
are available to query and manipulate modules.


module_t PPLL__ccoonntteexxtt()
    Return the module  identifier of the context module of the currently
    active foreign predicate.


int PPLL__ssttrriipp__mmoodduullee(_t_e_r_m___t _+_r_a_w_, _m_o_d_u_l_e___t _*_m_, _t_e_r_m___t _-_p_l_a_i_n)
    Utility  function.  If  _r_a_w is a  term, possibly holding the  module
    construct  <_m_o_d_u_l_e>:<_r_e_s_t>this function will make _p_l_a_i_n a  reference
    to  <_r_e_s_t>  and fill  _m_o_d_u_l_e _*  with <_m_o_d_u_l_e>.    For further  nested
    module  constructs  the inner  most module  is  returned via  _m_o_d_u_l_e
    _*.   If  _r_a_w is  not a module  construct _a_r_g will  simply be put  in
    _p_l_a_i_n.   If _m_o_d_u_l_e _* is NULL  it will be set to the  context module.
    Otherwise  it will be left untouched.   The following example  shows
    how  to obtain the  plain term and module  if the default module  is
    the user module:

    { module m = PL_new_module(PL_new_atom("user"));
      term_t plain = PL_new_term_ref();

      PL_strip_module(term, &m, plain);
      ...


atom_t PPLL__mmoodduullee__nnaammee(_m_o_d_u_l_e___t)
    Return the name of _m_o_d_u_l_e as an atom.


module_t PPLL__nneeww__mmoodduullee(_a_t_o_m___t _n_a_m_e)
    Find  an existing or create a new module with name specified  by the
    atom _n_a_m_e.


99..66..1111 PPrroolloogg eexxcceeppttiioonnss iinn ffoorreeiiggnn ccooddee

This     section     discusses    PL_exception(),      PL_throw()     and
PL_raise_exception(),  the   interface  functions  to  detect  and   gen-
erate Prolog exceptions from C-code.  PL_throw() and PL_raise_exception()
from  the  C-interface   to  raise  an  exception  from  foreign   code.
PL_throw()  exploits the  C-function longjmp() to  return immediately  to
the  innermost PL_next_solution().    PL_raise_exception()  registers  the
exception term and returns FALSE. If a foreign  predicate returns FALSE,
while  and exception-term  is  registered  a Prolog  exception  will  be
raised by the virtual machine.

Calling these functions  outside the context of a function  implementing
a foreign predicate results in undefined behaviour.

PL_exception()  may be used after a call to  PL_next_solution() fails,  and
returns  a term  reference to  an  exception term  if an  exception  was
raised, and 0 otherwise.

If a  C-function, implementing a predicate  calls Prolog and detects  an
exception using PL_exception(), it can handle this exception,  or return
with  the exception.    Some caution  is required  though.    It is  nnoott
allowed to call PL_close_query() or PL_discard_foreign_frame() afterwards,
as this  will invalidate the  exception term.   Below  is the code  that
calls a Prolog defined arithmetic function (see arithmetic_function/1).

If PL_next_solution()  succeeds, the  result is  analysed and  translated
to  a number,  after  which the  query  is closed  and all  Prolog  data
created  after  PL_open_foreign_frame()  is  destroyed.     On  the  other
hand,  if  PL_next_solution()  fails and  if  an  exception  was  raised,
just  pass  it.    Otherwise  generate an  exception  (PL_error()  is  an
internal  call  for  building  the  standard  error  terms  and  calling
PL_raise_exception()).     After  this,  the  Prolog  environment  should
be  discarded using  PL_cut_query()  and PL_close_foreign_frame() to  avoid
invalidating the exception term.

static int
prologFunction(ArithFunction f, term_t av, Number r)
{ int arity = f->proc->definition->functor->arity;
  fid_t fid = PL_open_foreign_frame();
  qid_t qid;
  int rval;

  qid = PL_open_query(NULL, PL_Q_NORMAL, f->proc, av);

  if ( PL_next_solution(qid) )
  { rval = valueExpression(av+arity-1, r);
    PL_close_query(qid);
    PL_discard_foreign_frame(fid);
  } else
  { term_t except;

    if ( (except = PL_exception(qid)) )
    { rval = PL_throw(except);          /* pass exception */
    } else
    { char *name = stringAtom(f->proc->definition->functor->name);

                                        /* generate exception */
      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f->proc);
    }

    PL_cut_query(qid);                  /* donot destroy data */
    PL_close_foreign_frame(fid);        /* same */
  }

  return rval;
}


int PPLL__rraaiissee__eexxcceeppttiioonn(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Generate  an exception (as  throw/1) and return  FALSE. Below is  an
    example returning an exception from foreign predicate:

    foreign_t
    pl_hello(term_t to)
    { char *s;

      if ( PL_get_atom_chars(to, &s) )
      { Sprintf("Hello \"%s\"\n", s);

        PL_succeed;
      } else
      { term_t except = PL_new_term_ref();

        PL_unify_term(except,
                      PL_FUNCTOR_CHARS, "type_error", 2,
                        PL_CHARS, "atom",
                        PL_TERM, to);

        return PL_raise_exception(except);
      }
    }


int PPLL__tthhrrooww(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Similar  to PL_raise_exception(), but returns  using the C  longjmp()
    function to the innermost PL_next_solution().


term_t PPLL__eexxcceeppttiioonn(_q_i_d___t _q_i_d)
    If  PL_next_solution()  fails, this  can  be  due to  normal  failure
    of  the  Prolog  call, or  because  an  exception was  raised  using
    throw/1.   This function returns  a handle to the exception term  if
    an exception was raised, or 0 if the Prolog goal simply failed..


99..66..1122 CCaattcchhiinngg SSiiggnnaallss ((SSooffttwwaarree IInntteerrrruuppttss))

SWI-Prolog offers both  a C and Prolog  interface to deal with  software
interrupts (signals).   The Prolog mapping  is defined in section  4.10.
This subsection deals with handling signals from C.

If a signal is not  used by Prolog and the handler does not  call Prolog
in any way, the native signal interface routines may be used.

Some versions of SWI-Prolog, notably running on  popular Unix platforms,
handle SIG_SEGV  for guarding  the Prolog stacks.    If the  application
wishes to handle  this signal too, it should  use PL_signal() to  install
its handler  after initialising Prolog.   SWI-Prolog will  pass SIG_SEGV
to the user  code if it detected the  signal is not related to a  Prolog
stack overflow.

Any handler that  wishes to call one  of the Prolog interface  functions
should call PL_signal() for its installation.


void (*)() PPLL__ssiiggnnaall(_s_i_g_, _f_u_n_c)
    This  function  is equivalent  to  the BSD-Unix  signal()  function,
    regardless  of the  platform used.   The  signal handler is  blocked
    while  the signal routine  is active, and automatically  reactivated
    after the handler returns.

    After  a  signal handler  is  registered using  this  function,  the
    native  signal interface  redirects the signal  to a generic  signal
    handler  inside  SWI-Prolog.   This  generic  handler validates  the
    environment,   creates  a  suitable  environment  for   calling  the
    interface functions described  in this chapter and finally calls the
    registered user-handler.

    By  default, signals  are handled asynchronously  (i.e. at the  time
    they  arrive).   It is inherently  dangerous to call extensive  code
    fragments,  and especially exception related code  from asynchronous
    handlers.     The  interface  allows  for  _s_y_n_c_h_r_o_n_o_u_s  handling  of
    signals.   In  this case  the native OS  handler just schedules  the
    signal  using PL_raise(),  which is checked by  PL_handle_signals()  at
    the  call- and redo-port.  This behaviour is realised by  or-ing _s_i_g
    with the constant PL_SIGSYNC.

    Signal    handling    routines    may   raise    exceptions    using
    PL_raise_exception().      The   use  of  PL_throw()  is  not   safe.
    If  a  synchronous handler  raises an  exception,  the exception  is
    delayed to the next call to PL_handle_signals();


int PPLL__rraaiissee(_i_n_t _s_i_g)
    Register  _s_i_g  for  _s_y_n_c_h_r_o_n_o_u_s handling  by  Prolog.    Synchronous
    signals  are  handled at  the  call-port or  if foreign  code  calls
    PL_handle_signals().  See also thread_signal/2.


int PPLL__hhaannddllee__ssiiggnnaallss(_v_o_i_d)
    Handle  any signals pending from  PL_raise().   PL_handle_signals()  is
    called  at  each pass  through the  call- and  redo-port  at a  safe
    point.   Exceptions raised by the  handler using PL_raise_exception()
    are properly passed to the environment.

    The  user  may   call  this  function  inside  long-running  foreign
    functions to handle  scheduled interrupts.  This routine returns the
    number  of signals handled.   If a handler raises an exception,  the
    return value is  -1 and the calling routine should return with FALSE
    as soon as possible.


int PPLL__ggeett__ssiiggnnuumm__eexx(_t_e_r_m___t _t_, _i_n_t _*_s_i_g)
    Extract  a signal  specification  from a  Prolog term  and store  as
    integer  signal number  in _s_i_g.   The  specification is an  integer,
    lowercase  signal name without SIG or  the full signal name.   These
    refer  to the same:  9, kill and SIGKILL. Leaves a typed,  domain or
    instantiation error if the conversion fails.


99..66..1133 MMiisscceellllaanneeoouuss


99..66..1133..11 TTeerrmm CCoommppaarriissoonn


int PPLL__ccoommppaarree(_t_e_r_m___t _t_1_, _t_e_r_m___t _t_2)
    Compares  two terms using  the standard order  of terms and  returns
    -1, 0 or 1.  See also compare/3.


int PPLL__ssaammee__ccoommppoouunndd(_t_e_r_m___t _t_1_, _t_e_r_m___t _t_2)
    Yields TRUE if _t_1  and _t_2 refer to physically the same compound term
    and FALSE otherwise.


99..66..1133..22 RReeccoorrddeedd ddaattaabbaassee

In some  applications it is  useful to store  and retrieve Prolog  terms
from C-code.  For example, the XPCE graphical  environment does this for
storing arbitrary Prolog data as slot-data of XPCE objects.

Please note  that the  returned handles  have no meaning  at the  Prolog
level  and  the recorded  terms  are  not  visible from  Prolog.     The
functions PL_recorded() and PL_erase() are the  only functions that  can
operate on the stored term.

Two groups of functions are  provided.  The first group (PL_record() and
friends) store Prolog terms on the Prolog heap for  retrieval during the
same session.   These functions are also used by recorda/3  and friends.
The recorded  database may be used  to communicate Prolog terms  between
threads.


record_t PPLL__rreeccoorrdd(_t_e_r_m___t _+_t)
    Record  the term _t into the Prolog database as recorda/3  and return
    an  opaque handle to  the term.   The returned handle remains  valid
    until  PL_erase()  is called on  it.   PL_recorded()  is used to  copy
    recorded terms back to the Prolog stack.


void PPLL__rreeccoorrddeedd(_r_e_c_o_r_d___t _r_e_c_o_r_d_, _t_e_r_m___t _-_t)
    Copy a recorded term  back to the Prolog stack.  The same record may
    be used to copy  multiple instances at any time to the Prolog stack.
    See also PL_record() and PL_erase().


void PPLL__eerraassee(_r_e_c_o_r_d___t _r_e_c_o_r_d)
    Remove  the recorded term from  the Prolog database, reclaiming  all
    associated memory resources.

The  second group  (headed  by  PL_record_external())  provides  the  same
functionality, but the returned data has properties  that enable storing
the  data on  an external  device.   It  has been  designed  to make  it
possible to store Prolog terms fast an compact in  an external database.
Here are the main features:

  o _I_n_d_e_p_e_n_d_e_n_t _o_f _s_e_s_s_i_o_n
    Records  can  be communicated  to another  Prolog  session and  made
    visible using PL_recorded_external().

  o _B_i_n_a_r_y
    The representation is  binary for maximum performance.  The returned
    data may contain 0-bytes.

  o _B_y_t_e_-_o_r_d_e_r _i_n_d_e_p_e_n_d_e_n_t
    The   representation  can  be  transferred  between   machines  with
    different byte-order.

  o _N_o _a_l_i_g_n_m_e_n_t _r_e_s_t_r_i_c_t_i_o_n_s
    There are no  memory alignment restrictions and copies of the record
    can  thus be  moved freely.    For example,  it is  possible to  use
    this  representation to exchange  terms using shared memory  between
    different Prolog processes.

  o _C_o_m_p_a_c_t
    It  is  assumed  that a  smaller  memory footprint  will  eventually
    outperform slightly faster representations.

  o _S_t_a_b_l_e
    The  format is  designed  for future  enhancements without  breaking
    compatibility with older records.


char * PPLL__rreeccoorrdd__eexxtteerrnnaall(_t_e_r_m___t _+_t_, _s_i_z_e___t _*_l_e_n)
    Record  the term _t into the Prolog database as recorda/3  and return
    an  opaque handle to  the term.   The returned handle remains  valid
    until PL_erase_external() is called on it.

    It  is allowed  to copy  the data  and use  PL_recorded_external()  on
    the  copy.   The user  is responsible for  the memory management  of
    the  copy.    After copying,  the original  may  be discarded  using
    PL_erase_external().

    PL_recorded_external() is  used to copy  such recorded terms back  to
    the Prolog stack.


int PPLL__rreeccoorrddeedd__eexxtteerrnnaall(_c_o_n_s_t _c_h_a_r _*_r_e_c_o_r_d_, _t_e_r_m___t _-_t)
    Copy a recorded term  back to the Prolog stack.  The same record may
    be used to copy  multiple instances at any time to the Prolog stack.
    See also PL_record_external() and PL_erase_external().


int PPLL__eerraassee__eexxtteerrnnaall(_c_h_a_r _*_r_e_c_o_r_d)
    Remove  the recorded term from  the Prolog database, reclaiming  all
    associated memory resources.


99..66..1133..33 GGeettttiinngg ffiillee nnaammeess

The function  PL_get_file_name() provides access  to Prolog filenames  and
its  file-search mechanism  described  with absolute_file_name/3.    Its
existence  is motivated  to realise  a uniform  interface  to deal  with
file-properties, search, naming conventions etc. from foreign code.


int PPLL__ggeett__ffiillee__nnaammee(_t_e_r_m___t _s_p_e_c_, _c_h_a_r _*_*_n_a_m_e_, _i_n_t _f_l_a_g_s)
    Translate  a Prolog  term into  a file  name.   The  name is  stored
    in  the  static  buffer  ring  described with  PL_get_chars()  option
    BUF_RING.  Conversion from  the internal  UNICODE  encoding is  done
    using   standard  C  library  functions.     _f_l_a_g_s  is   a  bit-mask
    controlling the conversion process.  Options are:

    PL_FILE_ABSOLUTE
         Return an absolute path to the requested file.

    PL_FILE_OSPATH
         Return  a the  name  using the  hosting  OS  conventions.    On
         MS-Windows, \ is  used to separate directories rather than  the
         canonical /.

    PL_FILE_SEARCH
         Invoke  absolute_file_name/3.      This   implies  rules   from
         file_search_path/2are used.

    PL_FILE_EXIST
         Demand the path to refer to an existing entity.

    PL_FILE_READ
         Demand read-access on the result.

    PL_FILE_WRITE
         Demand write-access on the result.

    PL_FILE_EXECUTE
         Demand execute-access on the result.

    PL_FILE_NOERRORS
         Do not raise any exceptions.


99..66..1144 EErrrroorrss aanndd wwaarrnniinnggss

PL_warning()  prints a standard  Prolog warning  message to the  standard
error (user_error) stream.   Please note  that new code should  consider
using  PL_raise_exception() to  raise  a  Prolog exception.     See  also
section 4.9.


int PPLL__wwaarrnniinngg(_f_o_r_m_a_t_, _a_1_, _._._.)
    Print  an  error message  starting  with `[WARNING: ',  followed  by
    the  output from  _f_o_r_m_a_t, followed  by a `]'  and a newline.    Then
    start  the tracer.   _f_o_r_m_a_t and  the arguments are  the same as  for
    printf(2).  Always returns FALSE.


99..66..1155 EEnnvviirroonnmmeenntt CCoonnttrrooll ffrroomm FFoorreeiiggnn CCooddee


int PPLL__aaccttiioonn(_i_n_t_, _._._.)
    Perform  some  action on  the  Prolog system.    _i_n_t  describes  the
    action,  Remaining arguments depend  on the requested  action.   The
    actions are listed in table 9.1.
    ___________________________________________________________________
    | PL_ACTION_TRACE        |Start Prolog tracer (trace/0).   Requires|
    |                        |no arguments.                            |
    | PL_ACTION_DEBUG        |Switch  on Prolog  debug mode  (debug/0).|
    |                        |Requires no arguments.                   |
    | PL_ACTION_BACKTRACE    |Print   backtrace   on   current   output|
    |                        |stream.   The  argument (an  int) is  the|
    |                        |number of frames printed.                |

    | PL_ACTION_HALT         |Halt  Prolog  execution.     This  action|
    |                        |should be called rather  than Unix exit()|
    |                        |to give  Prolog the opportunity  to clean|
    |                        |up.   This  call does  not return.    The|
    |                        |argument (an int) is the  exit code.  See|
    |                        |halt/1.                                  |
    | PL_ACTION_ABORT        |Generate a Prolog abort  (abort/0).  This|

    |                        |call  does  not  return.     Requires  no|
    |                        |arguments.                               |
    | PL_ACTION_BREAK        |Create  a  standard  Prolog  break  envi-|
    |                        |ronment  (break/0).    Returns after  the|
    |                        |user  types  the  end-of-file  character.|
    ||                       |Requires|no arguments.                   ||

    | PL_ACTION_GUIAPP       |Win32:  Used to  indicate the kernel that|
    |                        |the application  is a GUI  application if|
    |                        |the  argument  is  not 0  and  a  console|
    |                        |application if  the argument  is 0.    If|
    |                        |a  fatal error  occurs,  the system  uses|
    |                        |a windows  messagebox to  report this  on|
    |                        |a GUI  application and simply  prints the|
    |                        |error and exits otherwise.               |
    | PL_ACTION_WRITE        |Write  the  argument,  a  char *  to  the|

    |                        |current output stream.                   |
    | PL_ACTION_FLUSH        |Flush  the current  output stream.    Re-|
    |                        |quires no arguments.                     |
    | PL_ACTION_ATTACH_CONSOLE|Attach a console  to a thread if  it does|
    ||                       |not|have one.  See attach_console/0.     ||
    | PL_GMP_SET_ALLOC_FUNCTIONS|TakesTRUandE,integertheargument.GMP  alIflocation|are immediately

    |                        |                                         |
    |                        |bound  to  the  Prolog  functions.     If|
    |                        |FALSE,  SWI-Prolog   will  never   rebind|
    |                        |the  GMP  allocation  functions.      See|
    |                        |mp_set_memory_functions()  in the GMP  doc-|
    |                        |umentation.    The  action returns  FALSE|
    |                        |if  there is  no GMP  support  or GMP  is|
    |________________________|already_initialised._____________________|

                     Table 9.1:  PL_action() options


99..66..1166 QQuueerryyiinngg PPrroolloogg


long PPLL__qquueerryy(_i_n_t)
    Obtain  status  information  on  the  Prolog system.     The  actual
    argument  type depends on the  information required.  _i_n_t  describes
    what information is wanted.  The options are given in table 9.2.
    ___________________________________________________________________
    | PL_QUERY_ARGC          |Return an  integer holding the  number of|
    |                        |arguments given to Prolog from Unix.     |
    | PL_QUERY_ARGV          |Return  a char  **  holding the  argument|
    |                        |vector given to Prolog from Unix.        |
    | PL_QUERY_SYMBOLFILE    |Return  a  char  *  holding  the  current|

    |                        |symbol file of the running process.      |
    | PL_MAX_INTEGER         |Return a  long, representing  the maximal|
    |                        |integer  value  represented by  a  Prolog|
    |                        |integer.                                 |
    | PL_MIN_INTEGER         |Return a  long, representing  the minimal|
    |                        |integer value.                           |
    | PL_QUERY_VERSION       |Return a  long, representing  the version|

    |                        |as 10; 000M* +100m* +p, where  M is  the |
    |                        |major,  m the  minor version  number and |
    |                        |p the  patch-level.   For  example, 20717|
    |                        |means 2.7.17.                            |
    | PL_QUERY_MAX_THREADS   |Return  the  maximum  number  of  threads|
    |                        |that  can  be created  in  this  version.|
    |                        |Return  values   of  PL_thread_self()  are|
    |                        |between 0 and this number.               |

    | PL_QUERY_ENCODING      |Return  the  default stream  encoding  of|
    |                        |Prolog (of type IOENC).                  |
    | PL_QUERY_USER_CPU      |Get  amount  of  user  CPU  time  of  the|
    |________________________|process_in_milliseconds._________________|

                     Table 9.2:  PL_query() options


99..66..1177 RReeggiisstteerriinngg FFoorreeiiggnn PPrreeddiiccaatteess


int PPLL__rreeggiisstteerr__ffoorreeiiggnn__iinn__mmoodduullee(_c_o_n_s_t _c_h_a_r _*_m_o_d_u_l_e_, _c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _f_o_r_e_i_g_n___t _(_*_f_u_n_c_t_i_o_n_)_(_)_, _i_n_t _f_l_a_g_s)
    Register  a C-function to implement a Prolog predicate.   After this
    call returns successfully  a predicate with name _n_a_m_e (a char *) and
    arity  _a_r_i_t_y (a C int)  is created in module  _m_o_d_u_l_e.  If _m_o_d_u_l_e  is
    NULL, the predicate  is created in the module of the calling context
    or if no context is present in the module user.

    When  called in  Prolog, Prolog  will call  _f_u_n_c_t_i_o_n.   _f_l_a_g_s  forms
    bitwise or'ed list of options for the installation.  These are:
    ___________________________________________________________________
    | PL_FA_NOTRACE          |Predicate cannot be seen in the tracer   |
    | PL_FA_TRANSPARENT      |Predicate is module transparent          |
    | PL_FA_NONDETERMINISTIC |Predicate  is  non-deterministic.     See|
    |                        |also PL_retry().                         |

    |_PL_FA_VARARGS__________|Use_alternative_calling_convention.______|
    Predicates    may   be   registered    either   before   or    after
    PL_initialise().      When  registered  before  initialisation   the
    registration  is recorded and  executed after installing the  system
    predicates and before loading the saved state.

    Default  calling (i.e. without PL_FA_VARARGS) _f_u_n_c_t_i_o_n is  passed the
    same  number of term_t arguments  as the arity of the  predicate and,
    if  the predicate is  non-deterministic, an  extra argument of  type
    control_t  (see section  9.6.1.1).    If PL_FA_VARARGS is  provided,
    _f_u_n_c_t_i_o_n  is called  with three arguments.    The first argument  is
    a  term_t  handle to the  first argument.   Further arguments can  be
    reached  by adding  the  offset (see  also PL_new_term_refs()).    The
    second  argument is  the arity,  which defines the  number of  valid
    term-references  in the argument vector.  The last argument  is used
    for  non-deterministic  calls.   It  is  currently undocumented  and
    should be defined of type void*.  Here is an example:

    static foreign_t
    atom_checksum(term_t a0, int arity, void* context)
    { char *s;

      if ( PL_get_atom_chars(a0, &s) )
      { int sum;

        for(sum=0; *s; s++)
          sum += *s&0xff;

        return PL_unify_integer(a0+1, sum&0xff);
      }

      return FALSE;
    }

    install_t
    install()
    { PL_register_foreign("atom_checksum", 2, atom_checksum, PL_FA_VARARGS);
    }


int PPLL__rreeggiisstteerr__ffoorreeiiggnn(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _f_o_r_e_i_g_n___t _(_*_f_u_n_c_t_i_o_n_)_(_)_, _i_n_t _f_l_a_g_s)
    Same as PL_register_foreign_in_module(), passing NULL for the _m_o_d_u_l_e.


void PPLL__rreeggiisstteerr__eexxtteennssiioonnss__iinn__mmoodduullee(_c_o_n_s_t _c_h_a_r _*_m_o_d_u_l_e_, _P_L___e_x_t_e_n_s_i_o_n _*_e)
    Register a series  of predicates from an array of definitions of the
    type  PL_extension in  the given _m_o_d_u_l_e.    If _m_o_d_u_l_e  is NULL,  the
    predicate  is created in the module of the calling context or  if no
    context  is present in  the module user.   The PL_extension type  is
    defined as

    typedef struct PL_extension
    { char          *predicate_name;        /* Name of the predicate */
      short         arity;                  /* Arity of the predicate */
      pl_function_t function;               /* Implementing functions */
      short         flags;                  /* Or of PL_FA_... */
    } PL_extension;

    For  details, see PL_register_foreign_in_module().  Here  is an example
    of its usage:

    static PL_extension predicates[] = {
    { "foo",        1,      pl_foo, 0 },
    { "bar",        2,      pl_bar, PL_FA_NONDETERMINISTIC },
    { NULL,         0,      NULL,   0 }
    };

    main(int argc, char **argv)
    { PL_register_extensions_in_module("user", predicates);

      if ( !PL_initialise(argc, argv) )
        PL_halt(1);

      ...
    }


void PPLL__rreeggiisstteerr__eexxtteennssiioonnss( _P_L___e_x_t_e_n_s_i_o_n _*_e)
    Same  as PL_register_extensions_in_module()  using NULL for the  _m_o_d_u_l_e
    argument.


99..66..1188 FFoorreeiiggnn CCooddee HHooookkss

For various specific applications some hooks re provided.


PL_dispatch_hook_t PPLL__ddiissppaattcchh__hhooookk(_P_L___d_i_s_p_a_t_c_h___h_o_o_k___t)
    If this hook is  not NULL, this function is called when reading from
    the  terminal.   It is supposed  to dispatch events when  SWI-Prolog
    is  connected to a  window environment.   It can return two  values:
    PL_DISPATCH_INPUT  indicates  Prolog  input  is  available  on  file
    descriptor  0 or PL_DISPATCH_TIMEOUT to indicate a timeout.   The old
    hook is returned.  The type PL_dispatch_hook_t is defined as:

    typedef int  (*PL_dispatch_hook_t)(void);


void PPLL__aabboorrtt__hhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Install  a hook  when abort/0 is  executed.   SWI-Prolog abort/0  is
    implemented  using C  setjmp()/longjmp() construct.   The hooks  are
    executed  in  the  reverse order  of  their registration  after  the
    longjmp()  took place and before the Prolog top-level  is reinvoked.
    The type PL_abort_hook_t is defined as:

    typedef void (*PL_abort_hook_t)(void);


int PPLL__aabboorrtt__uunnhhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Remove  a hook installed with  PL_abort_hook().   Returns FALSE if  no
    such hook is found, TRUE otherwise.


void PPLL__oonn__hhaalltt(_v_o_i_d _(_*_f_)_(_i_n_t_, _v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e)
    Register  the function _f to be called if SWI-Prolog is halted.   The
    function  is  called with  two  arguments:   the  exit code  of  the
    process  (0 if this cannot  be determined on your operating  system)
    and  the _c_l_o_s_u_r_e argument passed to the PL_on_halt() call.   See also
    at_halt/1.


PL_agc_hook_t PPLL__aaggcc__hhooookk(_P_L___a_g_c___h_o_o_k___t _n_e_w)
    Register    a   hook   with   the   atom-garbage    collector   (see
    garbage_collect_atoms/0  that  is   called  on  any  atom  that   is
    reclaimed.    The old hook  is returned.   If  no hook is  currently
    defined,  NULL is returned.  The argument of the called hook  is the
    atom  that is to be garbage collected.  The return value  is an int.
    If  the return value is zero, the  atom is nnoott reclaimed.   The hook
    may invoke any Prolog predicate.

    The  example  below  defines  a foreign  library  for  printing  the
    garbage collected atoms for debugging purposes.

    #include <SWI-Stream.h>
    #include <SWI-Prolog.h>

    static int
    atom_hook(atom_t a)
    { Sdprintf("AGC: deleting %s\n", PL_atom_chars(a));

      return TRUE;
    }

    static PL_agc_hook_t old;

    install_t
    install()
    { old = PL_agc_hook(atom_hook);
    }

    install_t
    uninstall()
    { PL_agc_hook(old);
    }


99..66..1199 SSttoorriinngg ffoorreeiiggnn ddaattaa

This section  provides some hints for  handling foreign data in  Prolog.
With foreign  data, we refer  to data that is  used by foreign  language
predicates  and  needs  to  be passed  around  in  Prolog.     Excluding
combinations, there are three principal options for storing such data

  o _N_a_t_u_r_a_l _P_r_o_l_o_g _d_a_t_a
    E.i.  using the  representation  one would  choose if  there was  no
    foreign interface required.

  o _O_p_a_q_u_e _p_a_c_k_e_d _P_r_o_l_o_g _d_a_t_a
    Data  can also be represented in  a foreign structure and stored  on
    the  Prolog stacks  using PL_put_string_nchars()  and retrieved  using
    PL_get_string_chars().   It is  generally good practice  to wrap  the
    string  in a compound term with arity 1, so Prolog can  identify the
    type.    portray/1 rules  may be  used to  streamline printing  such
    terms during development.

  o _N_a_t_u_r_a_l _f_o_r_e_i_g_n _d_a_t_a_, _p_a_s_s_i_n_g _a _p_o_i_n_t_e_r
    An  alternative is to pass  a pointer to the  foreign data.   Again,
    this functor may be wrapped in a compound term.

The choice may be guided using the following distinctions

  o _I_s _t_h_e _d_a_t_a _o_p_a_q_u_e _t_o _P_r_o_l_o_g
    With  `opaque' data, we refer to data handled in  foreign functions,
    passed  around in  Prolog, but  of which Prolog  never examines  the
    contents  of the  data itself.   If  the data is  opaque to  Prolog,
    the  chosen representation  does not  depend on  simple analysis  by
    Prolog,  and the selection  will be driven  solely by simplicity  of
    the interface and performance (both in time and space).

  o _H_o_w _b_i_g _i_s _t_h_e _d_a_t_a
    Is  efficient encoding required?   For examine, a boolean array  may
    be  expressed as  a compound  term, holding integers  each of  which
    contains a number of bits, or as a list of true and false.

  o _W_h_a_t _i_s _t_h_e _n_a_t_u_r_e _o_f _t_h_e _d_a_t_a
    For  examples in C,  constants are often  expressed using `enum'  or
    #define'd  integer values.   If  prolog needs  to handle this  data,
    atoms  are a more logical  choice.  Whether  or not this mapping  is
    used  depends on  whether Prolog  needs to interpret  the data,  how
    important debugging is and how important performance is.

  o _W_h_a_t _i_s _t_h_e _l_i_f_e_t_i_m_e _o_f _t_h_e _d_a_t_a
    We can distinguish three cases.

     1.  The lifetime is  dictated by the  accessibility of the data  on
         the Prolog stacks.   Their is no way by which the  foreign code
         when the  data becomes `garbage',  and the  data thus needs  to
         be represented  on the Prolog  stacks using Prolog  data-types.
         (2),

     2.  The  data lives  on  the  `heap' and  is  explicitly  allocated
         and deallocated.   In  this case,  representing the data  using
         native foreign representation and passing a pointer to  it is a
         sensible choice.

     3.  The data lives as  during the lifetime of a  foreign predicate.
         If the predicate is deterministic, foreign  automatic variables
         are suitable.  if the predicate is  non-deterministic, the data
         may be allocated  using malloc() and  a pointer may be  passed.
         See section 9.6.1.1.


99..66..1199..11 EExxaammpplleess ffoorr ssttoorriinngg ffoorreeiiggnn ddaattaa

In this section, we will outline some examples,  covering typical cases.
In  the  first  example,  we will  deal  with  extending  Prolog's  data
representation with integer-sets, represented as bit-vectors.   Finally,
we discuss the outline of the DDE interface.

IInntteeggeerr  sseettss with  not-too-far-apart upper-  and  lower-bounds  can  be
represented using  bit-vectors.  Common  set operations, such as  union,
intersection,  etc.    are  reduced to  simple  and'ing and  or'ing  the
bit-vectors.  This can be done using Prolog's unbounded integers.

For really demanding  applications, foreign representation will  perform
better,  especially  time-wise.    Bit-vectors are  naturally  expressed
using  string  objects.    If  the  string is  wrapped  in  bitvector/1,
lower-bound of the vector  is 0, and the upper-bound is not  defined, an
implementation for  getting and putting  the sets as  well as the  union
predicate for it is below.

#include <SWI-Prolog.h>

#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))

static functor_t FUNCTOR_bitvector1;

static int
get_bitvector(term_t in, int *len, unsigned char **data)
{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, in, a);
    return PL_get_string(a, (char **)data, len);
  }

  PL_fail;
}

static int
unify_bitvector(term_t out, int len, const unsigned char *data)
{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, out, a);

    return PL_unify_string_nchars(a, len, (const char *)data);
  }

  PL_fail;
}

static foreign_t
pl_bitvector_union(term_t t1, term_t t2, term_t u)
{ unsigned char *s1, *s2;
  int l1, l2;

  if ( get_bitvector(t1, &l1, &s1) &&
       get_bitvector(t2, &l2, &s2) )
  { int l = max(l1, l2);
    unsigned char *s3 = alloca(l);

    if ( s3 )
    { int n;
      int ml = min(l1, l2);

      for(n=0; n<ml; n++)
        s3[n] = s1[n] | s2[n];
      for( ; n < l1; n++)
        s3[n] = s1[n];
      for( ; n < l2; n++)
        s3[n] = s2[n];

      return unify_bitvector(u, l, s3);
    }

    return PL_warning("Not enough memory");
  }

  PL_fail;
}

install_t
install()
{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);

  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);
}

TThhee DDDDEE  iinntteerrffaaccee (see section  4.42) represents  another common  usage
of  the foreign  interface:   providing communication  to new  operating
system features.  The DDE interface requires knowledge  about active DDE
server and  client channels.   These  channels contains various  foreign
data-types.  Such an interface is normally achieved  using an open/close
protocol that creates and destroys a _h_a_n_d_l_e.  The  handle is a reference
to a foreign data-structure containing the relevant information.

There are a  couple of possibilities for  representing the handle.   The
choice  depends on  responsibilities  and  debugging facilities.     The
simplest  approach is  to using  PL_unify_pointer() and  PL_get_pointer().
This  approach is  fast and  easy, but  has the  drawbacks of  (untyped)
pointers:   there  is no  reliable way  to detect  the  validity of  the
pointer, not  to verify  it is pointing  to a  structure of the  desired
type.   The pointer  may be wrapped  into a compound  term with arity  1
(i.e., dde_channel(<_P_o_i_n_t_e_r>)), making the type-problem less serious.

Alternatively  (used in  the  DDE  interface),  the interface  code  can
maintain a  (preferably variable  length) array of  pointers and  return
the index in this  array.  This provides better protection.   Especially
for debugging  purposes, wrapping  the handle  in a compound  is a  good
suggestion.


99..66..2200 EEmmbbeeddddiinngg SSWWII--PPrroolloogg iinn ootthheerr aapppplliiccaattiioonnss

With embedded Prolog we refer to the situation where  the `main' program
is not the Prolog application.  Prolog is sometimes  embedded in C, C++,
Java or  other languages  to provide  logic based services  in a  larger
application.   Embedding  loads the Prolog  engine as  a library to  the
external language.   Prolog  itself only provides  for embedding in  the
C-language (compatible with C++).   Embedding in Java is  achieved using
JPL using a C-glue between the Java and Prolog C-interfaces.

The  most   simple  embedded   program  is   below.      The   interface
function  PL_initialise()  mmuusstt  be   called  before  any  of  the  other
SWI-Prolog  foreign  language  functions  described  in   this  chapter,
except  for   PL_initialise_hook(),   PL_new_atom(),   PL_new_functor()   and
PL_register_foreign().   PL_initialise()  interprets all the  command-line
arguments,  except  for the  -t toplevel  flag  that is  interpreted  by
PL_toplevel().

int
main(int argc, char **argv)
{
#ifdef READLINE /* Remove if you don't want readline */
  PL_initialise_hook(install_readline);
#endif

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_halt(PL_toplevel() ? 0 : 1);
}


int PPLL__iinniittiiaalliissee(_i_n_t _a_r_g_c_, _c_h_a_r _*_*_a_r_g_v)
    Initialises  the SWI-Prolog  heap and  stacks,  restores the  Prolog
    state, loads the  system and personal initialisation files, runs the
    at_initialization/1 hooks and finally runs the -g goal hook.

    Special  consideration  is required  for argv[0].    On  UUnniixx,  this
    argument passes the  part of the command-line that is used to locate
    the  executable.   Prolog  uses this to  find the  file holding  the
    running executable.   The WWiinnddoowwss version uses this to find a _m_o_d_u_l_e
    of  the  running executable.    If the  specified  module cannot  be
    found, it tries  the module libpl.dll, containing the Prolog runtime
    kernel.   In  all these cases,  the resulting file  is used for  two
    purposes

      o  See whether a Prolog saved-state  is appended to the file.   If
         this is  the case,  this state  will be loaded  instead of  the
         default boot.prc file from the SWI-Prolog home directory.   See
         also qsave_program/[1,2] and section 9.7.

      o  Find the Prolog home  directory.  This process is  described in
         detail in section 9.8.

    PL_initialise() returns  1  if all  initialisation succeeded  and  0
    otherwise.

    In  most cases, _a_r_g_c and _a_r_g_v will be passed from the  main program.
    It  is allowed to create your own argument vector,  provided argv[0]
    is constructed according to the rules above.  For example:

    int
    main(int argc, char **argv)
    { char *av[10];
      int ac = 0;

      av[ac++] = argv[0];
      av[ac++] = "-x";
      av[ac++] = "mystate";
      av[ac]   = NULL;

      if ( !PL_initialise(ac, av) )
        PL_halt(1);
      ...
    }

    Please  note that the  passed argument vector  may be referred  from
    Prolog  at any time  and should  therefore be valid  as long as  the
    Prolog engine is used.

    A  good setup  in Windows is  to add  SWI-Prolog's bin directory  to
    your  PATH  and  either pass  a  module holding  a  saved-state,  or
    "libpl.dll"  as argv[0].  If the  Prolog state is attached to  a DLL
    (see the -dll option of plld, pass the name of this DLL.


int PPLL__iiss__iinniittiiaalliisseedd(_i_n_t _*_a_r_g_c_, _c_h_a_r _*_*_*_a_r_g_v)
    Test  whether the  Prolog engine  is already initialised.    Returns
    FALSE  if Prolog  is not  initialised and TRUE  otherwise.   If  the
    engine is initialised  and _a_r_g_c is not NULL, the argument count used
    with  PL_initialise()  is stored  in _a_r_g_c.    Same  for the  argument
    vector _a_r_g_v.


void PPLL__iinnssttaallll__rreeaaddlliinnee()
    Installs  the GNU-readline line-editor.  Embedded  applications that
    do  not use the Prolog  top-level should normally delete this  line,
    shrinking  the Prolog kernel significantly.   Note that the  Windows
    version does not use GNU readline.


int PPLL__ttoopplleevveell()
    Runs  the  goal of  the -t toplevel  switch  (default prolog/0)  and
    returns 1 if successful, 0 otherwise.


void PPLL__cclleeaannuupp(_i_n_t _s_t_a_t_u_s)
    This  function performs the reverse of PL_initialise().   It runs the
    PL_on_halt() and  at_halt/1 handlers, closes all streams (except  for
    the  `standard I/O'  streams which  are  flushed only),  deallocates
    all  memory and restores all signal  handlers.  The _s_t_a_t_u_s  argument
    is  passed  to  the  various termination  hooks  and  indicates  the
    _e_x_i_t_-_s_t_a_t_u_s.

    This  function allows deleting and  restarting the Prolog system  in
    the  same process.  Use it with care, as PL_initialise()  is a costly
    function.   Unix  users should consider  using exec() (available  as
    part of the clib package,).


void PPLL__cclleeaannuupp__ffoorrkk()
    Close  file  descriptors associated  to  Prolog streams  except  for
    0,1  and 2.   Stop intervaltimer  that may be  running on behalf  of
    profile/1.   The  call is  intended to be  used in combination  with
    fork():

        if ( (pid=fork()) == 0 )
        { PL_cleanup_fork();
          <some exec variation>
        }

    The  call behaves the same on  Windows, though there is probably  no
    meaningful application.


int PPLL__hhaalltt(_i_n_t _s_t_a_t_u_s)
    Cleanup  the Prolog environment using  PL_cleanup() and calls  exit()
    with  the status argument.  As  PL_cleanup() can only be  called from
    the  main  thread,  this function  returns  FALSE when  called  from
    another thread as the main one.


99..66..2200..11 TThhrreeaaddiinngg,, SSiiggnnaallss aanndd eemmbbeeddddeedd PPrroolloogg

This section  applies to  Unix-based environments that  have signals  or
multi-threading.   The Windows version  is compiled for  multi-threading
and Windows lacks proper signals.

We  can distinguish  two classes  of embedded  executables.   There  are
small C/C++-programs  that act  as an interfacing  layer around  Prolog.
Most  of  these  programs  can  be  replaced  using  the  normal  Prolog
executable extended with  a dynamically loaded foreign extension and  in
most cases  this is  the preferred  route.   In other  cases, Prolog  is
embedded in a complex application that---like  Prolog---wants to control
the process  environment.   A good  example is Java.   Embedding  Prolog
is generally  the only  way to  get these environments  together in  one
process image.   Java applications however are by  nature multi-threaded
and appear to do signal-handling (software interrupts).

To  make  Prolog  operate smoothly  in  such  environments  it  must  be
told not  to alter  the process  environment.   This is  partly done  at
build-time and  partly execution time.   At  build-time we must  specify
the  use of  software stack-overflow  rather then  the default  hardware
checks.  This is done using

sh configure --disable-segv-handling

The resulting  Prolog executable  is about  10% slower  than the  normal
executable,  but  behaves much  more  reliable in  complicated  embedded
situations.  In addition, as the process  no longer handles segmentation
violations, debugging foreign code linked to it is much easier.

At runtime,  it is advised to pass  the flag -nosignals, which  inhibits
all default signal handling.  This has a few consequences though:

  o It  is  no  longer  possible  to break  into  the  tracer  using  an
    interrupt signal (Control-C).

  o SIGPIPE is normally set  to be ignored.  Prolog uses return-codes to
    diagnose  broken pipes.  Depending on the situation one  should take
    appropriate action if Prolog streams are connected to pipes.

  o Fatal  errors normally cause Prolog to call PL_cleanup()  and exit().
    It  is advised to call PL_cleanup() as part of  the exit-procedure of
    your application.


99..77 LLiinnkkiinngg eemmbbeeddddeedd aapppplliiccaattiioonnss uussiinngg pplllldd

The  utility program  plld (Win32:   plld.exe)  may be  used  to link  a
combination of C-files  and Prolog files into a stand-alone  executable.
plld automates most of what is described in the previous sections.

In the normal  usage, a copy is  made of the default embedding  template
\ldots/pl/include/stub.c.    The  main()  routine is  modified  to  suit
your  application.    PL_initialise()  mmuusstt  be passed  the  program-name
(_a_r_g_v_[_0_])  (Win32:    the  executing  program  can   be  obtained  using
GetModuleFileName()).   The other  elements of  the command-line may  be
modified.  Next, plld is typically invoked as:

plld -o output stubfile.c [other-c-or-o-files] [plfiles]

plld  will first  split the  options into  various groups  for both  the
C-compiler and the Prolog  compiler.  Next, it will add  various default
options to the  C-compiler and call it  to create an executable  holding
the  user's C-code  and the  Prolog kernel.    Then,  it  will call  the
SWI-Prolog compiler  to create a  saved state  from the provided  Prolog
files  and finally,  it  will attach  this saved  state to  the  created
emulator to create the requested executable.

Below, it  is described how the options  are split and which  additional
options are passed.

--hheellpp
    Print brief synopsis.

--ppll _p_r_o_l_o_g
    Select  the prolog to use.   This prolog  is used for two  purposes:
    get  the home-directory as well  as the compiler/linker options  and
    create a saved state of the Prolog code.

--lldd _l_i_n_k_e_r
    Linker  used to  link the raw  executable.   Default is  to use  the
    C-compiler (Win32:  link.exe).

--cccc _C_-_c_o_m_p_i_l_e_r
    Compiler  for .c files  found on the command-line.   Default is  the
    compiler  used to  build  SWI-Prolog accessible  through the  Prolog
    flag c_cc (Win32:  cl.exe)..

--cc++++ _C_+_+_-_c_o_m_p_i_l_e_r
    Compiler  for C++ sources (extensions  .cpp, .cxx, .cc or .C)  files
    found on the command-line.   Default is c++ or g++ if the C-compiler
    is gcc) (Win32:  cl.exe).

--nnoossttaattee
    Just  relink  the  kernel,  do  not  add  any  Prolog  code  to  the
    new  kernel.     This  is  used  to  create  a  new  kernel  holding
    additional  foreign predicates on machines  that do not support  the
    shared-library  (DLL) interface, or if building the state  cannot be
    handled  by the default procedure used by plld.  In the  latter case
    the  state is created  separately and appended  to the kernel  using
    cat <_k_e_r_n_e_l> <_s_t_a_t_e> > <_o_u_t>(Win32:  copy /b <_k_e_r_n_e_l>+<_s_t_a_t_e> <_o_u_t>)

--sshhaarreedd
    Link  C, C++ or object files into a shared object (DLL) that  can be
    loaded  by the  load_foreign_library/1predicate.    If used with  -c
    it  sets the proper  options to compile  a C or  C++ file ready  for
    linking into a shared object

--ddllll
    _W_i_n_d_o_w_s  _o_n_l_y.     Embed  SWI-Prolog  into  a  DLL  rather  than  an
    executable.

--cc
    Compile  C  or C++  source-files  into object  files.    This  turns
    plld  into a  replacement for  the C  or C++  compiler where  proper
    options  such as the  location of the  include directory are  passed
    automatically to the compiler.

--EE
    Invoke the C preprocessor.   Used to make plld a replacement for the
    C or C++ compiler.

--ppll--ooppttiioonnss _,_._._.
    Additional  options passed to Prolog when creating the  saved state.
    The  first character  immediately  following pl-options  is used  as
    separator  and  translated to  spaces when  the  argument is  built.
    Example:  -pl-options,-F,xpce  passed -F xpce as additional flags to
    Prolog.

--lldd--ooppttiioonnss _,_._._.
    Passes options to the linker, similar to -pl-options.

--cccc--ooppttiioonnss _,_._._.
    Passes options to the C/C++ compiler, similar to -pl-options.

--vv
    Select  verbose operation,  showing the  various programs and  their
    options.

--oo _o_u_t_f_i_l_e
    Reserved to specify the final output file.

--ll_l_i_b_r_a_r_y
    Specifies  a library for the C-compiler.   By default, -lpl  (Win32:
    libpl.lib) and the libraries needed by the Prolog kernel are given.

--LL_l_i_b_r_a_r_y_-_d_i_r_e_c_t_o_r_y
    Specifies  a  library directory  for  the C-compiler.    By  default
    the  directory  containing  the  Prolog C-library  for  the  current
    architecture is passed.

-g | -I_i_n_c_l_u_d_e_-_d_i_r_e_c_t_o_r_y | -D_d_e_f_i_n_i_t_i_o_n
    These  options  are passed  to  the C-compiler.    By  default,  the
    include directory containing SWI-Prolog.h  is passed.  plld adds two
    additional * -Ddef flags:

    --DD____SWI_PROLOG__
         Indicates the code is to be connected to SWI-Prolog.

    --DD____SWI_EMBEDDED__
         Indicates the creation of an embedded program.

 _*_._o | _*_._c | _*_._C | _*_._c_x_x | _*_._c_p_p
    Passed as input files to the C-compiler

 _*_._p_l |_*_._q_l_f
    Passed  as  input  files  to  the  Prolog  compiler  to  create  the
    saved-state.

 *
    I.e.  all other options.  These are passed as linker options  to the
    C-compiler.


99..77..11 AA ssiimmppllee eexxaammppllee

The  following is  a very  simple example  going through  all the  steps
outlined above.   It  provides an arithmetic expression  evaluator.   We
will call  the application calc  and define it in  the files calc.c  and
calc.pl.  The Prolog file is simple:

calc(Atom) :-
        term_to_atom(Expr, Atom),
        A is Expr,
        write(A),
        nl.

The  C-part  of   the  application  parses  the  command-line   options,
initialises the  Prolog engine, locates  the calc/1 predicate and  calls
it.  The coder is in figure 9.5.

#include <stdio.h>
#include <SWI-Prolog.h>

#define MAXLINE 1024

int
main(int argc, char **argv)
{ char expression[MAXLINE];
  char *e = expression;
  char *program = argv[0];
  char *plav[2];
  int n;

  /* combine all the arguments in a single string */

  for(n=1; n<argc; n++)
  { if ( n != 1 )
      *e++ = ' ';
    strcpy(e, argv[n]);
    e += strlen(e);

  }

  /* make the argument vector for Prolog */

  plav[0] = program;
  plav[1] = NULL;

  /* initialise Prolog */

  if ( !PL_initialise(1, plav) )
    PL_halt(1);

  /* Lookup calc/1 and make the arguments and call */

  { predicate_t pred = PL_predicate("calc", 1, "user");

    term_t h0 = PL_new_term_refs(1);
    int rval;

    PL_put_atom_chars(h0, expression);
    rval = PL_call_predicate(NULL, PL_Q_NORMAL, pred, h0);

    PL_halt(rval ? 0 : 1);
  }

  return 0;
}

             Figure 9.5:  C-source for the calc application

The application is now created using the following command-line:

% plld -o calc calc.c calc.pl

The following indicates the usage of the application:

% calc pi/2
1.5708


99..88 TThhee PPrroolloogg ``hhoommee'' ddiirreeccttoorryy

Executables  embedding SWI-Prolog  should  be able  to find  the  `home'
directory  of  the  development  environment  unless   a  self-contained
saved-state has  been added to  the executable  (see qsave_program/[1,2]
and section 9.7).

If Prolog starts up, it will try to  locate the development environment.
To do so, it will try the following steps until one succeeds.

 1. If the --home=DIR is provided, use this.

 2. If  the environment variable  SWI_HOME_DIRis  defined and points  to
    an existing directory, use this.

 3. If  the  environment variable  SWIPL  is defined  and points  to  an
    existing directory, use this.

 4. Locate  the  primary   executable  or  (Windows  only)  a  component
    (_m_o_d_u_l_e)  thereof  and check  whether the  parent  directory of  the
    directory  holding this file contains the  file swipl.  If so,  this
    file  contains the (relative) path to  the home directory.  If  this
    directory  exists, use this.   This is the normal mechanism  used by
    the binary distribution.

 5. If  the precompiled path exists, use it.  This is only  useful for a
    source installation.

If  all fails  and  there is  no state  attached  to the  executable  or
provided Windows module (see  PL_initialise()), SWI-Prolog gives up.   If
a state is attached, the current working directory is used.

The file_search_path/2 alias swi is set  to point to the home  directory
located.


99..99 EExxaammppllee ooff UUssiinngg tthhee FFoorreeiiggnn IInntteerrffaaccee

Below is an example  showing all stages of the declaration of  a foreign
predicate that transforms atoms possibly holding  uppercase letters into
an atom only holding lower case letters.  Figure  9.6 shows the C-source
file, figure 9.7 illustrates compiling and loading of foreign code.
/*  Include file depends on local installation */

#include <SWI-Prolog.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

foreign_t
pl_lowercase(term_t u, term_t l)
{ char *copy;

  char *s, *q;
  int rval;

  if ( !PL_get_atom_chars(u, &s) )
    return PL_warning("lowercase/2: instantiation fault");
  copy = malloc(strlen(s)+1);

  for( q=copy; *s; q++, s++)
    *q = (isupper(*s) ? tolower(*s) : *s);
  *q = '\0';

  rval = PL_unify_atom_chars(l, copy);
  free(copy);

  return rval;

}

install_t
install()
{ PL_register_foreign("lowercase", 2, pl_lowercase, 0);
}

                   Figure 9.6:  Lowercase source file
% gcc -I/usr/local/lib/pl-\plversion/include -fpic -c lowercase.c

% gcc -shared -o lowercase.so lowercase.o
% pl
Welcome to SWI-Prolog (Version \plversion)
Copyright (c) 1993-1996 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

1 ?- load_foreign_library(lowercase).

Yes
2 ?- lowercase('Hello World!', L).

L = 'hello world!'

Yes

    Figure 9.7:  Compiling the C-source and loading the object file


99..1100 NNootteess oonn UUssiinngg FFoorreeiiggnn CCooddee


99..1100..11 MMeemmoorryy AAllllooccaattiioonn

SWI-Prolog's heap  memory allocation is based  on the malloc(3)  library
routines.     The  stacks  are  allocated  using  mmap()  on  most  Unix
machines and using  VirtualAlloc() on windows.  SWI-Prolog  provides the
functions below  as a  wrapper around  malloc().   Allocation errors  in
these functions  trap SWI-Prolog's  fatal-error handler,  in which  case
PL_malloc() or PL_realloc() do not return.

Portable applications must use  PL_free() to release strings  returned by
PL_get_chars() using the BUF_MALLOC argument.  Portable  applications may
use both PL_malloc() and friends or malloc() and friends but  should not
mix these two sets of functions on the same memory.


void * PPLL__mmaalllloocc(_s_i_z_e___t _b_y_t_e_s)
    Allocate  _b_y_t_e_s of  memory.    On failure  SWI-Prolog's fatal  error
    handler  is  called  and  PL_malloc()  does  not  return.     Memory
    allocated  using these functions must use  PL_realloc() and PL_free()
    rather than realloc() and free().


void * PPLL__rreeaalllloocc(_v_o_i_d _*_m_e_m_, _s_i_z_e___t _s_i_z_e)
    Change  the size of the  allocated chunk, possibly  moving it.   The
    _m_e_m  argument  must  be  obtained  from  a  previous PL_malloc()  or
    PL_realloc() call.


void PPLL__ffrreeee(_v_o_i_d _*_m_e_m)
    Release  memory.  The _m_e_m argument must be obtained from  a previous
    PL_malloc() or PL_realloc() call.


99..1100..22 CCoommppaattiibbiilliittyy bbeettwweeeenn PPrroolloogg vveerrssiioonnss

Great  care  is   taken  to  ensure  binary  compatibility  of   foreign
extensions  between  different   Prolog  versions.     Only  much   less
frequently  used  stream  interface  has  been  responsible  for  binary
incompatibilities.

Source-code that  relies on new  features of  the foreign interface  can
use  the  macro  PLVERSION to  find  the  version  of  SWI-Prolog.h  and
PL_query()  using  the option  PL_QUERY_VERSION  to  find the  version  of
the  attached Prolog  system.   Both  follow the  same numbering  schema
explained with PL_query().


99..1100..33 DDeebbuuggggiinngg aanndd pprrooffiilliinngg ffoorreeiiggnn ccooddee ((vvaallggrriinndd))

This section  is only  relevant for  Unix users  on platforms  supported
by valgrind.   Valgrind is an excellent binary  intrumentation platform.
Unlike  many other  instrumentation platforms,  valgrind  can deal  with
code loaded through dlopen().

The callgrind  tool can  be used  to profile foreign  code loaded  under
SWI-Prolog.   Compile  the foreign library  adding -g  option to gcc  or
plld.  By  setting the environment variable VALGRIND to yes,  SWI-Prolog
will _n_o_t release loaded  shared objects using dlclose().  This  trick is
required to  get source  information on  the loaded library.    Without,
valgrind claims  that the  shared object has  no debugging  information.
Here is the complete sequence using bash as login shell:

% VALGRIND=yes valgrind --tool=callgrind pl <args>
<prolog interaction>
% kcachegrind callgrind.out.<pid>


99..1100..44 NNaammee CCoonnfflliiccttss iinn CC mmoodduulleess

In  the  current  version  of the  system  all  public  C  functions  of
SWI-Prolog are in the symbol table.  This can lead  to name clashes with
foreign code.    Someday I  should write a  program to  strip all  these
symbols from the symbol table  (why does Unix not have that?).   For now
I can only suggest to give your function another name.   You can do this
using the C preprocessor.  If---for example---your  foreign package uses
a function warning(), which happens to exist in SWI-Prolog  as well, the
following macro should fix the problem.

#define warning warning_

Note  that shared  libraries do  not  have this  problem as  the  shared
library loader  will only look  for symbols in  the main executable  for
symbols that are not defined in the library itself.


99..1100..55 CCoommppaattiibbiilliittyy ooff tthhee FFoorreeiiggnn IInntteerrffaaccee

The term-reference  mechanism was first used  by Quintus Prolog  version
3.     SICStus  Prolog version  3  is  strongly  based  on  the  Quintus
interface.  The  described SWI-Prolog interface is similar to  using the
Quintus or SICStus interfaces, defining all  foreign-predicate arguments
of  type  +term.    SWI-Prolog  explicitly uses  type  functor_t,  while
Quintus  and SICStus  uses <_n_a_m_e>  and  <_a_r_i_t_y>.   As  the  names of  the
functions differ  from Prolog to  Prolog, a  simple macro layer  dealing
with the names can also deal with this detail.  For example:

#define QP_put_functor(t, n, a) PL_put_functor(t, PL_new_functor(n, a))

The  PL_unify_*()  functions are  lacking from  the  Quintus and  SICStus
interface.    They can  easily  be emulated  or the  put/unify  approach
should be used to write compatible code.

The PL_open_foreign_frame()/PL_close_foreign_frame() combination  is lacking
from both  other Prologs.   SICStus has  PL_new_term_refs(0), followed  by
PL_reset_term_refs() that allows for discarding term references.

The  Prolog interface  for  the graphical  user interface  package  XPCE
shares about  90% of the code  using a simple  macro layer to deal  with
different naming and calling conventions of the interfaces.


CChhaapptteerr 1100..  GGEENNEERRAATTIINNGG RRUUNNTTIIMMEE AAPPPPLLIICCAATTIIOONNSS

This  chapter  describes  the  features  of  SWI-Prolog  for  delivering
applications that can run without the development version  of the system
installed.

A SWI-Prolog runtime executable is a file consisting of two  parts.  The
first part  is the  _e_m_u_l_a_t_o_r, which is  machine dependent.   The  second
part is the _r_e_s_o_u_r_c_e  _a_r_c_h_i_v_e, which contains the compiled program  in a
machine-independent format,  startup options  and possibly  user-defined
_r_e_s_o_u_r_c_e_s, see resource/3 and open_resource/3.

These two parts  can be connected in various  different ways.  The  most
common way  for distributed runtime applications  is to _c_o_n_c_a_t_e_n_a_t_e  the
two parts.   This can be achieved  using external commands (Unix:   cat,
Windows:   copy), or  using the  stand_alone option  to qsave_program/2.
The  second option  is  to  attach a  startup  script  in front  of  the
resource that  starts the  emulator with the  proper options.   This  is
the default  under Unix.   Finally,  an emulator  can be told  to use  a
specified resource file using the -x command-line switch.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e_, _+_L_i_s_t_O_f_O_p_t_i_o_n_s))
    Saves  the current  state of  the program  to the  file _F_i_l_e.    The
    result   is  a  resource  archive  containing  a   saved-state  that
    expresses  all  Prolog   data  from  the  running  program  and  all
    user-defined  resources.   Depending on the stand_alone option,  the
    resource is headed by the emulator, a Unix shell-script or nothing.

    _L_i_s_t_O_f_O_p_t_i_o_n_s  is a  list of  <_K_e_y>=<_V_a_l_u_e> or  <_K_e_y>(<_V_a_l_u_e>)  pairs.
    The available keys are described in table 10.1.
_________________________________________________________________________
|__KKeeyy________________||OOppttiioonn__||________TTyyppee____________||DDeessccrriippttiioonn__________________________________________________||
|| local      | --LL   ||    K-bytes    |Size (Limit) of local stack         |
| global     | --GG   ||    K-bytes    |Size (Limit) of global stack        |
| trail      | --TT   ||    K-bytes    |Size (Limit) of trail stack         |

| argument   | --AA   ||    K-bytes    |Size (Limit) of argument stack      |
| goal       | --gg   ||     atom      |Initialisation goal                 |
| toplevel   | --tt   ||     atom      |Prolog top-level goal               |
|_init_file___|--ff___||_____atom______|Personal_initialisation_file________||||||
| class      |      |     atom      |If  runtime,  only  read  resources |
|            |      |               |from  the  state  (default).     If |

|            |      |               |kernel,  lock  all   predicates  as |
|            |      |               |system predicates  If  development, |
|            |      |               |save  the   predicates   in   their |
|            |      |               |current  state  and  keep   reading |
|            |      |               |resources  from  their  source  (if |
|            |      |               |present).  See also resource/3.     |
| autoload   |      |     bool      |If true, run autoload/0 first       |
| map        |      |     file      |File to write info on dump          |
| op         |      | save/standard |Save operator declarations?         |

| stand_alone |     |     bool      |Include the emulator in the state   |
| emulator   |      |     file      |Emulator attached  to  the  (stand- |
|            |      |               |alone) executable.  Default  is the |
|____________|______|_______________|running_emulator.___________________|

          Table 10.1:  <_K_e_y> = <_V_a_l_u_e> pairs for qsave_program/2

    Before   writing  the  data   to  file,  qsave_program/2  will   run
    autoload/0  to all  required  autoloading the  system can  discover.
    See autoload/0.

    Provided  the  application  does  not  require  any  of  the  Prolog
    libraries  to  be  loaded  at  runtime,   the  only  file  from  the
    SWI-Prolog development  environment required is the emulator itself.
    The  emulator may  be built in  two flavours.   The  default is  the
    _d_e_v_e_l_o_p_m_e_n_t  _e_m_u_l_a_t_o_r.  The  _r_u_n_t_i_m_e _e_m_u_l_a_t_o_r is similar, but  lacks
    the tracer.

    If  the option  stand_alone(true) is  present, the  emulator is  the
    first  part of the state.   If the emulator is started it  will test
    whether  a  boot-file (state)  is attached  to  the emulator  itself
    and  load this state.   Provided  the application has all  libraries
    loaded,  the resulting executable  is completely independent of  the
    runtime environment or location where it was build.

    See also section 2.10.2.4.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e))
    Equivalent to qsave_program(File, []).


aauuttoollooaadd
    Check  the current Prolog program  for predicates that are  referred
    to,  are  undefined and  have a  definition in  the Prolog  library.
    Load the appropriate libraries.

    This  predicate is used  by qsave_program/[1,2] to ensure the  saved
    state  will not  depend  on one  of the  libraries.   The  predicate
    autoload/0  will find all ddiirreecctt references to predicates.   It does
    not  find predicates referenced via meta-predicates.   The predicate
    log/2  is  defined  in the  library(quintus)  to provide  a  quintus
    compatible means to compute  the natural logarithm of a number.  The
    following program will  behave correctly if its state is executed in
    an environment where the library(quintus) is not available:

    logtable(From, To) :-
            From > To, !.
    logtable(From, To) :-
            log(From, Value),
            format('~d~t~8|~2f~n', [From, Value]),
            F is From + 1,
            logtable(F, To).

    However,  the following implementation  refers to log/2 through  the
    meta-predicate  maplist/3.   Autoload will not  be able to find  the
    reference.   This problem may be fixed either by loading  the module
    library(quintus)  explicitly or  use  require/1 to  tell the  system
    that the predicate log/2 is required by this module.

    logtable(From, To) :-
            findall(X, between(From, To, X), Xlist),
            maplist(log, Xlist, SineList),
            write_table(Xlist, SineList).

    write_table([], []).
    write_table([I|IT], [V|VT]) :-
            format('~d~t~8|~2f~n', [I, V]),
            write_table(IT, VT).


vvoollaattiillee _+_N_a_m_e_/_A_r_i_t_y_, _._._.
    Declare  that  the clauses  of specified  predicates  should nnoott  be
    saved to the program.   The volatile declaration is normally used to
    avoid  that the  clauses of dynamic  predicates that represent  data
    for the current session is saved in the state file.


1100..11 LLiimmiittaattiioonnss ooff qqssaavvee__pprrooggrraamm

There  are  three  areas  that  require  special  attention  when  using
qsave_program/[1,2].

  o If  the  program  is an  embedded  Prolog  application or  uses  the
    foreign  language interface,  care has  to be taken  to restore  the
    appropriate foreign context.  See section 10.2 for details.

  o If  the program uses directives (:- goal. lines) that  perform other
    actions then  setting predicate attributes (dynamic, volatile, etc.)
    or  loading files  (consult,  etc.), the  directive may  need to  be
    prefixed with initialization/1.

  o Database  references as returned by clause/3, recorded/3, etc.   are
    not preserved and may thus not be part of the database when saved.


1100..22 RRuunnttiimmeess aanndd FFoorreeiiggnn CCooddee

Some  applications may  need  to  use the  foreign  language  interface.
Object code is  by definition machine-dependent and thus cannot  be part
of the saved program file.

To complicate the matter even further there are various  ways of loading
foreign code:

  o _U_s_i_n_g _t_h_e _l_i_b_r_a_r_y_(_s_h_l_i_b_) _p_r_e_d_i_c_a_t_e_s
    This  is the preferred way of dealing  with foreign code.   It loads
    quickly and ensures  an acceptable level of independence between the
    versions  of the emulator and the foreign code loaded.  It  works on
    Unix  machines supporting shared libraries and library  functions to
    load  them.  Most  modern Unixes, as  well as Win32 (Windows  95/NT)
    satisfy this constraint.

  o _S_t_a_t_i_c _l_i_n_k_i_n_g
    This  mechanism works on  all machines,  but generally requires  the
    same  C-compiler and linker to be  used for the external code as  is
    used to build SWI-Prolog itself.

To make  a runtime  executable that  can run on  multiple platforms  one
must make runtime  checks to find the correct  way of linking.   Suppose
we have a  source-file myextension.c defining the installation  function
install().

If this file  is compiled into a  shared library, load_foreign_library/1
will load this library and call the installation  function to initialise
the  foreign code.    If it  is  loaded as  a static  extension,  define
install() as the predicate install/0:

static foreign_t
pl_install()
{ install();

  PL_succeed;
}

PL_extension PL_extensions [] =
{
/*{ "name",     arity,  function,       PL_FA_<flags> },*/

  { "install",  0,      pl_install,     0 },
  { NULL,       0,      NULL,           0 }     /* terminating line */
};

Now, use the following Prolog code to load the foreign library:

load_foreign_extensions :-
        current_predicate(install, install), !, % static loaded
        install.
load_foreign_extensions :-                      % shared library
        load_foreign_library(foreign(myextension)).

:- initialization load_foreign_extensions.

The path  alias foreign  is defined by  file_search_path/2.   By  default
it  searches  the  directories <_h_o_m_e>/lib/<_a_r_c_h> and  <_h_o_m_e>/lib.     The
application can specify additional rules for file_search_path/2.


1100..33 UUssiinngg pprrooggrraamm rreessoouurrcceess

A  _r_e_s_o_u_r_c_e is  very  similar to  a  file.    Resources however  can  be
represented in two different formats:  on files, as well  as part of the
resource _a_r_c_h_i_v_e of a saved-state (see qsave_program/2).

A resource has a _n_a_m_e  and a _c_l_a_s_s.  The _s_o_u_r_c_e data of the  resource is
a file.   Resources are declared by declaring the  predicate resource/3.
They are accessed using the predicate open_resource/3.

Before  going into  details,  let  us start  with  an  example.    Short
texts can  easily be  expressed in Prolog  source code,  but long  texts
are cumbersome.   Assume our application  defines a command `help'  that
prints a  helptext to the screen.   We put  the content of the  helptext
into a  file called help.txt.   The following  code implements our  help
command such that help.txt is incorporated into the runtime executable.

resource(help, text, 'help.txt').

help :-
        open_resource(help, text, In),
        call_cleanup(copy_stream_data(In, user_output),
                     close(In)).

The predicate  help/0 opens  the resource  as a Prolog  stream.   If  we
are executing this from the development environment,  this will actually
return a  stream to the file  help.txt itself.   When executed from  the
saved-state, the stream will actually be a stream  opened on the program
resource file, taking care of the offset and length of the resource.


1100..33..11 PPrreeddiiccaatteess DDeeffiinniittiioonnss


rreessoouurrccee((_+_N_a_m_e_, _+_C_l_a_s_s_, _+_F_i_l_e_S_p_e_c))
    This  predicate is  defined  as a  dynamic predicate  in the  module
    user.   Clauses for it may  be defined in any module,  including the
    user  module.   _N_a_m_e  is the  name of  the resource  (an atom).    A
    resource  name may contain any character, except for $ and  :, which
    are  reserved for  internal usage by  the resource  library.   _C_l_a_s_s
    describes  the  what  kind of  object  is  stored in  the  resource.
    In  the  current implementation,  it  is just  an  atom.    _F_i_l_e_S_p_e_c
    is  a file  specification that  may exploit  file_search_path/2 (see
    absolute_file_name/2).

    Normally,  resources are  defined as unit  clauses (facts), but  the
    definition  of this  predicate also allows  for rules.   For  proper
    generation  of the  saved state,  it must be  possible to  enumerate
    the  available  resources by  calling this  predicate  with all  its
    arguments unbound.

    Dynamic  rules are useful to turn  all files in a certain  directory
    into  resources, without specifying a resources for each file.   For
    example,  assume the file_search_path/2icons refers to  the resource
    directory  containing icon-files.   The  following definition  makes
    all these images available as resources:

    resource(Name, image, icons(XpmName)) :-
            atom(Name), !,
            file_name_extension(Name, xpm, XpmName).
    resource(Name, image, XpmFile) :-
            var(Name),
            absolute_file_name(icons(.), [type(directory)], Dir)
            concat(Dir, '/*.xpm', Pattern),
            expand_file_name(Pattern, XpmFiles),
            member(XpmFile, XpmFiles).


ooppeenn__rreessoouurrccee((_+_N_a_m_e_, _?_C_l_a_s_s_, _-_S_t_r_e_a_m))
    Opens the resource specified  by _N_a_m_e and _C_l_a_s_s.  If the latter is a
    variable,  it will  be unified to  the class  of the first  resource
    found that has the  specified _N_a_m_e.  If successful, _S_t_r_e_a_m becomes a
    handle to a  binary input stream, providing access to the content of
    the resource.

    The  predicate  open_resource/3  first  checks  resource/3.     When
    successful   it  will  open   the  returned  resource   source-file.
    Otherwise  it will  look in the  programs resource  database.   When
    creating  a  saved-state,  the system  normally saves  the  resource
    contents  into the resource archive, but does not save  the resource
    clauses.

    This   way,  the  development   environment  uses  the  files   (and
    modifications   to   the   resource/3  declarations   and/or   files
    containing  resource   info  thus  immediately  affect  the  running
    environment,  while the runtime  system quickly accesses the  system
    resources.


1100..33..22 TThhee plrc pprrooggrraamm

The  utility program  plrc can  be used  to examine  and manipulate  the
contents of  a SWI-Prolog resource  file.  The  options are inspired  by
the Unix ar program.  The basic command is:

% plrc option resource-file member ...

The options are described below.

ll
    List contents of the archive.

xx
    Extract  named (or  all)  members of  the archive  into the  current
    directory.

aa
    Add  files  to the  archive.    If the  archive already  contains  a
    member  with the  same name,  the contents  is replaced.    Anywhere
    in   the  sequence  of  members,   the  options  --class=_c_l_a_s_s   and
    --encoding=_e_n_c_o_d_i_n_g may appear.   They affect the class and encoding
    of subsequent files.  The initial class is data and encoding none.

dd
    Delete named members from the archive.

This command is also described in the pl(1) Unix manual page.


1100..44 FFiinnddiinngg AApppplliiccaattiioonn ffiilleess

If your application  uses files that are  not part of the saved  program
such as database  files, configuration files, etc., the  runtime version
has to be able to  locate these files.  The file_search_path/2 mechanism
in combination with  the -palias command-line argument is the  preferred
way to  locate runtime  files.   The first  step is to  define an  alias
for the  top-level directory  of your application.    We will call  this
directory gnatdir in our examples.

A  good  place  for storing  data  associated  with  SWI-Prolog  runtime
systems is  below the emulator's  home-directory.   swi is a  predefined
alias for this directory.  The following is  a useful default definition
for the search path.

user:file_search_path(gnatdir, swi(gnat)).

The  application  should  locate   all  files  using  absolute_file_name.
Suppose   gnatdir   contains   a  file   config.pl   to   define   local
configuration.  Then use the code below to load this file:

configure_gnat :-
        (   absolute_file_name(gnatdir('config.pl'), ConfigFile)
            ->  consult(ConfigFile)
            ;   format(user_error, 'gnat: Cannot locate config.pl~n'),
            halt(1)
            ).


1100..44..11 PPaassssiinngg aa ppaatthh ttoo tthhee aapppplliiccaattiioonn

Suppose   the  system   administrator  has   installed  the   SWI-Prolog
runtime  environment  in  /usr/local/lib/rt-pl-3.2.0.     A  user  wants
to  install  gnat,   but  gnat  will  look  for  its   configuration  in
/usr/local/lib/rt-pl-3.2.0/gnat where the user cannot write.

The user  decides to install the  gnat runtime files in  /users/bob/lib/
gnat.  For one-time  usage, the user may decide to start gnat  using the
command:

% gnat -p gnatdir=/users/bob/lib/gnat


1100..55 TThhee RRuunnttiimmee EEnnvviirroonnmmeenntt


1100..55..11 TThhee RRuunnttiimmee EEmmuullaattoorr

The sources  may be  used to built  two versions  of the emulator.    By
default,  the _d_e_v_e_l_o_p_m_e_n_t _e_m_u_l_a_t_o_r  is built.    This emulator  contains
all features  for interactive development  of Prolog  applications.   If
the system is  configured using --enable-runtime, make(1) will  create a
_r_u_n_t_i_m_e _v_e_r_s_i_o_n  of the emulator.   This emulator  is equivalent to  the
development version, except for the following features:

  o _N_o _i_n_p_u_t _e_d_i_t_i_n_g
    The  GNU library -lreadline  that provides EMACS compatible  editing
    of input lines will not be linked to the system.

  o _N_o _t_r_a_c_e_r
    The  tracer and  all its options  are removed,  making the system  a
    little faster too.

  o _N_o _p_r_o_f_i_l_e_r
    profile/3 and friends are  not supported.  This saves some space and
    provides better performance.

  o _N_o _i_n_t_e_r_r_u_p_t
    Keyboard  interrupt (Control-C  normally)  is not  rebound and  will
    normally terminate the application.

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_r_u_n_t_i_m_e_, _t_r_u_e_) _s_u_c_c_e_e_d_s
    This  may  be used  to verify  your application  is  running in  the
    runtime environment rather than the development environment.

  o _c_l_a_u_s_e_/_[_2_,_3
    do not work  on static predicates] This Prolog flag inhibits listing
    your program.  It is only a very limited protection however.

The  following  fragment   is  an  example  for  building  the   runtime
environment in  \env{HOME}/lib/rt-pl-3.2.0.   If  possible, the  shared-
library interface should  be configured to ensure  it can serve a  large
number of applications.

% cd pl-3.2.0
% mkdir runtime
% cd runtime
% ../src/configure --enable-runtime --prefix=$HOME
% make
% make rt-install

The  runtime directory  contains  the components  listed  below.    This
directory may be tar'ed and shipped with your application.

           __________________________________________________
           |_README.RT____|Info_on_the_runtime_environment___|
           |_bin/<_a_r_c_h>/pl|The_emulator_itself_______________|

           |_man/pl.1_____|Manual_page_for_pl________________|
           |_swipl________|pointer_to_the_home_directory_(.)_|
           | lib/         |directory for shared libraries    |
           |_lib/<_a_r_c_h>/__|machine-specific_shared_libraries_|


CChhaapptteerr 1111..  TTHHEE SSWWII--PPRROOLLOOGG LLIIBBRRAARRYY

This chapter documents  the SWI-Prolog library.  As  SWI-Prolog provides
auto-loading,  there is  little  difference between  library  predicates
and built-in predicates.   Part of  the library is therefore  documented
in the  rest of  the manual.   Library  predicates differ from  built-in
predicates in the following ways.

  o User-definition  of a  built-in leads to  a permission-error,  while
    using the name of a library predicate is allowed.

  o If  autoloading is disabled explicitely or because  trapping unknown
    predicates  is disabled  (see unknown/2  and current_prolog_flag/2),
    library predicates must be loaded explicitely.

  o Using  libraries reduce  the  footprint of  applications that  don't
    need them.

    _T_h_e  _d_o_c_u_m_e_n_t_a_t_i_o_n _o_f  _t_h_e _l_i_b_r_a_r_y _i_s  _j_u_s_t _s_t_a_r_t_e_d_.   _M_a_t_e_r_i_a_l
    _f_r_o_m  _t_h_e _s_t_a_n_d_a_r_d _p_a_c_k_a_g_e_s _s_h_o_u_l_d _b_e _m_o_v_e_d _h_e_r_e_, _s_o_m_e _m_a_t_e_r_i_a_l
    _f_r_o_m  _o_t_h_e_r _p_a_r_t_s _o_f _t_h_e _m_a_n_u_a_l _s_h_o_u_l_d _b_e _m_o_v_e_d _t_o_o _a_n_d _v_a_r_i_o_u_s
    _l_i_b_r_a_r_i_e_s _a_r_e _n_o_t _d_o_c_u_m_e_n_t_e_d _a_t _a_l_l_.


1111..11 aaggggrreeggaattee..ppll ---- AAggggrreeggaattiioonn ooppeerraattoorrss oonn bbaacckkttrraacckkaabbllee pprreeddiiccaatteess

    CCoommppaattiibbiilliittyy  Quintus,   SICStus  4.      The  forall/2  is  a
         SWI-Prolog built-in  and term_variables/3 is  a SWI-Prolog
         with a ddiiffffeerreenntt ddeeffiinniittiioonn.

    TToo bbee ddoonnee
         -  Analysing  the  aggregation  template and  compiling  a
         predicate for the list aggregation  can be done at compile
         time.
         -  aggregate_all/3 can  be rewritten  to  run  in constant
         space using non-backtrackable assignment on a term.

This  library provides  aggregating operators  over the  solutions of  a
predicate.  The operations are a generalisation of  the bagof/3, setof/3
and findall/3 built-in  predicates.  The defined aggregation  operations
are counting,  computing the sum, minimum,  maximum, a bag of  solutions
and a set of solutions.   We first give a simple example,  computing the
country with the smallest area:

smallest_country(Name, Area) :-
        aggregate(min(A, N), country(N, A), min(Area, Name)).

There are four aggregation predicates, distinguished on two properties.

aaggggrreeggaattee vvss..  aaggggrreeggaattee__aallll The   aggregate  predicates   use   setof/3
    (aggregate/4)  or bagof/3  (aggregate/3),  dealing with  existential
    qualified  variables  (Var^Goal) and  providing  multiple  solutions
    for  the  remaining free  variables in  Goal.   The  aggregate_all/3
    predicate  uses findall/3, implicitly qualifying all  free variables
    and  providing  exactly  one solution,  while  aggregate_all/4  uses
    sort/2  over solutions and  Distinguish (see below) generated  using
    findall/3.

TThhee DDiissttiinngguuiisshh aarrgguummeenntt  The  versions  with  4  arguments   provide  a
    Distinguish argument that  allow for keeping duplicate bindings of a
    variable  in the result.   For  example, if we  wish to compute  the
    total  population of all  countries we do  not want to lose  results
    because two countries have the same population.  Therefore we use:

    aggregate(sum(P), Name, country(Name, P), Total)

All  aggregation predicates  support  the  following operator  below  in
Template.  In addition, they allow for an  arbitrary named compound term
where each of the  arguments is a term from the  list below.  I.e.   the
term r(min(X),  max(X)) computes  both the minimum  and maximum  binding
for X.

ccoouunntt
    Count number of solutions.  Same as sum(1).

ssuumm((_E_x_p_r))
    Sum of Expr for all solutions.

mmiinn((_E_x_p_r))
    Minimum of Expr for all solutions.

mmiinn((_E_x_p_r_, _W_i_t_n_e_s_s))
    A  term min(Min, Witness), where Min is the minimal version  of Expr
    over  all Solution  and  Witness is  any other  template applied  to
    Solution that produced  Min.  If multiple solutions provide the same
    minimum, Witness corresponds to the first solution.

mmaaxx((_E_x_p_r))
    Maximum of Expr for all solutions.

mmaaxx((_E_x_p_r_, _W_i_t_n_e_s_s))
    As min(Expr, Witness), but producing the maximum result.

sseett((_X))
    An ordered set with all solutions for X.

bbaagg((_X))
    A list of all solutions for X.


1111..11..00..11 AAcckknnoowwlleeddggeemmeennttss

_T_h_e  _d_e_v_e_l_o_p_m_e_n_t   _o_f  _t_h_i_s  _l_i_b_r_a_r_y   _w_a_s  _s_p_o_n_s_o_r_e_d  _b_y   _S_e_c_u_r_i_t_E_a_s_e_,
http://www.securitease.com


aaggggrreeggaattee((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_R_e_s_u_l_t))                           _[_n_o_n_d_e_t_]
    Aggregate  bindings in _G_o_a_l according to _T_e_m_p_l_a_t_e.   The aggregate/3
    version performs bagof/3 on _G_o_a_l.


aaggggrreeggaattee((_+_T_e_m_p_l_a_t_e_, _+_D_i_s_c_r_i_m_i_n_a_t_o_r_, _:_G_o_a_l_, _-_R_e_s_u_l_t))           _[_n_o_n_d_e_t_]
    Aggregate  bindings in _G_o_a_l according to _T_e_m_p_l_a_t_e.   The aggregate/3
    version performs setof/3 on _G_o_a_l.


aaggggrreeggaattee__aallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_R_e_s_u_l_t))                       _[_s_e_m_i_d_e_t_]
    Aggregate   bindings  in   _G_o_a_l  according   to  _T_e_m_p_l_a_t_e.       The
    aggregate_all/3 version performs findall/3 on _G_o_a_l.


aaggggrreeggaattee__aallll((_+_T_e_m_p_l_a_t_e_, _+_D_i_s_c_r_i_m_i_n_a_t_o_r_, _:_G_o_a_l_, _-_R_e_s_u_l_t))       _[_s_e_m_i_d_e_t_]
    Aggregate   bindings  in   _G_o_a_l  according   to  _T_e_m_p_l_a_t_e.       The
    aggregate_all/3  version performs  findall/3 followed  by sort/2  on
    _G_o_a_l.


ffoorreeaacchh((_:_G_e_n_e_r_a_t_o_r_, _:_G_o_a_l))
    True  if the  conjunction of  instances of _G_o_a_l  using the  bindings
    from   _G_e_n_e_r_a_t_o_r  is  true.      Unlike  forall/2,   which  runs   a
    failure-driven   loop  that  proves   _G_o_a_l  for  each  solution   of
    _G_e_n_e_r_a_t_o_r,  foreach  creates a  conjunction.    Each member  of  the
    conjunction  is  a  copy of  _G_o_a_l,  where  the variables  it  shares
    with  _G_e_n_e_r_a_t_o_r are  filled with the  values from the  corresponding
    solution.

    The  implementation executes forall/2 if  _G_o_a_l does not contain  any
    variables that are not shared with _G_e_n_e_r_a_t_o_r.

    Here is an example:

    ?- foreach(between(1,4,X), dif(X,Y)), Y = 5.
    Y = 5
    ?- foreach(between(1,4,X), dif(X,Y)), Y = 3.
    No

         bbuugg _G_o_a_l  is copied  repeatetly, which may  cause problems
             if attributed variables are involved.


ffrreeee__vvaarriiaabblleess((_:_G_e_n_e_r_a_t_o_r_, _+_T_e_m_p_l_a_t_e_, _+_V_a_r_L_i_s_t_0_, _-_V_a_r_L_i_s_t))         _[_d_e_t_]
    In  order to  handle variables  properly, we  have to  find all  the
    universally  quantified variables in the  _G_e_n_e_r_a_t_o_r.  All  variables
    as yet unbound are universally quantified, unless

     1.  they occur in the template

     2.  they are bound by X^P, setof, or bagof

    free_variables(_G_e_n_e_r_a_t_o_r,  _T_e_m_p_l_a_t_e, OldList,  NewList)  finds  this
    set, using OldList as an accumulator.

         aauutthhoorr
             - Richard O'Keefe
             - Jan Wielemaker (made some SWI-Prolog enhancements)

         lliicceennssee Public domain (from DEC10 library).

         TToo bbee ddoonnee
             -  Distinguish  between  control-structures  and  data
             terms.
             -   Exploit  our  built-in  term_variables/2  at  some
             places?


1111..22 aappppllyy..ppll ---- AAppppllyy pprreeddiiccaatteess oonn aa lliisstt

    SSeeee aallssoo
         - apply_macros.pl provides compile-time expansion for part
         of this library.
         - http://www.cs.otago.ac.nz/staffpriv/ok/pllib.htm

    TToo bbee ddoonnee
         - Move maplist/N from boot/apply.pl to here.
         - Add include/4, include/5, exclude/4, exclude/5

This  module defines  meta-predicates  that  apply a  predicate  on  all
members of a list.


iinncclluuddee((_:_G_o_a_l_, _+_L_i_s_t_1_, _?_L_i_s_t_2))                                    _[_d_e_t_]
    Filter  elements for  which _G_o_a_l succeed.    True if _L_i_s_t_2  contains
    those elements Xi of _L_i_s_t_1 for which call(_G_o_a_l, Xi) succeeds.

         SSeeee aallssoo Older  versions of SWI-Prolog  had sublist/3 with
             the same arguments and semantics.


eexxcclluuddee((_:_G_o_a_l_, _+_L_i_s_t_1_, _?_L_i_s_t_2))                                    _[_d_e_t_]
    Filter elements for which  _G_o_a_l fails.  True if _L_i_s_t_2 contains those
    elements Xi of _L_i_s_t_1 for which call(_G_o_a_l, Xi) fails.


ppaarrttiittiioonn((_:_P_r_e_d_, _+_L_i_s_t_, _?_I_n_c_l_u_d_e_d_, _?_E_x_c_l_u_d_e_d))                     _[_d_e_t_]
    Filter  elements  of _L_i_s_t  according  to _P_r_e_d.    True  if  _I_n_c_l_u_d_e_d
    contains all elements  for which call(_P_r_e_d, X) succeeds and _E_x_c_l_u_d_e_d
    contains the remaining elements.


ppaarrttiittiioonn((_:_P_r_e_d_, _+_L_i_s_t_, _?_L_e_s_s_, _?_E_q_u_a_l_, _?_G_r_e_a_t_e_r))              _[_s_e_m_i_d_e_t_]
    Filter  list according to _P_r_e_d in three  sets.  For each  element Xi
    of  _L_i_s_t, its  destination is determined  by call(_P_r_e_d, Xi,  Place),
    where  Place must be  unified to one  of <, =  or >.   _P_r_e_d must  be
    deterministic.


1111..33 assoc::  AAssssoocciiaattiioonn lliissttss

      Authors:  _R_i_c_h_a_r_d _A_. _O_'_K_e_e_f_e_, _L_._D_a_m_a_s_, _V_._S_._C_o_s_t_a _a_n_d _M_a_r_k_u_s _T_r_i_s_k_a

Elements of an association  list have 2 components:  A (unique)  _k_e_y and
a _v_a_l_u_e.   Keys should be  ground, values need not  be.  An  association
list can be used  to fetch elements via their keys and to  enumerate its
elements in ascending  order of their keys.   The assoc module uses  AVL
trees to  implement association lists.   This makes inserting,  changing
and fetching a single  element an O(log(N)) (where N denotes  the number
of elements in the list) expected time (and worst-case time) operation.


aassssoocc__ttoo__lliisstt((_+_A_s_s_o_c_, _-_L_i_s_t))
    _L_i_s_t is a  list of Key-Value pairs corresponding to the associations
    in _A_s_s_o_c in ascending order of keys.


aassssoocc__ttoo__kkeeyyss((_+_A_s_s_o_c_, _-_L_i_s_t))
    _L_i_s_t  is a list of Keys  corresponding to the associations in  _A_s_s_o_c
    in ascending order.


aassssoocc__ttoo__vvaalluueess((_+_A_s_s_o_c_, _-_L_i_s_t))
    _L_i_s_t is a  list of Values corresponding to the associations in _A_s_s_o_c
    in ascending order of the keys they are associated to.


eemmppttyy__aassssoocc((_-_A_s_s_o_c))
    _A_s_s_o_c is unified with an empty association list.


ggeenn__aassssoocc((_?_K_e_y_, _+_A_s_s_o_c_, _?_V_a_l_u_e))
    Enumerate  matching elements  of _A_s_s_o_c in  ascending order of  their
    keys via backtracking.


ggeett__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_, _?_V_a_l_u_e))
    _V_a_l_u_e  is the  value  associated with  _K_e_y in  the association  list
    _A_s_s_o_c.


ggeett__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_, _?_O_l_d_, _?_N_e_w_A_s_s_o_c_, _?_N_e_w))
    _N_e_w_A_s_s_o_c  is an association list identical to _A_s_s_o_c except  that the
    value associated with _K_e_y is _N_e_w instead of _O_l_d.


lliisstt__ttoo__aassssoocc((_+_L_i_s_t_, _?_A_s_s_o_c))
    _A_s_s_o_c  is an association list  corresponding to the Key-Value  pairs
    in _L_i_s_t.


mmaapp__aassssoocc((_:_G_o_a_l_, _+_A_s_s_o_c))
    _G_o_a_l_(_V_) is true for every value V in _A_s_s_o_c.


mmaapp__aassssoocc((_:_G_o_a_l_, _+_A_s_s_o_c_I_n_, _?_A_s_s_o_c_O_u_t))
    _A_s_s_o_c_O_u_t is _A_s_s_o_c_I_n  with _G_o_a_l applied to all corresponding pairs of
    values.


mmaaxx__aassssoocc((_+_A_s_s_o_c_, _?_K_e_y_, _?_V_a_l_u_e))
    _K_e_y and _V_a_l_u_e are  key and value of the element with the largest key
    in _A_s_s_o_c.


mmiinn__aassssoocc((_+_A_s_s_o_c_, _?_K_e_y_, _?_V_a_l_u_e))
    _K_e_y  and _V_a_l_u_e are  key and value of  the element with the  smallest
    key in _A_s_s_o_c.


oorrdd__lliisstt__ttoo__aassssoocc((_+_L_i_s_t_, _?_A_s_s_o_c))
    _A_s_s_o_c  is an association list  correpsond to the Key-Value pairs  in
    _L_i_s_t, which must occur in ascending order of their keys.


ppuutt__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_, _+_V_a_l_u_e_, _?_N_e_w_A_s_s_o_c))
    _N_e_w_A_s_s_o_c  is an association list identical to _A_s_s_o_c except  that _K_e_y
    is  associated with _V_a_l_u_e.   This can be  used to insert and  change
    associations.


1111..44 broadcast::  BBrrooaaddccaasstt aanndd rreecceeiivvee eevveenntt nnoottiiffiiccaattiioonnss

The  broadcast  library   was  invented  to  realise  GUI   applications
consisting of  stand-alone components that use  the Prolog database  for
storing  the application  data.    Figure  ????  illustrates the  flow  of
information using this design

The  broadcasting service  provides two  services.    Using the  `shout'
service, an unknown number of agents may listen to  the message and act.
The broadcaster is not (directly) aware of the implications.   Using the
`request' service, listening  agents are asked for an  answer one-by-one
and the  broadcaster is allowed  to reject  answers using normal  Prolog
failure.

Shouting  is  often used  to  inform  about  changes made  to  a  common
database.  Other messages can be ``save yourself'' or ``show this''.

Requesting  is used  to get  information while  the  broadcaster is  not
aware who might  be able to answer the  question.  For example ``who  is
showing X?''.


bbrrooaaddccaasstt((_+_T_e_r_m))
    Broadcast  _T_e_r_m.   There are  no limitations to  _T_e_r_m, though  being
    a  global service,  it is  good practice  to use  a descriptive  and
    unique  principal  functor.     All  associated  goals  are  started
    and  regardless  of their  success  or failure,  broadcast/1  always
    succeeds.  Exceptions are passed.


bbrrooaaddccaasstt__rreeqquueesstt((_+_T_e_r_m))
    Unlike  broadcast/1,  this  predicate stops  if an  associated  goal
    succeeds.    Backtracking  causes it  to  try other  listeners.    A
    broadcast  request is used to fetch information without  knowing the
    identity  of the agent  providing it.   C.f. ``Is there someone  who
    knows the age of John?''  could be asked using

            ...,
            broadcast_request(age_of('John', Age)),

    If there is  an agent (_l_i_s_t_e_n_e_r) that registered an `age-of' service
    and knows about the age of `John' this question will be answered.


lliisstteenn((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Register  a  _l_i_s_t_e_n channel.    Whenever  a term  unifying  _T_e_m_p_l_a_t_e
    is  broadcasted,  call  _G_o_a_l.    The  following  example  traps  all
    broadcasted  messages as a variable unifies  to any message.  It  is
    commonly used to debug usage of the library.

    ?- listen(Term, (writeln(Term),fail)).
    ?- broadcast(hello(world)).
    hello(world)

    Yes


lliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Declare  _L_i_s_t_e_n_e_r as the  owner of  the channel.   Unlike a  channel
    opened  using listen/2,  channels that have  an owner can  terminate
    the  channel.  This  is commonly used if  an object is listening  to
    broadcast  messages.  In the  example below we define a  `name-item'
    displaying  the name of an  identifier represented by the  predicate
    name_of/2.

    :- pce_begin_class(name_item, text_item).

    variable(id,    any,    get, "Id visualised").

    initialise(NI, Id:any) :->
            name_of(Id, Name),
            send_super(NI, initialise, name, Name,
                       message(NI, set_name, @arg1)),
            send(NI, slot, id, Id),
            listen(NI, name_of(Id, Name),
                   send(NI, selection, Name)).

    unlink(NI) :->
            unlisten(NI),
            send_super(NI, unlink).

    set_name(NI, Name:name) :->
            get(NI, id, Id),
            retractall(name_of(Id, _)),
            assert(name_of(Id, Name)),
            broadcast(name_of(Id, Name)).

    :- pce_end_class.


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r))
    Deregister all entries created with listen/3 whose _L_i_s_t_e_n_e_r unify.


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e))
    Deregister  all entries  created  with listen/3  whose _L_i_s_t_e_n_e_r  and
    _T_e_m_p_l_a_t_e unify.


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Deregister  all   entries  created  with  listen/3  whose  _L_i_s_t_e_n_e_r,
    _T_e_m_p_l_a_t_e and _G_o_a_l unify.


lliisstteenniinngg((_?_L_i_s_t_e_n_e_r_, _?_T_e_m_p_l_a_t_e_, _?_G_o_a_l))
    Examine  the  current  listeners.    This  predicate is  useful  for
    debugging purposes.


1111..55 check::  EElleemmeennttaarryy ccoommpplleetteenneessss cchheecckkss

This library defines the predicate check/0 and a few  friends that allow
for a quick-and-dirty cross-referencing.


cchheecckk
    Performs  the three checking passes implemented by list_undefined/0,
    list_autoload/0 and  list_redefined/0.   Please check the  definition
    of these predicates for details.

    The  typical usage  of this  predicate is right  after loading  your
    program  to get a  quick overview on  the completeness and  possible
    conflicts in your program.


lliisstt__uunnddeeffiinneedd
    Scans  the  database for  predicates that  have no  definition.    A
    predicate  is  considered defined  if it  has clauses,  is  declared
    using  dynamic/1 or  multifile/1.   As a  program is compiled  calls
    are  translated to predicates.   If the called predicate is not  yet
    defined  it is created as a predicate without definition.   The same
    happens  with runtime  generated calls.   This  predicate lists  all
    such  undefined predicates  that are referenced  and not defined  in
    the  library.  See also  list_autoload/0.   Below is an example  from
    a  real program  and  an illustration  how to  edit the  referencing
    predicate using edit/1.

    ?- list_undefined.
    Warning: The predicates below are not defined. If these are defined
    Warning: at runtime using assert/1, use :- dynamic Name/Arity.
    Warning:
    Warning: rdf_edit:rdfe_retract/4, which is referenced by
    Warning:         1-st clause of rdf_edit:undo/4
    Warning: rdf_edit:rdfe_retract/3, which is referenced by
    Warning:         1-st clause of rdf_edit:delete_object/1
    Warning:         1-st clause of rdf_edit:delete_subject/1
    Warning:         1-st clause of rdf_edit:delete_predicate/1

    ?- edit(rdf_edit:undo/4).


lliisstt__aauuttoollooaadd
    Lists  all undefined (see  list_undefined/0)  predicates that have  a
    definition  in the library along with the file from which  they will
    be autoloaded when accessed.  See also autoload/0.


lliisstt__rreeddeeffiinneedd
    Lists  predicates that  are  defined in  the global  module user  as
    well  as in a normal  module.  I.e.  predicates for which the  local
    definition overrules the global default definition.


1111..66 clp/clp_distinct::  WWeeaakk aarrcc ccoonnssiisstteenntt ``aallll__ddiissttiinncctt'' ccoonnssttrraaiinntt

                                                  Author:  _M_a_r_k_u_s _T_r_i_s_k_a

The clp/clp_distinct module provides the following constraints:


aallll__ddiissttiinncctt((_+_V_a_r_s))
    The  variables  in _V_a_r_s  are constrained  to  be pairwise  distinct.
    All  variables must  already be assigned  domains (via  vars_in/2 or
    vars_in/3) when this constraint is posted.


vvaarrss__iinn((_+_V_a_r_s_, _+_D_o_m_a_i_n))
    Where  _V_a_r_s  is  a  list  of  variables and  _D_o_m_a_i_n  is  a  list  of
    non-negative  integers.  Each variable of _V_a_r_s is constrained  to be
    in _D_o_m_a_i_n.


vvaarrss__iinn((_+_V_a_r_s_, _+_F_r_o_m_, _+_T_o))
    Where  _V_a_r_s  is  a list  of  variables,  and 0<= From<= To.    Each
    variable  in _V_a_r_s  is  constrained to  be in  the discrete  interval
    [From,To].


1111..66..11 EExxaammppllee 11

The all_distinct/1 constraint can detect various inconsistencies:

?- vars_in([X,Y,Z], [1,2]), all_distinct([X,Y,Z]).

No


1111..66..22 EExxaammppllee 22

In this example, 3 is assigned to Z without labeling any variables:

?- vars_in([X,Y], [1,2]), vars_in([Z], [1,2,3]), all_distinct([X,Y,Z]).

X = _G180{1-2}
Y = _G183{1-2}
Z = 3 ;


1111..66..33 EExxaammppllee 33

The clp_distinct module can be used  in conjunction with clp/bounds.  All
relevant variables must still be assigned domains via one of the _v_a_r_s___i_n
predicates before all_distinct/1 can be posted:

:- use_module(library(bounds)).
:- use_module(library(clp_distinct)).

?- [X,Y] in 1..2, vars_in([X,Y], [1,2]), all_distinct([X,Y]), label([X,Y]).

X = 1
Y = 2 ;

X = 2
Y = 1 ;


1111..77 ccllppffdd..ppll ---- CCoonnssttrraaiinntt LLooggiicc PPrrooggrraammmmiinngg oovveerr FFiinniittee DDoommaaiinnss

    aauutthhoorr  Markus Triska

Constraint  programming  is  a  declarative  formalism   that  lets  you
describe conditions  a solution  must satisfy.    This library  provides
CLP(FD),  Constraint Logic  Programming over  Finite Domains.    It  can
be  used to  model  and solve  various  combinatorial problems  such  as
planning, scheduling and allocation tasks.

Most predicates  of this  library are finite  domain _c_o_n_s_t_r_a_i_n_t_s,  which
are relations over  integers.  They generalise arithmetic  evaluation of
integer expressions in  that propagation can proceed in all  directions.
This  library  also  provides  _e_n_u_m_e_r_a_t_i_o_n  _p_r_e_d_i_c_a_t_e_s,  which  let  you
systematically  search for  solutions on  variables  whose domains  have
become finite.  A finite domain _e_x_p_r_e_s_s_i_o_n is one of:

    ________________________________________________
    | an integer     |Given value                   |

    | a variable     |Unknown value                 |
    | -Expr          |Unary minus                   |
    | Expr + Expr    |Addition                      |
    | Expr * Expr    |Multiplication                |
    | Expr - Expr    |Subtraction                   |
    | min(Expr,Expr) |Minimum of two expressions    |
    | max(Expr,Expr) |Maximum of two expressions    |

    | Expr mod Expr  |Remainder of integer division |
    | abs(Expr)      |Absolute value                |
    |_Expr_/_Expr____|Integer_division______________|

The most important finite domain constraints are:

    ___________________________________________________________

    | Expr1 #>= Expr2 |Expr1 is larger than or equal to Expr2  |
    | Expr1 #=<  Expr2 |Expr1 is smaller than or equal to Expr2 |
    | Expr1 #= Expr2   |Expr1 equals Expr2                      |
    | Expr1 #\= Expr2  |Expr1 is not equal to Expr2             |
    | Expr1 #>  Expr2  |Expr1 is strictly larger than Expr2     |
    |_Expr1_#<__Expr2__|Expr1_is_strictly_smaller_than_Expr2___ |

The constraints in/2, #=/2, #\=/2,  #</2, #>/2, #=</2, and #>=/2  can be
_r_e_i_f_i_e_d, which means  reflecting their truth values into  Boolean values
represented by  the integers  0 and 1.    Let P and  Q denote  reifiable
constraints or Boolean variables, then:

    _____________________________________________
    | #\ Q       |True iff Q is false             |
    | P #\/ Q    |True iff either P or Q          |
    | P #/\ Q    |True iff both P and Q           |
    | P #<==>  Q |True iff P and Q are equivalent |
    | P #==>  Q  |True iff P implies Q            |

    |_P_#<==_Q___|True_iff_Q_implies_P___________ |

The constraints  of this table  are reifiable  as well.   If a  variable
occurs  at the  place  of a  constraint that  is  being reified,  it  is
implicitly constrained to  the Boolean values 0  and 1.  Therefore,  the
following queries all fail:  ?- #\ 2., ?- #\ #\ 2.  etc.

A common usage of this library is to first  post the desired constraints
among the variables of  a model, and then to use  enumeration predicates
to search  for solutions.   As an example  of a constraint  satisfaction
problem,  consider the  cryptoarithmetic  puzzle SEND  + MORE  =  MONEY,
where different letters  denote distinct integers between  0 and 9.   It
can be modeled in CLP(FD) as follows:

:- use_module(library(clpfd)).

puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-
        Vars = [S,E,N,D,M,O,R,Y],
        Vars ins 0..9,
        all_different(Vars),
                  S*1000 + E*100 + N*10 + D +
                  M*1000 + O*100 + R*10 + E #=
        M*10000 + O*1000 + N*100 + E*10 + Y,
        M #\= 0, S #\= 0.

Sample query and its result:

?- puzzle(As+Bs=Cs).
As = [9, _G10107, _G10110, _G10113],
Bs = [1, 0, _G10128, _G10107],
Cs = [1, 0, _G10110, _G10107, _G10152],
_G10107 in 4..7,
1000*9+91*_G10107+ -90*_G10110+_G10113+ -9000*1+ -900*0+10*_G10128+ -1*_G10152#=0,
all_different([_G10107, _G10110, _G10113, _G10128, _G10152, 0, 1, 9]),
_G10110 in 5..8,
_G10113 in 2..8,
_G10128 in 2..8,
_G10152 in 2..8.

Here, the  constraint solver has deduced  more stringent bounds for  all
variables.   Keeping the modeling part  separate from the search  allows
to  view  these residual  goals,  observe  termination  and  determinism
properties of  the modeling part  in isolation from  the search, and  to
more easily experiment  with different search strategies.   Labeling can
then be used to search for solutions:

?- puzzle(As+Bs=Cs), label(As).
As = [9, 5, 6, 7],
Bs = [1, 0, 8, 5],
Cs = [1, 0, 6, 5, 2] ;
false.

In this  case, it suffices to  label a subset  of variables to find  the
puzzle's unique solution,  since the constraint solver is  strong enough
to reduce  the domains  of remaining variables  to singleton  sets.   In
general though, it is necessary to label all  variables to obtain ground
solutions.

It  is  perfectly  reasonable to  use  CLP(FD)  constraints  instead  of
ordinary integer arithmetic with is/2, >/2 etc.  For example:

:- use_module(library(clpfd)).

fac(0, 1).
fac(N, F) :- N #> 0, N1 #= N - 1, F #= N * F1, fac(N1, F1).

This predicate can be used in all directions.  For example:

?- fac(47, F).
F = 258623241511168180642964355153611979969197632389120000000000 ;
false.

?- fac(N, 1).
N = 0 ;
N = 1 ;
false.

?- fac(N, 3).
false.

To make  the predicate terminate  if any  argument is instantiated,  add
the (implied) constraint F #\= 0 before the recursive  call.  Otherwise,
the query fac(N, 0) is the only non-terminating case of this kind.

This   library  uses   goal_expansion/2   to  rewrite   constraints   at
compilation  time.    The  expansion's  aim is  to  transparently  bring
the performance  of CLP(FD)  constraints close to  that of  conventional
arithmetic predicates (</2, =:=/2, is/2 etc.)   when the constraints are
used in  modes that  can also  be handled by  built-in arithmetic.    To
disable the expansion, set the flag clpfd_goal_expansion to false.

Use call_residue_vars/2 and  copy_term/3 to inspect  residual goals  and
the constraints  in which  a variable is  involved.   This library  also
provides _r_e_f_l_e_c_t_i_o_n  predicates (like  fd_dom/2, fd_size/2 etc.)    with
which you  can inspect a  variable's current domain.   These  predicates
can be useful if you want to implement your own labeling strategies.

You can  also define custom constraints.   The  mechanism to do this  is
not yet  finalised, and we welcome  suggestions and descriptions of  use
cases that are  important to you.  As  an example of how it can  be done
currently,  let us define  a new  custom constraint  "oneground(X,Y,Z)",
where Z shall be 1 if at least one of X and Y is instantiated:

:- use_module(library(clpfd)).

:- multifile clpfd:run_propagator/2.

oneground(X, Y, Z) :-
        clpfd:make_propagator(oneground(X, Y, Z), Prop),
        clpfd:init_propagator(X, Prop),
        clpfd:init_propagator(Y, Prop),
        clpfd:trigger_once(Prop).

clpfd:run_propagator(oneground(X, Y, Z), MState) :-
        (   integer(X) -> clpfd:kill(MState), Z = 1
        ;   integer(Y) -> clpfd:kill(MState), Z = 1
        ;   true
        ).

First,  clpfd:make_propagator/2  is used  to  transform  a  user-defined
representation  of  the new  constraint  to  an  internal form.     With
clpfd:init_propagator/2, this internal  form is then  attached to X  and
Y. From now on,  the propagator will be invoked whenever the  domains of
X or  Y are changed.    Then, clpfd:trigger_once/1 is  used to give  the
propagator its first  chance for propagation even though the  variables'
domains  have  not yet  changed.    Finally,  clpfd:run_propagator/2  is
extended to define the actual propagator.  As  explained, this predicate
is automatically called  by the constraint solver.   The first  argument
is  the  user-defined  representation  of  the  constraint  as  used  in
clpfd:make_propagator/2, and  the  second argument  is a  mutable  state
that can be used  to prevent further invocations of the  propagator when
the constraint has become  entailed, by using clpfd:kill/1.   An example
of using the new constraint:

?- oneground(X, Y, Z), Y = 5.
Y = 5,
Z = 1,
X in inf..sup.


_?_V_a_r iinn _+_D_o_m_a_i_n
    _V_a_r is an element of _D_o_m_a_i_n.  _D_o_m_a_i_n is one of:

    _I_n_t_e_g_e_r
         Singleton set consisting only of _I_n_t_e_g_e_r.

    _L_o_w_e_r ....  _U_p_p_e_r
         All integers _I such  that _L_o_w_e_r =< _I =<  _U_p_p_e_r.  _L_o_w_e_r must  be
         an integer or  the atom iinnff,  which denotes negative  infinity.
         _U_p_p_e_r  must be  an  integer  or the  atom  ssuupp,  which  denotes
         positive infinity.

    _D_o_m_a_i_n_1 \/ _D_o_m_a_i_n_2
         The union of Domain1 and Domain2.


_+_V_a_r_s iinnss _+_D_o_m_a_i_n
    The variables in the list _V_a_r_s are elements of _D_o_m_a_i_n.


iinnddoommaaiinn((_?_V_a_r))
    Bind _V_a_r to all  feasible values of its domain on backtracking.  The
    domain of _V_a_r must be finite.


llaabbeell((_+_V_a_r_s))
    Equivalent to labeling([], _V_a_r_s).


llaabbeelliinngg((_+_O_p_t_i_o_n_s_, _+_V_a_r_s))
    Labeling  means  systematically trying  out  values for  the  finite
    domain  variables _V_a_r_s until all of them are ground.  The  domain of
    each variable in _V_a_r_s  must be finite.  _O_p_t_i_o_n_s is a list of options
    that let you exhibit  some control over the search process.  Several
    categories of options exist:

    The  variable selection strategy lets you specify which  variable of
    _V_a_r_s should be labeled next and is one of:

    lleeffttmmoosstt
         Label the variables in the  order they occur in _V_a_r_s.   This is
         the default.

    ffff
         _F_i_r_s_t _f_a_i_l.   Label the leftmost variable with  smallest domain
         next, in order to detect infeasibility early.  This  is often a
         good strategy.

    ffffcc
         Of  the  variables with  smallest  domains,  the  leftmost  one
         participating in most constraints is labeled next.

    mmiinn
         Label the  leftmost variable  whose lower bound  is the  lowest
         next.

    mmaaxx
         Label the leftmost  variable whose upper  bound is the  highest
         next.

    The value order is one of:

    uupp
         Try the elements of  the chosen variable's domain in  ascending
         order.  This is the default.

    ddoowwnn
         Try the domain elements in descending order.

    The branching strategy is one of:

    sstteepp
         For each variable X, a  choice is made between X = V and  X #\=
         V, where V is determined  by the value ordering options.   This
         is the default.

    eennuumm
         For each variable X, a  choice is made between X = V_1, X = V_2
         etc.,  for all  values V_i  of  the domain  of X.  The order  is
         determined by the value ordering options.

    bbiisseecctt
         For each variable X, a choice is made between X #=< M  and X #>
         M, where M is the midpoint of the domain of X.

    At most one option  of each category can be specified, and an option
    must not occur repeatedly.

    The order of solutions can be influenced with:

    mmiinn((_E_x_p_r))

    mmaaxx((_E_x_p_r))

    This generates  solutions in ascending/descending order with respect
    to the evaluation  of the arithmetic expression Expr.  Labeling _V_a_r_s
    must make Expr ground.   If several such options are specified, they
    are interpreted from left to right, e.g.:

    ?- [X,Y] ins 10..20, labeling([max(X),min(Y)],[X,Y]).

    This  generates solutions  in descending  order of X,  and for  each
    binding  of X, solutions are generated  in ascending order of Y.  To
    obtain  the incomplete  behaviour  that other  systems exhibit  with
    "maximize(Expr)" and "minimize(Expr)", use once/1, e.g.:

    once(labeling([max(Expr)], Vars))

    Labeling  is  always  complete,  always terminates,  and  yields  no
    redundant solutions.


aallll__ddiiffffeerreenntt((_+_V_a_r_s))
    _V_a_r_s are pairwise distinct.


ssuumm((_+_V_a_r_s_, _+_R_e_l_, _+_E_x_p_r))
    The  sum of elements of  the list _V_a_r_s is  in relation _R_e_l to  _E_x_p_r.
    For example:

    ?- [A,B,C] ins 0..sup, sum([A,B,C], #=, 100).
    A in 0..100,
    A+B+C#=100,
    B in 0..100,
    C in 0..100.


_?_X #>= _?_Y
    _X is greater than or equal to _Y.


_?_X #=< _?_Y
    _X is less than or equal to _Y.


_?_X #= _?_Y
    _X equals _Y.


_?_X #\= _?_Y
    _X is not _Y.


_?_X #> _?_Y
    _X is greater than _Y.


_?_X #< _?_Y
    _X  is  less than  _Y. In  addition  to its  regular use  in  problems
    that  require it, this  constraint can also  be useful to  eliminate
    uninteresting symmetries from  a problem.  For example, all possible
    matches between pairs built from four players in total:

    ?- Vs = [A,B,C,D], Vs ins 1..4, all_different(Vs), A #< B, C #< D, A #< C,
       findall(pair(A,B)-pair(C,D), label(Vs), Ms).
    Ms = [pair(1, 2)-pair(3, 4), pair(1, 3)-pair(2, 4), pair(1, 4)-pair(2, 3)]


#\ _+_Q
    The  reifiable constraint _Q does _n_o_t  hold.  For example,  to obtain
    the complement of a domain:

    ?- #\ X in -3..0\/10..80.
    X in inf.. -4\/1..9\/81..sup.


_?_P #<==> _?_Q
    _P and _Q are equivalent.  For example:

    ?- X #= 4 #<==> B, X #\= 4.
    B = 0,
    X in inf..3\/5..sup.


_?_P #==> _?_Q
    _P implies _Q.


_?_P #<== _?_Q
    _Q implies _P.


_?_P #/\ _?_Q
    _P and _Q hold.


_?_P #\/ _?_Q
    _P  or _Q holds.  For  example, the sum of natural numbers  below 1000
    that are multiples of 3 or 5:

    ?- findall(N, (N mod 3 #= 0 #\/ N mod 5 #= 0, N in 0..999, indomain(N)), Ns), sum(Ns, #=, Sum).
    Ns = [0, 3, 5, 6, 9, 10, 12, 15, 18|...],
    Sum = 233168.


lleexx__cchhaaiinn((_+_L_i_s_t_s))
    _L_i_s_t_s are lexicographically non-decreasing.


ttuupplleess__iinn((_+_T_u_p_l_e_s_, _+_R_e_l_a_t_i_o_n))
    _R_e_l_a_t_i_o_n  must be a list of lists of integers.  The  elements of the
    list  _T_u_p_l_e_s are constrained to be elements of _R_e_l_a_t_i_o_n.   Arbitrary
    finite  relations, such as compatibility  tables, can be modeled  in
    this  way.  For example, if 1  is compatible with 2 and 5, and  4 is
    compatible with 0 and 3:

    ?- tuples_in([[X,Y]], [[1,2],[1,5],[4,0],[4,3]]), X = 4.
    X = 4,
    Y in 0\/3.

    As another example,  consider a train schedule represented as a list
    of  quadruples, denoting departure and arrival places and  times for
    each  train.   In the  following program, Ps  is a feasible  journey
    of  length 3  from A  to D  via trains that  are part  of the  given
    schedule.

    :- use_module(library(clpfd)).

    trains([[1,2,0,1],[2,3,4,5],[2,3,0,1],[3,4,5,6],[3,4,2,3],[3,4,8,9]]).

    threepath(A, D, Ps) :-
            Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
            T2 #> T1,
            T4 #> T3,
            trains(Ts),
            tuples_in(Ps, Ts).

    In this example, the unique solution is found without labeling:

    ?- threepath(1, 4, Ps).
    Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]].


aallll__ddiissttiinncctt((_+_L_s))
    Like all_different/1, with stronger propagation.


sseerriiaalliizzeedd((_+_S_t_a_r_t_s_, _+_D_u_r_a_t_i_o_n_s))
    Constrain a set  of intervals to a non-overlapping sequence.  _S_t_a_r_t_s
    =  [S_1,...,S_n], is  a list of  variables or  integers, _D_u_r_a_t_i_o_n_s  =
    [D_1,...,D_n] is a list of non-negative integers.   Constrains _S_t_a_r_t_s
    and  _D_u_r_a_t_i_o_n_s to denote a set of  non-overlapping tasks, i.e.:  S_i
    + D_i =< S_j or S_j + D_j =< S_i for all 1 =< i < j =<  n.

         SSeeee aallssoo Dorndorf  et al.   2000,  "Constraint Propagation
             Techniques for the Disjunctive Scheduling Problem"


eelleemmeenntt((_?_N_, _+_I_s_, _?_I))
    The  _N-th element  of the  list of integers  _I_s is  _I. Analogous  to
    nth1/3.


zzccoommppaarree((_?_O_r_d_e_r_, _?_A_, _?_B))
    Analogous  to  compare/3,  with finite  domain  variables _A  and  _B.
    Example:

     fac(N, F) :-
             zcompare(C, N, 0),
             fac_(C, N, F).

     fac_(=, _, 1).
     fac_(>, N, F) :- F #= F0*N, N1 #= N - 1, fac(N1, F0).

    This   version   is  deterministic   if   the  first   argument   is
    instantiated:

    ?- fac(30, F).
    F = 265252859812191058636308480000000.


cchhaaiinn((_+_Z_s_, _+_R_e_l_a_t_i_o_n))
    _Z_s  is a  list  of finite  domain variables  that are  a chain  with
    respect  to the partial order _R_e_l_a_t_i_o_n, in the order they  appear in
    the list.  _R_e_l_a_t_i_o_n must be #=, #=<, #>=, #<  or #>.  For example:

    ?- chain([X,Y,Z], #>=).
    X#>=Y,
    Y#>=Z.


ffdd__vvaarr((_+_V_a_r))
    True iff _V_a_r is a CLP(FD) variable.


ffdd__iinnff((_+_V_a_r_, _-_I_n_f))
    _I_n_f is the infimum of the current domain of _V_a_r.


ffdd__ssuupp((_+_V_a_r_, _-_S_u_p))
    _S_u_p is the supremum of the current domain of _V_a_r.


ffdd__ssiizzee((_+_V_a_r_, _-_S_i_z_e))
    _S_i_z_e is the number  of elements of the current domain of _V_a_r, or the
    atom ssuupp if the domain is unbounded.


ffdd__ddoomm((_+_V_a_r_, _-_D_o_m))
    _D_o_m  is the current  domain (see in/2)  of _V_a_r.   This predicate  is
    useful  if you  want to  reason about  domains.   It  is not  needed
    if  you only want  to display remaining  domains; instead,  separate
    your  model from the search part  and let the toplevel display  this
    information via residual goals.


1111..88 clpqr::  CCoonnssttrraaiinntt LLooggiicc PPrrooggrraammmmiinngg oovveerr RRaattiioonnaallss aanndd RReeaallss

    Author:  _L_e_s_l_i_e _D_e _K_o_n_i_n_c_k, K.U. Leuven

This CLP(Q,R) system is a port of the CLP(Q,R)  system of Sicstus Prolog
by Christian  Holzbaur:   Holzbaur C.:   OFAI  clp(q,r) Manual,  Edition
1.3.3, Austrian Research Institute for Artificial  Intelligence, Vienna,
TR-95-09,  1995.   This manual  is roughly  based on the  manual of  the
above mentioned CLP(Q,R) implementation.

The CLP(Q,R) system consists of two components:  the  CLP(Q) library for
handling constraints  over the rational numbers  and the CLP(R)  library
for handling  constraints over  the real numbers  (using floating  point
numbers as  representation).  Both  libraries offer the same  predicates
(with exception  of bb_inf/4 in  CLP(Q) and bb_inf/5  in CLP(R)). It  is
allowed to use both libraries in one program, but  using both CLP(Q) and
CLP(R) constraints on the same variable will result in an exception.

Please  note that  the clpqr  library  is _n_o_t  an _a_u_t_o_l_o_a_d  library  and
therefore this library must be loaded explicitely before using it:

:- use_module(library(clpq)).

or

:- use_module(library(clpr)).


1111..88..11 SSoollvveerr pprreeddiiccaatteess

The following predicates are provided to work with constraints:


{}((_+_C_o_n_s_t_r_a_i_n_t_s))
    Adds the constraints given by _C_o_n_s_t_r_a_i_n_t_s to the constraint store.


eennttaaiilleedd((_+_C_o_n_s_t_r_a_i_n_t))
    Succeeds  if  _C_o_n_s_t_r_a_i_n_t  is  necessarily true  within  the  current
    constraint  store.    This means  that adding  the  negation of  the
    constraint to the store results in failure.


iinnff((_+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f))
    Computes  the infimum of _E_x_p_r_e_s_s_i_o_n within the current state  of the
    constraint  store and returns that infimum  in _I_n_f.  This  predicate
    does not change the constraint store.


ssuupp((_+_E_x_p_r_e_s_s_i_o_n_, _-_S_u_p))
    Computes the supremum  of _E_x_p_r_e_s_s_i_o_n within the current state of the
    constraint  store and returns that supremum in _S_u_p.   This predicate
    does not change the constraint store.


mmiinniimmiizzee((_+_E_x_p_r_e_s_s_i_o_n))
    Minimizes  _E_x_p_r_e_s_s_i_o_n within the current constraint store.   This is
    the  same as computing  the infimum and  equation the expression  to
    that infimum.


mmaaxxiimmiizzee((_+_E_x_p_r_e_s_s_i_o_n))
    Maximizes  _E_x_p_r_e_s_s_i_o_n within the current constraint store.   This is
    the  same as computing the  supremum and equating the expression  to
    that supremum.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f_, _-_V_e_r_t_e_x_, _+_E_p_s))
    This  predicate  is  offered  in  CLP(R) only.     It  computes  the
    infimum of _E_x_p_r_e_s_s_i_o_n  within the current constraint store, with the
    additional  constraint that in that  infimum, all variables in  _I_n_t_s
    have  integral values.   _V_e_r_t_e_x will contain  the values of _I_n_t_s  in
    the  infimum.   _E_p_s  denotes how  much a  value may  differ from  an
    integer to be considered  an integer.  E.g. when _E_p_s = 0.001, then X
    =  4.999 will be  considered as an  integer (5 in this  case).   _E_p_s
    should be between 0 and 0.5.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f_, _-_V_e_r_t_e_x))
    This  predicate is offered in CLP(Q) only.   It behaves the  same as
    bb_inf/5 but does not use an error margin.


bbbb__iinnff((_+_i_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f))
    The  same as bb_inf/5 or  bb_inf/4 but without returning the  values
    of the integers.  In CLP(R), an error margin of 0.001 is used.


dduummpp((_+_T_a_r_g_e_t_, _+_N_e_w_v_a_r_s_, _-_C_o_d_e_d_A_n_s_w_e_r))
    Returns the constraints  on _T_a_r_g_e_t in the list _C_o_d_e_d_A_n_s_w_e_r where all
    variables  of _T_a_r_g_e_t have veen replaced by _N_e_w_V_a_r_s.   This operation
    does not change the constraint store.  E.g. in

    dump([X,Y,Z],[x,y,z],Cons)

    Cons  will  contain  the constraints  on  X,  Y and  Z  where  these
    variables have been replaced by atoms x, y and z.


1111..88..22 SSyynnttaaxx ooff tthhee pprreeddiiccaattee aarrgguummeennttss

The arguments  of the  predicates defined  in the  subsection above  are
defined in table 11.1.  Failing to meet the syntax  rules will result in
an exception.
__________________________________________________________________________________________
| <Constraints> ::=  <_C_o_n_s_t_r_a_i_n_t>                   |single constraint                    |
|                  | <_C_o_n_s_t_r_a_i_n_t> , <_C_o_n_s_t_r_a_i_n_t_s>    |conjunction                         |
|                  | <_C_o_n_s_t_r_a_i_n_t> ; <_C_o_n_s_t_r_a_i_n_t_s>    |disjunction                         |
| <Constraint>  ::=  <_E_x_p_r_e_s_s_i_o_n> < <_E_x_p_r_e_s_s_i_o_n>     |less than                           |

|                  | <_E_x_p_r_e_s_s_i_o_n> > <_E_x_p_r_e_s_s_i_o_n>     |greater than                        |
|                  | <_E_x_p_r_e_s_s_i_o_n> =< <_E_x_p_r_e_s_s_i_o_n>    |less or equal                       |
|                  | <=(<_E_x_p_r_e_s_s_i_o_n>, <_E_x_p_r_e_s_s_i_o_n>)  |less or equal                       |
|                  | <_E_x_p_r_e_s_s_i_o_n> >= <_E_x_p_r_e_s_s_i_o_n>    |greater or equal                    |
|                  | <_E_x_p_r_e_s_s_i_o_n> =\= <_E_x_p_r_e_s_s_i_o_n>   |not equal                           |
|                  | <_E_x_p_r_e_s_s_i_o_n> =:= <_E_x_p_r_e_s_s_i_o_n>   |equal                               |
|                  | <_E_x_p_r_e_s_s_i_o_n> = <_E_x_p_r_e_s_s_i_o_n>     |equal                               |
| <Expression>  ::=  <_V_a_r_i_a_b_l_e>                     |Prolog variable                      |

|                  | <_N_u_m_b_e_r>                       |Prolog number (float, integer)       |
|                  | +<_E_x_p_r_e_s_s_i_o_n>                  |unary plus                           |
|                  | -<_E_x_p_r_e_s_s_i_o_n>                  |unary minus                          |
|                  | <_E_x_p_r_e_s_s_i_o_n> + <_E_x_p_r_e_s_s_i_o_n>     |addition                            |
|                  | <_E_x_p_r_e_s_s_i_o_n> - <_E_x_p_r_e_s_s_i_o_n>     |substraction                        |
|                  | <_E_x_p_r_e_s_s_i_o_n> * <_E_x_p_r_e_s_s_i_o_n>     |multiplication                      |
|                  | <_E_x_p_r_e_s_s_i_o_n> / <_E_x_p_r_e_s_s_i_o_n>     |division                            |

|                  | abs(<_E_x_p_r_e_s_s_i_o_n>)              |absolute value                       |
|                  | sin(<_E_x_p_r_e_s_s_i_o_n>)              |sine                                 |
|                  | cos(<_E_x_p_r_e_s_s_i_o_n>)              |cosine                               |
|                  | tan(<_E_x_p_r_e_s_s_i_o_n>)              |tangent                              |
|                  | exp(<_E_x_p_r_e_s_s_i_o_n>)              |exponent                             |
|                  | pow(<_E_x_p_r_e_s_s_i_o_n>)              |exponent                             |
|                  | <_E_x_p_r_e_s_s_i_o_n> ^ <_E_x_p_r_e_s_s_i_o_n>     |exponent                            |
|                  | min(<_E_x_p_r_e_s_s_i_o_n>, <_E_x_p_r_e_s_s_i_o_n>) |minimum                             |

|__________________|_max(<_E_x_p_r_e_s_s_i_o_n>,_<_E_x_p_r_e_s_s_i_o_n>)_|maximum_____________________________|
                  Table 11.1:  CLP(Q,R) constraint BNF


  1111..88..33 UUssee ooff uunniiffiiccaattiioonn

  Instead  of using  the {}/1  predicate, you  can also  use the  standard
  unification mechanism to store constraints.  The  following code samples
  are equivalent:

o _U_n_i_f_i_c_a_t_i_o_n _w_i_t_h _a _v_a_r_i_a_b_l_e
      {X =:= Y}
      {X = Y}
      X = Y

o _U_n_i_f_i_c_a_t_i_o_n _w_i_t_h _a _n_u_m_b_e_r
      {X =:= 5.0}
      {X = 5.0}
      X = 5.0


1111..88..44 NNoonn--lliinneeaarr ccoonnssttrraaiinnttss

The CLP(Q,R)  system deals only  passively with non-linear  constraints.
They remain in  a passive state until certain conditions  are satisfied.
These conditions,  which are called the  isolation axioms, are given  in
table 11.2.
     ______________________________________________________________
     | A =B *C     |B or C is ground       |A = 5 *  C or A = B * |
     |             |                       |4                     |
     |              |A  and  (B or  C)  are|20 = 5  * C or 20 = B |
     |______________|ground________________|*_4___________________|_
     | A =B=C      |C is ground            |A = B / 3             |
     |______________|A_and_B_are_ground____|4_=_12_/_C____________|_

     | X =min(Y; Z) |Y and Z are ground    |X = min(4,3)          |
     | X =max(Y; Z) |Y and Z are ground    |X = max(4,3)          |
     |_X_=abs(Y_)___|Y_is_ground___________|X_=_abs(-7)___________|_
     | X =pow(Y; Z) |X and Y are ground    |8 = 2 ^ Z             |
     | X =exp(Y; Z) |X and Z are ground    |8 = Y ^ 3             |
     |_X_=Y__^_Z___|Y_and_Z_are_ground_____|X_=_2_^_3_____________|_
     | X =sin(Y )   X|is ground            |1 = sin(Y)            |

     | X =cos(Y )   Y|is ground            |X = sin(1.5707)       |
     |_X_=tan(Y_)___|______________________|______________________|_
                 Table 11.2:  CLP(Q,R) isolating axioms


1111..99 debug::  SSoommee rreeuussaabbllee ccooddee ttoo hheellpp ddeebbuuggggiinngg aapppplliiccaattiioonnss

This  library provides  an  structured  alternative for  putting  print-
statements into  your source-code  to trace  what is  going on.    Debug
messages are organised in _t_o_p_i_c_s that can be  activated and de-activated
without  changing  the  source.     In  addition,   if  the  application
is  compiled  with  the -O  flag  these  predicates  are  removed  using
goal_expansion/2.

Although  this library  can be  used through  the normal  demand-loading
mechanism it is adviced  to load it explicitely before code using  it to
profit from goal-expansion,  which removes these calls if  compiled with
optimisation on and records the topics from debug/3  and debugging/1 for
list_debug_topics/0.


ddeebbuugg((_+_T_o_p_i_c_, _+_F_o_r_m_a_t_, _+_A_r_g_s))
    If  _T_o_p_i_c is a selected debugging  topic (see debug/1) a message  is
    printed using  print_message/2with level informational.   _F_o_r_m_a_t and
    _A_r_g_s are interpreted by format/2.  Here is a typical example:

            ...,
            debug(init, 'Initialised ~w', [Module]),
            ...,

    _T_o_p_i_c  can be any Prolog term.   Compound terms can be used  to make
    categories of topics that can be activated using debug/1.


ddeebbuuggggiinngg((_+_T_o_p_i_c))
    Succeeds  if _T_o_p_i_c is  a selected debugging topic.   It is  intended
    to  execute  arbitrary  code  depending on  the  users  debug  topic
    selection.     The  construct  (debugging(Topic) -> _C_o_d_e ; true)  is
    removed if the code is compiled in optimise mode.


ddeebbuugg((_+_T_o_p_i_c))
    Select  all registered topics that  unify with _T_o_p_i_c for  debugging.
    This  call is normally  used from the  toplevel to activate a  topic
    for  debugging.   If no  matching _T_o_p_i_c is  registered a warning  is
    printed and the  topic is registered for debugging as matching debug
    statements  may be  loaded  later.   Topics  are de-activated  using
    nodebug/1.


nnooddeebbuugg((_+_T_o_p_i_c))
    Deactivates topics for debugging.  See debug/1 for the arguments.


lliisstt__ddeebbuugg__ttooppiiccss
    List   the  current  status  of   registered  topics.     See   also
    debugging/0.


aasssseerrttiioonn((_:_G_o_a_l))
    This  predicate  is   to  be  compared  to  the  C-library  assert()
    function.   By inserting this goal you explicitely state  you expect
    _G_o_a_l  to succeed at  this place.   As assertion/1 calls are  removed
    when compiling in  optimized mode _G_o_a_l should not have side-effects.
    Typical  examples are type-tests  and validating invariants  defined
    by your application.

    If   _G_o_a_l  fails  the  system  prints  a  message,  followed   by  a
    stack-trace and starts the debugger.

    In  older  versions  of  this  library  this  predicate  was  called
    assume/1.    Code using  assume/1 is  automatically converted  while
    printing a warning on the first occurrence.


1111..1100 gensym::  GGeenneerraattee uunniiqquuee iiddeennttiiffiieerrss

Gensym  (GGeennerate SSyymmbols)  is  an  old library  for  generating  unique
symbols (atoms).    Such symbols are  generated from  a base atom  which
gets a sequence number  appended.  Of course there is no  guarantee that
`catch22'  is not  an already  defined atom  and therefore  one must  be
aware these atoms are only unique in an isolated context.

The SWI-Prolog gensym library is thread-safe.  The  sequence numbers are
global over  all threads and therefore  generated atoms are unique  over
all threads.


ggeennssyymm((_+_B_a_s_e_, _-_U_n_i_q_u_e))
    Generate  a unique  atom from base  _B_a_s_e and  unify it with  _U_n_i_q_u_e.
    _B_a_s_e  should be an  atom.  The  first call will  return <_b_a_s_e>1,  the
    next  <_b_a_s_e>2, etc.   Note that this is  no warrant that the atom  is
    unique in the system.


rreesseett__ggeennssyymm((_+_B_a_s_e))
    Restart  generation of identifiers  from _B_a_s_e  at <_B_a_s_e>1.   Used to
    make  sure a program produces  the same results on subsequent  runs.
    Use with care.


rreesseett__ggeennssyymm
    Reset  gensym for all registered keys.  This predicate  is available
    for  compatibility only.  New  code is strongly advice to avoid  the
    use  of reset_gensym or at least to reset only the keys  used by your
    program to avoid unexpected site-effects on other components.


1111..1111 lists::  LLiisstt MMaanniippuullaattiioonn

This  library  provides  commonly accepted  basic  predicates  for  list
manipulation  in   the  Prolog   community.      Some  additional   list
manipulations are built-in.  Their description is in section 4.28.


aappppeenndd((_?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_3))
    Succeeds  when _L_i_s_t_3  unifies with  the concatenation  of _L_i_s_t_1  and
    _L_i_s_t_2.   The  predicate can be  used with any instantiation  pattern
    (even three variables).


aappppeenndd((_?_L_i_s_t_O_f_L_i_s_t_s_, _?_L_i_s_t))
    Concatenate  a list of lists.  Is true if _L_i_s_t_s is a  list of lists,
    and  _L_i_s_t is the concatenation of these lists.  _L_i_s_t_O_f_L_i_s_t_s  must be
    a list of -possibly- partial lists.


mmeemmbbeerr((_?_E_l_e_m_, _?_L_i_s_t))
    Succeeds  when _E_l_e_m can be unified with one of the members  of _L_i_s_t.
    The predicate can be used with any instantiation pattern.


nneexxttttoo((_?_X_, _?_Y_, _?_L_i_s_t))
    Succeeds when _Y immediatly follows _X in _L_i_s_t.


ddeelleettee((_+_L_i_s_t_1_, _?_E_l_e_m_, _?_L_i_s_t_2))
    Delete all members  of _L_i_s_t_1 that simultaneously unify with _E_l_e_m and
    unify the result with _L_i_s_t_2.


sseelleecctt((_?_E_l_e_m_, _?_L_i_s_t_, _?_R_e_s_t))
    Select  _E_l_e_m  from _L_i_s_t  leaving  _R_e_s_t.    It behaves  as  member/2,
    returning  the  remaining  elements in  _R_e_s_t.    Note  that  besides
    selecting  elements  from a  list, it  can also  be  used to  insert
    elements.


sseelleeccttcchhkk((_?_E_l_e_m_, _?_L_i_s_t_, _?_R_e_s_t))
    Semi-deterministic selection from a list.  Steadfast:  defines as

    selectchk(Elem, List, Rest) :-
            select(Elem, List, Rest0), !,
            Rest = Rest0.


nntthh00((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    Succeeds  when  the  _I_n_d_e_x-th element  of  _L_i_s_t unifies  with  _E_l_e_m.
    Counting starts at 0.


nntthh11((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    Succeeds  when  the  _I_n_d_e_x-th element  of  _L_i_s_t unifies  with  _E_l_e_m.
    Counting starts at 1.


llaasstt((_?_L_i_s_t_, _?_E_l_e_m))
    Succeeds  if _E_l_e_m unifies with  the last element of  _L_i_s_t.  If  _L_i_s_t
    is  a proper list last/2 is deterministic.   If _L_i_s_t has  an unbound
    tail, backtracking will cause _L_i_s_t to grow.


rreevveerrssee((_+_L_i_s_t_1_, _-_L_i_s_t_2))
    Reverse  the order  of the elements  in _L_i_s_t_1  and unify the  result
    with the elements of _L_i_s_t_2.


ppeerrmmuuttaattiioonn((_?_L_i_s_t_1_, _?_L_i_s_t_2))
    Permuation  is true  when  _L_i_s_t_1 is  a permutation  of _L_i_s_t_2.    The
    implementation  can  solve  for _L_i_s_t_2  given  _L_i_s_t_1 or  _L_i_s_t_1  given
    _L_i_s_t_2, or even enumerate _L_i_s_t_1 and _L_i_s_t_2 together.


ffllaatttteenn((_+_L_i_s_t_1_, _-_L_i_s_t_2))
    Transform  _L_i_s_t_1, possibly holding lists  as elements into a  `flat'
    list by replacing  each list with its elements (recursively).  Unify
    the resulting flat list with _L_i_s_t_2.  Example:

    ?- flatten([a, [b, [c, d], e]], X).

    X = [a, b, c, d, e]


ssuummlliisstt((_+_L_i_s_t_, _-_S_u_m))
    Unify  _S_u_m to the result of adding all elements in _L_i_s_t.   _L_i_s_t must
    be  a proper  list holding numbers.   See  number/1 and  is/2.   for
    details on arithmetic.


mmaaxx__lliisstt((_+_L_i_s_t_, _-_M_a_x))
    True  if _M_a_x is the largest number  in _L_i_s_t.  See also  the function
    max/2.


mmiinn__lliisstt((_+_L_i_s_t_, _-_M_i_n))
    True  if _M_i_n is the smallest number in _L_i_s_t.  See  also the function
    min/2.


nnuummlliisstt((_+_L_o_w_, _+_H_i_g_h_, _-_L_i_s_t))
    If  _L_o_w and _H_i_g_h are integers with Low=< High, unify _L_i_s_t to a list
    [Low, Low +1, ...High].  See also between/3.


1111..1111..11 SSeett MMaanniippuullaattiioonn

The set  predicates listed  in this  section work  on ordinary  unsorted
lists.     Note that  this  makes  many  of  the  operations order  N2.
For  larger sets  consider the  use of  ordered sets  as implemented  by
library ordsets.pl,  running most  these operations  in order  N.   See
section 11.15.


iiss__sseett((_+_S_e_t))
    Succeeds if _S_e_t is a list (see is_list/1) without duplicates.


lliisstt__ttoo__sseett((_+_L_i_s_t_, _-_S_e_t))
    Unifies  _S_e_t  with a  list  holding the  same  elements as  _L_i_s_t  in
    the  same order.   If  _l_i_s_t contains duplicates,  only the first  is
    retained.  See also sort/2.  Example:

    ?- list_to_set([a,b,a], X)

    X = [a,b]


iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))
    Succeeds  if _S_e_t_3 unifies  with the intersection  of _S_e_t_1 and  _S_e_t_2.
    _S_e_t_1  and _S_e_t_2  are  lists without  duplicates.   They  need not  be
    ordered.


ssuubbttrraacctt((_+_S_e_t_, _+_D_e_l_e_t_e_, _-_R_e_s_u_l_t))
    Delete  all  elements  of set  `Delete'  from  `Set' and  unify  the
    resulting set with `Result'.


uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))
    Succeeds if _S_e_t_3 unifies  with the union of _S_e_t_1 and _S_e_t_2.  _S_e_t_1 and
    _S_e_t_2 are lists without duplicates.  They need not be ordered.


ssuubbsseett((_+_S_u_b_s_e_t_, _+_S_e_t))
    Succeeds if all elements of _S_u_b_s_e_t are elements of _S_e_t as well.


1111..1122 nbset::  NNoonn--bbaacckkttrraacckkaabbllee sseett

The  library  nb_set  defines  _n_o_n_-_b_a_c_k_t_r_a_c_k_a_b_l_e  _s_e_t_s,  implemented  as
binary  trees.     The  sets  are  represented  as  compound  terms  and
manipulated  using  nb_setarg/3.     Non-backtrackable  manipulation  of
datastructures  is   not  supported   by  a  large   number  of   Prolog
implementation,  but  it  it  has  several  advantages  over  using  the
database.    It produces  less garbage,  is thread-safe,  reentrant  and
deals with exceptions without leaking data.

Similar to the assoc library keys can be any Prolog term,  but it is not
allowed to instantiate or modify a term.

One of  the ways to  use this  library is to  generate unique values  on
backtracking  _w_i_t_h_o_u_t generating  _a_l_l solutions  first,  for example  to
act as  a filter between  a generator producing  many duplicates and  an
expensive test routine, as outlines below.

generate_and_test(Solution) :-
        empty_nb_set(Set),
        generate(Solution),
        add_nb_set(Solution, Set, true),
        test(Solution).


eemmppttyy__nnbb__sseett((_?_S_e_t))
    True if _S_e_t is a non-backtrackable emoty set.


aadddd__nnbb__sseett((_+_K_e_y_, _!_S_e_t))
    Add  _K_e_y to _S_e_t.   If _K_e_y  is already a member  of _S_e_t, add_nb_set/3
    succeeds without modifying _S_e_t.


aadddd__nnbb__sseett((_+_K_e_y_, _!_S_e_t_, _?_N_e_w))
    If  _K_e_y is not  in _S_e_t and _N_e_w  is unified to  true _K_e_y is added  to
    _S_e_t.  If _K_e_y is  in _S_e_t _N_e_w is unified to false.  It can be used for
    many purposes:

             add_nb_set(+, +, false) Test membership
             add_nb_set(+, +, true)  Succeed only if new member
             add_nb_set(+, +, Var)   Succeed, bindin _V_a_r


ggeenn__nnbb__sseett((_+_S_e_t_, _-_K_e_y))
    Generate  all members of _S_e_t  on backtracking in the standard  order
    of terms.  To test membership, use add_nb_set/3.


ssiizzee__nnbb__sseett((_+_S_e_t_, _-_S_i_z_e))
    Unify _S_i_z_e with the number of elements in _S_e_t.


nnbb__sseett__ttoo__lliisstt((_+_S_e_t_, _-_L_i_s_t))
    Unify _L_i_s_t with a  list of all elements in set in the standard order
    of terms (i.e. and _o_r_d_e_r_e_d _l_i_s_t).


1111..1133 www_browser::  AAccttiivvaattiinngg yyoouurr WWeebb--bbrroowwsseerr

This library deals with the very system dependent task  of opening a web
page in a browser.  See also url and the HTTP package.


wwwwww__ooppeenn__uurrll((_+_U_R_L))
    Open  _U_R_L in  an external  web-browser.   The reason  to place  this
    in  the library  is  to centralise  the maintenance  on this  highly
    platform  and browser specific task.   It distinguishes between  the
    following cases:

      o  _M_S_-_W_i_n_d_o_w_s
         If it detects MS-Windows  it uses win_shell/2 to open the  _U_R_L.
         The behaviour  and browser  started depends on  the Window  and
         Windows-shell configuration,  but in general  it should be  the
         behaviour expected by the user.

      o  _O_t_h_e_r _p_l_a_t_f_o_r_m_s
         On  other platforms  it  tests  the environment  variable  (see
         getenv/2) named BROWSER  or uses netscape  if this variable  is
         not  set.    If the  browser  is  either mozilla  or  netscape,
         www_open_url/1 first tries to  open a new  window on a  running
         using the  -remote option of netscape.   If  this fails or  the
         browser is  not mozilla  or netscape the  system simply  passes
         the URL as first argument to the program.


1111..1144 ooppttiioonn..ppll ---- OOppttiioonn lliisstt pprroocceessssiinngg

    SSeeee aallssoo  library(record)

    TToo bbee ddoonnee
         - We should  consider putting many options  in an assoc or
         record with  appropriate  preprocessing to  achieve better
         performance.
         -  We  should  provide   some  standard  to  to  automatic
         type-checking on option lists.

The  library(option)  provides  some  utilities  for  processing  option
lists.    Option lists  are commonly  used as  an  alternative for  many
arguments.   Examples built-in  predicates are open/4  and write_term/3.
Naming the arguments results  in more readable code and the  list nature
makes it  easy to extend  the list of options  accepted by a  predicate.
Option lists  come in  two styles,  both of  which are  handled by  this
library.

NNaammee((VVaalluuee))  This is the preferred style.

NNaammee == VVaalluuee  This is often used, but deprecated.

Processing  options  inside   time  critical  code  (loops)  can   cause
serious  overhead.     One possibility  is  to  define  a  record  using
library(record) and initialise this using make_<record>/2.  In addition
to  providing good  performance, this  also  provides type-checking  and
central declaration of defaults.

:- record atts(width:integer=100, shape:oneof([box,circle])=box).

process(Data, Options) :-
        make_atts(Options, Attributes),
        action(Data, Attributes).

action(Data, Attributes) :-
        atts_shape(Attributes, Shape),
        ...


ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_L_i_s_t_, _+_D_e_f_a_u_l_t))
    Get an option from  a _O_p_t_i_o_n_L_i_s_t.  _O_p_t_i_o_n_L_i_s_t can use the Name=Value
    as well as the Name(Value) convention.

    __________________________________________________________Parameters_
     _O_p_t_i_o_n  Term of the form Name(?Value).


ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_L_i_s_t))
    Get an option from  a _O_p_t_i_o_n_L_i_s_t.  _O_p_t_i_o_n_L_i_s_t can use the Name=Value
    as  well  as the  Name(Value) convention.    Fails  silently if  the
    option does not appear in _O_p_t_i_o_n_L_i_s_t.

    __________________________________________________________Parameters_
     _O_p_t_i_o_n  Term of the form Name(?Value).


sseelleecctt__ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_s_, _-_R_e_s_t_O_p_t_i_o_n_s))                 _[_s_e_m_i_d_e_t_]
    Get  and remove option from an  option list.  As option/2,  removing
    the matching option  from _O_p_t_i_o_n_s and unifying the remaining options
    with _R_e_s_t_O_p_t_i_o_n_s.


sseelleecctt__ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_s_, _-_R_e_s_t_O_p_t_i_o_n_s_, _+_D_e_f_a_u_l_t))           _[_d_e_t_]
    Get  and remove option with default value.   As select_option/3, but
    if  _O_p_t_i_o_n is not in _O_p_t_i_o_n_s, its value is unified with  _D_e_f_a_u_l_t and
    _R_e_s_t_O_p_t_i_o_n_s with _O_p_t_i_o_n_s.


mmeerrggee__ooppttiioonnss((_+_N_e_w_, _+_O_l_d_, _-_M_e_r_g_e_d))                                 _[_d_e_t_]
    Merge  two option lists.  _M_e_r_g_e_d  is a sorted list of  options using
    the  canonical format Name(Value) holding  all options from _N_e_w  and
    _O_l_d, after removing conflicting options from _O_l_d.


mmeettaa__ooppttiioonnss((_+_I_s_M_e_t_a_, _:_O_p_t_i_o_n_s_0_, _-_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Perform   meta-expansion  on  options  that  are   module-sensitive.
    Whether an option  name is module sensitive is determined by calling
    call(_I_s_M_e_t_a, Name).  Here is an example:

            meta_options(is_meta, OptionsIn, Options),
            ...

    is_meta(callback).


1111..1155 ordsets::  OOrrddeerreedd SSeett MMaanniippuullaattiioonn

Ordered  sets are  lists with  unique elements  sorted  to the  standard
order of  terms (see  sort/2).   Exploiting  ordering, many  of the  set
operations can  be expressed  in order  N rather  than N2  when dealing
with  unordered sets  that  may contain  duplicates.    The  ordsets  is
available in  a number of  Prolog implementations.   Our predicates  are
designed to be compatible with common practice in  the Prolog community.
The implementation  is incomplete and  relies partly  on oset, an  older
ordered set library  distributed with SWI-Prolog.  New  applications are
advices to use ordsets.

Some  of   these  predicates  match   directly  to  corresponding   list
operations.   It is  adviced to  use the versions  from this library  to
make clear you are operating on ordered sets.


oorrdd__eemmppttyy((_?_S_e_t))
    True  if _S_e_t is an  empty ordered set.   _S_e_t unifies with the  empty
    list.


lliisstt__ttoo__oorrdd__sseett((_+_L_i_s_t_, _-_O_r_d_S_e_t))
    Convert a _L_i_s_t to an ordered set.  Same as sort/2.


oorrdd__aadddd__eelleemmeenntt((_+_S_e_t_, _+_E_l_e_m_e_n_t_, _-_N_e_w_S_e_t))
    Add  an element to  an ordered set.   _N_e_w_S_e_t is  the same as _S_e_t  if
    _E_l_e_m_e_n_t is already part of _S_e_t.


oorrdd__ddeell__eelleemmeenntt((_+_S_e_t_, _+_E_l_e_m_e_n_t_, _-_N_e_w_S_e_t))
    Delete _E_l_e_m_e_n_t from _S_e_t.   Succeeds without changing _S_e_t if _S_e_t does
    not contain _E_l_e_m_e_n_t.


oorrdd__iinntteerrsseecctt((_+_S_e_t_1_, _+_S_e_t_2))
    True if the intersection of _S_e_t_1 and _S_e_t_2 is non-empty.


oorrdd__iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_I_n_t_e_r_s_e_c_t_i_o_n))
    True if _I_n_t_e_r_s_e_c_t_i_o_n is the intersection of _S_e_t_1 and _S_e_t_2.


oorrdd__ddiissjjooiinntt((_+_S_e_t_1_, _+_S_e_t_2))
    True  if  _S_e_t_1  and  _S_e_t_2 have  no  common  element.    Negation  of
    ord_intersect/2.


oorrdd__ssuubbttrraacctt((_+_S_e_t_, _+_D_e_l_e_t_e_, _-_R_e_m_a_i_n_i_n_g))
    True  if _R_e_m_a_i_n_i_n_g contains the elements of _S_e_t that are not  in set
    _D_e_l_e_t_e.


oorrdd__uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_U_n_i_o_n))
    True if _U_n_i_o_n contains all elements from _S_e_t_1 and _S_e_t_2


oorrdd__uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_U_n_i_o_n_, _-_N_e_w))
    Defined  as  if  ord_union(_S_e_t_1_,  _S_e_t_2_,  _U_n_i_o_n),  ord_subtract(_S_e_t_2_,
    _S_e_t_1_, _N_e_w).


oorrdd__ssuubbsseett((_+_S_u_b_, _+_S_u_p_e_r))
    True if all elements of _S_u_b are in _S_u_p_e_r.


oorrdd__mmeemmbbeerrcchhkk((_+_E_l_e_m_e_n_t_, _+_S_e_t))
    True  if _E_l_e_m_e_n_t  appears in  _S_e_t.   Does not  backtrack.   Same  as
    memberchk/2.


1111..1166 ppaaiirrss..ppll ---- OOppeerraattiioonnss oonn kkeeyy--vvaalluuee lliissttss

    aauutthhoorr  Jan Wielemaker

    SSeeee aallssoo  keysort/2, library(assoc)

This  module  implements common  operations  on  Key-Value  lists,  also
known as  _P_a_i_r_s.   Pairs have great practical  value, especially due  to
keysort/2 and the library assoc.pl.

This  library is  based  on  disussion in  the  SWI-Prolog  mailinglist,
including specifications from Quintus and a library  proposal by Richard
O'Keefe.


ppaaiirrss__kkeeyyss__vvaalluueess((_?_P_a_i_r_s_, _?_K_e_y_s_, _?_V_a_l_u_e_s))                          _[_d_e_t_]
    True if _K_e_y_s holds the keys of _P_a_i_r_s and _V_a_l_u_e_s the values.

    Deterministic  if any argument is instantiated to a finite  list and
    the others are either free or finite lists.


ppaaiirrss__vvaalluueess((_+_P_a_i_r_s_, _-_V_a_l_u_e_s))                                      _[_d_e_t_]
    Remove  the  keys  from  a  list  of  Key-Value  pairs.     Same  as
    pairs_keys_values(_P_a_i_r_s, _, _V_a_l_u_e_s)


ppaaiirrss__kkeeyyss((_+_P_a_i_r_s_, _-_K_e_y_s))                                          _[_d_e_t_]
    Remove  the  values  from  a list  of  Key-Value  pairs.    Same  as
    pairs_keys_values(_P_a_i_r_s, _K_e_y_s, _)


ggrroouupp__ppaaiirrss__bbyy__kkeeyy((_+_P_a_i_r_s_, _-_J_o_i_n_e_d_:_l_i_s_t_(_K_e_y_-_V_a_l_u_e_s_)))                _[_d_e_t_]
    Group values with the same key.  For example:

    ?- group_pairs_by_key([a-2, a-1, b-4], X).

    X = [a-[2,1], b-[4]]

    __________________________________________________________Parameters__P_a_i_r_s_K_e_y-Value list, sorted to the standard order  of

             terms (as keysort/2 does)
     _J_o_i_n_e_d  List  of _K_e_y-Group, where  Group is the list  of
             _V_a_l_u_e_s associated with _K_e_y.


ttrraannssppoossee__ppaaiirrss((_+_P_a_i_r_s_, _-_T_r_a_n_s_p_o_s_e_d))                               _[_d_e_t_]
    Swap  Key-Value to Value-Key and sort  the result on Value (the  new
    key) using keysort/2.


mmaapp__lliisstt__ttoo__ppaaiirrss((_:_F_u_n_c_t_i_o_n_, _+_L_i_s_t_, _-_K_e_y_e_d))
    Create  a key-value  list  by mapping  each element  of _L_i_s_t.    For
    example,  if  we have  a  list of  lists  we can  create a  list  of
    Length-_L_i_s_t using

            map_list_to_pairs(length, ListOfLists, Pairs),


1111..1177 pio::  PPuurree II//OO

This library provides  pure list-based I/O processing for Prolog,  where
the communication  to the actual I/O  device is performed  transparently
through coroutining.   This  module itself is just  an interface to  the
actual implementation modules.


1111..1177..11 ppuurree__iinnppuutt..ppll ---- PPuurree IInnppuutt ffrroomm ffiilleess

    aauutthhoorr
         - Ulrich Neumerkel
         - Jan Wielemaker

    TToo bbee ddoonnee
         -  Provide support  for  alternative  input readers,  e.g.
         reading terms, tokens, etc.
         - Support  non-repositioning streams, such  as sockets and
         pipes.

This module  is part  of pio.pl,  dealing with _p_u_r_e  _i_n_p_u_t:   processing
input  streams from  the outside  world using  pure predicates,  notably
grammar  rules  (DCG). Using  pure  predicates  makes  non-deterministic
processing of input much simpler.

Pure input uses  coroutining (freeze/2) to read input from  the external
source into  a list _o_n  _d_e_m_a_n_d.   The overhead of  lazy reading is  more
than compensated for by using block reads based on read_pending_input/3.


pphhrraassee__ffrroomm__ffiillee((_:_G_r_a_m_m_a_r_, _+_F_i_l_e))                               _[_n_o_n_d_e_t_]
    Process  the  content of  _F_i_l_e using  the  DCG rule  _G_r_a_m_m_a_r.    The
    space  usage of  this mechanism  depends on  the length  of the  not
    committed  part of _G_r_a_m_m_a_r.   Committed parts of the temporary  list
    are  reclaimed by the garbage collector, while the list  is extended
    on demand.   Here is a very simple definition for searching a string
    in a file:

    ... --> []|[_],... .

    file_contains(File, Pattern) :-
            phrase_from_file((..., Pattern, ...), File).

    match_count(File, Pattern, Count) :-
            findall(x, file_contains(File, Pattern), Xs),
            length(Xs, Count).

    This can be called  as (note that the pattern must be a string (code
    list)):

    ?- match_count('pure_input.pl', "file", Count).


pphhrraassee__ffrroomm__ffiillee((_:_G_r_a_m_m_a_r_, _+_F_i_l_e_, _+_O_p_t_i_o_n_s))                     _[_n_o_n_d_e_t_]
    As  phrase_from_file/2,  providing additional _O_p_t_i_o_n_s.   _O_p_t_i_o_n_s  are
    passed  to  open/4,  except  for buffer_size,  which  is  passed  to
    set_stream/2.   If  not specified,  the default buffer  size is  512
    bytes.   Of  particular importance are  the open/4 options type  and
    encoding.


ssttrreeaamm__ttoo__llaazzyy__lliisstt((_+_S_t_r_e_a_m_, _-_L_i_s_t))                                 _[_d_e_t_]
    Create  a lazy list representing the character codes in _S_t_r_e_a_m.   It
    must be possible to  reposition _S_t_r_e_a_m.  _L_i_s_t is a list that ends in
    a  delayed goal.   _L_i_s_t can be  unified completely transparent to  a
    (partial)  list and processed  transparently using DCGs, but  please
    be aware that a  lazy list is not the same as a materialized list in
    all respects.

    Typically, this predicate  is used as a building block for more high
    level safe predicates such as phrase_from_file/2.

         TToo bbee ddoonnee Enhance of lazy list throughout the system.


1111..1188 prologxref::  CCrroossss--rreeffeerreennccee ddaattaa ccoolllleeccttiioonn lliibbrraarryy

This library collects information on defined and used  objects in Prolog
sourcefiles.  Typically these are predicates, but  we expect the library
to deal  with other  types of objects  in the  future.   The library  is
a building  block for tools doing  dependency tracking in  applications.
Dependency tracking  is useful  to reveal  the structure  of an  unknown
program  or detect  missing components  at  compile-time, but  also  for
program  transformation or  minimising  a  program saved-state  by  only
saving the reachable objects.

This section gives  a partial description of the library  API, providing
some insight  in how you  can use it  for analysing your  program.   The
library should be  further modularized, moving its knowledge  about -for
example- XPCE  into a different file  and allowing for adding  knowledge
about other  libraries such  as Logtalk.   PPlleeaassee  ddoo nnoott ccoonnssiiddeerr  tthhiiss
iinntteerrffaaccee rroocckk--ssoolliidd..

The  library is  exploited  by two  graphical  tools in  the  SWI-Prolog
environment.   The  XPCE frontend  started by gxref/0  and described  in
section 3.7 and  PceEmacs (section 3.4) which exploits this  library for
its syntax colouring.

For  all predicates  described  below,  _S_o_u_r_c_e  is the  source  that  is
processed.    This is  normally a  filename in  any notation  acceptable
to the  file loading  predicates (see  load_files/2).    Using the  hooks
defined  in  section  11.18.1  it can  be  anything  else  that  can  be
translated into a  Prolog stream holding Prolog  source text.   _C_a_l_l_a_b_l_e
is a callable  term (see callable/1).   Callables do not carry a  module
qualifier unless  the referred predicate  is not  in the module  defined
_S_o_u_r_c_e.


xxrreeff__ssoouurrccee((_+_S_o_u_r_c_e))
    Gather information on  _S_o_u_r_c_e.  If _S_o_u_r_c_e has already been processed
    and  is still up-to-date according to the file timestamp,  no action
    is  taken.     This  predicate  must be  called  on  a  file  before
    information can be gathered.


xxrreeff__ccuurrrreenntt__ssoouurrccee((_?_S_o_u_r_c_e))
    _S_o_u_r_c_e has been processed.


xxrreeff__cclleeaann((_+_S_o_u_r_c_e))
    Remove the information gathered for _S_o_u_r_c_e


xxrreeff__ddeeffiinneedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e_, _-_H_o_w))
    _C_a_l_l_a_b_l_e is defined in _S_o_u_r_c_e.  _H_o_w is one of

             dynamic(_L_i_n_e)       Declared dynamic at _L_i_n_e

             thread_local(_L_i_n_e)  Declared thread local at _L_i_n_e
             multifile(_L_i_n_e)     Declared multifile at _L_i_n_e
             local(_L_i_n_e)         First clause at _L_i_n_e
             foreign(_L_i_n_e)       Foreign library loaded at _L_i_n_e
             constraint(_L_i_n_e)    CHR Constraint at _L_i_n_e
             imported(_F_i_l_e)      Imported from _F_i_l_e


xxrreeff__ccaalllleedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e_, _?_B_y))
    _C_a_l_l_a_b_l_e is called in _S_o_u_r_c_e by _B_y.


xxrreeff__eexxppoorrtteedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e))
    _C_a_l_l_a_b_l_e is public (exported from the module).


xxrreeff__mmoodduullee((_?_S_o_u_r_c_e_, _?_M_o_d_u_l_e))
    _S_o_u_r_c_e is a module-file defining the given module.


xxrreeff__bbuuiilltt__iinn((_?_C_a_l_l_a_b_l_e))
    True  if  _C_a_l_l_a_b_l_e is  a  built-in predicate.    Currently  this  is
    assumed  for all predicates defined in the system module  and having
    the  property built_in.  Built-in  predicates are not registered  as
    `called'.


1111..1188..11 EExxtteennddiinngg tthhee lliibbrraarryy

The library provides hooks  for extending its rules it uses  for finding
predicates called by some programming construct.


pprroolloogg::ccaalllleedd__bbyy((_+_G_o_a_l_, _-_C_a_l_l_e_d))
    Where  _G_o_a_l  is   a  non-var  subgoal  appearing  in  called  object
    (typically a clause-body).   If it succeeds it must return a list of
    goals called by _G_o_a_l.  As a special construct, if a term Callable +N
    is  returned,  N variable  arguments are  added to  _C_a_l_l_a_b_l_e before
    further  processing.  For simple meta-calls a single  fact suffices.
    Complex  rules as  used in  the html_write library  provided by  the
    HTTP  package examine  the  arguments and  create a  list of  called
    objects.

    The  current  system   cannot  deal  with  the  same  name/arity  in
    different  modules that  behave differently with  respect to  called
    arguments.


1111..1199 readutil::  RReeaaddiinngg lliinneess,, ssttrreeaammss aanndd ffiilleess

This library contains  primitives to read lines, files,  multiple terms,
etc.   The package clib provides  a shared object (DLL) named  readutil.
If the  library can locate  this shared object it  will use the  foreign
implementation for  reading character codes.   Otherwise  it will use  a
Prolog implementation.    Distributed applications should  make sure  to
deliver the  readutil shared object if  performance of these  predicates
is critical.


rreeaadd__lliinnee__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s))
    Read  the  next line  of  input from  _S_t_r_e_a_m  and unify  the  result
    with  _C_o_d_e_s _a_f_t_e_r the  line has  been read.   A line  is ended by  a
    newline character or end-of-file.  Unlike  read_line_to_codes/3, this
    predicate removes trailing newline character.

    On  end-of-file  the  atom  end_of_file  is  returned.     See  also
    at_end_of_stream/[0,1].


rreeaadd__lliinnee__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Diference-list version to  read an input line to a list of character
    codes.   Reading stops at the newline or end-of-file  character, but
    unlike  read_line_to_codes/2, the newline is retained in  the output.
    This  predicate is especially  useful for readine  a block of  lines
    upto  some delimiter.   The following  example reads an HTTP  header
    ended by a blank line:

    read_header_data(Stream, Header) :-
            read_line_to_codes(Stream, Header, Tail),
            read_header_data(Header, Stream, Tail).

    read_header_data("\r\n", _, _) :- !.
    read_header_data("\n", _, _) :- !.
    read_header_data("", _, _) :- !.
    read_header_data(_, Stream, Tail) :-
            read_line_to_codes(Stream, Tail, NewTail),
            read_header_data(Tail, Stream, NewTail).


rreeaadd__ssttrreeaamm__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s))
    Read all input until end-of-file and unify the result to _C_o_d_e_s.


rreeaadd__ssttrreeaamm__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Difference-list version of read_stream_to_codes/2.


rreeaadd__ffiillee__ttoo__ccooddeess((_+_S_p_e_c_, _-_C_o_d_e_s_, _+_O_p_t_i_o_n_s))
    Read  a  file to  a  list of  character  codes.    _S_p_e_c is  a  file-
    specification  for  absolute_file_name/3.    _C_o_d_e_s is  the  resulting
    code-list.   _O_p_t_i_o_n_s  is a list of  options for absolute_file_name/3
    and open/4.   In addition, the option tail(_T_a_i_l) is defined, forming
    a difference-list.


rreeaadd__ffiillee__ttoo__tteerrmmss((_+_S_p_e_c_, _-_T_e_r_m_s_, _+_O_p_t_i_o_n_s))
    Read  a  file  to  a list  of  prolog  terms  (see read/1).     _S_p_e_c
    is  a  file-specification for  absolute_file_name/3.    _T_e_r_m_s is  the
    resulting  list of  Prolog  terms.   _O_p_t_i_o_n_s  is a  list of  options
    for  absolute_file_name/3 and  open/4.    In  addition,  the  option
    tail(_T_a_i_l) is defined, forming a difference-list.


1111..2200 record::  AAcccceessss nnaammeedd ffiieellddss iinn aa tteerrmm

The  library  record  provides  named  access  to  fields  in  a  record
represented as a  compound term such as  point(X, Y).  The Prolog  world
knows various  approaches to solve this  problem, unfortunately with  no
consensus.   The approach taken by  this library is proposed by  Richard
O'Keefe on the SWI-Prolog mailinglist.

The  approach  automates  a  technique  commonly   described  in  Prolog
text-books, where  access- and modification  predicates are defined  for
the record type.   Such predicates  are subject to normal  import/export
as well as  analysis by cross-referencers.   Given the simple nature  of
the access  predicates, an  optimizing compiler can  easily inline  them
for optimal preformance.

A record  is defined  using the directive  record/1.   We introduce  the
library with a short example:

:- record point(x:integer=0, y:integer=0).

        ...,
        default_point(Point),
        point_x(Point, X),
        set_x_of_point(10, Point, Point1),

        make_point([y(20)], YPoint),

The principal functor  and arity of the  term used defines the name  and
arity of  the compound  used as  records.   Each  argument is  described
using a term of the format below.

    <name>[:<_t_y_p_e>][=<_d_e_f_a_u_l_t>]

In this definition, <_n_a_m_e> is an atom defining the name of the argument.
<type> is  an optional type specification  as defined by  must_be/2 from
library error  and <_d_e_f_a_u_l_t> is the  default initial value.   The <type>
defaults to  any.  If  no default value is  specified the default is  an
unbound variable.

A  record  declaration  creates  a  set  of   predicates  through  _t_e_r_m_-
_e_x_p_a_n_s_i_o_n.   We describe these predicates  below.  In this  description,
<_c_o_n_s_t_r_u_c_t_o_r> refers to  the name of the record  (`point' in the example
above) and <_n_a_m_e> to the name of an argument (field).

  o _d_e_f_a_u_l_t__<_c_o_n_s_t_r_u_c_t_o_r>_(_-_R_e_c_o_r_d_)
    Create  a new  record where  all fields have  their default  values.
    This is the same as make_<_c_o_n_s_t_r_u_c_t_o_r>([], Record).

  o _m_a_k_e__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_F_i_e_l_d_s_, _-_R_e_c_o_r_d_)
    Create  a  new  record where  specified  fields have  the  specified
    values  and  remaining  fields  have  their default  value.     Each
    field  is specified as  a term <_n_a_m_e>(<_v_a_l_u_e>).   See example  in the
    introduction.

  o _m_a_k_e__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_F_i_e_l_d_s_, _-_R_e_c_o_r_d_, _-_R_e_s_t_F_i_e_l_d_s_)
    Same as  make_<_c_o_n_s_t_r_u_c_t_o_r>/2, but named fields that do not appear in
    _R_e_c_o_r_d  are returned in _R_e_s_t_F_i_e_l_d_s.  This predicate is  motivated by
    option-list processing.  See library option.

  o <_c_o_n_s_t_r_u_c_t_o_r>_<_n_a_m_e>_(_R_e_c_o_r_d_, _V_a_l_u_e_)
    Unify _V_a_l_u_e with argument in _R_e_c_o_r_d named <_n_a_m_e>.

  o _s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _+_O_l_d_R_e_c_o_r_d_, _-_N_e_w_R_e_c_o_r_d_)
    Replace  the value for  <_n_a_m_e> in  _O_l_d_R_e_c_o_r_d by _V_a_l_u_e  and unify the
    result with _N_e_w_R_e_c_o_r_d.

  o _s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _!_R_e_c_o_r_d_)
    Destructively  replace the argument <_n_a_m_e> in  _R_e_c_o_r_d by _V_a_l_u_e based
    on setarg/3.  Use with care.

  o _n_b___s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _!_R_e_c_o_r_d_)
    As   above,   but  using  non-backtrackable   assignment  based   on
    nb_setarg/3.  Use with _e_x_t_r_e_m_e care.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_s_(_+_F_i_e_l_d_s_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_)
    Set  multiple fields using  the same syntax  as make_<_c_o_n_s_t_r_u_c_t_o_r>/2,
    but starting with _R_e_c_o_r_d_0 rather than the default record.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_s_(_+_F_i_e_l_d_s_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_, _-_R_e_s_t_F_i_e_l_d_s_)
    Similar  to  set_<_c_o_n_s_t_r_u_c_t_o_r>_fields/4, but  fields  not  defined by
    <constructor> are returned in _R_e_s_t_F_i_e_l_d_s.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_(_+_F_i_e_l_d_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_)
    Set a single field specified as a term <_n_a_m_e>(<_v_a_l_u_e>).


rreeccoorrdd((_+_S_p_e_c))
    The  construct  :- record Spec, ...  is  used to  define  access  to
    named  fields  in a  compound.    It  is subject  to  term-expansion
    (see  expand_term/2) and  cannot  be called  as a  predicate.    See
    section 11.20 for details.


1111..2211 registry::  MMaanniippuullaattiinngg tthhee WWiinnddoowwss rreeggiissttrryy

The registry is only available on the MS-Windows  version of SWI-Prolog.
It loads  the foreign extension  plregtry.dll, providing the  predicates
described below.   This  library only makes  the most common  operations
on the registry available  through the Prolog user.  The  underlying DLL
provides a  more complete coverage of  the Windows registry API.  Please
consult  the  sources  in  pl/src/win32/foreign/plregtry.c  for  further
details.

In  all these  predicates,  _P_a_t_h refers  to a  `/' separated  path  into
the registry.   This  is _n_o_t an atom  containing `/'-characters as  used
for  filenames, but  a term  using the  functor  //2.   Windows  defines
the  following  roots for  the  registry:   classes_root,  current_user,
local_machine and users


rreeggiissttrryy__ggeett__kkeeyy((_+_P_a_t_h_, _-_V_a_l_u_e))
    Get  the principal (default)  value associated to  this key.   Fails
    silently of the key does not exist.


rreeggiissttrryy__ggeett__kkeeyy((_+_P_a_t_h_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Get a named value associated to this key.


rreeggiissttrryy__sseett__kkeeyy((_+_P_a_t_h_, _+_V_a_l_u_e))
    Set the principal (default)  value of this key.  Creates (a path to)
    the key if this does not already exist.


rreeggiissttrryy__sseett__kkeeyy((_+_P_a_t_h_, _+_N_a_m_e_, _+_V_a_l_u_e))
    Associated  a named value to this key.  Creates (a path  to) the key
    if this does not already exist.


rreeggiissttrryy__ddeelleettee__kkeeyy((_+_P_a_t_h))
    Delete the indicated key.


sshheellll__rreeggiisstteerr__ffiillee__ttyyppee((_+_E_x_t_, _+_T_y_p_e_, _+_N_a_m_e_, _+_O_p_e_n_A_c_t_i_o_n))
    Register  a file-type.   _E_x_t is  the extension to  associate.   _T_y_p_e
    is  the type name,  often something link prolog.type.   _N_a_m_e is  the
    name visible in  the Windows file-type browser.  Finally, _O_p_e_n_A_c_t_i_o_n
    defines  the action to  execute when a  file with this extension  is
    opened in the Windows explorer.


sshheellll__rreeggiisstteerr__ddddee((_+_T_y_p_e_, _+_A_c_t_i_o_n_, _+_S_e_r_v_i_c_e_, _+_T_o_p_i_c_, _+_C_o_m_m_a_n_d_, _+_I_f_N_o_t_R_u_n_n_i_n_g))
    Associate  DDE  actions  to a  type.    _T_y_p_e  is  the same  type  as
    used  for  the  2nd argument  of  shell_register_file_type/4,  _A_c_t_i_o_n
    is  the  a action  to perform,  _S_e_r_v_i_c_e and  _T_o_p_i_c  specify the  DDE
    topic  to address  and _C_o_m_m_a_n_d  is the  command to  execute on  this
    topic.   Finally, _I_f_N_o_t_R_u_n_n_i_n_g defines the command to execute if the
    required DDE server is not present.


sshheellll__rreeggiisstteerr__pprroolloogg((_+_E_x_t))
    Default registration of  SWI-Prolog, which is invoked as part of the
    initialisation  process on  Windows  systems.   As  the source  also
    explains the above predicates, it is given as an example:

    shell_register_prolog(Ext) :-
            current_prolog_flag(argv, [Me|_]),
            concat_atom(['"', Me, '" "%1"'], OpenCommand),
            shell_register_file_type(Ext, 'prolog.type', 'Prolog Source',
                                     OpenCommand),
            shell_register_dde('prolog.type', consult,
                               prolog, control, 'consult(''%1'')', Me),
            shell_register_dde('prolog.type', edit,
                               prolog, control, 'edit(''%1'')', Me).


1111..2222 simplex::  SSoollvvee lliinneeaarr pprrooggrraammmmiinngg pprroobblleemmss

                                                  Author:  _M_a_r_k_u_s _T_r_i_s_k_a

A linear programming problem consists of a set  of (linear) constraints,
a number  of variables and  a linear  objective function.   The goal  is
to assign values  to the variables so  as to maximize (or minimize)  the
value of the objective function while satisfying all constraints.

Many optimization problems can be modeled in this way.   Consider having
a knapsack with fixed capacity C, and a number of  items with sizes s(i)
and values v(i).   The goal is to  put as many items as possible  in the
knapsack (not exceeding its capacity) while maximizing the  sum of their
values.

As another example,  suppose you are given  a set of coins with  certain
values, and you are to find the minimum number of  coins such that their
values  sum up  to a  fixed amount.    Instances of  these problems  are
solved below.

The simplex module provides the following predicates:


aassssiiggnnmmeenntt((_+_C_o_s_t_, _-_A_s_s_i_g_n_m_e_n_t))
    _C_o_s_t  is a  list of  lists representing the  quadratic cost  matrix,
    where  element  (i,j) denotes  the  cost of  assigning  entity i  to
    entity  j.  An assignment with minimal cost is  computed and unified
    with  _A_s_s_i_g_n_m_e_n_t  as a  list  of lists,  representing  an  adjacency
    matrix.


ccoonnssttrraaiinntt((_+_C_o_n_s_t_r_a_i_n_t_, _+_S_0_, _-_S))
    Adds  a  linear  or integrality  constraint  to the  linear  program
    corresponding  to state  _S_0.   A linear  constraint is  of the  form
    "Left  Op C", where "Left"  is a list of Coefficient*Variable  terms
    (variables  in  the  context of  linear  programs  can be  atoms  or
    compound terms) and C  is a non-negative numeric constant.  The list
    represents  the sum of its elements.   _O_p can be  =, =< or >=.   The
    coefficient  "1" can be  omitted.   An integrality constraint is  of
    the  form integral(Variable) and constrains Variable to  an integral
    value.


ccoonnssttrraaiinntt((_+_N_a_m_e_, _+_C_o_n_s_t_r_a_i_n_t_, _+_S_0_, _-_S))
    Like  constraint/3, and attaches the name _N_a_m_e (an atom  or compound
    term) to the new constraint.


ccoonnssttrraaiinntt__aadddd((_+_N_a_m_e_, _+_L_e_f_t_, _+_S_0_, _-_S))
    _L_e_f_t  is a list of Coefficient*Variable terms.  The terms  are added
    to  the left-hand side of the constraint  named _N_a_m_e.  _S  is unified
    with the resulting state.


ggeenn__ssttaattee((_-_S_t_a_t_e))
    Generates  an  initial   state  corresponding  to  an  empty  linear
    program.


mmaaxxiimmiizzee((_+_O_b_j_e_c_t_i_v_e_, _+_S_0_, _-_S))
    Maximizes  the  objective function,  stated as  a  list of  "Coeffi-
    cient*Variable" terms that  represents the sum of its elements, with
    respect  to the  linear program  corresponding to state  _S_0.   _S  is
    unified with an internal representation of the solved instance.


mmiinniimmiizzee((_+_O_b_j_e_c_t_i_v_e_, _+_S_0_, _-_S))
    Analogous to maximize/3.


oobbjjeeccttiivvee((_+_S_t_a_t_e_, _-_O_b_j_e_c_t_i_v_e))
    Unifies  _O_b_j_e_c_t_i_v_e with the result of the objective function  at the
    obtained extremum.  _S_t_a_t_e must correspond to a solved instance.


sshhaaddooww__pprriiccee((_+_S_t_a_t_e_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Unifies  _V_a_l_u_e with  the shadow  price corresponding  to the  linear
    constraint  whose name is _N_a_m_e.   _S_t_a_t_e must correspond to a  solved
    instance.


ttrraannssppoorrttaattiioonn((_+_S_u_p_p_l_i_e_s_, _+_D_e_m_a_n_d_s_, _+_C_o_s_t_s_, _-_T_r_a_n_s_p_o_r_t))
    _S_u_p_p_l_i_e_s  and _D_e_m_a_n_d_s  are both lists  of positive  numbers.   Their
    respective  sums  must  be  equal.     _C_o_s_t_s  is  a  list  of  lists
    representing the cost  matrix, where an entry (i,j) denotes the cost
    of transporting  one unit from i to j.  A transportation plan having
    minimum  cost is computed and unified with _T_r_a_n_s_p_o_r_t in the  form of
    a  list of lists  that represents  the transportation matrix,  where
    element (i,j) denotes how many units to ship from i to j.


vvaarriiaabbllee__vvaalluuee((_+_S_t_a_t_e_, _+_V_a_r_i_a_b_l_e_, _-_V_a_l_u_e))
    _V_a_l_u_e  is unified with the value obtained for _V_a_r_i_a_b_l_e.   _S_t_a_t_e must
    correspond to a solved instance.

All numeric  quantities are  converted to  rationals via  rationalize/1,
and rational arithmetic is used throughout solving linear programs.   In
the  current implementation,  all variables  are implicitly  constrained
to  be  non-negative.     This  may  change  in  future  versions,   and
non-negativity constraints should therefore be stated explicitly.


1111..2222..11 EExxaammppllee 11

This is  the "radiation  therapy" example, taken  from "Introduction  to
Operations Research" by Hillier and Lieberman.  DCG  notation is used to
implicitly thread the state through posting the constraints:

:- use_module(library(simplex)).

post_constraints -->
        constraint([0.3*x1, 0.1*x2] =< 2.7),
        constraint([0.5*x1, 0.5*x2] = 6),
        constraint([0.6*x1, 0.4*x2] >= 6),
        constraint([x1] >= 0),
        constraint([x2] >= 0).

radiation(S) :-
        gen_state(S0),
        post_constraints(S0, S1),
        minimize([0.4*x1, 0.5*x2], S1, S).

An example query:

?- radiation(S), variable_value(S, x1, Val1), variable_value(S, x2, Val2).

Val1 = 15 rdiv 2
Val2 = 9 rdiv 2 ;


1111..2222..22 EExxaammppllee 22

Here is  an instance of  the knapsack problem  described above, where  C
= 8,  and we have two types  of items:  One  item with value 7 and  size
6,  and 2  items each  having size  4 and  value 4.    We introduce  two
variables, x(1)  and x(2)  that denote how  many items  to take of  each
type.

knapsack_constrain(S) :-
        gen_state(S0),
        constraint([6*x(1), 4*x(2)] =< 8, S0, S1),
        constraint([x(1)] =< 1, S1, S2),
        constraint([x(2)] =< 2, S2, S).

knapsack(S) :-
        knapsack_constrain(S0),
        maximize([7*x(1), 4*x(2)], S0, S).

An example query yields:

?- knapsack(S), variable_value(S, x(1), X1), variable_value(S, x(2), X2).

X1 = 1
X2 = 1 rdiv 2 ;

That is, we are to take the one item of the first  type, and half of one
of the items of the  other type to maximize the total value of  items in
the knapsack.

If items can not be split, integrality constraints have to be imposed:

knapsack_integral(S) :-
        knapsack_constrain(S0),
        constraint(integral(x(1)), S0, S1),
        constraint(integral(x(2)), S1, S2),
        maximize([7*x(1), 4*x(2)], S2, S).

Now the result is different:

?- knapsack_integral(S), variable_value(S, x(1), X1), variable_value(S, x(2), X2).

X1 = 0
X2 = 2

That  is,  we are  to  take  only the  two  items of  the  second  type.
Notice in particular  that always choosing the remaining item  with best
performance (ratio  of value to  size) that still  fits in the  knapsack
does  not necessarily  yield  an optimal  solution  in the  presence  of
integrality constraints.


1111..2222..33 EExxaammppllee 33

We are given 3 coins  each worth 1, 20 coins each worth 5, and  10 coins
each worth 20 units of  money.  The task is to find a minimal  number of
these coins that amount  to 111 units of money.  We  introduce variables
c(1), c(5) and c(20)  denoting how many coins to take of  the respective
type:

coins -->
        constraint([c(1), 5*c(5), 20*c(20)] = 111),
        constraint([c(1)] =< 3),
        constraint([c(5)] =< 20),
        constraint([c(20)] =< 10),
        constraint([c(1)] >= 0),
        constraint([c(5)] >= 0),
        constraint([c(20)] >= 0),
        constraint(integral(c(1))),
        constraint(integral(c(5))),
        constraint(integral(c(20))),
        minimize([c(1), c(5), c(20)]).

coins(S) :-
        gen_state(S0),
        coins(S0, S).

An example query:

?- coins(S), variable_value(S, c(1), C1), variable_value(S, c(5), C5), variable_value(S, c(20), C20).

C1 = 1
C5 = 2
C20 = 5


1111..2233 tthhrreeaadd__ppooooll..ppll ---- RReessoouurrccee bboouunnddeedd tthhrreeaadd mmaannaaggeemmeenntt

    SSeeee aallssoo  http_handler/3 and http_spawn/2.

The  module library(thread_pool)  manages threads  in  pools.    A  pool
defines  properties of  its member  threads and  the  maximum number  of
threads that can coexist  in the pool.  The call  thread_create_in_pool/4
allocates a thread in the pool, just  like thread_create/3.   If the pool
is fully allocated it can be asked to wait or raise an error.

The  library has  been designed  to deal  with  server application  that
recieve a variety of requests, such as HTTP servers.   Simply starting a
thread for each request is a bit too simple minded for such servers:

  o Creating  many  CPU intensive  threads often  leads  to a  slow-down
    rather than a speedup.

  o Creating many memory intensive threads may exhaust resources

  o Tasks  that require little CPU and memory but take long  waiting for
    external resources can run many threads.

Using this  library, one can define  a pool for  each set of tasks  with
comparable characteristics and create threads in this pool.   Unlike the
worker-pool model,  threads are not started  immediately.  Depending  on
the design, both approaches can be attractive.

The  library is  implemented  by means  of  a  manager thread  with  the
fixed  thread id  __thread_pool_manager.   All  state  is maintained  in
this manager  thread, which  receives and processes  requests to  create
and destroy  pools, create threads  in a pool  and handle messages  from
terminated threads.   Thread pools  are _n_o_t saved  in a saved state  and
must  therefore be  recreated using  the  initialization/1 directive  or
otherwise during startup of the application.


tthhrreeaadd__ppooooll__ccrreeaattee((_+_P_o_o_l_, _+_S_i_z_e_, _+_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Create  a pool  of threads.    A pool  of threads  is a  declaration
    for  creating  threads  with  shared properties  (stack  sizes)  and
    a   limited  number  of  threads.      Threads  are  created   using
    thread_create_in_pool/4.   If all threads  in the  pool are in  use,
    the  behaviour depends on the wait option of  thread_create_in_pool/4
    and  the backlog  option described  below.   _O_p_t_i_o_n_s  are passed  to
    thread_create/3, except for

    bbaacckklloogg((_+_M_a_x_B_a_c_k_L_o_g))
         Maximum number of requests  that can be suspended.   Default is
         infinite.  Otherwise it must be a non-negative integer.   Using
         backlog(0) will never delay thread creation for this pool.

    The  pooling mechanism does _n_o_t interact with the detached  state of
    a  thread.  Threads can be created but detached and normal  and must
    be joined using thread_join/2 if they are not detached.

         bbuugg The  thread  creation option  at_exit is  reserved for
             internal use by this library.


tthhrreeaadd__ppooooll__ddeessttrrooyy((_+_N_a_m_e))                                         _[_d_e_t_]
    Destroy the thread pool named _N_a_m_e.

         EErrrroorrss existence_error(thread_pool, _N_a_m_e).


ccuurrrreenntt__tthhrreeaadd__ppooooll((_?_N_a_m_e))                                      _[_n_o_n_d_e_t_]
    True if _N_a_m_e refers to a defined thread pool.


tthhrreeaadd__ppooooll__pprrooppeerrttyy((_?_N_a_m_e_, _?_P_r_o_p_e_r_t_y))                          _[_n_o_n_d_e_t_]
    True  if  _P_r_o_p_e_r_t_y is  a property  of  thread pool  _N_a_m_e.    Defined
    properties are:

    ooppttiioonnss((_O_p_t_i_o_n_s))
         Thread creation options for this pool

    ffrreeee((_S_i_z_e))
         Number of free slots on this pool

    bbaacckklloogg((_S_i_z_e))
         Number of delayed thread creations on this pool


tthhrreeaadd__ccrreeaattee__iinn__ppooooll((_+_P_o_o_l_, _:_G_o_a_l_, _-_I_d_, _+_O_p_t_i_o_n_s))                  _[_d_e_t_]
    Create  a thread in _P_o_o_l.  _O_p_t_i_o_n_s overrule default  thread creation
    options  associated to the pool.  In addition, the  following option
    is defined:

    wwaaiitt((_+_B_o_o_l_e_a_n))
         If true (default) and the pool is full, wait until  a member of
         the pool completes.  If false, throw a resource_error.

         EErrrroorrss resource_error(threads_in_pool(_P_o_o_l)) is  raised  if
             wait is false or the backlog limit has been reached.


1111..2244 ugraphs::  UUnnwweeiigghhtteedd GGrraapphhss

                          Authors:  _R_i_c_h_a_r_d _O_'_K_e_e_f_e _& _V_i_t_o_r _S_a_n_t_o_s _C_o_s_t_a

    _I_m_p_l_e_m_e_n_t_a_t_i_o_n  _a_n_d  _d_o_c_u_m_e_n_t_a_t_i_o_n _a_r_e  _c_o_p_i_e_d _f_r_o_m  _Y_A_P _5_._0_._1_.
    _T_h_e   ugraph  _l_i_b_r_a_r_y  _i_s  _b_a_s_e_d  _o_n  _c_o_d_e  _o_r_i_g_i_n_a_l_l_y  _w_r_i_t_t_e_n
    _b_y  _R_i_c_h_a_r_d  _O_'_K_e_e_f_e_.     _T_h_e  _c_o_d_e  _w_a_s  _t_h_e_n _e_x_t_e_n_d_e_d  _t_o  _b_e
    _c_o_m_p_a_t_i_b_l_e  _w_i_t_h _t_h_e _S_I_C_S_t_u_s _P_r_o_l_o_g _u_g_r_a_p_h_s  _l_i_b_r_a_r_y_.  _C_o_d_e _a_n_d
    _d_o_c_u_m_e_n_t_a_t_i_o_n  _h_a_v_e _b_e_e_n _c_l_e_a_n_e_d _a_n_d _s_t_y_l_e  _h_a_s _b_e_e_n _c_h_a_n_g_e_d _t_o
    _b_e _m_o_r_e _i_n _l_i_n_e _w_i_t_h _t_h_e _r_e_s_t _o_f _S_W_I_-_P_r_o_l_o_g_.

    _T_h_e  _u_g_r_a_p_h_s  _l_i_b_r_a_r_y  _w_a_s _o_r_i_g_i_n_a_l_l_y  _r_e_l_e_a_s_e_d  _i_n  _t_h_e _p_u_b_l_i_c
    _d_o_m_a_i_n_.   _Y_A_P _i_s  _c_o_n_v_e_r_e_d _b_y _t_h_e _P_e_r_l  _a_r_t_i_s_t_i_c _l_i_c_e_n_s_e_, _w_h_i_c_h
    _d_o_e_s  _n_o_t  _i_m_p_l_y _f_u_r_t_h_e_r  _r_e_s_t_r_i_c_t_i_o_n_s _o_n  _t_h_e  _S_W_I_-_P_r_o_l_o_g _L_G_P_L
    _l_i_c_e_n_s_e_.

The  routines   assume  directed  graphs,   undirected  graphs  may   be
implemented by using two edges.

Originally  graphs  where represented  in  two  formats.    The  SICStus
library and this  version of ugraphs.pl only uses the  _S_-_r_e_p_r_e_s_e_n_t_a_t_i_o_n.
The S-representation of  a graph is a list of  (vertex-neighbors) pairs,
where the pairs are  in standard order (as produced by keysort)  and the
neighbors of  each vertex  are also  in standard order  (as produced  by
sort).   This form  is convenient  for many calculations.   Each  vertex
appears in the S-representation, also if it has no neighbors.


vveerrttiicceess__eeddggeess__ttoo__uuggrraapphh((_+_V_e_r_t_i_c_e_s_, _+_E_d_g_e_s_, _-_G_r_a_p_h))
    Given  a graph  with a set  of _V_e_r_t_i_c_e_s  and a set  of _E_d_g_e_s,  _G_r_a_p_h
    must  unify with the corresponding S-representation.  Note  that the
    vertices  without edges will  appear in _V_e_r_t_i_c_e_s  but not in  _E_d_g_e_s.
    Moreover, it is sufficient for a vertice to appear in _E_d_g_e_s.

    ?- vertices_edges_to_ugraph([],[1-3,2-4,4-5,1-5], L).
    L = [1-[3,5], 2-[4], 3-[], 4-[5], 5-[]]

    In this case all  vertices are defined implicitly.  The next example
    shows three unconnected vertices:

    ?- vertices_edges_to_ugraph([6,7,8],[1-3,2-4,4-5,1-5], L).
    L = [1-[3,5], 2-[4], 3-[], 4-[5], 5-[], 6-[], 7-[], 8-[]] ?


vveerrttiicceess((_+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify   _V_e_r_t_i_c_e_s  with  all  vertices  appearing  in   graph  _G_r_a_p_h.
    Example:

    ?- vertices([1-[3,5],2-[4],3-[],4-[5],5-[]], L).
    L = [1, 2, 3, 4, 5]


eeddggeess((_+_G_r_a_p_h_, _-_E_d_g_e_s))
    Unify  _E_d_g_e_s  with all  edges  appearing  in _G_r_a_p_h.    In  the  next
    example:

    ?- edges([1-[3,5],2-[4],3-[],4-[5],5-[]], L).
    L = [1-3, 1-5, 2-4, 4-5]


aadddd__vveerrttiicceess((_+_G_r_a_p_h_, _+_V_e_r_t_i_c_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with  a new  graph obtained  by adding  the list  of
    _V_e_r_t_i_c_e_s to the _G_r_a_p_h.  Example:

    ?- add_vertices([1-[3,5],2-[]], [0,1,2,9], NG).
    NG = [0-[], 1-[3,5], 2-[], 9-[]]


ddeell__vveerrttiicceess((_+_G_r_a_p_h_, _+_V_e_r_t_i_c_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with a  new graph obtained  by deleting the list  of
    _V_e_r_t_i_c_e_s  and all the  edges that start  from or go  to a vertex  in
    _V_e_r_t_i_c_e_s to the _G_r_a_p_h.  Example:

    ?- del_vertices([2,1],
                    [1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[2,6],8-[]],
                    NL).
    NL = [3-[],4-[5],5-[],6-[],7-[6],8-[]]


aadddd__eeddggeess((_+_G_r_a_p_h_, _+_E_d_g_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with  a new  graph obtained  by adding  the list  of
    edges _E_d_g_e_s to the graph _G_r_a_p_h.  Example:

    ?- add_edges([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[],8-[]],
                 [1-6,2-3,3-2,5-7,3-2,4-5],
                 NL).
    NL = [1-[3,5,6], 2-[3,4], 3-[2], 4-[5], 5-[7], 6-[], 7-[], 8-[]]


ddeell__eeddggeess((_+_G_r_a_p_h_, _+_E_d_g_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with a  new graph obtained  by removing the list  of
    _E_d_g_e_s from the _G_r_a_p_h.   Notice that no vertices are deleted.  In the
    next example:

    ?- del_edges([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[],8-[]],
                 [1-6,2-3,3-2,5-7,3-2,4-5,1-3],
                 NL).
    NL = [1-[5],2-[4],3-[],4-[],5-[],6-[],7-[],8-[]]


ttrraannssppoossee((_+_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with a  new graph obtained  from _G_r_a_p_h by  replacing
    all  edges of the form V1-V2 by edges  of the form V2-V1.   The cost
    is  O(|V|2).  Notice  that an undirected graph is  its own transpose.
    Example:

    ?- transpose([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[],8-[]], NL).
    NL = [1-[],2-[],3-[1],4-[2],5-[1,4],6-[],7-[],8-[]]


nneeiigghhbboouurrss((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify  _V_e_r_t_i_c_e_s with  the  list of  neighbours of  vertex _V_e_r_t_e_x  in
    _G_r_a_p_h.  Example:

    ?- neighbours(4,[1-[3,5],2-[4],3-[],
                     4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).
    NL = [1,2,7,5]


nneeiigghhbboorrss((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    American version of neighbours/3.


ccoommpplleemmeenntt((_+_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Unify _N_e_w_G_r_a_p_h with the graph complementary to _G_r_a_p_h.  Example:

    ?- complement([1-[3,5],2-[4],3-[],
                   4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).
    NL = [1-[2,4,6,7,8],2-[1,3,5,6,7,8],3-[1,2,4,5,6,7,8],
          4-[3,5,6,8],5-[1,2,3,4,6,7,8],6-[1,2,3,4,5,7,8],
          7-[1,2,3,4,5,6,8],8-[1,2,3,4,5,6,7]]


ccoommppoossee((_+_L_e_f_t_G_r_a_p_h_, _+_R_i_g_h_t_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Compose,  by connecting the  _d_r_a_i_n_s of _L_e_f_t_G_r_a_p_h  to the _s_o_u_r_c_e_s  of
    _R_i_g_h_t_G_r_a_p_h.  Example:

    ?- compose([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).
    L = [1-[4], 2-[1,2,4], 3-[]]


uuggrraapphh__uunniioonn((_+_G_r_a_p_h_1_, _+_G_r_a_p_h_2_, _-_N_e_w_G_r_a_p_h))
    _N_e_w_G_r_a_p_h is the union of _G_r_a_p_h_1 and _G_r_a_p_h_2.  Example:

    ?- ugraph_union([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).
    L = [1-[2], 2-[3,4], 3-[1,2,4]]


ttoopp__ssoorrtt((_+_G_r_a_p_h_, _-_S_o_r_t))
    Generate  the set of  nodes _S_o_r_t as  a topological sorting of  graph
    _G_r_a_p_h,  if  one is  possible.    A toplogical  sort  is possible  if
    the  graph is connected  and acyclic.   In the  example we show  how
    topological sorting works for a linear graph:

    ?- top_sort([1-[2], 2-[3], 3-[]], L).
    L = [1, 2, 3]


ttoopp__ssoorrtt((_+_G_r_a_p_h_, _-_S_o_r_t_0_, _-_S_o_r_t))
    Generate the difference  list Sort-Sort0 as a topological sorting of
    graph _G_r_a_p_h, if one is possible.


ttrraannssiittiivvee__cclloossuurree((_+_G_r_a_p_h_, _-_C_l_o_s_u_r_e))
    Generate  the  graph  Closure as  the  transitive closure  of  graph
    _G_r_a_p_h.  Example:

     ?- transitive_closure([1-[2,3],2-[4,5],4-[6]],L).
    L = [1-[2,3,4,5,6], 2-[4,5,6], 4-[6]]


rreeaacchhaabbllee((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify _V_e_r_t_i_c_e_s with the  set of all vertices in graph _G_r_a_p_h that are
    reachable from _V_e_r_t_e_x.  Example:

    ?- reachable(1,[1-[3,5],2-[4],3-[],4-[5],5-[]],V).
    V = [1, 3, 5]


1111..2255 uurrll..ppll ---- AAnnaallyyssiinngg aanndd ccoonnssttrruuccttiinngg UURRLL

    aauutthhoorr
         - Jan Wielemaker
         - Lukas Faulstich

This  library  deals  with the  analysis  and  construction  of  a  URL,
Universal  Resource  Locator.    URL  is  the  basis  for  communicating
locations of resources (data) on the web.  A URL  consists of a protocol
identifier (e.g.    HTTP, FTP,  and a  protocol-specific syntax  further
defining the location.  URLs are standardized in RFC-1738.

The implementation in  this library covers only  a small portion of  the
defined protocols.  Though the initial  implementation followed RFC-1738
strictly, the current  is more relaxed to deal with  frequent violations
of the standard encountered in practical use.


gglloobbaall__uurrll((_+_U_R_L_, _+_B_a_s_e_, _-_G_l_o_b_a_l))                                   _[_d_e_t_]
    Translate a possibly relative _U_R_L into an absolute one.

         EErrrroorrss syntax_error(illegal_url) if _U_R_L is not legal.


iiss__aabbssoolluuttee__uurrll((_+_U_R_L))
    True  if _U_R_L is an absolute _U_R_L.  That is, a _U_R_L that starts  with a
    protocol identifier.


hhttttpp__llooccaattiioonn((_?_P_a_r_t_s_, _?_L_o_c_a_t_i_o_n))
    Construct  or  analyze  an  HTTP  location.    This  is  similar  to
    parse_url/2, but only  deals with the location part of an  HTTP URL.
    That  is, the  path, search and  fragment specifiers.   In the  HTTP
    protocol, the first line of a message is

    <Action> <Location> HTTP/<version>

    __________________________________________________________Parameters_
     _L_o_c_a_t_i_o_n  Atom or list of character codes.


ppaarrssee__uurrll((_+_U_R_L_, _-_A_t_t_r_i_b_u_t_e_s))                                       _[_d_e_t_]


ppaarrssee__uurrll((_+_U_R_L_, _+_B_a_s_e_U_R_L_, _-_A_t_t_r_i_b_u_t_e_s))                             _[_d_e_t_]
    Construct  or analyse  a _U_R_L.  _U_R_L is  an atom  holding a  _U_R_L or  a
    variable.  Parts  is a list of components.  Each component is of the
    format Name(Value).  Defined components are:

    pprroottooccooll((_P_r_o_t_o_c_o_l))
         The used  protocol.    This is,  after  the optional  url:,  an
         identifier  separated  from the  remainder  of  the  _U_R_L  using
         :.   parse_url/2 assumes the  http protocol  if no protocol  is
         specified and  the  _U_R_L can  be  parsed as  a valid  HTTP  url.
         In  addition to  the  RFC-1738 specified  protocols,  the  file
         protocol is supported as well.

    hhoosstt((_H_o_s_t))
         Host-name  or IP-address  on  which  the resource  is  located.
         Supported by all network-based protocols.

    ppoorrtt((_P_o_r_t))
         Integer port-number  to access on  the \arg{Host}.    This only
         appears  if  the port  is  explicitly  specified  in  the  _U_R_L.
         Implicit default ports (e.g.  80 for HTTP) do \emph{not} appear
         in the part-list.

    ppaatthh((_P_a_t_h))
         (File-) path addressed  by the _U_R_L.  This is supported for  the
         ftp, http and file protocols.  If no path  appears, the library
         generates the path /.

    sseeaarrcchh((_L_i_s_t_O_f_N_a_m_e_V_a_l_u_e))
         Search-specification of HTTP  _U_R_L. This is  the part after  the
         ?, normally used to transfer data from HTML forms  that use the
         GET protocol.   In  the _U_R_L it  consists of a  www-form-encoded
         list of Name=Value pairs.   This is mapped to a list  of Prolog
         Name=Value terms with decoded names and values.

    ffrraaggmmeenntt((_F_r_a_g_m_e_n_t))
         Fragment specification of HTTP _U_R_L. This is the  part after the
         # character.

    The example below illustrates the all this for an HTTP _U_R_L.

    ?- parse_url('http://swi.psy.uva.nl/message.cgi?msg=Hello+World%21#x', P).

    P = [ protocol(http),
          host('swi.psy.uva.nl'),
          fragment(x),
          search([ msg = 'Hello World!'
                 ]),
          path('/message.cgi')
        ]

    By  instantiating  the  parts-list this  predicate  can be  used  to
    create a _U_R_L.


wwwwww__ffoorrmm__eennccooddee((_+_V_a_l_u_e_, _-_X_W_W_W_F_o_r_m_E_n_c_o_d_e_d))                          _[_d_e_t_]


wwwwww__ffoorrmm__eennccooddee((_-_V_a_l_u_e_, _+_X_W_W_W_F_o_r_m_E_n_c_o_d_e_d))                          _[_d_e_t_]
    En/Decode  between native value and  application/x-www-form-encoded.
    Maps  space  to  +, keeps  alnum,  maps  anything  else to  %XX  and
    newlines  to  %OD%OA. When  decoding, newlines  appear  as a  single
    newline (10) character.


sseett__uurrll__eennccooddiinngg((_?_O_l_d_, _+_N_e_w))                                   _[_s_e_m_i_d_e_t_]
    Query  and set the  encoding for URLs.   The default  is utf8.   The
    only other defined value is iso_latin_1.

         TToo bbee ddoonnee Having  a global  flag is  highly inconvenient,
             but  a work-around  for  old sites  using ISO  Latin 1
             encoding.


uurrll__iirrii((_+_E_n_c_o_d_e_d_, _-_D_e_c_o_d_e_d))                                        _[_d_e_t_]


uurrll__iirrii((_-_E_n_c_o_d_e_d_, _+_D_e_c_o_d_e_d))                                        _[_d_e_t_]
    Convert between a URL,  encoding in US-ASCII and an IRI. An IRI is a
    fully  expanded Unicode string.   Unicode strings are first  encoded
    into UTF-8, after which %-encoding takes place.


ppaarrssee__uurrll__sseeaarrcchh((_?_S_p_e_c_, _?_F_i_e_l_d_s_:_l_i_s_t_(_N_a_m_e_=_V_a_l_u_e_)))                  _[_d_e_t_]
    Construct or analyze  an HTTP search specification.  This deals with
    form  data using  the MIME-type  =application/x-www-form-urlencoded=
    as used in HTTP GET requests.


ffiillee__nnaammee__ttoo__uurrll((_+_F_i_l_e_, _-_U_R_L))                                       _[_d_e_t_]


ffiillee__nnaammee__ttoo__uurrll((_-_F_i_l_e_, _+_U_R_L))                                   _[_s_e_m_i_d_e_t_]
    Translate between a filename and a file:// _U_R_L.

         TToo bbee ddoonnee Current   implementation  does  not  deal  with
             paths that need special encoding.


CChhaapptteerr 1122..  HHAACCKKEERRSS CCOORRNNEERR

This  appendix  describes  a  number  of  predicates  which  enable  the
Prolog  user  to  inspect the  Prolog  environment  and  manipulate  (or
even redefine)  the debugger.    They can be  used as  entry points  for
experiments with debugging  tools for Prolog.  The  predicates described
here should  be handled  with some  care as it  is easy  to corrupt  the
consistency of the Prolog system by misusing them.


1122..11 EExxaammiinniinngg tthhee EEnnvviirroonnmmeenntt SSttaacckk


pprroolloogg__ccuurrrreenntt__ffrraammee((_-_F_r_a_m_e))
    Unify  _F_r_a_m_e with  an integer  providing a reference  to the  parent
    of  the  current local  stack  frame.    A  pointer to  the  current
    local   frame  cannot   be  provided  as   the  predicate   succeeds
    deterministically  and therefore its frame is  destroyed immediately
    after succeeding.


pprroolloogg__ffrraammee__aattttrriibbuuttee((_+_F_r_a_m_e_, _+_K_e_y_, _-_V_a_l_u_e))
    Obtain  information  about  the local  stack  frame  _F_r_a_m_e.    _F_r_a_m_e
    is  a  frame reference  as obtained  through prolog_current_frame/1,
    prolog_trace_interception/4 or this predicate.   The key values  are
    described below.

    aalltteerrnnaattiivvee
         _V_a_l_u_e is unified with  an integer reference to the  local stack
         frame in  which execution  is  resumed if  the goal  associated
         with _F_r_a_m_e  fails.    Fails  if the  frame has  no  alternative
         frame.

    hhaass__aalltteerrnnaattiivveess
         _V_a_l_u_e is unified  with true if _F_r_a_m_e  still is a candidate  for
         backtracking.  false otherwise.

    ggooaall
         _V_a_l_u_e is unified with the  goal associated with _F_r_a_m_e.   If the
         definition module of the active predicate is not  user the goal
         is represented as <_m_o_d_u_l_e>:<_g_o_a_l>.  Do not instantiate variables
         in this goal  unless you kknnooww  what you are  doing!  Note  that
         the  returned term  may contain  references  to the  frame  and
         should be discarded before the frame terminates.

    ppaarreenntt__ggooaall
         If _V_a_l_u_e  is  instantiated to  a callable  term,  find a  frame
         executing  the  predicate described  by  _V_a_l_u_e  and  unify  the
         arguments of _V_a_l_u_e  to the goal  arguments associated with  the
         frame.    This  is  intended  to check  the  current  execution
         context.  The user  must ensure the checked parent goal  is not
         removed from  the stack  due to last-call  optimisation and  be
         aware of the slow operation on deeply nested calls.

    pprreeddiiccaattee__iinnddiiccaattoorr
         Similar     to    goal,      but     only     returning     the
         [<_m_o_d_u_l_e>:]<_n_a_m_e>/<_a_r_i_t_y>   term   describing  the   term,    not
         the actual arguments.   It avoids  creating an illegal term  as
         goal and is used by the library prolog_stack.

    ccllaauussee
         _V_a_l_u_e is  unified with  a  reference to  the currently  running
         clause.    Fails  if the  current  goal  is associated  with  a
         foreign  (C) defined  predicate.    See  also nth_clause/3  and
         clause_property/2.

    lleevveell
         _V_a_l_u_e is unified  with the recursion level  of _F_r_a_m_e.  The  top
         level frame is at level `0'.

    ppaarreenntt
         _V_a_l_u_e is unified with an integer reference to  the parent local
         stack frame of _F_r_a_m_e.  Fails if _F_r_a_m_e is the top frame.

    ccoonntteexxtt__mmoodduullee
         _V_a_l_u_e is  unified with the  name of the  context module of  the
         environment.

    ttoopp
         _V_a_l_u_e is  unified with  true if _F_r_a_m_e  is the  top Prolog  goal
         from a recursive  call back from the  foreign language.   false
         otherwise.

    hhiiddddeenn
         _V_a_l_u_e is  unified with  true if the  frame is  hidden from  the
         user, either  because a  parent has  the hide-childs  attribute
         (all  system  predicates),  or  the  system   has  no  trace-me
         attribute.

    ppcc
         _V_a_l_u_e is unified  with the program-pointer  saved on behalf  of
         the parent-goal if  the parent-goal is  not owned by a  foreign
         predicate.

    aarrgguummeenntt((_N))
         _V_a_l_u_e is  unified with the _N-th  slot of the  frame.   Argument
         1 is  the first  argument of  the goal.    Arguments above  the
         arity refer to local variables.  Fails silently if _N  is out of
         range.


pprroolloogg__cchhooiiccee__aattttrriibbuuttee((_+_C_h_o_i_c_e_P_o_i_n_t_, _+_K_e_y_, _-_V_a_l_u_e))
    Extract  attributes of a choice-point.   _C_h_o_i_c_e_P_o_i_n_t is a  reference
    to  a choice-point as  passed to  prolog_trace_interception/4on  the
    3-th argument.  _K_e_y specifies the requested information:

    ppaarreenntt
         Requests a reference to the first older choice-point.

    ffrraammee
         Requests a  reference to  the frame to  which the  choice-point
         refers.

    ttyyppee
         Requests  the type.     Defined  values are  clause  (the  goal
         has alternative  clauses),  foreign (non-deterministic  foreign
         predicate),  jump (clause  internal choice-point),  top  (first
         dummy choice-point), catch  (catch/3 to allow for undo),  debug
         (help the debugger), or none (has been deleted).

    This  predicate  is used  for  the graphical  debugger to  show  the
    choice-point stack.


ddeetteerrmmiinniissttiicc((_-_B_o_o_l_e_a_n))
    Unifies  its argument  with true  if no choicepoint  exists that  is
    more  recent  than the  entry of  the clause  in  which is  appears.
    There are few realistic  situations for using this predicate.  It is
    used by the  prolog/0 toplevel to check whether Prolog should prompt
    the  user for alternatives.   Similar results  can be achieved in  a
    more portable fashion using call_cleanup/2.


1122..22 IInntteerrcceeppttiinngg tthhee TTrraacceerr


pprroolloogg__ttrraaccee__iinntteerrcceeppttiioonn((_+_P_o_r_t_, _+_F_r_a_m_e_, _+_C_h_o_i_c_e_, _-_A_c_t_i_o_n))
    Dynamic  predicate, normally not defined.  This predicate  is called
    from  the SWI-Prolog debugger just before it would show a port.   If
    this  predicate succeeds the debugger  assumes the trace action  has
    been  taken care of and continues execution as described  by _A_c_t_i_o_n.
    Otherwise the normal Prolog debugger actions are performed.

    _P_o_r_t  denotes  the reason  to  activate the  tracer (`port'  in  the
    4/5-port, but with some additions:

    ccaallll
         Normal entry through the call-port of the 4-port debugger.

    rreeddoo
         Normal entry  through  the call-port  of the  4-port  debugger.
         The  redo  port  signals  resuming  a  predicate   to  generate
         alternative solutions.

    uunniiffyy
         The unify-port represents the _n_e_c_k instruction,  signalling the
         end  of the  head-matching  process.    This port  is  normally
         invisible.  See leash/1 and visible/1.

    eexxiitt
         The exit-port signals the goal  is proved.  It is  possible for
         the goal to have alternative.   See prolog_frame_attribute/3 to
         examine the goal-stack.

    ffaaiill
         The fail-port signals final failure of the goal.

    eexxcceeppttiioonn((_E_x_c_e_p_t))
         An  exception is  raised  and still  pending.    This  port  is
         activated on  each parent  frame  of the  frame generating  the
         exception until the  exception is caught  or the user  restarts
         normal  computation  using  retry.     _E_x_c_e_p_t  is  the  pending
         exception-term.

    bbrreeaakk((_P_C))
         A break instruction is executed.  _P_C is program counter.   This
         port is used by the graphical debugger.

    ccuutt__ccaallll((_P_C))
         A cut is encountered at _P_C. This port is used  by the graphical
         debugger.  to visualise the effect of the cut.

    ccuutt__eexxiitt((_P_C))
         A cut has  been executed.   See cut_call(_P_C) for more  informa-
         tion.

    _F_r_a_m_e  is  a  reference to  the  current local  stack  frame,  which
    can  be  examined  using  prolog_frame_attribute/3.     _C_h_o_i_c_e  is  a
    reference  to  the  last  choice-point and  can  be  examined  using
    prolog_choice_attribute/3.   _A_c_t_i_o_n  should be unified  with one  of
    the  atoms  continue (just  continue  execution), retry  (retry  the
    current goal) or fail  (force the current goal to fail).  Leaving it
    a variable is identical to continue.

    Together  with  the predicates  described in  section  4.38 and  the
    other  predicates of this chapter this predicate enables  the Prolog
    user  to define a complete new debugger in Prolog.  Besides  this it
    enables  the Prolog programmer monitor  the execution of a  program.
    The  example below records  all goals trapped  by the tracer in  the
    database.

    prolog_trace_interception(Port, Frame, _PC, continue) :-
            prolog_frame_attribute(Frame, goal, Goal),
            prolog_frame_attribute(Frame, level, Level),
            recordz(trace, trace(Port, Level, Goal)).

    To  trace the execution of `go' this way the following  query should
    be given:

    ?- trace, go, notrace.


pprroolloogg__sskkiipp__lleevveell((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d with  the old  value of `skip  level' and  than set  this
    level  according to _N_e_w.   New  is an integer,  or the special  atom
    very_deep  (meaning don't  skip).    The `skip  level' is  a  global
    variable  of the  Prolog system  that disables the  debugger on  all
    recursion  levels deeper than  the level of the  variable.  Used  to
    implement the trace  options `skip' (sets skip level to the level of
    the  frame) and `up'  (sets skip  level to the  level of the  parent
    frame (i.e., the level of this frame minus 1).


1122..33 AAddddiinngg ccoonntteexxtt ttoo eerrrroorrss::  pprroolloogg__eexxcceeppttiioonn__hhooookk

The hook prolog_exception_hook/4 has been introduced in SWI-Prolog 5.6.5
to  provide  dedicated exception  handling  facilities  for  application
frameworks.   For example non-interactive server applications that  wish
to provide extensive context for exceptions for offline debugging.


pprroolloogg__eexxcceeppttiioonn__hhooookk((_+_E_x_c_e_p_t_i_o_n_I_n_, _-_E_x_c_e_p_t_i_o_n_O_u_t_, _+_F_r_a_m_e_, _+_C_a_t_c_h_e_r_F_r_a_m_e))
    This  hook predicate,  if  defined in  the module  user, is  between
    raising  an  exception   and  handling  it.     It  is  intended  to
    allow  a  program  adding  additional context  to  an  exception  to
    simplify  diagnosing  the problem.    _E_x_c_e_p_t_i_o_n_I_n  is the  exception
    term  as  raised  by throw/1  or  one  of the  bullt-in  predicates.
    The  output  argument  _E_x_c_e_p_t_i_o_n_O_u_t  describes  the  exception  that
    is  actually  raised.      _F_r_a_m_e  is  the  innermost  frame.     See
    prolog_frame_attribute/3 and  the library  prolog_stack for  getting
    information  from this.   _C_a_t_c_h_e_r_F_r_a_m_e is  a reference to the  frame
    calling  the  matching  catch/3 or  none  of  the exception  is  not
    caught.

    The  hook is run in `nodebug' mode.  If it succeeds  _E_x_c_e_p_t_i_o_n_O_u_t is
    considered the current  exception.  If it fails, _E_x_c_e_p_t_i_o_n_I_n is used
    for further processing.   The hook is _n_e_v_e_r called recursively.  The
    hook  is _n_o_t allowed to modify  _E_x_c_e_p_t_i_o_n_O_u_t in such as way that  it
    no longer unifies with the catching frame.

    Typically,   prolog_exception_hook/4 is  used  to  fill  the  second
    argument  of error(_F_o_r_m_a_l_, _C_o_n_t_e_x_t) exceptions.   _F_o_r_m_a_l is  defined
    by  the  ISO  standard,   while  SWI-Prolog  defines  _C_o_n_t_e_x_t  as  a
    term  context(_L_o_c_a_t_i_o_n_,  _M_e_s_s_a_g_e).    _L_o_c_a_t_i_o_n is  bound to  a  term
    <_n_a_m_e>/<_a_r_i_t_y>  by the kernel.    This hook can  be used to  add more
    information on the calling context, such as a full stack trace.

    Applications  that use exceptions as part of normal  processing must
    do  a  quick  test  of the  environment  before  starting  expensive
    gathering information on the state of the program.

    The  hook can call  trace/0 to  enter trace mode  immediately.   For
    example  imagine an application  performing an unwanted division  by
    zero while all other  errors are expected and handled.  We can force
    the  debugger using the hook definition  below.  Run the program  in
    debug  mode (see  debug/0) to preserve  as much  as possible of  the
    error context.

    user:prolog_exception_hook(error(evaluation_error(zero_divisor), _),
                               _, _, _) :-
            trace, fail.


1122..44 HHooookkss uussiinngg tthhee eexxcceeppttiioonn pprreeddiiccaattee

This section describes  the predicate exception/3, which can  be defined
by the  user in the module  user as a multifile  predicate.  Unlike  the
name suggests,  this is actually a _h_o_o_k  predicate that has no  relation
to  Prolog exceptions  as  defined by  the  ISO predicates  catch/3  and
throw/1.

The  predicate exception/3  is  called by  the  kernel  on a  couple  of
events, allowing  the user  to `fix' errors  just in time  events.   The
mechanism allows for _l_a_z_y creation of objects such as predicates.


eexxcceeppttiioonn((_+_E_x_c_e_p_t_i_o_n_, _+_C_o_n_t_e_x_t_, _-_A_c_t_i_o_n))
    Dynamic  predicate,  normally not  defined.   Called  by the  Prolog
    system  on run-time exceptions that can be repaired `just  in time'.
    The values for _E_x_c_e_p_t_i_o_n  are described below.  See also catch/3 and
    throw/1.

    If  this  hook predicate  succeeds it  must  instantiate the  _A_c_t_i_o_n
    argument  to the  atom  fail to  make the  operation fail  silently,
    retry  to tell Prolog  to retry the operation  or error to make  the
    system generate an exception.   The action retry only makes sense if
    this  hook modified the environment such that the operation  can now
    succeed without error.

    uunnddeeffiinneedd__pprreeddiiccaattee
         _C_o_n_t_e_x_t is instantiated to  a term _N_a_m_e/_A_r_i_t_y.  _N_a_m_e  refers to
         the name  and _A_r_i_t_y to  the arity  of the undefined  predicate.
         If the definition module of the predicate is  not _u_s_e_r, _C_o_n_t_e_x_t
         will be of the  form <Module>:<_N_a_m_e>/<_A_r_i_t_y>.  If the  predicate
         fails Prolog will generate an existence_error exception.

    uunnddeeffiinneedd__gglloobbaall__vvaarriiaabbllee
         _C_o_n_t_e_x_t  is instantiated  to the  name  of the  missing  global
         variable.  The hook  must call nb_setval/2 or b_setval/2 before
         returning with the action retry.


1122..55 HHooookkss ffoorr iinntteeggrraattiinngg lliibbrraarriieess

Some libraries  realise an entirely new  programming paradigm on top  of
Prolog.   An example is  XPCE which adds  an object-system to Prolog  as
well as an extensive  set of graphical primitives.   SWI-Prolog provides
several hooks to  improve the integration of  such libraries.  See  also
section 4.4  for editing hooks  and section 4.9.3  for hooking into  the
message system.


pprroolloogg__lliisstt__ggooaall((_:_G_o_a_l))
    Hook, normally not defined.   This hook is called by the 'L' command
    of  the  tracer in  the module  user to  list  the currently  called
    predicate.   This hook may be defined to list only  relevant clauses
    of  the indicated  _G_o_a_l  and/or show  the actual  source-code in  an
    editor.  See also portray/1 and multifile/1.


pprroolloogg::ddeebbuugg__ccoonnttrrooll__hhooookk((_:_A_c_t_i_o_n))
    Hook for the  debugger-control predicates that allows the creator of
    more  high-level programming languages  to use the common  front-end
    predicates  to control de  debugger.  For  example, XPCE uses  these
    hooks  to allow for spying methods  rather then predicates.   _A_c_t_i_o_n
    is one of:

    ssppyy((_S_p_e_c))
         Hook in  spy/1.  If  the hook succeeds  spy/1 takes no  further
         action.

    nnoossppyy((_S_p_e_c))
         Hook in nospy/1.   If the hook succeeds spy/1 takes  no further
         action.    If  spy/1  is  hooked,  it is  advised  to  place  a
         complementary hook for nospy/1.

    nnoossppyyaallll
         Hook in nospyall/0.   Should remove all spy-points.   This hook
         is called in a failure-driven loop.

    ddeebbuuggggiinngg
         Hook in  debugging/0.   It can  be used in  two ways.   It  can
         report the status of the additional debug-points  controlled by
         the above hooks  and fail to let  the system report the  others
         or it succeed, overruling the entire behaviour of debugging/0.


pprroolloogg::hheellpp__hhooookk((_+_A_c_t_i_o_n))
    Hook  into help/0 and help/1.   If  the hook succeeds, the  built-in
    actions are not  executed.  For example, ?- help(picture). is caught
    by  the XPCE help-hook to give help  on the class _p_i_c_t_u_r_e.   Defined
    actions are:

    hheellpp
         User entered plain  help/0 to give default  help.  The  default
         performs help(help/1), giving help on help.

    hheellpp((_W_h_a_t))
         Hook in help/1 on the topic _W_h_a_t.

    aapprrooppooss((_W_h_a_t))
         Hook in apropos/1 on the topic _W_h_a_t.


1122..66 HHooookkss ffoorr llooaaddiinngg ffiilleess

All  loading of  source-files is  achieved by  load_files/2.   The  hook
prolog_load_file/2 can be  used to  load Prolog code  from non-files  or
even load entirely different information, such as foreign files.


pprroolloogg__llooaadd__ffiillee((_+_S_p_e_c_, _+_O_p_t_i_o_n_s))
    Load  a single object.  If this  call succeeds, load_files/2 assumes
    the  action has been  taken care of.   This hook  is only called  if
    _O_p_t_i_o_n_s  does not contain the stream(_I_n_p_u_t)  option.  The hook  must
    be defined in the module user.

    The  http_load  provides an example, loading Prolog sources  directly
    from an HTTP server.


pprroolloogg::ccoommmmeenntt__hhooookk((_+_C_o_m_m_e_n_t_s_, _+_P_o_s_, _+_T_e_r_m))
    This  hook allows for  processing ---structured--- comments  encoun-
    tered  by the  compiler.   The  reader collects  all comments  found
    from  the current position to  the end of the  next term.  It  calls
    this  hook providing  a list  of _P_o_s_i_t_i_o_n-_C_o_m_m_e_n_t  in _C_o_m_m_e_n_t_s,  the
    start-position  of the  next term in  _P_o_s and  the next term  itself
    in  _T_e_r_m.  All  positions are stream-position terms.   This hook  is
    exploited  by the documentation system.  See stream_position_data/3.
    See also read_term/3.


1122..77 RReeaaddlliinnee IInntteerraaccttiioonn

The following  predicates are available if  SWI-Prolog is linked to  the
GNU  readline library.    This is  by default  the  case on  non-Windows
installations  and indicated  by the  Prolog flag  readline.   See  also
readline(3)


rrll__rreeaadd__iinniitt__ffiillee((_+_F_i_l_e))
    Read  a readline  initialisation file.   Readline  by default  reads
    ~/.inputrc.     This  predicate  may be  used  to  read  alternative
    readline initialisation files.


rrll__aadddd__hhiissttoorryy((_+_L_i_n_e))
    Add  a  line  to  the  Control-P/Control-N  history  system  of  the
    readline library.


rrll__wwrriittee__hhiissttoorryy((_+_F_i_l_e_N_a_m_e))
    Write  current history to _F_i_l_e_N_a_m_e.   Can be used  from at_halt/1 to
    save the history.


rrll__rreeaadd__hhiissttoorryy((_+_F_i_l_e_N_a_m_e))
    Read history from _F_i_l_e_N_a_m_e, appending to the current history.


CChhaapptteerr 1133..  CCOOMMPPAATTIIBBIILLIITTYY WWIITTHH OOTTHHEERR PPRROOLLOOGG DDIIAALLEECCTTSS

This  chapter explains  issues  for  writing portable  Prolog  programs.
It was  started after discussion  with Vitor  Santos Costa, the  leading
developer  of  YAP   Prolog  YAP  and  SWI-Prolog  have  expressed   the
ambition to enhance the portability beyond the  trivial Prolog examples,
including complex libraries involving foreign code.

Although it  is our  aim to enhance  compatibility, we  are still  faced
with many incompatibilities between the dialects.  As  a first step both
YAP and SWI will provide some instruments that  help developing portable
code.   A first  release of these tools  appeared in SWI-Prolog  5.6.43.
Some of the  facilities are implemented in the  base system.  Others  in
the library dialect.pl.

  o The  Prolog flag dialect is an unambiguous and fast way to  find out
    which  Prolog dialect executes your program.   It has the value  swi
    for SWI-Prolog and yap on YAP.

  o The  Prolog flag version_data is bound  to a term swi(_M_a_j_o_r_,  _M_i_n_o_r_,
    _P_a_t_c_h_, _E_x_t_r_a)

  o Conditional   compilation  using  :- if(Condition)  ...:- endif   is
    supported.  See section 4.3.1.1.

  o The  predicate  expects_dialect/1 allows  for specifying  for  which
    Prolog system the code was written.

  o The  predicates exists_source/1 and source_exports/2 can be used  to
    query  the library content.  The require/1 directive can be  used to
    get access to predicates without knowing their location.

  o The  module predicates use_module/1,  use_module/2have  been extended
    with  a  notion  for  `import-except'  and `import-as'.     This  is
    particulary  useful  together  with  reexport/1  and  reexport/2  to
    compose modules from other modules and mapping names.

  o Foreign  code can expect __SWI_PROLOG__ when compiled for  SWI-Prolog
    and  __YAP_PROLOG__when compiled on YAP.


::-- eexxppeeccttss__ddiiaalleecctt((_+_D_i_a_l_e_c_t))
    This  directive  states that  the code  following  the directive  is
    written  for the  given Prolog  _D_i_a_l_e_c_t.   See  also dialect.    The
    declaration  holds until the  end of the  file in which it  appears.
    The current dialect is available using prolog_load_context/2.

    The   exact  behaviour  of  this  predicate  is  still   subject  to
    discussion.   Of course, if _D_i_a_l_e_c_t matches the running  dialect the
    directive  has no  effect.   Otherwise  we check  for the  existence
    of  library(_d_i_a_l_e_c_t_/_D_i_a_l_e_c_t)  and  load it  if  the file  is  found.
    Currently, this file has this functionality:

      o  Define system  predicates of  the requested dialect  we do  not
         have.

      o  Apply goal_expansion/2  rules that  map conflicting  predicates
         to versions emulating the  requested dialect.  These  expansion
         rules  reside in  the  dialect compatibility  module,  but  are
         applied if prolog_load_context(dialect, Dialect) is active.

      o  Modify  the  search  path  for  library  directories,   putting
         libraries compatible with the target dialect before  the native
         libraries.

      o  Setup  support  for  the  default  filename  extension  of  the
         dialect.


eexxiissttss__ssoouurrccee((_+_S_p_e_c))
    Is  true if  _S_p_e_c exists as  a Prolog source.    _S_p_e_c uses the  same
    conventions as  load_files/2.  Fails without error  if _S_p_e_c cannot be
    found.


ssoouurrccee__eexxppoorrttss((_+_S_p_e_c_, _+_E_x_p_o_r_t))
    Is  true  if source  _S_p_e_c  exports _E_x_p_o_r_t,  a  predicate  indicator.
    Fails without error otherwise.


1133..11 SSoommee ccoonnssiiddeerraattiioonnss ffoorr wwrriittiinngg ppoorrttaabbllee ccooddee

The  traditional  way  to  write  portable  code  is  to  define  custom
predicates  for  all  potentially non-portable  code  and  define  these
separately for  all Prolog  dialects one wishes  to support.   Here  are
some considerations.

  o Probably  the  best reason  for this  is that  it  allows to  define
    minimal  semantics required by  the application for the  portability
    predicates.   Such functionality can often be mapped  efficiently to
    the  target dialect.    Contrary, if  code was  written for  dialect
    X,  the defined semantics are  those of dialect X.   Emulating all
    extreme  cases and full error handling compatibility may  be tedious
    and  result in a much slower  implementation that needed.  Take  for
    example  call_cleanup/2.   The SICStus  definition is  fundamentally
    different from the  SWI definition, but 99% of the applications just
    want to make  calls like below to guarantee _S_t_r_e_a_m_I_n is closed, even
    if process/1 misbehaves.

            call_cleanup(process(StreamIn), close(In))

  o As  a drawback,  the code becomes  full of _m_y___c_a_l_l___c_l_e_a_n_u_p, etc.  and
    every  potential portability conflict  needs to be  abstracted.   It
    is  hard for people  who have to maintain  such code later to  grasp
    the  exact semantics  of the  _m_y___* predicates  and applications  that
    combine  multiple libraries  using this  compatibility approach  are
    likely  to encounter conflicts  between the portability  layers.   A
    good  start  is not  to  use _m_y___*, but  a  prefix derived  from  the
    library  or  application name  or names  that  explain the  intended
    semantics more precisely.

  o Another  problem is  that most  code is initially  not written  with
    portability  in mind.    Instead, ports  are requested  by users  or
    arise from the desire  to switch Prolog dialect.  Typically, we want
    to  achieve compatibility with the  new Prolog dialect with  minimal
    changes,  often keeping compatibility with the  original dialect(s).
    This  problem is  well known  from the  C/Unix world  and we  advice
    anyone  to study the philosophy of GNU autoconf, from which  we will
    illustrate some highlights below.

The  GNU autoconf  suite, known  to  most people  as configure,  was  an
answer to the frustrating life of Unix/C programmers  when Unix dialects
were  about as  abundant  and  poorly standardised  as  Prolog  dialects
today.   Writing a portable  C program can  only be achieved using  cpp,
the C  preprocessor.   The  C preprocessor  performs two  tasks:   macro
expansion and conditional compilation.  Prolog  realises macro expansion
through term_expansion/2 and goal_expansion/2.   Conditional compilation
is  achieved using  :- if(Condition) as  explained  in section  4.3.1.1.
The situation appears similar.

The important lesson learned  from GNU autoconf is that the  _l_a_s_t resort
for conditional compilation  to achieve portability is to switch  on the
platform or dialect.   Instead, GNU  autoconf allows you to write  tests
for specific  properties of  the platform.   Most  of these are  whether
or  not some  function  or file  is  available.    Then there  are  some
standard tests  for difficult-to-write-portable  situations and  finally
there  is a  framework that  allows you  to write  arbitrary C  programs
and check  whether they  can be  compiled and/or whether  they show  the
intended behaviour.   Using  a separate configure  program is needed  in
C, as  you cannot  perform C  compilation step  or run  C programs  from
the C  preprocessor.  In  most Prolog environments  we do not need  this
distinction as the  compiler is integrated into the runtime  environment
and Prolog has excelent reflexion capabilities.

We  must learn  from the  distinction to  test for  features instead  of
platform (dialect), as this makes the platform specific  code robust for
future changes of the dialect.  Suppose we need  compare/3 as defined in
this manual.   The compare/3 predicate is not part of the  ISO standard,
but  many systems  support it  and it  is not  unlikely  it will  become
ISO standard  or the  intended dialect will  start supporting  it.   GNU
autoconf strongly advises to test for the availability:

:- if(\+current_predicate(_, compare(_,_,_))).
compare(<, Term1, Term2) :-
        Term1 @< Term2, !.
compare(>, Term1, Term2) :-
        Term1 @> Term2, !.
compare(=, Term1, Term2) :-
        Term1 == Term2.
:- endif.

This code is  mmuucchh more robust against  changes to the intended  dialect
and, possible  at least  as important,  will provide compatibility  with
dialects you didn't even consider porting to right now.

In a  more challenging case,  the target Prolog  has compare/3, but  the
semantics  are different.    What to  do?    One option  is  to write  a
my_compare/3 and change all occurrences in the code.   Alternatively you
can rename  calls using  goal_expansion/2 like  below.   This  construct
will  not only  deal with  Prolog dialects  lacking compare  as well  as
those that  only implement  it for  numeric comparison  or have  changed
the argument order.   Of course,  writing rock-solid code would  require
a  complete  test-suite,  but  this  example  will  probably  cover  all
Prolog dialects  that allow for conditional  compilation, have core  ISO
facilities and  provide goal_expansion/2, the things  we claim a  Prolog
dialect should have to start writing portable code for it.

:- if(\+catch(compare(<,a,b), _, fail)).
compare_standard_order(<, Term1, Term2) :-
        Term1 @< Term2, !.
compare_standard_order(>, Term1, Term2) :-
        Term1 @> Term2, !.
compare_standard_order(=, Term1, Term2) :-
        Term1 == Term2.

goal_expansion(compare(Order, Term1, Term2),
               compare_standard_order(Order, Term1, Term2)).
:- endif.


CChhaapptteerr 1144..  GGLLOOSSSSAARRYY OOFF TTEERRMMSS

aannoonnyymmoouuss [[vvaarriiaabbllee]]
      The  variable  _ is  called  the  _a_n_o_n_y_m_o_u_s variable.     Multiple
    occurrences of _ in a single _t_e_r_m are not _s_h_a_r_e_d.

aarrgguummeennttss
    Arguments  are _t_e_r_m_s that appear in a _c_o_m_p_o_u_n_d _t_e_r_m.  _A_1  and _a_2 are
    the first and second argument of the term myterm(_A_1_, _a_2).

aarriittyy
    Argument count (is number of arguments) of a _c_o_m_p_o_u_n_d _t_e_r_m.

aasssseerrtt
    Add a _c_l_a_u_s_e to  a _p_r_e_d_i_c_a_t_e.  Clauses can be added at either end of
    the clause-list of a _p_r_e_d_i_c_a_t_e.  See assert/1 and assertz/1.

aattoomm
    Textual  constant.   Used as name for  _c_o_m_p_o_u_n_d terms, to  represent
    constants or text.

bbaacckkttrraacckkiinngg
    Searching  process used by Prolog.   If a predicate offers  multiple
    _c_l_a_u_s_e_s  to  solve  a _g_o_a_l,  they  are  tried one-by-one  until  one
    _s_u_c_c_e_e_d_s.    If  a subsequent  part of  the proof  is not  satisfied
    with  the resulting _v_a_r_i_a_b_l_e _b_i_n_d_i_n_g, it may ask for  an alternative
    _s_o_l_u_t_i_o_n (= _b_i_n_d_i_n_g  of the _v_a_r_i_a_b_l_e_s), causing Prolog to reject the
    previously chosen _c_l_a_u_s_e and try the next one.

bbiinnddiinngg [[ooff aa vvaarriiaabbllee]]
    Current value of the _v_a_r_i_a_b_l_e.  See also _b_a_c_k_t_r_a_c_k_i_n_g and _q_u_e_r_y.

bbuuiilltt--iinn [[pprreeddiiccaattee]]
    Predicate  that is part of the  Prolog system.  Built in  predicates
    cannot  be redefined  by the  user, unless this  is overruled  using
    redefine_system_predicate/1.

bbooddyy
    Part of a _c_l_a_u_s_e behind the _n_e_c_k operator (:-).

ccllaauussee
    `Sentence'  of a Prolog program.   A _c_l_a_u_s_e  consists of a _h_e_a_d  and
    _b_o_d_y  separated by  the _n_e_c_k operator  (:-) or it  is a _f_a_c_t.    For
    example:

    parent(X) :-
            father(X, _).

    Expressed  ``X is a parent if X is a father of someone''.   See also
    _v_a_r_i_a_b_l_e and _p_r_e_d_i_c_a_t_e.

ccoommppiillee
    Process  where  a Prolog  _p_r_o_g_r_a_m  is translated  to a  sequence  of
    instructions.   See  also _i_n_t_e_r_p_r_e_t_e_d.   SWI-Prolog always  compiles
    your program before executing it.

ccoommppoouunndd [[tteerrmm]]
    Also  called  _s_t_r_u_c_t_u_r_e.    It  consists of  a  name followed  by  _N
    _a_r_g_u_m_e_n_t_s,  each of which are _t_e_r_m_s.   _N is called the _a_r_i_t_y  of the
    term.

ccoonntteexxtt mmoodduullee
    If  a _t_e_r_m  is referring  to a _p_r_e_d_i_c_a_t_e  in a  _m_o_d_u_l_e, the  _c_o_n_t_e_x_t
    _m_o_d_u_l_e  is used to find the target module.  The context  module of a
    _g_o_a_l  is the module in which  the _p_r_e_d_i_c_a_t_e is defined, unless  this
    _p_r_e_d_i_c_a_t_e  is _m_o_d_u_l_e _t_r_a_n_s_p_a_r_e_n_t, in  which case the _c_o_n_t_e_x_t  _m_o_d_u_l_e
    is inherited from the parent _g_o_a_l.  See also module_transparent/1.

ddyynnaammiicc [[pprreeddiiccaattee]]
    A _d_y_n_a_m_i_c predicate  is a predicate to which _c_l_a_u_s_e_s may be _a_s_s_e_r_ted
    and  from  which  _c_l_a_u_s_e_s may  be  _r_e_t_r_a_c_ted  while the  program  is
    running.  See also _u_p_d_a_t_e _v_i_e_w.

eexxppoorrtteedd [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e is  said to  be _e_x_p_o_r_t_e_d from  a _m_o_d_u_l_e  if it  appears
    in  the  _p_u_b_l_i_c _l_i_s_t.     This implies  that  the predicate  can  be
    _i_m_p_o_r_t_e_d  into another module  to make it visible  there.  See  also
    use_module/[1,2].

ffaacctt
    _C_l_a_u_s_e  without a _b_o_d_y.   This is called a fact because  interpreted
    as logic, there is  no condition to be satisfied.  The example below
    states john is a person.

    person(john).

ffaaiill
    A _g_o_a_l is said to haved failed if it could not be _p_r_o_v_e_n.

ffllooaatt
    Computers crippled representation  of a real number.  Represented as
    `IEEE double'.

ffoorreeiiggnn
    Computer code expressed  in other languages than Prolog.  SWI-Prolog
    can only cooperate directly with the C and C++ computer languages.

ffuunnccttoorr
    Combination  of name and _a_r_i_t_y of a _c_o_m_p_o_u_n_d term.  The  term foo(_a_,
    _b_,  _c) is said to be a  term belonging to the functor foo/3.   foo/0
    is used to refer to the _a_t_o_m foo.

ggooaall
    Question  stated to the Prolog engine.  A _g_o_a_l is either  an _a_t_o_m or
    a  _c_o_m_p_o_u_n_d term.  A _g_o_a_l  succeeds, in which case the  _v_a_r_i_a_b_l_e_s in
    the _c_o_m_p_o_u_n_d terms have  a _b_i_n_d_i_n_g or _f_a_i_l_s if Prolog fails to prove
    the _g_o_a_l.

hhaasshhiinngg
    _I_n_d_e_x_i_n_g technique used for quick lookup.

hheeaadd
    Part  of a _c_l_a_u_s_e before the _n_e_c_k  instruction.  This is an  atom or
    _c_o_m_p_o_u_n_d term.

iimmppoorrtteedd [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e is said to be _i_m_p_o_r_t_e_d  into a _m_o_d_u_l_e if it  is defined
    in  another _m_o_d_u_l_e  and made  available in this  _m_o_d_u_l_e.   See  also
    chapter 5.

iinnddeexxiinngg
    Indexing  is a  technique used to  quickly select candidate  _c_l_a_u_s_e_s
    of  a  _p_r_e_d_i_c_a_t_e for  a specific  _g_o_a_l.    In most  Prolog  systems,
    including  SWI-Prolog, indexing  is done  on the  first _a_r_g_u_m_e_n_t  of
    the  _h_e_a_d.  If  this argument is  instantiated to an _a_t_o_m,  _i_n_t_e_g_e_r,
    _f_l_o_a_t or _c_o_m_p_o_u_n_d  term with _f_u_n_c_t_o_r, _h_a_s_h_i_n_g is used quickly select
    all  _c_l_a_u_s_e_s of which  the first argument  may _u_n_i_f_y with the  first
    argument of the _g_o_a_l.

iinntteeggeerr
    Whole number.   On all implementations of SWI-Prolog integers are at
    least  64-bit signed values.   When linked  to the GNU GMP  library,
    integer  arithmetic is unbounded.    See also current_prolog_flag/2,
    flags bounded, max_integer and min_integer.

iinntteerrpprreetteedd
    As  opposed  to  _c_o_m_p_i_l_e_d,   interpreted  means  the  Prolog  system
    attempts  to prove  a _g_o_a_l  by directly reading  the _c_l_a_u_s_e_s  rather
    than executing instructions  from an (abstract) instruction set that
    is not or only indirectly related to Prolog.

mmeettaa--pprreeddiiccaattee
    A  _p_r_e_d_i_c_a_t_e that reasons about other _p_r_e_d_i_c_a_t_e_s, either  by calling
    them, (re)defining them or querying _p_r_o_p_e_r_t_i_e_s.

mmoodduullee
    Collection  of predicates.    Each module defines  a name-space  for
    predicates.   _b_u_i_l_t_-_i_n predicates  are accessible from all  modules.
    Predicates  can be published (_e_x_p_o_r_t_e_d)  and _i_m_p_o_r_t_e_d to make  their
    definition available to other modules.

mmoodduullee ttrraannssppaarreenntt [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e that  does not change  the _c_o_n_t_e_x_t  _m_o_d_u_l_e.   Sometimes
    also called a _m_e_t_a_-_p_r_e_d_i_c_a_t_e.

mmuullttiiffiillee [[pprreeddiiccaattee]]
    Predicate  for which  the  definition is  distributed over  multiple
    source-files.  See multifile/1.

nneecckk
    Operator (:-) separating _h_e_a_d from _b_o_d_y in a _c_l_a_u_s_e.

ooppeerraattoorr
    Symbol (_a_t_o_m) that  may be placed before its _o_p_e_r_a_n_d (prefix), after
    its _o_p_e_r_a_n_d (postfix) or between its two _o_p_e_r_a_n_d_s (infix).

    In  Prolog, the expression a+b is exactly the same as  the canonical
    term +(a,b).

ooppeerraanndd
    _A_r_g_u_m_e_n_t of an _o_p_e_r_a_t_o_r.

pprreecceeddeennccee
    The  _p_r_i_o_r_i_t_y  of an  _o_p_e_r_a_t_o_r.    Operator  precedence is  used  to
    interpret a+b*c as +(a, *(b,c)).

pprreeddiiccaattee
    Collection  of _c_l_a_u_s_e_s  with the same  _f_u_n_c_t_o_r (name/_a_r_i_t_y).   If  a
    _g_o_a_l  is proved,  the system  looks for  a _p_r_e_d_i_c_a_t_e  with the  same
    functor,  then used  _i_n_d_e_x_i_n_g to select  candidate _c_l_a_u_s_e_s and  then
    tries these _c_l_a_u_s_e_s one-by-one.  See also _b_a_c_k_t_r_a_c_k_i_n_g.

pprreeddiiccaattee iinnddiiccaattoorr
    Term  of the form Name/Arity  (traditional) or Name//Arity (ISO  DCG
    proposal)  where Name is  an atom an  Arity a non-negative  integer.
    It acts as an _i_n_d_i_c_a_t_o_r (or reference) to a predicate or _D_C_G rule.

pprriioorriittyy
    In the context of _o_p_e_r_a_t_o_r_s a synonym for _p_r_e_c_e_d_e_n_c_e.

pprrooggrraamm
    Collection of _p_r_e_d_i_c_a_t_e_s.

pprrooppeerrttyy
    Attribute  of  an object.    SWI-Prolog  defines  various _*___p_r_o_p_e_r_t_y
    predicates to query the status of predicates, clauses.  etc.

pprroovvee
    Process  where Prolog attempts to prove a _q_u_e_r_y using  the available
    _p_r_e_d_i_c_a_t_e_s.

ppuubblliicc lliisstt
    List of _p_r_e_d_i_c_a_t_e_s exported from a _m_o_d_u_l_e.

qquueerryy
    See _g_o_a_l.

rreettrraacctt
    Remove  a _c_l_a_u_s_e from a  _p_r_e_d_i_c_a_t_e.   See also _d_y_n_a_m_i_c, _u_p_d_a_t_e  _v_i_e_w
    and _a_s_s_e_r_t.

sshhaarreedd
    Two  _v_a_r_i_a_b_l_e_s  are called  _s_h_a_r_e_d after  they are  _u_n_i_f_i_e_d.    This
    implies  if either of them is _b_o_u_n_d, the other is bound to  the same
    value:

    ?- A = B, A = a.

    A = a,
    B = a

ssiinngglleettoonn [[vvaarriiaabbllee]]
    _V_a_r_i_a_b_l_e  appearing only one time in a _c_l_a_u_s_e.   SWI-Prolog normally
    warns  for  this to  avoid  you  making spelling  mistakes.    If  a
    variable  appears on  purpose only  once in  a clause,  write it  as
    _  (see _a_n_o_n_y_m_o_u_s).    Rules for naming  a variable  and avoiding  a
    warning are given in section 2.15.1.5.

ssoolluuttiioonn
    _B_i_n_d_i_n_g_s resulting from a successfully _p_r_o_v_en _g_o_a_l.

ssttrruuccttuurree
    Synonym for _c_o_m_p_o_u_n_d term.

ssttrriinngg
    Used  for the  following representations  of text:   a packed  array
    (see section 4.23),  SWI-Prolog specific), a list of character codes
    or a list of one-character _a_t_o_m_s.

ssuucccceeeedd
    A _g_o_a_l is said to have _s_u_c_c_e_e_d_e_d if it has been _p_r_o_v_e_n.

tteerrmm
    Value in Prolog.   A _t_e_r_m is either a _v_a_r_i_a_b_l_e, _a_t_o_m, integer, float
    or  _c_o_m_p_o_u_n_d term.   In addition,  SWI-Prolog also defines the  type
    _s_t_r_i_n_g

ttrraannssppaarreenntt
    See _m_o_d_u_l_e _t_r_a_n_s_p_a_r_e_n_t.

uunniiffyy
    Prolog  process to make  two terms equal  by assigning variables  in
    one term to  values at the corresponding location of the other term.
    For example:

    ?- foo(a, B) = foo(A, b).

    A = a,
    B = b

    Unlike  assignment (which does not exist in Prolog),  unification is
    not directed.

uuppddaattee vviieeww
    How  Prolog behaves when a _d_y_n_a_m_i_c _p_r_e_d_i_c_a_t_e is changed while  it is
    running.   There are two models.   In most older Prolog  systems the
    change  becomes immediately visible to  the _g_o_a_l, in modern  systems
    including  SWI-Prolog, the running _g_o_a_l is  not affected.  Only  new
    _g_o_a_l_s `see' the new definition.

vvaarriiaabbllee
    A  Prolog  variable is  a value  that `is  not yet  bound'.    After
    _b_i_n_d_i_n_g a variable, it  cannot be modified.  _B_a_c_k_t_r_a_c_k_i_n_g to a point
    in  the execution before  the variable was  bound will turn it  back
    into a variable:

    ?- A = b, A = c.
    No
    ?- (A = b; true; A = c).
    A = b ;
    A = _G283 ;
    A = c ;
    No

    See also _u_n_i_f_y.


CChhaapptteerr 1155..  SSWWII--PPRROOLLOOGG LLIICCEENNSSEE CCOONNDDIITTIIOONNSS AANNDD TTOOOOLLSS

SWI-Prolog licensing aims at a large audience, combining  ideas from the
Free Software Foundation and the less principal  Open Source Initiative.
The license aims at:

  o Make SWI-Prolog itself and its libraries are `As free as possible'.

  o Allow for easy integration of contributions.  See section 15.2.

  o Free software can build on SWI-Prolog without limitations.

  o Non-free  (open  or  proprietary)  software can  be  produced  using
    SWI-Prolog,  although contributed pure  GPL-ed components cannot  be
    used.

To achieve this, different parts of the system  have different licenses.
SWI-Prolog  programs consists  of  a mixture  of `native'  code  (source
compiled to  machine instructions)  and `virtual  machine' code  (Prolog
source  compiled to  SWI-Prolog virtual  machine instructions,  covering
both compiled SWI-Prolog libraries and your compiled application).

For  maximal coherence  between free  licenses, we  start  with the  two
prime  licenses from  the  Free  Software Foundation,  the  GNU  General
Public License (GPL)  and the Lesser GNU General Public  License (LGPL),
after which we add a proven (used by the  GNU-C compiler runtime library
as  well as  the  GNU _C_l_a_s_s_P_a_t_h  project)  exception  to deal  with  the
specific nature of compiled virtual machine code in a saved state.


1155..11 TThhee SSWWII--PPrroolloogg kkeerrnneell aanndd ffoorreeiiggnn lliibbrraarriieess

The SWI-Prolog  kernel and our foreign  libraries are distributed  under
the  LLGGPPLL. A  Prolog executable  consists of  the  combination of  these
`native'  code  components  and  Prolog  virtual  machine  code.     The
SWI-Prolog  plrc  utility allows  for  disassembling  and  re-assembling
these parts, a process satisfying article 66bb of the LGPL.

Under  the LGPL  SWI-Prolog  can be  linked  to code  distributed  under
arbitrary licenses,  provided a number  of requirements are  fullfilled.
The most  important requirement is  that, if  an application replies  on
a _m_o_d_i_f_i_e_d  version of  SWI-Prolog, the  modified sources  must be  made
available.


1155..11..11 TThhee SSWWII--PPrroolloogg PPrroolloogg lliibbrraarriieess

Lacking a  satisfactory technical solution  to handle  article 66 of  the
LGPL, this  license cannot be  used for the Prolog  source code that  is
part of the  SWI-Prolog system (both libraries  and kernel code).   This
situation is  comparable to libgcc,  the runtime  library used with  the
GNU C-compiler.    Therefore, we use  the same  proven license terms  as
this library.    The libgcc  license is  the with  a special  exception.
Below we rephrased this exception adjusted to our needs:

    _A_s  _a _s_p_e_c_i_a_l  _e_x_c_e_p_t_i_o_n_, _i_f _y_o_u  _l_i_n_k _t_h_i_s  _l_i_b_r_a_r_y _w_i_t_h _o_t_h_e_r
    _f_i_l_e_s_,  _c_o_m_p_i_l_e_d  _w_i_t_h  _a _F_r_e_e  _S_o_f_t_w_a_r_e  _c_o_m_p_i_l_e_r_,  _t_o _p_r_o_d_u_c_e
    _a_n  _e_x_e_c_u_t_a_b_l_e_,  _t_h_i_s  _l_i_b_r_a_r_y  _d_o_e_s _n_o_t  _b_y  _i_t_s_e_l_f  _c_a_u_s_e _t_h_e
    _r_e_s_u_l_t_i_n_g  _e_x_e_c_u_t_a_b_l_e _t_o _b_e  _c_o_v_e_r_e_d _b_y _t_h_e  _G_N_U _G_e_n_e_r_a_l _P_u_b_l_i_c
    _L_i_c_e_n_s_e_.   _T_h_i_s _e_x_c_e_p_t_i_o_n _d_o_e_s _n_o_t _h_o_w_e_v_e_r _i_n_v_a_l_i_d_a_t_e _a_n_y _o_t_h_e_r
    _r_e_a_s_o_n_s  _w_h_y _t_h_e  _e_x_e_c_u_t_a_b_l_e _f_i_l_e _m_i_g_h_t  _b_e _c_o_v_e_r_e_d _b_y  _t_h_e _G_N_U
    _G_e_n_e_r_a_l _P_u_b_l_i_c _L_i_c_e_n_s_e_.


1155..22 CCoonnttrriibbuuttiinngg ttoo tthhee SSWWII--PPrroolloogg pprroojjeecctt

To  achieve maximal  coherence using  SWI-Prolog for  Free and  Non-Free
software we  advice the  use of  the LGPL for  contributed foreign  code
and the  use of the  GPL with SWI-Prolog exception  for Prolog code  for
contributed modules.

As a  rule of thumb  it is  advised to use  the above licenses  whenever
possible and only use a strict GPL compliant license  only if the module
contains other code under strict GPL compliant licenses.


1155..33 SSooffttwwaarree ssuuppppoorrtt ttoo kkeeeepp ttrraacckk ooff lliicceennssee ccoonnddiittiioonnss

Given the above, it is possible that SWI-Prolog  packages and extensions
will  rely  on the  GPL.  The  predicates below  allow  for  registering
license  requirements  for  Prolog files  and  foreign  modules.     The
predicate  eval_license/0 reports  which  components from  the  currenly
configured  system  are  distributed under  copy-left  and  open  source
enforcing  licenses (the  GPL)  and therefore  must be  replaced  before
distributing linked applications under non-free license conditions.


eevvaall__lliicceennssee
    Evaluate  the license conditions of all  loaded components.  If  the
    system  contains  one or  more components  that  are licenced  under
    GPL-like  restrictions the  system indicates this  program may  only
    be  distributed under the  GPL license as  well as which  components
    prohibit the use of other license conditions.


lliicceennssee((_+_L_i_c_e_n_s_e_I_d_, _+_C_o_m_p_o_n_e_n_t))
    Register  the fact  that _C_o_m_p_o_n_e_n_t  is distributed  under a  license
    identified by _L_i_c_e_n_s_e_I_d.  The most important _L_i_c_e_n_s_e_I_d's are:

    sswwiippll
         Indicates this  module  is distributed  under the  GNU  General
         Public License (GPL) with the SWI-Prolog exception:

             _A_s _a  _s_p_e_c_i_a_l _e_x_c_e_p_t_i_o_n_, _i_f _y_o_u _l_i_n_k _t_h_i_s _l_i_b_r_a_r_y _w_i_t_h
             _o_t_h_e_r  _f_i_l_e_s_, _c_o_m_p_i_l_e_d _w_i_t_h _S_W_I_-_P_r_o_l_o_g_,  _t_o _p_r_o_d_u_c_e _a_n
             _e_x_e_c_u_t_a_b_l_e_, _t_h_i_s  _l_i_b_r_a_r_y _d_o_e_s _n_o_t _b_y _i_t_s_e_l_f _c_a_u_s_e _t_h_e
             _r_e_s_u_l_t_i_n_g _e_x_e_c_u_t_a_b_l_e  _t_o _b_e _c_o_v_e_r_e_d _b_y _t_h_e _G_N_U _G_e_n_e_r_a_l
             _P_u_b_l_i_c  _L_i_c_e_n_s_e_.    _T_h_i_s  _e_x_c_e_p_t_i_o_n  _d_o_e_s  _n_o_t _h_o_w_e_v_e_r
             _i_n_v_a_l_i_d_a_t_e  _a_n_y _o_t_h_e_r _r_e_a_s_o_n_s _w_h_y  _t_h_e _e_x_e_c_u_t_a_b_l_e _f_i_l_e
             _m_i_g_h_t _b_e _c_o_v_e_r_e_d _b_y _t_h_e _G_N_U _G_e_n_e_r_a_l _P_u_b_l_i_c _L_i_c_e_n_s_e_.

         This should  be the  default  for software  contributed to  the
         SWI-Prolog  project  as it  allows  the  community  to  prosper
         both in  the free  and non-free  world.    Still, people  using
         SWI-Prolog  to create  non-free  applications  must  contribute
         sources to improvements they make to the community.

    llggppll
         This is the  default license for foreign-libraries linked  with
         SWI-Prolog.   Use PL_license() to  register the condition  from
         foreign code.

    ggppll
         Indicates this module is strictly Free Software,  which implies
         it  cannot   be  used   together  with  any   module  that   is
         incompatible with  the GPL.  Please only  use these  conditions
         when forced by other code used in the component.

    Other  licenses known to the system are guile,  gnu_ada,  x11, expat,
    sml,  public_domain,  cryptix, bsd,  zlib,  constlgpl_compatible  and
    gpl_compatible.    New licenses  can be  defined  by adding  clauses
    for  the  multifile  predicate  license:license/3.     Below  is  an
    example.   The  second argument  is either gpl  or lgpl to  indicate
    compatibility  with these licenses.  Other values cause  the license
    to  interpreted as _p_r_o_p_r_i_e_t_a_r_y.   Proprietary licenses are  reported
    by eval_license/0.  See the file boot/license.pl for details.

    :- multifile license:license/3.

    license:license(mylicense, lgpl,
                    [ comment('My personal license'),
                      url('http://www.mine.org/license.html')
                    ]).

    :- license(mylicense).


lliicceennssee((_+_L_i_c_e_n_s_e_I_d))
    Intented  as a  directive  in Prolog  source files.    It takes  the
    current filename and calls license/2.


void PPLL__lliicceennssee(_c_o_n_s_t _c_h_a_r _*_L_i_c_e_n_s_e_I_d_, _c_o_n_s_t _c_h_a_r _*_C_o_m_p_o_n_e_n_t)
    Intended  for the install()  procedure of foreign  libraries.   This
    call can be made _b_e_f_o_r_e PL_initialise().


1155..44 LLiibbrraarryy pprreeddiiccaatteess


1155..44..11 aggregate

 aggregate/3      Aggregate bindings in Goal according to Template.
 aggregate/4      Aggregate bindings in Goal according to Template.
 aggregate_all/3  Aggregate bindings in Goal according to Template.
 aggregate_all/4  Aggregate bindings in Goal according to Template.
 foreach/2        True if the conjunction of instances of Goal using the bindings from Generator is true.
 free_variables/4 In order to handle variables properly, we have to find all the universally quantified variables in the Generator.


1155..44..22 apply

 exclude/3    Filter elements for which Goal fails.
 include/3    Filter elements for which Goal succeed.
 partition/4  Filter elements of List according to Pred.
 partition/5  Filter list according to Pred in three sets.


1155..44..33 assoc

 assoc_to_list/2    Translate assoc into a pairs list
 assoc_to_keys/2    Translate assoc into a key list

 assoc_to_values/2  Translate assoc into a value list
 empty_assoc/1      Test/create an empty assoc
 gen_assoc/3        Non-deterministic enumeration of assoc
 get_assoc/3        Get associated value
 get_assoc/5        Get and replace associated value
 list_to_assoc/2    Translate pair list to assoc
 map_assoc/2        Test assoc values
 map_assoc/3        Map assoc values

 max_assoc/3        Max key-value of an assoc
 min_assoc/3        Min key-value of an assoc
 ord_list_to_assoc/3Translate ordered list into an assoc
 put_assoc/4        Add association to an assoc


1155..44..44 broadcast

 broadcast/1         Send event notification
 broadcast_request/1 Request all agents

 listen/2            Listen to event notifications
 listen/3            Listen to event notifications
 unlisten/1          Stop listening to event notifications
 unlisten/2          Stop listening to event notifications
 unlisten/3          Stop listening to event notifications
 listening/3         Who is listening to event notifications?


1155..44..55 check

 check/0          Program completeness and consistency
 list_undefined/0 List undefined predicates

 list_autoload/0  List predicates that require autoload
 list_redefined/0 List locally redefined predicates


1155..44..66 lists

 append/2        Concatenate a list of lists
 append/3        Concatenate lists

 delete/3        Delete all matching members from a list
 flatten/2       Transform nested list into flat list
 intersection/3  Set intersection
 is_set/1        Type check for a set
 list_to_set/2   Remove duplicates
 max_list/2      Largest number in a list
 member/2        Element is member of a list
 min_list/2      Smallest number in a list

 nextto/3        Y follows X in List
 nth0/3          N-th element of a list (0-based)
 nth1/3          N-th element of a list (1-based)
 numlist/3       Create list of integers in interval
 permutation/2   Test/generate permutations of a list
 reverse/2       Inverse the order of the elements in a list
 select/3        Select element of a list

 selectchk/3     Semi-deterministic selection from a list
 subset/2        Check subset relation for unordered sets
 subtract/3      Delete elements that do not satisfy condition
 sumlist/2       Add all numbers in a list
 union/3         Union of two sets


1155..44..77 option

 merge_options/3 Merge two option lists.
 meta_options/3  Perform meta-expansion on options that are module-sensitive.
 option/2        Get an option from a OptionList.
 option/3        Get an option from a OptionList.
 select_option/3 Get and remove option from an option list.
 select_option/4 Get and remove option with default value.


1155..44..88 ordsets

 ord_empty/1        Test empty ordered set
 list_to_ord_set/2  Create ordered set

 ord_add_element/3  Add element to ordered set
 ord_del_element/3  Delete element from ordered set
 ord_intersect/2    Test non-empty intersection
 ord_intersection/3 Compute intersection
 ord_disjoint/2     Test empty intersection
 ord_subtract/3     Delete set from set
 ord_union/3        Union of two ordered sets
 ord_union/4        Union and difference of two ordered sets

 ord_subset/2       Test subset
 ord_memberchk/2    Deterministically test membership


1155..44..99 prologxref

 prolog:called_by/2    (hook) Extend cross-referencer
 xref_built_in/1       Examine defined built-ins
 xref_called/3         Examine called predicates
 xref_clean/1          Remove analysis of source
 xref_current_source/1 Examine cross-referenced sources
 xref_defined/3        Examine defined predicates
 xref_exported/2       Examine exported predicates
 xref_module/2         Module defined by source

 xref_source/1         Cross-reference analysis of source


1155..44..1100 pairs

 group_pairs_by_key/2Group values with the same key.
 map_list_to_pairs/3 Create a key-value list by mapping each element of List.
 pairs_keys/2        Remove the values from a list of Key-Value pairs.
 pairs_keys_values/3 True if Keys holds the keys of Pairs and Values the values.
 pairs_values/2      Remove the keys from a list of Key-Value pairs.
 transpose_pairs/2   Swap Key-Value to Value-Key and sort the result on Value (the new key) using keysort/2.


1155..44..1111 pio


1155..44..1111..11 pure_input

 phrase_from_file/2   Process the content of File using the DCG rule Grammar.
 phrase_from_file/3   As phrase_from_file/2, providing additional Options.
 stream_to_lazy_list/2Create a lazy list representing the character codes in Stream.


1155..44..1122 readutil

 read_line_to_codes/2  Read line from a stream
 read_line_to_codes/3  Read line from a stream

 read_stream_to_codes/2Read contents of stream
 read_stream_to_codes/3Read contents of stream
 read_file_to_codes/3  Read contents of file
 read_file_to_terms/3  Read contents of file to Prolog terms


1155..44..1133 record

 record/1  Define named fields in a term


1155..44..1144 registry

This library is only available on Windows systems.

 registry_get_key/2        Get principal value of key
 registry_get_key/3        Get associated value of key
 registry_set_key/2        Set principal value of key
 registry_set_key/3        Set associated value of key
 registry_delete_key/1     Remove a key
 shell_register_file_type/4Register a file-type
 shell_register_dde/6      Register DDE action
 shell_register_prolog/1   Register Prolog


1155..44..1155 ugraphs

 vertices_edges_to_ugraph/3Create unweighted graph
 vertices/2                Find vertices in graph
 edges/2                   Find edges in graph
 add_vertices/3            Add vertices to graph
 del_vertices/3            Delete vertices from graph
 add_edges/3               Add edges to graph
 del_edges/3               Delete edges from graph
 transpose/2               Invert the direction of all edges

 neighbors/3               Find neighbors of vertice
 neighbours/3              Find neighbors of vertice
 complement/2              Inverse presense of edges
 compose/3
 top_sort/2                Sort graph topologically
 top_sort/3                Sort graph topologically
 transitive_closure/2      Create transitive closure of graph

 reachable/3               Find all reachable vertices
 ugraph_union/3            Union of two graphs


1155..44..1166 url

 file_name_to_url/2 Translate between a filename and a file:// URL.
 global_url/3       Translate a possibly relative URL into an absolute one.

 http_location/2    Construct or analyze an HTTP location.
 is_absolute_url/1  True if URL is an absolute URL.
 parse_url/2        Construct or analyse a URL.
 parse_url_search/2 Construct or analyze an HTTP search specification.
 set_url_encoding/2 Query and set the encoding for URLs.
 url_iri/2          Convert between a URL, encoding in US-ASCII and an IRI.
 www_form_encode/2  En/Decode between native value and application/x-www-form-encoded.


1155..44..1177 www_browser

 www_open_url/1 Open a web-page in a browser


1155..44..1188 clp/clp_distinct

 all_distinct/1 Demand distinct values
 vars_in/2      Declare domain of variable as set
 vars_in/3      Declare domain of variable as interval


1155..44..1199 clp/clpfd

 #/\/2           P and Q hold.
 #</2            X is less than Y.
 #<==/2          Q implies P.
 #<==>/2         P and Q are equivalent.
 #=/2            X equals Y.
 #=</2           X is less than or equal to Y.
 #==>/2          P implies Q.
 #>/2            X is greater than Y.

 #>=/2           X is greater than or equal to Y.
 #\/1            The reifiable constraint Q does _not_hold.
 #\//2           P or Q holds.
 #\=/2           X is not Y.
 all_different/1 Vars are pairwise distinct.
 all_distinct/1  Like all_different/1, with stronger propagation.
 chain/2         Zs is a list of finite domain variables that are a chain with respect to the partial order Relation, in the order they appear in the li@

 element/3       The N-th element of the list of integers Is is I.
 fd_dom/2        Dom is the current domain (see in/2) of Var.
 fd_inf/2        Inf is the infimum of the current domain of Var.
 fd_size/2       Size is the number of elements of the current domain of Var, or the atom *sup* if the domain is unbounded.
 fd_sup/2        Sup is the supremum of the current domain of Var.
 fd_var/1        True iff Var is a CLP(FD) variable.
 in/2            Var is an element of Domain.
 indomain/1      Bind Var to all feasible values of its domain on backtracking.

 ins/2           The variables in the list Vars are elements of Domain.
 label/1         Equivalent to labeling([], Vars).
 labeling/2      Labeling means systematically trying out values for the finite domain variables Vars until all of them are ground.
 lex_chain/1     Lists are lexicographically non-decreasing.
 serialized/2    Constrain a set of intervals to a non-overlapping sequence.
 sum/3           The sum of elements of the list Vars is in relation Rel to Expr.
 tuples_in/2     Relation must be a list of lists of integers.

 zcompare/3      Analogous to compare/3, with finite domain variables A and B.


1155..44..2200 clpqr

 entailed/1  Check if constraint is entailed
 inf/2       Find the infimum of an expression
 sup/2       Find the supremum of an expression
 minimize/1  Minimizes an expression
 maximize/1  Maximizes an expression
 bb_inf/3    Infimum of expression for mixed-integer problems
 bb_inf/4    Infimum of expression for mixed-integer problems
 bb_inf/5    Infimum of expression for mixed-integer problems

 dump/3      Dump constraints on variables


1155..44..2211 clp/simplex

 assignment/2      Solve assignment problem
 constraint/3      Add linear constraint to state
 constraint/4      Add named linear constraint to state
 constraint_add/4  Extend a named constraint
 gen_state/1       Create empty linear program
 maximize/3        Maximize objective function in to linear constraints
 minimize/3        Minimize objective function in to linear constraints
 objective/2       Fetch value of objective function

 shadow_price/3    Fetch shadow price in solved state
 transportation/4  Solve transportation problem
 variable_value/3  Fetch value of variable in solved state


1155..44..2222 thread_pool

 current_thread_pool/1  True if Name refers to a defined thread pool.
 thread_create_in_pool/4Create a thread in Pool.
 thread_pool_create/3   Create a pool of threads.
 thread_pool_destroy/1  Destroy the thread pool named Name.
 thread_pool_property/2 True if Property is a property of thread pool Name.


Bibliography

[Anjewierden & Wielemaker, 1989]  A.  Anjewierden  and  J.   Wielemaker.
                                  Extensible  objects.  ESPRIT   Project
                                  1098 Technical Report  UvA-C1-TR-006a,
                                  University of Amsterdam, March 1989.

[BIM, 1989]                       BIM  sa/nv,  Everberg,  Belgium.   _B_I_M
                                  _P_r_o_l_o_g _r_e_l_e_a_s_e _2_._4, 1989.

[Bowen _e_t _a_l_., 1983]              D.  L.   Bowen,   L.  M.   Byrd,   and
                                  WF.  Clocksin.   A   portable   Prolog
                                  compiler. In  L. M.  Pereira,  editor,
                                  _P_r_o_c_e_e_d_i_n_g_s _o_f  _t_h_e _L_o_g_i_c  _P_r_o_g_r_a_m_m_i_n_g
                                  _W_o_r_k_s_h_o_p  _1_9_8_3,   Lisabon,   Portugal,
                                  1983. Universidade nova de Lisboa.

[Bratko, 1986]                    I. Bratko. _P_r_o_l_o_g _P_r_o_g_r_a_m_m_i_n_g _f_o_r  _A_r_-
                                  _t_i_f_i_c_i_a_l _I_n_t_e_l_l_i_g_e_n_c_e. Addison-Wesley,
                                  Reading, Massachusetts, 1986.

[Butenhof, 1997]                  David R.  Butenhof.  _P_r_o_g_r_a_m_m_i_n_g  _w_i_t_h
                                  _P_O_S_I_X _t_h_r_e_a_d_s.  Addison-Wesley,  Read-
                                  ing, MA, USA, 1997.

[Byrd, 1980]                      L.  Byrd.  Understanding  the  control
                                  flow   of  Prolog   programs.    _L_o_g_i_c
                                  _P_r_o_g_r_a_m_m_i_n_g _W_o_r_k_s_h_o_p, 1980.

[Clocksin & Melish, 1987]         W.  F.  Clocksin  and  C.  S.  Melish.
                                  _P_r_o_g_r_a_m_m_i_n_g   _i_n  _P_r_o_l_o_g.    Springer-
                                  Verlag, New York,  Third, Revised  and
                                  Extended edition, 1987.

[Demoen, 2002]                    Bart Demoen. Dynamic attributes, their
                                  hProlog implementation,  and  a  first
                                  evaluation. Report CW 350,  Department
                                  of  Computer   Science,    K.U.Leuven,
                                  Leuven,  Belgium,  oct  2002.   URL  =
                                  http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/CW350.abs.html.

[Deransart _e_t _a_l_., 1996]          P.  Deransart,    A.  Ed-Dbali,    and
                                  L. Cervoni.  _P_r_o_l_o_g_:    _T_h_e  _S_t_a_n_d_a_r_d.
                                  Springer-Verlag, New York, 1996.

[Fr"uhwirth, ]                    T.   Fr"uhwirth.   Thom    Fruehwirth's
                                  constraint   handling    rules    web-
                                  site.       http://www.informatik.uni-
                                  ulm.de/pm/mitarbeiter/fruehwirth/chr-
                                  intro.html.

[Fr"uhwirth, 1998]                T.  Fr"uhwirth.  Theory  and   Practice
                                  of  Constraint  Handling   Rules.   In
                                  P. Stuckey  and K.  Marriot,  editors,
                                  _S_p_e_c_i_a_l  _I_s_s_u_e  _o_n  _C_o_n_s_t_r_a_i_n_t   _L_o_g_i_c
                                  _P_r_o_g_r_a_m_m_i_n_g, volume 37, October 1998.

[Graham _e_t _a_l_., 1982]             Susan L. Graham, Peter B. Kessler, and
                                  Marshall K. McKusick.  gprof:  a  call
                                  graph execution  profiler. In  _S_I_G_P_L_A_N
                                  _S_y_m_p_o_s_i_u_m  _o_n  _C_o_m_p_i_l_e_r  _C_o_n_s_t_r_u_c_t_i_o_n,
                                  pages 120--126, 1982.

[Hodgson, 1998]                   Jonathan     Hodgson.       validation
                                  suite  for   conformance   with   part
                                  1    of    the     standard,     1998,
                                  http://www.sju.edu/~jhodgson/pub/suite.tar.gz.

[Holzbaur, 1992]                  Christian  Holzbaur.    Metastructures
                                  versus  attributed  variables  in  the
                                  context of extensible unification.  In
                                  _P_L_I_L_P,  volume  631,  pages  260--268.
                                  Springer-Verlag, 1992. LNCS 631.

[Kernighan & Ritchie, 1978]       B. W. Kernighan and D. M. Ritchie. _T_h_e
                                  _C _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e. Prentice-Hall,
                                  Englewood Cliffs, New Jersey, 1978.

[Neumerkel, 1993]                 Ulrich    Neumerkel.     The    binary
                                  WAM,   a    simplified   Prolog    en-
                                  gine.    Technical   report,     Tech-
                                  nische   Universit"at    Wien,    1993.
                                  http://www.complang.tuwien.ac.at/ulrich/papers/PDF/binwam-
                                  nov93.pdf.

[O'Keefe, 1990]                   R. A.  O'Keefe. _T_h_e  _C_r_a_f_t _o_f  _P_r_o_l_o_g.
                                  MIT Press, Massachussetts, 1990.

[Pereira, 1986]                   F. Pereira.  _C_-_P_r_o_l_o_g  _U_s_e_r_'_s  _M_a_n_u_a_l.
                                  EdCaad, University of Edinburgh, 1986.

[Qui, 1997]                       AI  International  ltd.,  Berkhamsted,
                                  UK.  _Q_u_i_n_t_u_s _P_r_o_l_o_g_,  _U_s_e_r  _G_u_i_d_e  _a_n_d
                                  _R_e_f_e_r_e_n_c_e _M_a_n_u_a_l, 1997.

[Sterling & Shapiro, 1986]        L.  Sterling  and   E.  Shapiro.   _T_h_e
                                  _A_r_t _o_f _P_r_o_l_o_g.  MIT Press,  Cambridge,
                                  Massachusetts, 1986.

                                  1427


Index

'MANUAL' _l_i_b_r_a_r_y, 43                 read_pending_input/3, 374
--disable-segv-handling, 1077        read_stream_to_codes/2, 1295, 1296
-lpl _l_i_b_r_a_r_y, 1078                   read_stream_to_codes/3, 1296
-lreadline _l_i_b_r_a_r_y, 1106             read_term/2, 60, 389, 391--393, 420
.pl, 91                              read_term/3,  391,  392,  448,  623,
.pro, 91                                   1382
?=/2, 206                            read_term/[2
=:=/2, 461                              3], 391
/\/2, 496                            readutil _l_i_b_r_a_r_y, 96, 1292, 1416
=\=/2, 460                           record _l_i_b_r_a_r_y, 1299, 1417
|/2, 215                             record/1, 1299, 1300
#/\/2, 1175                          recorda/2, 265
#=/2, 1167                           recorda/3, 75, 264, 266, 270,  288,
#<==>/2, 1172                              742, 1041, 1042, 1045
#>=/2, 1165                          recorded/2, 269
#>/2, 1169                           recorded/3, 268, 270, 1096
#=</2, 1166                          recordz/2, 267
#</2, 1170                           recordz/3, 75, 266
#\=/2, 1168                          redefine_system_predicate/1,      11,
#\/1, 1171                                 255, 1393
,/2, 213                             reexport/1, 124, 697, 1388
#\//2, 1176                          reexport/2, 124, 698, 1388
{}/1, 1191                           registry, 80
!/0, 212                             registry _l_i_b_r_a_r_y, 1301, 1418
!/1, 248                             registry_delete_key/1, 1306
/, 92                                registry_get_key/2, 1302
//2, 471                             registry_get_key/3, 1303
./2, 480                             registry_set_key/2, 1304
=/2, 189                             registry_set_key/3, 1305
==/2, 192                            release(), 991
>=/2, 459                            reload_library_index/0, 66
>/2, 456                             rem/2, 473
^/2, 512                             rename_file/2, 602
///2, 474                            repeat/0, 207, 211, 226
->/2, 216                            require/1, 128, 1094, 1388
=</2, 458                            reset_gensym/0, 1214
#<==/2, 1174                         reset_gensym/1, 1213
<</2, 494                            reset_profiler/0, 656, 660
</2, 457                             resource/3,  18,  60,  1091,  1092,
-/1, 466                                   1098, 1100, 1101
-/2, 469                             retract, 1393
\=/2, 190                            retract/1, 123, 131, 252, 253, 256,
\/1, 498                                   272, 277, 278, 291, 720, 807
\==/2, 193                           retractall/1, 252, 253, 257
\+/1, 218                            reverse/2, 690, 1226
\//2, 495                            rl_add_history/1, 1385
+/1, 467                             rl_read_history/1, 1387
+/2, 468                             rl_read_init_file/1, 1384
**/2, 510                            rl_write_history/1, 1386
#==>/2, 1173                         rlimit _l_i_b_r_a_r_y, 25
>>/2, 493                            round/1, 482, 483
;/2, 214
*->/2, 217                           same_file/2, 599
=@=/2, 201                           same_term/2, 410
\=@=/2, 202                          see/1, 20, 297, 299, 312--314
@>=/2, 197                           seeing/1, 312, 313, 317
@>/2, 196                            seek/4, 304, 307, 309
*/2, 470                             seen/0, 319
@=</2, 195                           select/3, 22, 1221
@</2, 194                            select_option/3, 1252
=../2, 399                           select_option/4, 1253
\, 92                                selectchk/3, 1222
_PL_get_arg(), 924                   serialized/2, 1180
64-bits                              set_input/1, 310, 314, 322
   platforms, 85                     set_output/1,s315,e323t_prolog_flag/2,  21,  49, 59,  61,

abolish/1, 17, 253, 254                    455
abolish/2, 254, 862                  set_prolog_IO/3, 311
abolish/[1                           set_prolog_stack/3, 669
   2], 60                            set_stream/2,  77,  299,  304,  310,
abort/0, 41, 51, 60, 299, 310, 619,        311, 329
      765, 816, 1053, 1063           set_stream_position/2, 304, 307, 309
abs/1, 476                           set_tty/2, 562
absolute_file_name/2, 32,  124, 136, set_url_encoding/2, 1357
      605, 607, 615, 1100            setarg/3, 121, 404, 406, 407,  409,
absolute_file_name/3, 60,  62,  116,       410, 725, 750, 1299
      123,   133,  605,  606,  860,  setenv/2, 574
      1048, 1049, 1297, 1298         setlocale/3, 437, 576
absolute_file_name/[2                setof/3, 75, 146, 537
   3], 60, 132, 606                  setup_and_call_cleanup/3, 229
access_file/2, 60, 595, 606          shadow_price/3, 1319
acos/1, 504                          shared, 1393
acquire(), 990                       shell/0, 567, 577
acyclic_term/1, 75, 186, 187         shell/1, 92, 166, 566, 577
add_edges/3, 1337                    shell/2, 565
add_import_module/3, 715, 716        shell/[0-2], 574
add_nb_set/2, 1242                   shell/[1
add_nb_set/3, 1242--1244                2], 565
add_vertices/3, 1335                 shell_register_dde/6, 1308
agent, 1136                          shell_register_file_type/4,     1307,
aggregate _l_i_b_r_a_r_y, 1404                    1308
aggregate/3, 1110                    shell_register_prolog/1, 1309
aggregate/4, 1111                    show_profile/1, 656, 658
aggregate_all/3, 1112                show_profile/2, 657
aggregate_all/4, 1113                sign/1, 477
all_different/1, 1163                silent, 236
all_distinct/1,  1151,  1154,  1156, simplex _l_i_b_r_a_r_y, 1310
      1179                           sin/1, 500
Alpha                                singleton, 1393
   DEC, 16                              variable, 74
AMD64, 86                            size_file/2, 603
anonymous                            size_nb_set/2, 1245
   variable, 74                      skip/1, 367, 368
anonymous variable, 1393             skip/2, 368
append/1, 312, 316                   sleep/1, 686
append/2, 693, 1217                  socket _l_i_b_r_a_r_y, 329
append/3, 421, 1216                  Solaris, 788
apply _l_i_b_r_a_r_y, 1405                  solution, 1393
apply/2, 222                         sort/2, 527, 528,  530, 537,  1235,
apropos/1, 45, 46, 62, 1379                1256, 1258
arg/3, 398                           source_exports/2, 1388, 1391
arithmetic_function/1,   520,   521, source_file/1, 135
      1028                           source_file/2, 136, 159, 291
arity, 1393                          source_file/[1
asin/1, 503                             2], 710
assert, 1393                         source_location/2, 137, 138
assert/1, 123,  131, 252, 258--261,  spy/1, 51, 60,  62, 108, 109,  119,
      272,   277,  278,  291,  701,        121, 642, 828, 829, 1378
      720, 742, 807, 1393            sqrt/1, 499
assert/2, 261--263, 270, 294         stack
asserta/1, 41, 131, 259                 memory management, 81
asserta/2, 262, 270                  stamp_date_time/3, 579, 582, 583
assertion/1, 1210                    startup file, 39
assertions, 1210                     statistics _l_i_b_r_a_r_y, 653
assertz/1, 260, 1393                 statistics/0, 651
assertz/2, 263, 270                  statistics/2, 515, 650, 791
assignment/2, 1311                   stream_position_data/3,   137,   304,
assoc _l_i_b_r_a_r_y, 1121, 1240, 1406            308, 391, 1382
assoc_to_keys/2, 1123                stream_property/2,  78,  299,   304,
assoc_to_list/2, 1122                      307--310, 391
assoc_to_values/2, 1124              stream_to_lazy_list/2, 1280
at_end_of_stream/0, 370              string/1, 181, 182, 553
at_end_of_stream/1, 371, 374         string_concat/3, 421, 442
at_end_of_stream/[0                  string_length/2, 441
   1], 304, 1293                     string_to_atom/2, 439
at_halt/1,   139,  140,   620,  787, string_to_list/2, 440
      1065, 1074, 1386               strip_module/3, 712
at_initialization/1, 139, 141, 1070  structure, 1393
atan/1, 505                          style_check/1, 74, 82, 83, 280, 648
atan/2, 506                          sub_atom/5, 426, 443
atom, 1393                           sub_string/5, 443
atom/1, 180, 892                     subset/2, 1239
atom_chars/2,  60,  122,  327,  355, subsumes/2, 199, 203
      411, 413, 415, 429             subsumes_chk/2, 199, 204
atom_codes/2,   21,  60,  122,  327, subtract/3, 1237
      411--413, 417, 429             succ/2, 453
atom_concat/3, 421, 422, 442         succeed, 1393
atom_length/2, 60, 424, 441          sum/3, 1164
atom_number/2, 327, 417              sumlist/2, 1229
atom_prefix/2, 425                   sup/2, 1194
atom_to_term/3, 420                  swi/pce_profile _l_i_b_r_a_r_y, 653
atomic/1, 182                        swi_edit _l_i_b_r_a_r_y, 167
attach_console/0, 821--823, 1053     swi_help _l_i_b_r_a_r_y, 43
attr_portray_hook/2, 376, 729        swritef/2, 550
attr_unify_hook/2, 723, 728          swritef/3, 327, 549
attribute_goals//1, 734
attribute_goals/3, 723, 730          TAB
attvar/1, 724                           completion, 98
autoload/0, 128, 1092, 1094, 1148    tab/1,t346ab/2, 347

b_getval/2, 744, 746                 tan/1, 502
b_setval/2, 742, 743, 1375           tdebug/0, 825, 829
backcomp _l_i_b_r_a_r_y, 17, 21             tdebug/1, 824, 825, 828
backtracking, 1393                   tell/1, 20,  297,  299,  312,  313,
bagof/3, 75, 146, 534, 536, 537            315, 316
bb_inf/3, 1199                       telling/1, 312, 313, 318
bb_inf/4, 1198                       term, 1393
bb_inf/5, 1197                       term//1, 327
between/3, 452, 1232                 term_expansion/2,  62,  123,   142--
binding, 1393                              146,  150,  159,   623,  762,
bits                                       1392
   64, 84                            term_hash/2, 75, 273--275, 281, 282
blackboard, 1136                     term_hash/4, 273, 275
block/3, 244, 245                    term_to_atom/2, 327, 419, 986
body, 1393                           term_variables/2, 75, 391, 402, 403
BOM, 78                              term_variables/3, 402, 403
break/0, 41, 51, 618, 765, 1053      terms
broadcast, 1136                         cyclic, 75
broadcast _l_i_b_r_a_r_y, 1136, 1407        thread _l_i_b_r_a_r_y, 60
broadcast/1, 1137, 1138              thread_at_exit/1, 781, 787, 839
broadcast_request/1, 1138            thread_create/3,   781,  784,   787,
built-in predicate, 1393                   845, 847
Byte Order Mark, 78                  thread_create_in_pool/4, 1330
byte_count/2, 308, 330               thread_detach/1, 781, 784

call/1,  21,  115, 146,  184,  220,  thread_exit/1,t783,h785,r790ead_get_message/1, 796, 801
      222,   231,  638,  661,  663,  thread_get_message/2, 801
      737, 1006                      thread_initialization/1, 742, 786
call/2, 221                          thread_join/2, 781, 783, 785, 790
call/[2-6], 221                      thread_local/1, 277, 291, 806, 807
call_cleanup/2,  227--229, 327, 785, thread_peek_message/1, 796, 797, 802
      1368, 1392                     thread_peek_message/2, 802
call_cleanup/3, 227, 812             thread_pool _l_i_b_r_a_r_y, 1426
call_cleanup/[2-3], 813              thread_pool_create/3, 1326
call_residue_vars/2, 741             thread_pool_destroy/1, 1327
call_shared_object_function/2, 858   thread_pool_property/2, 1329
call_with_depth_limit/3, 226         thread_property/2,  783,  784,  787,
call_with_time_limit/2, 229                790
callable/1, 184, 1281                thread_self/1, 60, 782, 787, 795
catch/3,  17,  19,  230--233,  244,  thread_send_message/2, 795, 798, 799
      334,   391,  661,  781,  789,  thread_setconcurrency/2, 60, 788
      790, 1367, 1373--1375          thread_signal/2,   229,  805,   816,
ceil/1, 492                                824, 1034
ceiling/1, 491, 492                  thread_statistics/3, 791
chain/2, 1183                        threads/0, 819
char_code/2, 122, 414                throw/1, 17, 51, 75, 230--232, 244,
char_conversion/2, 60, 448, 449            619,  785,  790,   804,  805,
char_type/2, 73, 428--431                  1029, 1031, 1373--1375
character set, 70                    time/1, 515, 652, 655, 656
character_count/2, 308, 330, 331     time_file/2, 604
chdir/1, 615, 616                    tmp_file/2, 612
check _l_i_b_r_a_r_y, 130, 291, 1145, 1408  tnodebug/0, 827
check/0, 128, 1145, 1146             tnodebug/1, 826, 829
check_old_select/0, 22               told/0, 320
checkselect _l_i_b_r_a_r_y, 22              top_sort/2, 1345
chr _l_i_b_r_a_r_y, 762, 766                top_sort/3, 1346
chr_constraint/1, 760, 774           tprofile/1, 830, 831
chr_leash/1, 769                     trace/0, 51,  60,  108,  109,  119,
chr_notrace/0, 765, 768                    631,  637,  767,   768,  805,
chr_option/2, 756, 774                     1053, 1373
chr_show_store/1, 770                trace/1, 60, 636
chr_trace/0, 765, 767                trace/2, 637
chr_type/1, 761                      tracing/0, 632
clause, 1393                         transformation
clause/2, 293, 294                      of program, 143
clause/3, 261, 270, 294, 296, 1096   transitive_closure/2, 1347
clause/[2                            transparent, 1393
   3], 60                            transportation/4, 1320
clause_property/2, 136, 296, 1366    transpose/2, 1339
clib                                 transpose_pairs/2, 1274
   package, 1074                     trim_stacks/0, 60, 666, 668
close/1, 297, 302                    true/0, 60, 210, 226
close/2, 303                         truncate/1, 489
close_dde_conversation/1, 673        tspy/1, 822, 829
close_shared_object/1, 857           tspy/2, 828
clp/clp_distinct   _l_i_b_r_a_r_y,    1150, tty_get_capability/3, 559, 561, 563
      1422                           tty_goto/2, 560, 562
clp/clpfd _l_i_b_r_a_r_y, 1423              tty_put/2, 561, 562
clp/simplex _l_i_b_r_a_r_y, 1425            tty_size/2, 563
clpqr _l_i_b_r_a_r_y, 1189, 1424            ttyflush/0, 350, 548
code_type/2, 427, 429, 430           tuples_in/2, 1178
collate, 435
collation_key/2, 436, 437, 576       UCS, 76
COM, 988                             ugraph _l_i_b_r_a_r_y, 1331
commandline                          ugraph_union/3, 1344
   arguments, 41                     ugraphs _l_i_b_r_a_r_y, 1331, 1419
compare                              ugraphs.pl _l_i_b_r_a_r_y, 1331
   language-specific, 435            Unicode, 76
compare(), 992                       unifiable/3, 199, 205
compare/3, 75, 198, 530, 1039, 1392  unify, 1393
compile_aux_clauses/1, 148           unify_with_occurs_check/2,  60,  199,
compile_predicates/1, 277, 278             200
compiling/0, 142, 159                union/3, 1238
complement/2, 1342                   Unix, 7
completion                           unix, 60
   TAB, 98                           unix/1, 21, 577
compose/3, 1343                      unknown/2, 63, 647, 704, 1107
compound, 1393                       unlisten/1, 1141
compound/1, 183                      unlisten/2, 1142
concat_atom/2, 422, 423              unlisten/3, 1143
concat_atom/3, 423                   unload_foreign_library/1, 862
constraint/3, 1312, 1313             unsetenv/1, 574, 575
constraint/4, 1313                   upcase_atom/2, 428, 432
constraint_add/4, 1314               update view, 272, 1393
consult/1,  36,  39, 53,  62,  106,  URL, 569
      123--126,   158,   159,  279,  url _l_i_b_r_a_r_y, 1247, 1420
      389, 648                       url_iri/2, 1358, 1359
context module, 1393                 use_module/1,  62,  93,   124,  692,
context_module/1, 711, 1012                1388
convert_time/2, 60                   use_module/2,  63,  124,  693,  698,
convert_time/[2                            1388
   8], 604                           use_module/[1
copy_stream_data/2, 373, 374            2], 53, 60, 106, 123,  124, 126,
copy_stream_data/3, 309, 372               691, 694, 699, 713, 1393
copy_term/2, 75, 404, 409, 735, 744  use_modules/1, 697
copy_term/3, 730, 734                user profile file, 39
copy_term_nat/2, 735                 UTF-8, 76
cos/1, 501                           utf-8, 122
cputime/0, 515
ctype _l_i_b_r_a_r_y, 427                   valgrind, 1088
current_arithmetic_function/1, 522   var/1, 12, 173, 724, 892
current_atom/1, 284                  variable, 1393
current_blob/2, 285, 989                anonymous, 1393
current_char_conversion/2, 448, 449  variable_value/3, 1321
current_flag/1, 287                  variant
current_foreign_library/2, 863          term comparison, 201
current_format_predicate/2, 557      vars_in/2, 1151, 1152
current_functor/2, 286               vars_in/3, 1151, 1153
current_input/1, 137, 317, 324       verbose, 41
current_key/1, 288                   vertices/2, 1333
current_module/1, 709                vertices_edges_to_ugraph/3, 1332
current_module/2, 710                view
current_op/3, 446                       update, 1393
current_output/1, 318, 325           visible/1, 646, 1370
current_predicate/1, 290             volatile/1, 291, 807, 1095
current_predicate/2, 289, 290
current_prolog_flag/2, 21,  41,  59, wait_for_input/3, 310, 329
      60,  63,  67,  71, 124,  391,  when _l_i_b_r_a_r_y, 739
      648, 678, 852, 1107, 1393      when/2, 75, 739
current_signal/3, 241, 242           wildcard_match/2, 685
current_stream/3, 305                win_exec/2, 565, 568, 569
current_thread_pool/1, 1328          win_folder/2, 39, 41, 572
cyclic terms, 75                     win_has_menu/0, 591
cyclic_term/1, 75, 186, 187          win_insert_menu/2,w591--593in_insert_menu_item/4, 591, 593
daemon, 1136                         win_registry_get_value/3, 571
date_time_stamp/2, 583               win_shell/2, 565, 569, 570, 1248
date_time_value/3, 579, 584          win_window_pos/1, 590
DCG, 123, 249                        Window interface, 8
dde_current_connection/2, 681        window_title/2, 589
dde_current_service/2, 680           Windows, 7
dde_execute/2, 675                   windows, 60
dde_poke/4, 676                      with_mutex/2, 812, 813, 833
dde_register_service/2, 678          with_output_to/2,   323,  327,   375,
dde_request/3, 674                         417, 434, 554, 585
dde_unregister_service/1, 679        working_directory/2, 577, 606,  615,
debug _l_i_b_r_a_r_y, 118, 1204                   616
debug/0,  51, 233,  637, 639,  640,  write(), 993
      824, 1053, 1373                write/1, 60,  75,  380,  384,  419,
debug/1, 1205, 1207, 1208                  424, 548, 553, 911, 950, 993
debug/3, 1204, 1205                  write/2, 381
debugging                            write_canonical/1, 378, 553
   exceptions, 233                   write_canonical/2, 379, 401
debugging/0,  62,  637, 641,  1209,  write_canonical/[1
      1378                              2], 17
debugging/1, 1204, 1206              write_term/2,  51,  60,  200,  376--
DEC                                        378,  401,  438,   548,  553,
   Alpha, 16                               729
default_module/2, 718                write_term/3, 60, 62, 376, 377, 400
del_attr/2, 727, 731                 write_term/[2
del_edges/3, 1338                       3], 17, 60
del_vertices/3, 1336                 writef/1, 547
delete/3, 1220                       writef/2, 32, 71, 375, 548, 549
delete_directory/1, 614              writef/[1
delete_file/1, 601                      2], 544
delete_import_module/2, 715--717     writeln/1, 546
deterministic/1, 227, 1368           writeq/1, 382, 548, 553
Development environment, 88          writeq/2, 383
dialect.pl _l_i_b_r_a_r_y, 1388             www_browser _l_i_b_r_a_r_y, 1247, 1421
dif _l_i_b_r_a_r_y, 740                     www_form_encode/2, 1355, 1356
dif/2, 75, 190, 206, 739, 740        www_open_url/1, 1248
discontiguous/1, 276, 280
display/1, 548, 950                  X-Windows, 7
display/[1                           X11, 8
   2], 17                            xor/2, 497
displayq/[1                          XPCE, 8
   2], 17                            xref_built_in/1, 1289
do_not_use/1, 696                    xref_called/3, 1286
downcase_atom/2, 428, 431, 432       xref_clean/1, 1284
dump/3, 1200                         xref_current_source/1, 1283
dup/2, 21                            xref_defined/3, 1285
dup_stream/2, 21                     xref_exported/2, 1287
duplicate_term/2,   75,  404,   407, xref_module/2, 1288
      409, 745                       xref_source/1, 1282
dwim_match/2, 292, 683, 684          YAP
dwim_match/3, 684                       prolog, 1388
dwim_predicate/2, 292
dynamic predicate, 1393              zcompare/3, 1182
dynamic/1, 60,  121, 252, 276--278,
      291, 707, 806, 807, 1147

e/0, 514
edges/2, 1334
edit/0, 162
edit/1, 23,  60, 62, 98,  101, 106,
      119,   130,   160--163,  165,
      1147
edit_source/1, 166
editor _c_l_a_s_s, 97, 102
element/3, 1181
elif/1, 152
else/0, 153
Emacs, 42
emacs/[0
   1], 101
emacs/prolog_colour _l_i_b_r_a_r_y, 105
emacs/swi_prolog _l_i_b_r_a_r_y, 23
empty_assoc/1, 1125
empty_nb_set/1, 1241
encoding/1, 77, 129
endif/0, 154
ensure_loaded/1, 53, 123, 126, 692
entailed/1, 1192
erase/1, 261, 264, 270, 294
error _l_i_b_r_a_r_y, 1299
eval/1, 516
eval_license/0, 1398--1400
exception/3, 742, 1374, 1375
exceptions
   debugging, 233
exclude/3, 1118
exists_directory/1, 600
exists_file/1, 60, 596
exists_source/1, 1388, 1390
exit/2, 245, 246
exp/1, 509
expand_answer/2, 623, 624
expand_file_name/2,  60,  124,  574,
      577, 605, 606, 609
expand_file_search_path/2, 133
expand_goal/2,  60,  143, 144,  146,
      147, 151
expand_query/4, 623
expand_term/2, 143--146, 249, 1300
expects_dialect/1, 137, 1388, 1389
explain/1, 47
explain/2, 48
export/1, 694, 704, 713
export_list/2, 694, 714
exported predicate, 1393

fact, 1393
fail/0, 208
fail/1, 247
false/0, 209
fd_dom/2, 1188
fd_inf/2, 1185
fd_size/2, 1187
fd_sup/2, 1186
fd_var/1, 1184
file_base_name/2, 598
file_directory_name/2, 597
file_name_extension/3, 608
file_name_to_url/2, 1361, 1362
file_search_path/2, 39, 41,  60, 63,
      66,  93, 116, 124,  125, 132,
      134,  860, 1049,  1080, 1097,
      1100, 1103
fileerrors/2, 60, 334
find_chr_constraint/1, 771
findall/3, 75, 146,  207, 534, 535,
      720
findall/4, 535
flag/3, 271, 287, 407
flag:abort_with_exception, 60
flag:address_bits, 60
flag:agc_margin, 60
flag:allow_variable_name_as_functor,
      60
flag:arch, 60
flag:argv, 60
flag:associate, 60
flag:autoload, 60
flag:backquoted_string, 60
flag:bounded, 60
flag:c_cc, 60
flag:c_ldflags, 60
flag:c_libs, 60
flag:char_conversion, 60
flag:character_escapes, 60
flag:compiled_at, 60
flag:console_menu, 60
flag:cpu_count, 60
flag:dde, 60
flag:debug, 60
flag:debug_on_error, 60
flag:debugger_print_options, 60
flag:debugger_show_context, 60
flag:dialect, 60
flag:double_quotes, 60
flag:dynamic_stacks, 60
flag:editor, 60
flag:emacs_inferior_process, 60
flag:encoding, 60
flag:executable, 60
flag:file_name_variables, 60
flag:float_format, 60
flag:gc, 60
flag:generate_debug_info, 60
flag:gmp_version, 60
flag:gui, 60
flag:history, 60
flag:home, 60
flag:hwnd, 60
flag:integer_rounding_function, 60
flag:iso, 60
flag:large_files, 60
flag:last_call_optimisation, 60
flag:max_arity, 60
flag:max_integer, 60
flag:max_tagged_integer, 60
flag:max_threads, 60
flag:min_integer, 60
flag:min_tagged_integer, 60
flag:occurs_check, 60
flag:open_shared_object, 60
flag:optimise, 60
flag:pid, 60
flag:pipe, 60
flag:prompt_alternatives_on, 60
flag:readline, 60
flag:report_error, 60
flag:resource_database, 60
flag:runtime, 60
flag:saved_program, 60
flag:shared_object_extension, 60
flag:shared_object_search_path, 60
flag:signals, 60
flag:system_thread_id, 60
flag:timezone, 60
flag:toplevel_print_anon, 60
flag:toplevel_print_options, 60
flag:toplevel_var_size, 60
flag:trace_gc, 60
flag:tty_control, 60
flag:unix, 60
flag:unknown, 60
flag:verbose, 60
flag:verbose_autoload, 60
flag:verbose_file_search, 60
flag:verbose_load, 60
flag:version, 60
flag:version_data, 60
flag:version_git, 60
flag:windows, 60
flag:write_attributes, 60
flag:write_help_with_overstrike, 60
flag:xpce, 60
flag:xpce_version, 60
flatten/2, 1228
float/1, 176, 484
float_fractional_part/1, 487
float_integer_part/1, 488
floor/1, 490
flush_output/0, 348
flush_output/1, 237, 349, 374
flush_output/[0
   1], 299, 350
forall/2, 146, 543
foreach/2, 1114
format/1, 237, 552
format/2, 553, 554, 1205
format/3, 237, 327,  375, 434, 463,
      464, 553, 554
format/[1
   2], 60, 375, 544
format/[2
   3], 71
format_predicate/2, 556
format_time/3, 576, 585
format_time/4, 585, 586
free_variables/4, 1115
freeze/2, 736, 737, 739
frozen/2, 738
functor, 1393
functor/3, 6, 183, 184, 397, 750

garbage_collect/0, 666
garbage_collect_atoms/0, 667, 1066
garbage_collect_clauses/0, 155--157
gdebug/0, 112
gen_assoc/3, 1126
gen_nb_set/2, 1244
gen_state/1, 1315
gensym _l_i_b_r_a_r_y, 1211
gensym/2, 1212
get/1, 359
get/2, 360
get0/1, 299, 357, 358
get0/2, 358
get_assoc/3, 1127
get_assoc/5, 1128
get_attr/3, 726, 731
get_attrs/2, 732, 733
get_byte/1, 351, 357, 361
get_byte/2, 352, 356, 362
get_byte/[1
   2], 122
get_char/1, 353, 355, 365
get_char/2, 356, 366
get_char/[1
   2], 122
get_code/1, 353, 357, 363, 367, 369
get_code/2, 77,  309, 354, 356, 358,
      364, 372, 374
get_code/[1
   2], 122
get_single_char/1, 41, 60, 369
get_time/1, 581, 604, 650
getenv/2, 573, 574, 1248
global_url/3, 1350
GMP, 463
GNU-Emacs, 42
goal, 1393
goal_expansion/2,   123,  143,  144,
      146--148,  150,  1204,  1389,
      1392
Graphics, 8
ground/1, 75, 185, 274, 896
group_pairs_by_key/2, 1273
gspy/1, 113
gtrace/0, 111, 822
GUI, 8
guitracer/0,  23,   108--110,  119,
      630, 634
gxref/0, 47, 116, 1281

halt/0, 51, 620, 621
halt/1, 621, 1053
halt/[0
   1], 140
hash/1, 281, 282
hashing, 1393
head, 1393
help/0, 44, 62, 1098, 1379
help/1, 43--45, 60, 62, 1379
helpidx _l_i_b_r_a_r_y, 43
hooks, 62
html_write _l_i_b_r_a_r_y, 1291
http/http_error _l_i_b_r_a_r_y, 233
http_load _l_i_b_r_a_r_y, 124, 1381
http_location/2, 1352

IA32, 86
IDE, 88
if
   directive, 150
if/1, 151
ignore/1, 146, 225, 661, 781
immediate
   update view, 272
import/1, 691, 694, 704
import_module/2, 715, 716, 718
imported predicate, 1393
in/2, 1158
in_pce_thread/1, 845, 846
include/1, 123, 124, 127, 137
include/3, 1117
index/1, 273, 281, 282, 291
indexing, 1393
indomain/1, 1160
inf/2, 1193
infinite trees, 75
initialization/1,  141,  742,  786,
      853, 1096
ins/2, 1159
integer, 1393
   unbounded, 463
integer/1, 175, 483
interactor/0, 310, 821
internationalization, 76
interpreted, 1393
intersection/3, 1236
is/2, 462, 463, 484, 521, 774, 1229
is_absolute_file_name/1, 607
is_absolute_url/1, 1351
is_list/1, 524, 1234
is_set/1, 1234
is_stream/1, 306
ISO Latin 1, 70
Java, 988
join_threads/0, 820

keysort/2, 529, 530

label/1, 1161
labeling/2, 1162
last/2, 1225
leash/1, 51, 645, 646, 769, 1370
length/2, 526
lex_chain/1, 1177
library_directory/1,  63,  66,  125,
      131
license/1, 1401
license/2, 1400, 1401
line_count/2, 308, 310, 332, 560
line_position/2, 308, 310, 333, 560
list_autoload/0, 1146--1148
list_debug_topics/0, 1204, 1209
list_redefined/0, 1146, 1149
list_to_assoc/2, 1129
list_to_ord_set/2, 1258
list_to_set/2, 1235
list_undefined/0, 130, 1146--1148
listen/2, 1139, 1140
listen/3, 1140--1143
listening/3, 1144
listing/0, 169
listing/1, 51, 168, 169
lists _l_i_b_r_a_r_y, 523, 1215, 1409
load_files/2, 60,  62, 77, 124, 125,
      693, 1281, 1380, 1381, 1390
load_foreign_library/1,  861,  1078,
      1097
load_foreign_library/2, 860, 861
load_foreign_library/[1
   2], 132, 855
locale, 435
locale_sort/2, 436, 437, 576
log/1, 507
log10/1, 508
logical
   update view, 272
lsb/1, 518

MacOS X, 7
make/0,  7, 63,  66, 99,  106, 119,
      124, 130, 155
make_directory/1, 613
make_library_index/1, 63, 64
make_library_index/2, 63, 65
make_library_index/[1
   2], 66
manpce/0, 80
map_assoc/2, 1130
map_assoc/3, 1131
map_list_to_pairs/3, 1275
maplist/2, 539
maplist/3, 540, 702, 1094
maplist/4, 541
max/2, 478, 479, 1230
max_assoc/3, 1132
max_list/2, 1230
maximize/1, 1196
maximize/3, 1316, 1317
member/2, 51,  227, 295,  525, 606,
      693, 1218, 1221
memberchk/2, 525, 1268
memory
   layout, 81
merge/3, 531
merge_options/3, 1254
merge_set/3, 532
message
   service, 1136
message_hook/3, 20, 235--238
message_queue_create/1,  794,   798,
      800
message_queue_create/2, 799
message_queue_destroy/1, 800
message_queue_property/2, 803
message_to_string/2, 236, 238, 239
meta-predicate, 1393
meta_options/3, 693, 1255
meta_predicate/1, 708, 720, 721
min/2, 479, 1231
min_assoc/3, 1133
min_list/2, 1231
minimize/1, 1195
minimize/3, 1317
mod/2, 472
module, 1393
   contex, 1393
module transparent, 1393
module/1, 719
module/2, 144, 444, 690, 706, 713
module_transparent/1,    291,   707,
      720, 1012, 1393
msb/1, 516, 517
msort/2, 528, 529
multifile/1,  160,  276, 279,  291,
      1147, 1377, 1393
must_be/2, 1299
mutex_create/1, 809, 812, 813
mutex_create/2, 810, 817
mutex_destroy/1, 811
mutex_lock/1, 813, 814
mutex_property/2, 817
mutex_statistics/0, 792
mutex_trylock/1, 814
mutex_unlock/1, 815
mutex_unlock_all/0, 816
my_compare/3, 1392
mypred/1, 696

name/2, 411, 418
name_of/2, 1140
nb_current/2, 748
nb_delete/1, 749
nb_getval/2, 746
nb_linkarg/3, 407--409
nb_linkval/2, 408, 409, 747, 750
nb_set _l_i_b_r_a_r_y, 1240
nb_set_to_list/2, 1246
nb_setarg/3,  121,  406--409,  1240,
      1299
nb_setval/2,  407,  409,  742,  745,
      747, 750, 1375
nbset _l_i_b_r_a_r_y, 1240
neck, 1393
neighbors/3, 1341
neighbours/3, 1340, 1341
nextto/3, 1219
nl/0, 336
nl/1, 337
nl/[0
   1], 548
nodebug/0, 640
nodebug/1, 1207, 1208
noguitracer/0, 108, 110, 119, 635
nonvar/1, 174
noprofile/1, 661
noprotocol/0, 628
normalize_space/2, 434
nospy/1, 51, 62, 643, 829, 1378
nospyall/0, 62, 644, 1378
not/1, 146, 223
notrace/0, 633, 767, 768
notrace/1, 638
nth0/3, 1223
nth1/3, 1224
nth_clause/3, 295, 296, 1366
number
   rational, 463
number/1, 179, 1229
number_chars/2, 21, 122, 415, 416
number_codes/2,  21, 122,  411, 416,
      417
numbervars/3, 376, 400, 401
numbervars/4, 378, 400, 401
numbervars/[3
   4], 75
numlist/3, 1232

objective/2, 1318
occurs_check, 200
on_signal/3, 19, 241, 242
once/1,  146, 224,  225, 227,  241,
      327, 638, 652, 812, 1017
op/3, 276, 376, 445, 446
open/3, 60, 297, 298, 300
open/4, 13, 77,  78, 122, 299, 300,
      304,  309,  310,  371,  1297,
      1298
open_dde_conversation/3, 672
open_null_stream/1, 301, 309
open_resource/3,   18,  1091,  1098,
      1101
open_shared_object/2, 60,  852, 855,
      856
open_shared_object/3, 856
operand, 1393
operator, 1393
   and modules, 444
option _l_i_b_r_a_r_y, 1299, 1410
option/2, 1251
option/3, 1250
ord_add_element/3, 1259
ord_del_element/3, 1260
ord_disjoint/2, 1263
ord_empty/1, 1257
ord_intersect/2, 1261, 1263
ord_intersection/3, 1262
ord_list_to_assoc/2, 1134
ord_memberchk/2, 1268
ord_subset/2, 1267
ord_subtract/3, 1264
ord_union/3, 1265
ord_union/4, 1266
ordsets _l_i_b_r_a_r_y, 1256, 1411
oset _l_i_b_r_a_r_y, 1256
package
   clib, 1074
pairs _l_i_b_r_a_r_y, 1413
pairs_keys/2, 1272
pairs_keys_values/3, 1270
pairs_values/2, 1271
parse_time/2, 587
parse_url/2, 1353
parse_url/3, 1354
parse_url_search/2, 1360
partition/4, 1119
partition/5, 1120
pce_call/1, 846, 848
pce_dispatch/1, 846, 847
pce_xref _l_i_b_r_a_r_y, 115
peek_byte/1, 361
peek_byte/2, 362
peek_byte/[1
   2], 122
peek_char/1, 365
peek_char/2, 366
peek_char/[1
   2], 122
peek_code/1, 363
peek_code/2, 364
peek_code/[1
   2], 122
permutation/2, 1227
phrase/2, 249, 250
phrase/3, 249, 251
phrase_from_file/2, 1278
phrase_from_file/3, 1279
pi/0, 513
pio _l_i_b_r_a_r_y, 1276, 1414
PL_abort_hook(), 1063
PL_abort_unhook(), 1064
PL_action(), 1053
PL_agc_hook(), 1066
PL_atom_chars(), 885
PL_atom_nchars(), 938
PL_atom_wchars(), 941
PL_blob_data(), 1000
PL_BLOB_NOCOPY, 989
PL_BLOB_TEXT, 989
PL_BLOB_UNIQUE, 989
PL_call(), 1017
PL_call_predicate(), 1016
PL_chars_to_term(), 986
PL_cleanup(), 1074
PL_cleanup_fork(), 1075
PL_close_foreign_frame(), 1020
PL_close_query(), 1015
PL_compare(), 1039
PL_cons_functor(), 966
PL_cons_functor_v(), 967
PL_cons_list(), 968
PL_context(), 1024
PL_copy_term_ref(), 869
PL_create_engine(), 841
PL_cut_query(), 1014
PL_destroy_engine(), 842
PL_discard_foreign_frame(), 1021
PL_dispatch_hook(), 1062
PL_erase(), 1044
PL_erase_external(), 1047
PL_exception(), 1031
PL_fail(), 876
PL_foreign_context(), 881
PL_foreign_context_address(), 882
PL_foreign_control(), 880
PL_free(), 1086
PL_functor_arity(), 888
PL_functor_name(), 887
PL_get_arg(), 923
PL_get_atom(), 908
PL_get_atom_chars(), 909
PL_get_atom_nchars(), 926
PL_get_blob(), 999
PL_get_bool(), 917
PL_get_chars(), 911
PL_get_file_name(), 1049
PL_get_float(), 919
PL_get_functor(), 920
PL_get_head(), 947
PL_get_int64(), 915
PL_get_integer(), 913
PL_get_intptr(), 916
PL_get_list(), 946
PL_get_list_chars(), 912
PL_get_list_nchars(), 927
PL_get_long(), 914
PL_get_module(), 922
PL_get_mpq(), 1003
PL_get_mpz(), 1002
PL_get_name_arity(), 921
PL_get_nchars(), 928
PL_get_nil(), 949
PL_get_pointer(), 918
PL_get_signum_ex(), 1036
PL_get_string_chars(), 910
PL_get_tail(), 948
PL_get_wchars(), 942
PL_halt(), 1076
PL_handle_signals(), 1035
PL_initialise(), 1070
PL_install_readline(), 1072
PL_is_acyclic(), 906
PL_is_atom(), 897
PL_is_atomic(), 904
PL_is_blob(), 996
PL_is_compound(), 901
PL_is_float(), 900
PL_is_functor(), 902
PL_is_ground(), 896
PL_is_initialised(), 1071
PL_is_integer(), 899
PL_is_list(), 903
PL_is_number(), 905
PL_is_string(), 898
PL_is_variable(), 895
PL_license(), 1402
PL_malloc(), 1084
PL_module_name(), 1026
PL_new_atom(), 884
PL_new_atom_nchars(), 937
PL_new_atom_wchars(), 940
PL_new_functor(), 886
PL_new_module(), 1027
PL_new_term_ref(), 867
PL_new_term_refs(), 868
PL_next_solution(), 1013
PL_on_halt(), 1065
PL_open_foreign_frame(), 1019
PL_open_query(), 1012
PL_pred(), 1008
PL_predicate(), 1009
PL_predicate_info(), 1010
PL_put_atom(), 953
PL_put_atom_chars(), 954
PL_put_atom_nchars(), 929
PL_put_blob(), 998
PL_put_float(), 961
PL_put_functor(), 962
PL_put_int64(), 959
PL_put_integer(), 958
PL_put_list(), 963
PL_put_list_chars(), 957
PL_put_list_nchars(), 932
PL_put_list_ncodes(), 931
PL_put_nil(), 964
PL_put_pointer(), 960
PL_put_string_chars(), 955
PL_put_string_nchars(), 930, 956
PL_put_term(), 965
PL_put_variable(), 952
PL_query(), 1055
PL_quote(), 987
PL_raise(), 1034
PL_raise_exception(), 1029
PL_realloc(), 1085
PL_record(), 1042
PL_record_external(), 1045
PL_recorded(), 1043
PL_recorded_external(), 1046
PL_register_atom(), 890
PL_register_extensions(), 1060
PL_register_extensions_in_module(),
      1059
PL_register_foreign(), 1058
PL_register_foreign_in_module(), 1057
PL_reset_term_refs(), 870
PL_retry(), 878
PL_retry_address(), 879
PL_rewind_foreign_frame(), 1022
PL_same_compound(), 1040
PL_set_engine(), 843
PL_signal(), 1033
PL_strip_module(), 1025
PL_succeed(), 875
PL_term_type(), 894
PL_thread_at_exit(), 839
PL_thread_attach_engine(), 837
PL_thread_destroy_engine(), 838
PL_thread_self(), 835
PL_throw(), 1030
PL_toplevel(), 1073
PL_unify(), 970
PL_unify_arg(), 984
PL_unify_atom(), 971
PL_unify_atom_chars(), 973
PL_unify_atom_nchars(), 933
PL_unify_blob(), 997
PL_unify_chars(), 972
PL_unify_float(), 979
PL_unify_functor(), 981
PL_unify_int64(), 978
PL_unify_integer(), 977
PL_unify_list(), 982
PL_unify_list_chars(), 974
PL_unify_list_nchars(), 936
PL_unify_list_ncodes(), 935
PL_unify_mpq(), 1005
PL_unify_mpz(), 1004
PL_unify_nil(), 983
PL_unify_pointer(), 980
PL_unify_string_chars(), 975
PL_unify_string_nchars(), 934, 976
PL_unify_term(), 985
PL_unify_thread_id(), 836
PL_unify_wchars(), 943
PL_unify_wchars_diff(), 944
PL_unregister_atom(), 891
PL_unregister_blob_type(), 994
PL_warning(), 1051
plus/3, 221, 454
PLVERSION, 1087
popcount/1, 519
portable
   prolog code, 1388
portray/1, 51,  94, 375,  376, 384,
      386, 1012, 1067, 1377
portray_clause/1, 168, 170, 171
portray_clause/2, 170, 171, 401
powm/3, 511
precedence, 1393
pred/1, 696
predicate, 1393
   dynamic, 1393
   exported, 1393
   imported, 1393
predicate indicator, 121, 1393
predicate_property/2, 282, 291, 714
predsort/3, 530
preprocessor/2, 149
print/1, 376,  384, 386,  548, 553,
      1012
print/2, 385
print/[1
   2], 375
print_message/2,  20,  60, 62,  124,
      140,   235--238,   391,  781,
      783, 1205
print_message_lines/3, 20, 236--238
priority, 1393
profile file, 39
profile/1, 655, 656, 830, 1075
profile/3, 656, 1106
profiler/2, 659
profiling
   foreign code, 1088
program, 1393
prolog/0,  41, 60,  311, 618,  622,
      623, 719, 1073, 1368
prolog:called_by/2, 1291
prolog:comment_hook/3, 1382
prolog:debug_control_hook/1, 1378
prolog:help_hook/1, 1379
prolog_choice_attribute/3,     1367,
      1370
prolog_current_frame/1, 1365, 1366
prolog_edit:edit_command/2, 166
prolog_edit:edit_source/1, 165
prolog_edit:load/0, 167
prolog_edit:locate/2, 164
prolog_edit:locate/3, 163
prolog_exception_hook/4, 233,  1372,
      1373
prolog_file_type/2, 123, 134, 606
prolog_frame_attribute/3, 296, 1366,
      1370, 1373
prolog_ide _c_l_a_s_s, 118
prolog_ide/1, 117, 118
prolog_list_goal/1, 1377
prolog_load_context/2,   137,   138,
      1389
prolog_load_file/2, 124, 1380, 1381
prolog_server _l_i_b_r_a_r_y, 311
prolog_skip_level/2, 1371
prolog_stack _l_i_b_r_a_r_y, 1366, 1373
prolog_to_os_filename/2,   92,   607,
      610
prolog_trace_interception/4,    107,
      634, 1366, 1367, 1370
prolog_xref _l_i_b_r_a_r_y, 115
prologxref _l_i_b_r_a_r_y, 1281, 1412
prompt
   alternatives, 60
prompt/2, 393--395
prompt1/1, 395
property, 1393
protocol/1, 626, 627, 629
protocola/1, 627, 629
protocolling/1, 629
prove, 1393
public list, 1393
pure_input _l_i_b_r_a_r_y, 1415
put/1, 338, 339
put/2, 339
put_assoc/4, 1135
put_attr/3, 724, 725, 728, 731
put_attrs/2, 733
put_byte/1, 340
put_byte/2, 341
put_byte/[1
   2], 122
put_char/1, 338, 342, 344
put_char/2, 343
put_char/[1
   2], 122
put_code/1, 338, 344, 345
put_code/2, 77, 345, 372, 374
put_code/[1
   2], 122

qcompile/1, 124, 142, 158, 159, 776
qsave_program/1, 1093
qsave_program/2,  14,  58,  60,  94,
      117, 1091, 1092, 1098
qsave_program/[1
   2],  13,  18, 41,  57, 60,  141,
      291,  853, 1070,  1080, 1094,
      1096
query, 1393
quiet, 41, 236
quintus _l_i_b_r_a_r_y, 21, 708, 721

random/1, 481
rational
   number, 463
rational/1, 177, 463, 464, 485, 486
rational/3, 178, 463
rationalize/1, 463,  464, 485, 486,
      1321
RDF
   memory usage, 87
rdiv/2, 463, 464, 471, 475
reachable/3, 1348
read/1, 60, 82, 299, 348, 382, 387,
      389,   391,  394,  438,  648,
      750, 1298
read/2, 329, 388
read_clause/1, 389, 390, 648
read_clause/2, 390
read_file_to_codes/3, 1297
read_file_to_terms/3, 1298
read_history/6, 393
read_line_to_codes/2, 1293, 1294
read_line_to_codes/3, 1293, 1294
read_link/3, 611

                                  1428

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.59 Reference Manual: Section 4.39</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="debugger.html">
<LINK REL=next HREF="profile.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="debugger.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="profile.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:4.39"><SPAN class="sec-nr">4.39</SPAN> <SPAN class="sec-title">Obtaining 
Runtime Statistics</SPAN></A></H2>

<A NAME="sec:statistics"></A>

<DL>
<DT class="pubdef"><A NAME="statistics/2"><STRONG>statistics</STRONG>(<VAR>+Key, 
-Value</VAR>)</A></DT>
<DD class="defbody">
Unify system statistics determined by <VAR>Key</VAR> with <VAR>Value</VAR>. 
The possible keys are given in the <A class="tab" href="statistics.html#tab:statistics">table 
5</A>. The last part of the table contains keys for compatibility to 
other Prolog implementations (Quintus) for improved portability. Note 
that the ISO standard does not define methods to collect system 
statistics. Space unit is bytes<SUP class="fn">66<SPAN class="fn-text">This 
may change to `cells' to enhance compatibility between the 32- and 
64-bit versions.</SPAN></SUP>. Times are in seconds, represented as a 
floating point number. The Quintus compatibility keys express times in 
milliseconds.

<P>
<CENTER>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD>agc</TD><TD>Number of atom garbage-collections 
performed </TD></TR>
<TR VALIGN=top><TD>agc_gained</TD><TD>Number of atoms removed </TD></TR>
<TR VALIGN=top><TD>agc_time</TD><TD>Time spent in atom 
garbage-collections </TD></TR>
<TR VALIGN=top><TD>cputime</TD><TD>(User) <font size=-1>CPU</font> time 
since Prolog was started in seconds </TD></TR>
<TR VALIGN=top><TD>inferences</TD><TD>Total number of passes via the 
call and redo ports since Prolog was started. </TD></TR>
<TR VALIGN=top><TD>heap</TD><TD>Estimated total size of the heap (see <A class="sec" href="limits.html">section 
2.18.1.1</A>) </TD></TR>
<TR VALIGN=top><TD>heapused</TD><TD>Bytes heap in use by Prolog. </TD></TR>
<TR VALIGN=top><TD>heaplimit</TD><TD>Maximum size of the heap (see <A class="sec" href="limits.html">section 
2.18.1.1</A>) </TD></TR>
<TR VALIGN=top><TD>local</TD><TD>Allocated size of the local stack in 
bytes. </TD></TR>
<TR VALIGN=top><TD>localused</TD><TD>Number of bytes in use on the local 
stack. </TD></TR>
<TR VALIGN=top><TD>locallimit</TD><TD>Size to which the local stack is 
allowed to grow </TD></TR>
<TR VALIGN=top><TD>global</TD><TD>Allocated size of the global stack in 
bytes. </TD></TR>
<TR VALIGN=top><TD>globalused</TD><TD>Number of bytes in use on the 
global stack. </TD></TR>
<TR VALIGN=top><TD>globallimit</TD><TD>Size to which the global stack is 
allowed to grow </TD></TR>
<TR VALIGN=top><TD>trail</TD><TD>Allocated size of the trail stack in 
bytes. </TD></TR>
<TR VALIGN=top><TD>trailused</TD><TD>Number of bytes in use on the trail 
stack. </TD></TR>
<TR VALIGN=top><TD>traillimit</TD><TD>Size to which the trail stack is 
allowed to grow </TD></TR>
<TR VALIGN=top><TD>atoms</TD><TD>Total number of defined atoms. </TD></TR>
<TR VALIGN=top><TD>functors</TD><TD>Total number of defined name/arity 
pairs. </TD></TR>
<TR VALIGN=top><TD>predicates</TD><TD>Total number of predicate 
definitions. </TD></TR>
<TR VALIGN=top><TD>modules</TD><TD>Total number of module definitions. </TD></TR>
<TR VALIGN=top><TD>codes</TD><TD>Total amount of byte codes in all 
clauses. </TD></TR>
<TR VALIGN=top><TD>threads</TD><TD>MT-version: number of active threads </TD></TR>
<TR VALIGN=top><TD>threads_created</TD><TD>MT-version: number of created 
threads </TD></TR>
<TR VALIGN=top><TD>thread_cputime</TD><TD>MT-version: seconds CPU time 
used by finished threads. Supported on Windows-NT and later, Linux and 
possibly a few more. Verify it gives plausible results before using. </TD></TR>
<TBODY>
<TR VALIGN=top><TD COLSPAN=2 ALIGN=center>Compatibility keys (times in 
milliseconds)</TR>
<TBODY>
<TR VALIGN=top><TD>runtime</TD><TD>[ CPU time, CPU time since last ] 
(milliseconds) </TD></TR>
<TR VALIGN=top><TD>system_time</TD><TD>[ System CPU time, System CPU 
time since last ] (milliseconds)</TD></TR>
<TR VALIGN=top><TD>real_time</TD><TD>[ Wall time, Wall time since last ] 
(see <A NAME="idx:gettime1:1127"></A><A class="pred" href="system.html#get_time/1">get_time/1</A>) </TD></TR>
<TR VALIGN=top><TD>memory</TD><TD>[ Total unshared data, free memory ] 
(Uses getrusage() if available, otherwise incomplete own statistics.) </TD></TR>
<TR VALIGN=top><TD>stacks</TD><TD>[ global use, local use ] </TD></TR>
<TR VALIGN=top><TD>program</TD><TD>[ heap, 0 ] </TD></TR>
<TR VALIGN=top><TD>global_stack</TD><TD>[ global use, global free ] </TD></TR>
<TR VALIGN=top><TD>local_stack</TD><TD>[ local use, local free ] </TD></TR>
<TR VALIGN=top><TD>trail</TD><TD>[ trail use, 0 ] </TD></TR>
<TR VALIGN=top><TD>garbage_collection</TD><TD>[ number of GC, bytes 
gained, time spent ] </TD></TR>
<TR VALIGN=top><TD>stack_shifts</TD><TD>[ global shifts, local shifts, 
time spent ] (fails if no shifter in this version) </TD></TR>
<TR VALIGN=top><TD>atoms</TD><TD>[ number, memory use, 0 ] </TD></TR>
<TR VALIGN=top><TD>atom_garbage_collection</TD><TD>[ number of AGC, 
bytes gained, time spent ] </TD></TR>
<TR VALIGN=top><TD>core</TD><TD>Same as memory </TD></TR>
</TABLE>

</CENTER>
<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Table 5 : </B>Keys for <A NAME="idx:statistics2:1128"></A><A class="pred" href="statistics.html#statistics/2">statistics/2</A></TABLE>

<A NAME="tab:statistics"></A>
</DD>
<DT class="pubdef"><A NAME="statistics/0"><STRONG>statistics</STRONG></A></DT>
<DD class="defbody">
Display a table of system statistics on the current output stream.
</DD>
<DT class="pubdef"><A NAME="time/1"><STRONG>time</STRONG>(<VAR>+Goal</VAR>)</A></DT>
<DD class="defbody">
Execute <VAR>Goal</VAR> just like <A NAME="idx:once1:1129"></A><A class="pred" href="metacall.html#once/1">once/1</A> 
(i.e., leaving no choice points), but print used time, number of logical 
inferences and the average number of <VAR>lips</VAR> (logical inferences 
per second). Note that SWI-Prolog counts the actual executed number of 
inferences rather than the number of passes through the call- and redo 
ports of the theoretical 4-port model.
</DD>
</DL>

<P></BODY></HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.59 Reference Manual: Section 4.32</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="forall2.html">
<LINK REL=next HREF="tty.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="forall2.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="tty.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:4.32"><SPAN class="sec-nr">4.32</SPAN> <SPAN class="sec-title">Formatted 
Write</SPAN></A></H2>

<A NAME="sec:format"></A>

<P>The current version of SWI-Prolog provides two formatted write 
predicates. The first is <A NAME="idx:writef12:1008"></A><A class="pred" href="format.html#writef/1">writef/[1,2]</A>, 
which is compatible with Edinburgh C-Prolog. The second is <A NAME="idx:format12:1009"></A><A class="pred" href="format.html#format/1">format/[1,2]</A>, 
which is compatible with Quintus Prolog. We hope the Prolog community 
will once define a standard formatted write predicate. If you want 
performance use
<A NAME="idx:format12:1010"></A><A class="pred" href="format.html#format/1">format/[1,2]</A> 
as this predicate is defined in C. Otherwise compatibility reasons might 
tell you which predicate to use.

<H3><A NAME="sec:4.32.1"><SPAN class="sec-nr">4.32.1</SPAN> <SPAN class="sec-title">Writef</SPAN></A></H3>

<DL>
<DT class="pubdef"><A NAME="writeln/1"><STRONG>writeln</STRONG>(<VAR>+Term</VAR>)</A></DT>
<DD class="defbody">
Equivalent to <CODE>write(Term), nl.</CODE>
</DD>
<DT class="pubdef"><A NAME="writef/1"><STRONG>writef</STRONG>(<VAR>+Atom</VAR>)</A></DT>
<DD class="defbody">
Equivalent to <CODE>writef(Atom, []).</CODE>
</DD>
<DT class="pubdef"><A NAME="writef/2"><STRONG>writef</STRONG>(<VAR>+Format, 
+Arguments</VAR>)</A></DT>
<DD class="defbody">
Formatted write. <VAR>Format</VAR> is an atom whose characters will be 
printed.
<VAR>Format</VAR> may contain certain special character sequences which 
specify certain formatting and substitution actions. <VAR>Arguments</VAR> 
then provides all the terms required to be output.

<P>Escape sequences to generate a single special character:

<P>
<CENTER>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>\n</CODE> </TD><TD>Output a newline character 
(see also <A NAME="idx:nl01:1011"></A><A class="pred" href="chario.html#nl/0">nl/[0,1]</A>) </TD></TR>
<TR VALIGN=top><TD><CODE>\l</CODE> </TD><TD>Output a line separator 
(same as <CODE>\n</CODE>) </TD></TR>
<TR VALIGN=top><TD><CODE>\r</CODE> </TD><TD>Output a carriage-return 
character (ASCII 13) </TD></TR>
<TR VALIGN=top><TD><CODE>\t</CODE> </TD><TD>Output the ASCII character 
TAB (9) </TD></TR>
<TR VALIGN=top><TD><CODE>\\</CODE> </TD><TD>The character <CODE><CODE>\</CODE></CODE> 
is output </TD></TR>
<TR VALIGN=top><TD><CODE>\%</CODE> </TD><TD>The character <CODE><CODE>%</CODE></CODE> 
is output </TD></TR>
<TR VALIGN=top><TD><CODE>\nnn</CODE> </TD><TD>where &lt;<VAR>nnn</VAR>&gt; 
is an integer (1-3 digits) the character with character code &lt;<VAR>nnn</VAR>&gt; 
is output (NB : &lt;<VAR>nnn</VAR>&gt; is read as <STRONG>decimal</STRONG>) </TD></TR>
</TABLE>

</CENTER>

<P>Note that <CODE>\l</CODE>, <CODE>\nnn</CODE> and <CODE>\\</CODE> are 
interpreted differently when character-escapes are in effect. See
<A class="sec" href="syntax.html">section 2.15.1.2</A>.

<P>Escape sequences to include arguments from <VAR>Arguments</VAR>. Each 
time a
% escape sequence is found in <VAR>Format</VAR> the next argument from <VAR>Arguments</VAR> 
is formatted according to the specification.

<P>
<CENTER>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>%t</CODE> </TD><TD><A NAME="idx:print1:1012"></A><A class="pred" href="termrw.html#print/1">print/1</A> 
the next item (mnemonic: term) </TD></TR>
<TR VALIGN=top><TD><CODE>%w</CODE> </TD><TD><A NAME="idx:write1:1013"></A><A class="pred" href="termrw.html#write/1">write/1</A> 
the next item </TD></TR>
<TR VALIGN=top><TD><CODE>%q</CODE> </TD><TD><A NAME="idx:writeq1:1014"></A><A class="pred" href="termrw.html#writeq/1">writeq/1</A> 
the next item </TD></TR>
<TR VALIGN=top><TD><CODE>%d</CODE> </TD><TD>Write the term, ignoring 
operators. See also
<A NAME="idx:writeterm2:1015"></A><A class="pred" href="termrw.html#write_term/2">write_term/2</A>. 
Mnemonic: old Edinburgh <A NAME="idx:display1:1016"></A><SPAN class="pred-ext">display/1</SPAN>. </TD></TR>
<TR VALIGN=top><TD><CODE>%p</CODE> </TD><TD><A NAME="idx:print1:1017"></A><A class="pred" href="termrw.html#print/1">print/1</A> 
the next item (identical to <CODE>%t</CODE>) </TD></TR>
<TR VALIGN=top><TD><CODE>%n</CODE> </TD><TD>Put the next item as a 
character (i.e., it is a character code) </TD></TR>
<TR VALIGN=top><TD><CODE>%r</CODE> </TD><TD>Write the next item N times 
where N is the second item (an integer) </TD></TR>
<TR VALIGN=top><TD><CODE>%s</CODE> </TD><TD>Write the next item as a 
String (so it must be a list of characters) </TD></TR>
<TR VALIGN=top><TD><CODE>%f</CODE> </TD><TD>Perform a <A NAME="idx:ttyflush0:1018"></A><A class="pred" href="chario.html#ttyflush/0">ttyflush/0</A> 
(no items used) </TD></TR>
<TR VALIGN=top><TD><CODE>%Nc</CODE> </TD><TD>Write the next item 
Centered in <VAR>N</VAR> columns. </TD></TR>
<TR VALIGN=top><TD><CODE>%Nl</CODE> </TD><TD>Write the next item Left 
justified in <VAR>N</VAR> columns. </TD></TR>
<TR VALIGN=top><TD><CODE>%Nr</CODE> </TD><TD>Write the next item Right 
justified in <VAR>N</VAR> columns.
<VAR>N</VAR> is a decimal number with at least one digit. The item must 
be an atom, integer, float or string. </TD></TR>
</TABLE>

</CENTER>
</DD>
<DT class="pubdef"><A NAME="swritef/3"><STRONG>swritef</STRONG>(<VAR>-String, 
+Format, +Arguments</VAR>)</A></DT>
<DD class="defbody">
Equivalent to <A NAME="idx:writef2:1019"></A><A class="pred" href="format.html#writef/2">writef/2</A>, 
but ``writes'' the result on <VAR>String</VAR> instead of the current 
output stream. Example:

<PRE class="code">
?- swritef(S, '%15L%w', ['Hello', 'World']).

S = "Hello          World"
</PRE>

</DD>
<DT class="pubdef"><A NAME="swritef/2"><STRONG>swritef</STRONG>(<VAR>-String, 
+Format</VAR>)</A></DT>
<DD class="defbody">
Equivalent to <CODE>swritef(String, Format, []).</CODE>
</DD>
</DL>

<H3><A NAME="sec:4.32.2"><SPAN class="sec-nr">4.32.2</SPAN> <SPAN class="sec-title">Format</SPAN></A></H3>

<DL>
<DT class="pubdef"><A NAME="format/1"><STRONG>format</STRONG>(<VAR>+Format</VAR>)</A></DT>
<DD class="defbody">
Defined as `<CODE>format(Format) :- format(Format, []).</CODE>'</DD>
<DT class="pubdef"><A NAME="format/2"><STRONG>format</STRONG>(<VAR>+Format, 
+Arguments</VAR>)</A></DT>
<DD class="defbody">
<VAR>Format</VAR> is an atom, list of character codes, or a Prolog 
string.
<VAR>Arguments</VAR> provides the arguments required by the format 
specification. If only one argument is required and this is not a list 
of character codes the argument need not be put in a list. Otherwise the 
arguments are put in a list.

<P>Special sequences start with the tilde (<CODE><CODE>~</CODE></CODE>), 
followed by an optional numeric argument, followed by a character 
describing the action to be undertaken. A numeric argument is either a 
sequence of digits, representing a positive decimal number, a sequence <CODE>`&lt;<VAR>character</VAR>&gt;</CODE>, 
representing the character code value of the character (only useful for <CODE>~t</CODE>) 
or a asterisk (<CODE><CODE>*</CODE></CODE>), in when the numeric 
argument is taken from the next argument of the argument list, which 
should be a positive integer.

<P>Numeric conversion (<CODE>d</CODE>, <CODE>D</CODE>, <CODE>e</CODE>, <CODE>E</CODE>, <CODE>f</CODE>, <CODE>g</CODE> 
and <CODE>G</CODE>) accept an arithmetic expression as argument. This is 
introduced to handle rational numbers transparently (see
<A class="sec" href="arith.html">section 4.26.2.2</A>. The floating 
point conversions allow for unlimited precision for printing rational 
numbers in decimal form.

<P>
<UL>
<LI><CODE><CODE>~</CODE></CODE><BR>
Output the tilde itself.

<P>
<LI><CODE>a</CODE><BR>
Output the next argument, which must be an atom. This option is 
equivalent to <B>w</B>, except for that it requires the argument to be 
an atom.

<P>
<LI><CODE>c</CODE><BR>
Interpret the next argument as an character code and add it to the 
output. This argument should be an integer in the range [0, ... , 255] 
(including 0 and 255).

<P>
<LI><CODE>d</CODE><BR>
Output next argument as a decimal number. It should be an integer. If a 
numeric argument is specified a dot is inserted <VAR>argument</VAR> 
positions from the right (useful for doing fixed point arithmetic with 
integers, such as handling amounts of money).

<P>
<LI><CODE>D</CODE><BR>
Same as <B>d</B>, but makes large values easier to read by inserting a 
comma every three digits left to the dot or right.

<P>
<LI><CODE>e</CODE><BR>
Output next argument as a floating point number in exponential notation. 
The numeric argument specifies the precision. Default is 6 digits. Exact 
representation depends on the C library function printf(). This function 
is invoked with the format
<TT>%.&lt;<VAR>precision</VAR>&gt;e</TT>.

<P>
<LI><CODE>E</CODE><BR>
Equivalent to <B>e</B>, but outputs a capital E to indicate the 
exponent.

<P>
<LI><CODE>f</CODE><BR>
Floating point in non-exponential notation. See C library function 
printf().
<LI><CODE>g</CODE><BR>
Floating point in <B>e</B> or <B>f</B> notation, whichever is shorter.
<LI><CODE>G</CODE><BR>
Floating point in <B>E</B> or <B>f</B> notation, whichever is shorter.
<LI><CODE>i</CODE><BR>
Ignore next argument of the argument list. Produces no output.
<LI><CODE>k</CODE><BR>
Give the next argument to (<A NAME="idx:writecanonical1:1020"></A><A class="pred" href="termrw.html#write_canonical/1">write_canonical/1</A>).
<LI><CODE>n</CODE><BR>
Output a newline character.
<LI><CODE>N</CODE><BR>
Only output a newline if the last character output on this stream was 
not a newline. Not properly implemented yet.
<LI><CODE>p</CODE><BR>
Give the next argument to <A NAME="idx:print1:1021"></A><A class="pred" href="termrw.html#print/1">print/1</A>.
<LI><CODE>q</CODE><BR>
Give the next argument to <A NAME="idx:writeq1:1022"></A><A class="pred" href="termrw.html#writeq/1">writeq/1</A>.
<LI><CODE>r</CODE><BR>
Print integer in radix the numeric argument notation. Thus
<CODE>~16r</CODE> prints its argument hexadecimal. The argument should 
be in the range <VAR>[2, ... , 36]</VAR>. Lower case letters are used 
for digits above 9.
<LI><CODE>R</CODE><BR>
Same as <B>r</B>, but uses upper case letters for digits above 9.

<P>
<LI><CODE>s</CODE><BR>
Output text from a list of character codes or a string (see <A NAME="idx:string1:1023"></A><A class="pred" href="typetest.html#string/1">string/1</A> 
and
<A class="sec" href="strings.html">section 4.23</A>) from the next 
argument.

<P>
<LI><CODE>@</CODE><BR>
Interpret the next argument as a goal and execute it. Output written to 
the <CODE>current_output</CODE> stream is inserted at this place. Goal 
is called in the module calling <A NAME="idx:format3:1024"></A><A class="pred" href="format.html#format/3">format/3</A>. 
This option is not present in the original definition by Quintus, but 
supported by some other Prolog systems.

<P>
<LI><CODE>t</CODE><BR>
All remaining space between 2 tab stops is distributed equally over
<CODE>~t</CODE> statements between the tab stops. This space is padded 
with spaces by default. If an argument is supplied this is taken to be 
the character code of the character used for padding. This can be used 
to do left or right alignment, centering, distributing, etc. See also <CODE>~|</CODE> 
and <CODE>~+</CODE> to set tab stops. A tab stop is assumed at the start 
of each line.

<P>
<LI><CODE><CODE>|</CODE></CODE><BR>
Set a tab stop on the current position. If an argument is supplied set a 
tab stop on the position of that argument. This will cause all
<CODE>~t</CODE>'s to be distributed between the previous and this tab 
stop.
<LI><CODE><CODE>+</CODE></CODE><BR>
Set a tab stop relative to the current position. Further the same as <CODE>~|</CODE>. 
<LI><CODE>w</CODE><BR>
Give the next argument to <A NAME="idx:write1:1025"></A><A class="pred" href="termrw.html#write/1">write/1</A>.

<P>
<LI><CODE>W</CODE><BR>
Give the next two argument to <A NAME="idx:writeterm2:1026"></A><A class="pred" href="termrw.html#write_term/2">write_term/2</A>. 
E.g. <CODE>format('&nbsp;W', [Term, [numbervars(true)]])</CODE>. This 
option is SWI-Prolog specific.
</UL>

<P>Example:

<PRE class="code">
simple_statistics :-
    &lt;obtain statistics&gt;         % left to the user
    format('~tStatistics~t~72|~n~n'),
    format('Runtime: ~`.t ~2f~34|  Inferences: ~`.t ~D~72|~n',
                                            [RunT, Inf]),
    ....
</PRE>

<P>Will output

<PRE class="code">
                             Statistics

Runtime: .................. 3.45  Inferences: .......... 60,345
</PRE>

</DD>
<DT class="pubdef"><A NAME="format/3"><STRONG>format</STRONG>(<VAR>+Output, 
+Format, +Arguments</VAR>)</A></DT>
<DD class="defbody">
As <A NAME="idx:format2:1027"></A><A class="pred" href="format.html#format/2">format/2</A>, 
but write the output on the given <VAR>Output</VAR>. The de-facto 
standard only allows <VAR>Output</VAR> to be a stream. The SWI-Prolog 
implementation allows all valid arguments for
<A NAME="idx:withoutputto2:1028"></A><A class="pred" href="IO.html#with_output_to/2">with_output_to/2</A>.<SUP class="fn">59<SPAN class="fn-text">Earlier 
versions defined sformat/3 . These predicates have been moved to the 
library <CODE>library(backcomp)</CODE>.</SPAN></SUP> For example:

<PRE class="code">
?- format(atom(A), '~D', [1000000]).
A = '1,000,000'
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:4.32.3"><SPAN class="sec-nr">4.32.3</SPAN> <SPAN class="sec-title">Programming 
Format</SPAN></A></H3>

<DL>
<DT class="pubdef"><A NAME="format_predicate/2"><STRONG>format_predicate</STRONG>(<VAR>+Char, 
+Head</VAR>)</A></DT>
<DD class="defbody">
If a sequence <CODE>~c</CODE> (tilde, followed by some character) is 
found, the format derivatives will first check whether the user has 
defined a predicate to handle the format. If not, the built in 
formatting rules described above are used. <VAR>Char</VAR> is either an <font size=-1>ASCII</font> 
value, or a one character atom, specifying the letter to be (re)defined. <VAR>Head</VAR> 
is a term, whose name and arity are used to determine the predicate to 
call for the redefined formatting character. The first argument to the 
predicate is the numeric argument of the format command, or the atom <CODE>default</CODE> 
if no argument is specified. The remaining arguments are filled from the 
argument list. The example below redefines <CODE>~n</CODE> to produce <VAR>Arg</VAR> 
times return followed by linefeed (so a (Grr.) DOS machine is happy with 
the output).

<PRE class="code">
:- format_predicate(n, dos_newline(_Arg)).

dos_newline(default) :- !,
        dos_newline(1).
dos_newline(N) :-
        (   N &gt; 0
        -&gt;  write('\r\n'),
            N2 is N - 1,
            dos_newline(N2)
        ;   true
        ).
</PRE>

</DD>
<DT class="pubdef"><A NAME="current_format_predicate/2"><STRONG>current_format_predicate</STRONG>(<VAR>?Code, 
?:Head</VAR>)</A></DT>
<DD class="defbody">
Enumerates all user-defined format predicates. <VAR>Code</VAR> is the 
character code of the format character. <VAR>Head</VAR> is unified with 
a term with the same name and arity as the predicate. If the predicate 
does not reside in module <CODE>user</CODE>, <VAR>Head</VAR> is 
qualified with the definition module of the predicate.
</DD>
</DL>

<P></BODY></HTML>